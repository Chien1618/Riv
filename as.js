import * as st from "react";
import Qm, { useState as NN, useRef as QD, useEffect as OA, useMemo as zN, useLayoutEffect as HN } from "react";
import EU from "react-dom";
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const T1 = "175", zS = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, HS = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, bU = 0, FC = 1, MU = 2, LN = 3, xU = 0, ax = 1, wA = 2, qv = 3, Zg = 0, ed = 1, Lp = 2, jv = 0, QS = 1, cM = 2, PC = 3, XC = 4, TU = 5, I0 = 100, CU = 101, RU = 102, DU = 103, BU = 104, UU = 200, OU = 201, wU = 202, NU = 203, fM = 204, dM = 205, zU = 206, HU = 207, LU = 208, GU = 209, IU = 210, VU = 211, FU = 212, PU = 213, XU = 214, hM = 0, pM = 1, mM = 2, KS = 3, vM = 4, gM = 5, yM = 6, SM = 7, aE = 0, YU = 1, qU = 2, Yg = 0, ZU = 1, QU = 2, jU = 3, d2 = 4, JU = 5, KU = 6, kU = 7, YC = "attached", WU = "detached", X0 = 300, Qg = 301, Y0 = 302, p1 = 303, YA = 304, C1 = 306, q0 = 1e3, Mo = 1001, m1 = 1002, _c = 1003, ix = 1004, GN = 1004, VS = 1005, IN = 1005, Ni = 1006, c1 = 1007, VN = 1007, qm = 1008, qC = 1008, qh = 1009, lx = 1010, sx = 1011, kS = 1012, iE = 1013, jg = 1014, pr = 1015, au = 1016, rx = 1017, ox = 1018, v1 = 1020, h2 = 35902, p2 = 1021, m2 = 1022, xo = 1023, v2 = 1024, g2 = 1025, WS = 1026, g1 = 1027, lE = 1028, sE = 1029, y2 = 1030, ux = 1031, FN = 1032, cx = 1033, NA = 33776, zA = 33777, HA = 33778, LA = 33779, _M = 35840, AM = 35841, EM = 35842, bM = 35843, MM = 36196, xM = 37492, TM = 37496, CM = 37808, RM = 37809, DM = 37810, BM = 37811, UM = 37812, OM = 37813, wM = 37814, NM = 37815, zM = 37816, HM = 37817, LM = 37818, GM = 37819, IM = 37820, VM = 37821, GA = 36492, FM = 36494, PM = 36495, S2 = 36283, XM = 36284, YM = 36285, qM = 36286, $U = 2200, eO = 2201, tO = 2202, y1 = 2300, S1 = 2301, iM = 2302, FS = 2400, PS = 2401, qA = 2402, fx = 2500, _2 = 2501, nO = 0, A2 = 1, ZM = 2, aO = 3200, iO = 3201, PN = 3202, XN = 3203, Q0 = 0, lO = 1, Fy = "", lf = "srgb", Kv = "srgb-linear", ZA = "linear", Nl = "srgb", YN = 0, LS = 7680, qN = 7681, ZN = 7682, QN = 7683, jN = 34055, JN = 34056, KN = 5386, kN = 512, WN = 513, $N = 514, ez = 515, tz = 516, nz = 517, az = 518, ZC = 519, sO = 512, rO = 513, oO = 514, E2 = 515, uO = 516, cO = 517, fO = 518, dO = 519, QA = 35044, iz = 35048, lz = 35040, sz = 35045, rz = 35049, oz = 35041, uz = 35046, cz = 35050, fz = 35042, dz = "100", QC = "300 es", Qv = 2e3, jA = 2001, hz = {
  COMPUTE: "compute",
  RENDER: "render"
};
let Jg = class {
  /**
   * Adds the given event listener to the given event type.
   *
   * @param {string} type - The type of event to listen to.
   * @param {Function} listener - The function that gets called when the event is fired.
   */
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const a = this._listeners;
    a[e] === void 0 && (a[e] = []), a[e].indexOf(t) === -1 && a[e].push(t);
  }
  /**
   * Returns `true` if the given event listener has been added to the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to check.
   * @return {boolean} Whether the given event listener has been added to the given event type.
   */
  hasEventListener(e, t) {
    const a = this._listeners;
    return a === void 0 ? !1 : a[e] !== void 0 && a[e].indexOf(t) !== -1;
  }
  /**
   * Removes the given event listener from the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to remove.
   */
  removeEventListener(e, t) {
    const a = this._listeners;
    if (a === void 0) return;
    const r = a[e];
    if (r !== void 0) {
      const d = r.indexOf(t);
      d !== -1 && r.splice(d, 1);
    }
  }
  /**
   * Dispatches an event object.
   *
   * @param {Object} event - The event that gets fired.
   */
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const a = t[e.type];
    if (a !== void 0) {
      e.target = this;
      const r = a.slice(0);
      for (let d = 0, p = r.length; d < p; d++)
        r[d].call(this, e);
      e.target = null;
    }
  }
};
const Kf = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let jD = 1234567;
const jS = Math.PI / 180, _1 = 180 / Math.PI;
function Gp() {
  const o = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, a = Math.random() * 4294967295 | 0;
  return (Kf[o & 255] + Kf[o >> 8 & 255] + Kf[o >> 16 & 255] + Kf[o >> 24 & 255] + "-" + Kf[e & 255] + Kf[e >> 8 & 255] + "-" + Kf[e >> 16 & 15 | 64] + Kf[e >> 24 & 255] + "-" + Kf[t & 63 | 128] + Kf[t >> 8 & 255] + "-" + Kf[t >> 16 & 255] + Kf[t >> 24 & 255] + Kf[a & 255] + Kf[a >> 8 & 255] + Kf[a >> 16 & 255] + Kf[a >> 24 & 255]).toLowerCase();
}
function Fa(o, e, t) {
  return Math.max(e, Math.min(t, o));
}
function b2(o, e) {
  return (o % e + e) % e;
}
function pz(o, e, t, a, r) {
  return a + (o - e) * (r - a) / (t - e);
}
function mz(o, e, t) {
  return o !== e ? (t - o) / (e - o) : 0;
}
function IA(o, e, t) {
  return (1 - t) * o + t * e;
}
function vz(o, e, t, a) {
  return IA(o, e, 1 - Math.exp(-t * a));
}
function gz(o, e = 1) {
  return e - Math.abs(b2(o, e * 2) - e);
}
function yz(o, e, t) {
  return o <= e ? 0 : o >= t ? 1 : (o = (o - e) / (t - e), o * o * (3 - 2 * o));
}
function Sz(o, e, t) {
  return o <= e ? 0 : o >= t ? 1 : (o = (o - e) / (t - e), o * o * o * (o * (o * 6 - 15) + 10));
}
function _z(o, e) {
  return o + Math.floor(Math.random() * (e - o + 1));
}
function Az(o, e) {
  return o + Math.random() * (e - o);
}
function Ez(o) {
  return o * (0.5 - Math.random());
}
function bz(o) {
  o !== void 0 && (jD = o);
  let e = jD += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function Mz(o) {
  return o * jS;
}
function xz(o) {
  return o * _1;
}
function Tz(o) {
  return (o & o - 1) === 0 && o !== 0;
}
function Cz(o) {
  return Math.pow(2, Math.ceil(Math.log(o) / Math.LN2));
}
function Rz(o) {
  return Math.pow(2, Math.floor(Math.log(o) / Math.LN2));
}
function Dz(o, e, t, a, r) {
  const d = Math.cos, p = Math.sin, y = d(t / 2), _ = p(t / 2), E = d((e + a) / 2), T = p((e + a) / 2), C = d((e - a) / 2), D = p((e - a) / 2), B = d((a - e) / 2), z = p((a - e) / 2);
  switch (r) {
    case "XYX":
      o.set(y * T, _ * C, _ * D, y * E);
      break;
    case "YZY":
      o.set(_ * D, y * T, _ * C, y * E);
      break;
    case "ZXZ":
      o.set(_ * C, _ * D, y * T, y * E);
      break;
    case "XZX":
      o.set(y * T, _ * z, _ * B, y * E);
      break;
    case "YXY":
      o.set(_ * B, y * T, _ * z, y * E);
      break;
    case "ZYZ":
      o.set(_ * z, _ * B, y * T, y * E);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function Jd(o, e) {
  switch (e.constructor) {
    case Float32Array:
      return o;
    case Uint32Array:
      return o / 4294967295;
    case Uint16Array:
      return o / 65535;
    case Uint8Array:
      return o / 255;
    case Int32Array:
      return Math.max(o / 2147483647, -1);
    case Int16Array:
      return Math.max(o / 32767, -1);
    case Int8Array:
      return Math.max(o / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Wa(o, e) {
  switch (e.constructor) {
    case Float32Array:
      return o;
    case Uint32Array:
      return Math.round(o * 4294967295);
    case Uint16Array:
      return Math.round(o * 65535);
    case Uint8Array:
      return Math.round(o * 255);
    case Int32Array:
      return Math.round(o * 2147483647);
    case Int16Array:
      return Math.round(o * 32767);
    case Int8Array:
      return Math.round(o * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const dx = {
  DEG2RAD: jS,
  RAD2DEG: _1,
  /**
   * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
   * (universally unique identifier).
   *
   * @static
   * @method
   * @return {string} The UUID.
   */
  generateUUID: Gp,
  /**
   * Clamps the given value between min and max.
   *
   * @static
   * @method
   * @param {number} value - The value to clamp.
   * @param {number} min - The min value.
   * @param {number} max - The max value.
   * @return {number} The clamped value.
   */
  clamp: Fa,
  /**
   * Computes the Euclidean modulo of the given parameters that
   * is `( ( n % m ) + m ) % m`.
   *
   * @static
   * @method
   * @param {number} n - The first parameter.
   * @param {number} m - The second parameter.
   * @return {number} The Euclidean modulo.
   */
  euclideanModulo: b2,
  /**
   * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
   * for the given value.
   *
   * @static
   * @method
   * @param {number} x - The value to be mapped.
   * @param {number} a1 - Minimum value for range A.
   * @param {number} a2 - Maximum value for range A.
   * @param {number} b1 - Minimum value for range B.
   * @param {number} b2 - Maximum value for range B.
   * @return {number} The mapped value.
   */
  mapLinear: pz,
  /**
   * Returns the percentage in the closed interval `[0, 1]` of the given value
   * between the start and end point.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} value - A value between start and end.
   * @return {number} The interpolation factor.
   */
  inverseLerp: mz,
  /**
   * Returns a value linearly interpolated from two known points based on the given interval -
   * `t = 0` will return `x` and `t = 1` will return `y`.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {number} The interpolated value.
   */
  lerp: IA,
  /**
   * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
   * time to maintain frame rate independent movement. For details, see
   * [Frame rate independent damping using lerp]{@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}.
   *
   * @static
   * @method
   * @param {number} x - The current point.
   * @param {number} y - The target point.
   * @param {number} lambda - A higher lambda value will make the movement more sudden,
   * and a lower value will make the movement more gradual.
   * @param {number} dt - Delta time in seconds.
   * @return {number} The interpolated value.
   */
  damp: vz,
  /**
   * Returns a value that alternates between `0` and the given `length` parameter.
   *
   * @static
   * @method
   * @param {number} x - The value to pingpong.
   * @param {number} [length=1] - The positive value the function will pingpong to.
   * @return {number} The alternated value.
   */
  pingpong: gz,
  /**
   * Returns a value in the range `[0,1]` that represents the percentage that `x` has
   * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
   * the `min` and `max`.
   *
   * See [Smoothstep]{@link http://en.wikipedia.org/wiki/Smoothstep} for more details.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smoothstep: yz,
  /**
   * A [variation on smoothstep]{@link https://en.wikipedia.org/wiki/Smoothstep#Variations}
   * that has zero 1st and 2nd order derivatives at x=0 and x=1.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smootherstep: Sz,
  /**
   * Returns a random integer from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random integer.
   */
  randInt: _z,
  /**
   * Returns a random float from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random float.
   */
  randFloat: Az,
  /**
   * Returns a random integer from `<-range/2, range/2>` interval.
   *
   * @static
   * @method
   * @param {number} range - Defines the value range.
   * @return {number} A random float.
   */
  randFloatSpread: Ez,
  /**
   * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
   *
   * @static
   * @method
   * @param {number} [s] - The integer seed.
   * @return {number} A random float.
   */
  seededRandom: bz,
  /**
   * Converts degrees to radians.
   *
   * @static
   * @method
   * @param {number} degrees - A value in degrees.
   * @return {number} The converted value in radians.
   */
  degToRad: Mz,
  /**
   * Converts radians to degrees.
   *
   * @static
   * @method
   * @param {number} radians - A value in radians.
   * @return {number} The converted value in degrees.
   */
  radToDeg: xz,
  /**
   * Returns `true` if the given number is a power of two.
   *
   * @static
   * @method
   * @param {number} value - The value to check.
   * @return {boolean} Whether the given number is a power of two or not.
   */
  isPowerOfTwo: Tz,
  /**
   * Returns the smallest power of two that is greater than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The smallest power of two that is greater than or equal to the given number.
   */
  ceilPowerOfTwo: Cz,
  /**
   * Returns the largest power of two that is less than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The largest power of two that is less than or equal to the given number.
   */
  floorPowerOfTwo: Rz,
  /**
   * Sets the given quaternion from the [Intrinsic Proper Euler Angles]{@link https://en.wikipedia.org/wiki/Euler_angles}
   * defined by the given angles and order.
   *
   * Rotations are applied to the axes in the order specified by order:
   * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
   *
   * @static
   * @method
   * @param {Quaternion} q - The quaternion to set.
   * @param {number} a - The rotation applied to the first axis, in radians.
   * @param {number} b - The rotation applied to the second axis, in radians.
   * @param {number} c - The rotation applied to the third axis, in radians.
   * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
   */
  setQuaternionFromProperEuler: Dz,
  /**
   * Normalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The float value in the range `[0,1]` to normalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The normalize value.
   */
  normalize: Wa,
  /**
   * Denormalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The value to denormalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The denormalize (float) value in the range `[0,1]`.
   */
  denormalize: Jd
};
class Ot {
  /**
   * Constructs a new 2D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   */
  constructor(e = 0, t = 0) {
    Ot.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  /**
   * Alias for {@link Vector2#x}.
   *
   * @type {number}
   */
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  /**
   * Alias for {@link Vector2#y}.
   *
   * @type {number}
   */
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @return {Vector2} A reference to this vector.
   */
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector2} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @param {number} value - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector2} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector2} v - The vector to copy.
   * @return {Vector2} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector2} v - The vector to add.
   * @return {Vector2} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector2} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector2} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector2} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector2} v - The vector to subtract.
   * @return {Vector2} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector2} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector2} v - The vector to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector2} v - The vector to divide.
   * @return {Vector2} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector2} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Multiplies this vector (with an implicit 1 as the 3rd component) by
   * the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {Vector2} A reference to this vector.
   */
  applyMatrix3(e) {
    const t = this.x, a = this.y, r = e.elements;
    return this.x = r[0] * t + r[3] * a + r[6], this.y = r[1] * t + r[4] * a + r[7], this;
  }
  /**
   * If this vector's x or y value is greater than the given vector's x or y
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is less than the given vector's x or y
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is greater than the max vector's x or y
   * value, it is replaced by the corresponding value.
   * If this vector's x or y value is less than the min vector's x or y value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector2} min - The minimum x and y values.
   * @param {Vector2} max - The maximum x and y values in the desired range.
   * @return {Vector2} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = Fa(this.x, e.x, t.x), this.y = Fa(this.y, e.y, t.y), this;
  }
  /**
   * If this vector's x or y values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x or y values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = Fa(this.x, e, t), this.y = Fa(this.y, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampLength(e, t) {
    const a = this.length();
    return this.divideScalar(a || 1).multiplyScalar(Fa(a, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector2} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x and y = -y.
   *
   * @return {Vector2} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the cross product with.
   * @return {number} The result of the cross product.
   */
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Computes the angle in radians of this vector with respect to the positive x-axis.
   *
   * @return {number} The angle in radians.
   */
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector2} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const a = this.dot(e) / t;
    return Math.acos(Fa(a, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector2} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const t = this.x - e.x, a = this.y - e.y;
    return t * t + a * a;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector2} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector2} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector2} v1 - The first vector.
   * @param {Vector2} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerpVectors(e, t, a) {
    return this.x = e.x + (t.x - e.x) * a, this.y = e.y + (t.y - e.y) * a, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector2} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]` and y
   * value to be `array[ offset + 1 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector2} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector2} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  /**
   * Rotates this vector around the given center by the given angle.
   *
   * @param {Vector2} center - The point around which to rotate.
   * @param {number} angle - The angle to rotate, in radians.
   * @return {Vector2} A reference to this vector.
   */
  rotateAround(e, t) {
    const a = Math.cos(t), r = Math.sin(t), d = this.x - e.x, p = this.y - e.y;
    return this.x = d * a - p * r + e.x, this.y = d * r + p * a + e.y, this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class ja {
  /**
   * Constructs a new 3x3 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   */
  constructor(e, t, a, r, d, p, y, _, E) {
    ja.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, a, r, d, p, y, _, E);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @return {Matrix3} A reference to this matrix.
   */
  set(e, t, a, r, d, p, y, _, E) {
    const T = this.elements;
    return T[0] = e, T[1] = r, T[2] = y, T[3] = t, T[4] = d, T[5] = _, T[6] = a, T[7] = p, T[8] = E, this;
  }
  /**
   * Sets this matrix to the 3x3 identity matrix.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix3} m - The matrix to copy.
   * @return {Matrix3} A reference to this matrix.
   */
  copy(e) {
    const t = this.elements, a = e.elements;
    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix3} A reference to this matrix.
   */
  extractBasis(e, t, a) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), a.setFromMatrix3Column(this, 2), this;
  }
  /**
   * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  /**
   * Post-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 3x3 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix3} a - The first matrix.
   * @param {Matrix3} b - The second matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyMatrices(e, t) {
    const a = e.elements, r = t.elements, d = this.elements, p = a[0], y = a[3], _ = a[6], E = a[1], T = a[4], C = a[7], D = a[2], B = a[5], z = a[8], V = r[0], G = r[3], N = r[6], F = r[1], q = r[4], Y = r[7], ie = r[2], k = r[5], le = r[8];
    return d[0] = p * V + y * F + _ * ie, d[3] = p * G + y * q + _ * k, d[6] = p * N + y * Y + _ * le, d[1] = E * V + T * F + C * ie, d[4] = E * G + T * q + C * k, d[7] = E * N + T * Y + C * le, d[2] = D * V + B * F + z * ie, d[5] = D * G + B * q + z * k, d[8] = D * N + B * Y + z * le, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, t = e[0], a = e[1], r = e[2], d = e[3], p = e[4], y = e[5], _ = e[6], E = e[7], T = e[8];
    return t * p * T - t * y * E - a * d * T + a * y * _ + r * d * E - r * p * _;
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  invert() {
    const e = this.elements, t = e[0], a = e[1], r = e[2], d = e[3], p = e[4], y = e[5], _ = e[6], E = e[7], T = e[8], C = T * p - y * E, D = y * _ - T * d, B = E * d - p * _, z = t * C + a * D + r * B;
    if (z === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const V = 1 / z;
    return e[0] = C * V, e[1] = (r * E - T * a) * V, e[2] = (y * a - r * p) * V, e[3] = D * V, e[4] = (T * t - r * _) * V, e[5] = (r * d - y * t) * V, e[6] = B * V, e[7] = (a * _ - E * t) * V, e[8] = (p * t - a * d) * V, this;
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  /**
   * Computes the normal matrix which is the inverse transpose of the upper
   * left 3x3 portion of the given 4x4 matrix.
   *
   * @param {Matrix4} matrix4 - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  /**
   * Transposes this matrix into the supplied array, and returns itself unchanged.
   *
   * @param {Array<number>} r - An array to store the transposed matrix elements.
   * @return {Matrix3} A reference to this matrix.
   */
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  /**
   * Sets the UV transform matrix from offset, repeat, rotation, and center.
   *
   * @param {number} tx - Offset x.
   * @param {number} ty - Offset y.
   * @param {number} sx - Repeat x.
   * @param {number} sy - Repeat y.
   * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
   * @param {number} cx - Center x of rotation.
   * @param {number} cy - Center y of rotation
   * @return {Matrix3} A reference to this matrix.
   */
  setUvTransform(e, t, a, r, d, p, y) {
    const _ = Math.cos(d), E = Math.sin(d);
    return this.set(
      a * _,
      a * E,
      -a * (_ * p + E * y) + p + e,
      -r * E,
      r * _,
      -r * (-E * p + _ * y) + y + t,
      0,
      0,
      1
    ), this;
  }
  /**
   * Scales this matrix with the given scalar values.
   *
   * @param {number} sx - The amount to scale in the X axis.
   * @param {number} sy - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  scale(e, t) {
    return this.premultiply(RT.makeScale(e, t)), this;
  }
  /**
   * Rotates this matrix by the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  rotate(e) {
    return this.premultiply(RT.makeRotation(-e)), this;
  }
  /**
   * Translates this matrix by the given scalar values.
   *
   * @param {number} tx - The amount to translate in the X axis.
   * @param {number} ty - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  translate(e, t) {
    return this.premultiply(RT.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  /**
   * Sets this matrix as a 2D translation transform.
   *
   * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D rotational transformation.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  makeRotation(e) {
    const t = Math.cos(e), a = Math.sin(e);
    return this.set(
      t,
      -a,
      0,
      a,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D scale transform.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix3} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const t = this.elements, a = e.elements;
    for (let r = 0; r < 9; r++)
      if (t[r] !== a[r]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix3} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let a = 0; a < 9; a++)
      this.elements[a] = e[a + t];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], t = 0) {
    const a = this.elements;
    return e[t] = a[0], e[t + 1] = a[1], e[t + 2] = a[2], e[t + 3] = a[3], e[t + 4] = a[4], e[t + 5] = a[5], e[t + 6] = a[6], e[t + 7] = a[7], e[t + 8] = a[8], e;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix3} A clone of this instance.
   */
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const RT = /* @__PURE__ */ new ja();
function hO(o) {
  for (let e = o.length - 1; e >= 0; --e)
    if (o[e] >= 65535) return !0;
  return !1;
}
const Bz = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function r1(o, e) {
  return new Bz[o](e);
}
function JA(o) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", o);
}
function pO() {
  const o = JA("canvas");
  return o.style.display = "block", o;
}
const JD = {};
function lM(o) {
  o in JD || (JD[o] = !0, console.warn(o));
}
function Uz(o, e, t) {
  return new Promise(function(a, r) {
    function d() {
      switch (o.clientWaitSync(e, o.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case o.WAIT_FAILED:
          r();
          break;
        case o.TIMEOUT_EXPIRED:
          setTimeout(d, t);
          break;
        default:
          a();
      }
    }
    setTimeout(d, t);
  });
}
function Oz(o) {
  const e = o.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function wz(o) {
  const e = o.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const KD = /* @__PURE__ */ new ja().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), kD = /* @__PURE__ */ new ja().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function Nz() {
  const o = {
    enabled: !0,
    workingColorSpace: Kv,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(r, d, p) {
      return this.enabled === !1 || d === p || !d || !p || (this.spaces[d].transfer === Nl && (r.r = qy(r.r), r.g = qy(r.g), r.b = qy(r.b)), this.spaces[d].primaries !== this.spaces[p].primaries && (r.applyMatrix3(this.spaces[d].toXYZ), r.applyMatrix3(this.spaces[p].fromXYZ)), this.spaces[p].transfer === Nl && (r.r = f1(r.r), r.g = f1(r.g), r.b = f1(r.b))), r;
    },
    fromWorkingColorSpace: function(r, d) {
      return this.convert(r, this.workingColorSpace, d);
    },
    toWorkingColorSpace: function(r, d) {
      return this.convert(r, d, this.workingColorSpace);
    },
    getPrimaries: function(r) {
      return this.spaces[r].primaries;
    },
    getTransfer: function(r) {
      return r === Fy ? ZA : this.spaces[r].transfer;
    },
    getLuminanceCoefficients: function(r, d = this.workingColorSpace) {
      return r.fromArray(this.spaces[d].luminanceCoefficients);
    },
    define: function(r) {
      Object.assign(this.spaces, r);
    },
    // Internal APIs
    _getMatrix: function(r, d, p) {
      return r.copy(this.spaces[d].toXYZ).multiply(this.spaces[p].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(r) {
      return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(r = this.workingColorSpace) {
      return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
    }
  }, e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], t = [0.2126, 0.7152, 0.0722], a = [0.3127, 0.329];
  return o.define({
    [Kv]: {
      primaries: e,
      whitePoint: a,
      transfer: ZA,
      toXYZ: KD,
      fromXYZ: kD,
      luminanceCoefficients: t,
      workingColorSpaceConfig: { unpackColorSpace: lf },
      outputColorSpaceConfig: { drawingBufferColorSpace: lf }
    },
    [lf]: {
      primaries: e,
      whitePoint: a,
      transfer: Nl,
      toXYZ: KD,
      fromXYZ: kD,
      luminanceCoefficients: t,
      outputColorSpaceConfig: { drawingBufferColorSpace: lf }
    }
  }), o;
}
const wi = /* @__PURE__ */ Nz();
function qy(o) {
  return o < 0.04045 ? o * 0.0773993808 : Math.pow(o * 0.9478672986 + 0.0521327014, 2.4);
}
function f1(o) {
  return o < 31308e-7 ? o * 12.92 : 1.055 * Math.pow(o, 0.41666) - 0.055;
}
let V_;
class mO {
  /**
   * Returns a data URI containing a representation of the given image.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
   * @param {string} [type='image/png'] - Indicates the image format.
   * @return {string} The data URI.
   */
  static getDataURL(e, t = "image/png") {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let a;
    if (e instanceof HTMLCanvasElement)
      a = e;
    else {
      V_ === void 0 && (V_ = JA("canvas")), V_.width = e.width, V_.height = e.height;
      const r = V_.getContext("2d");
      e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), a = V_;
    }
    return a.toDataURL(t);
  }
  /**
   * Converts the given sRGB image data to linear color space.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
   * @return {HTMLCanvasElement|Object} The converted image.
   */
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = JA("canvas");
      t.width = e.width, t.height = e.height;
      const a = t.getContext("2d");
      a.drawImage(e, 0, 0, e.width, e.height);
      const r = a.getImageData(0, 0, e.width, e.height), d = r.data;
      for (let p = 0; p < d.length; p++)
        d[p] = qy(d[p] / 255) * 255;
      return a.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let a = 0; a < t.length; a++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[a] = Math.floor(qy(t[a] / 255) * 255) : t[a] = qy(t[a]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let zz = 0;
class V0 {
  /**
   * Constructs a new video texture.
   *
   * @param {any} [data=null] - The data definition of a texture.
   */
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: zz++ }), this.uuid = Gp(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  /**
   * When the property is set to `true`, the engine allocates the memory
   * for the texture (if necessary) and triggers the actual texture upload
   * to the GPU next time the source is used.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Serializes the source into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized source.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const a = {
      uuid: this.uuid,
      url: ""
    }, r = this.data;
    if (r !== null) {
      let d;
      if (Array.isArray(r)) {
        d = [];
        for (let p = 0, y = r.length; p < y; p++)
          r[p].isDataTexture ? d.push(DT(r[p].image)) : d.push(DT(r[p]));
      } else
        d = DT(r);
      a.url = d;
    }
    return t || (e.images[this.uuid] = a), a;
  }
}
function DT(o) {
  return typeof HTMLImageElement < "u" && o instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && o instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && o instanceof ImageBitmap ? mO.getDataURL(o) : o.data ? {
    data: Array.from(o.data),
    width: o.width,
    height: o.height,
    type: o.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Hz = 0;
class Ml extends Jg {
  /**
   * Constructs a new texture.
   *
   * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e = Ml.DEFAULT_IMAGE, t = Ml.DEFAULT_MAPPING, a = Mo, r = Mo, d = Ni, p = qm, y = xo, _ = qh, E = Ml.DEFAULT_ANISOTROPY, T = Fy) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Hz++ }), this.uuid = Gp(), this.name = "", this.source = new V0(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = a, this.wrapT = r, this.magFilter = d, this.minFilter = p, this.anisotropy = E, this.format = y, this.internalFormat = null, this.type = _, this.offset = new Ot(0, 0), this.repeat = new Ot(1, 1), this.center = new Ot(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ja(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = T, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  /**
   * The image object holding the texture data.
   *
   * @type {?Object}
   */
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  /**
   * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
   * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
   */
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  /**
   * Returns a new texture with copied values from this instance.
   *
   * @return {Texture} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given texture to this instance.
   *
   * @param {Texture} source - The texture to copy.
   * @return {Texture} A reference to this instance.
   */
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  /**
   * Serializes the texture into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized texture.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const a = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (a.userData = this.userData), t || (e.textures[this.uuid] = a), a;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Transforms the given uv vector with the textures uv transformation matrix.
   *
   * @param {Vector2} uv - The uv vector.
   * @return {Vector2} The transformed uv vector.
   */
  transformUv(e) {
    if (this.mapping !== X0) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case q0:
          e.x = e.x - Math.floor(e.x);
          break;
        case Mo:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case m1:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case q0:
          e.y = e.y - Math.floor(e.y);
          break;
        case Mo:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case m1:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  /**
   * Setting this property to `true` indicates the engine the texture
   * must be updated in the next render. This triggers a texture upload
   * to the GPU and ensures correct texture parameter configuration.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  /**
   * Setting this property to `true` indicates the engine the PMREM
   * must be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Ml.DEFAULT_IMAGE = null;
Ml.DEFAULT_MAPPING = X0;
Ml.DEFAULT_ANISOTROPY = 1;
class Bi {
  /**
   * Constructs a new 4D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   * @param {number} [w=1] - The w value of this vector.
   */
  constructor(e = 0, t = 0, a = 0, r = 1) {
    Bi.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = a, this.w = r;
  }
  /**
   * Alias for {@link Vector4#z}.
   *
   * @type {number}
   */
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  /**
   * Alias for {@link Vector4#w}.
   *
   * @type {number}
   */
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @param {number} w - The value of the w component.
   * @return {Vector4} A reference to this vector.
   */
  set(e, t, a, r) {
    return this.x = e, this.y = t, this.z = a, this.w = r, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector4} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Sets the vector's w component to the given value
   *
   * @param {number} w - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setW(e) {
    return this.w = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @param {number} value - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector4} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3|Vector4} v - The vector to copy.
   * @return {Vector4} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector4} v - The vector to add.
   * @return {Vector4} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector4} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector4} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector4} v - The vector to subtract.
   * @return {Vector4} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector4} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector4} v - The vector to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  /**
   * Multiplies this vector with the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  applyMatrix4(e) {
    const t = this.x, a = this.y, r = this.z, d = this.w, p = e.elements;
    return this.x = p[0] * t + p[4] * a + p[8] * r + p[12] * d, this.y = p[1] * t + p[5] * a + p[9] * r + p[13] * d, this.z = p[2] * t + p[6] * a + p[10] * r + p[14] * d, this.w = p[3] * t + p[7] * a + p[11] * r + p[15] * d, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector4} v - The vector to divide.
   * @return {Vector4} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector4} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Sets the x, y and z components of this
   * vector to the quaternion's axis and w to the angle.
   *
   * @param {Quaternion} q - The Quaternion to set.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  /**
   * Sets the x, y and z components of this
   * vector to the axis of rotation and w to the angle.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromRotationMatrix(e) {
    let t, a, r, d;
    const _ = e.elements, E = _[0], T = _[4], C = _[8], D = _[1], B = _[5], z = _[9], V = _[2], G = _[6], N = _[10];
    if (Math.abs(T - D) < 0.01 && Math.abs(C - V) < 0.01 && Math.abs(z - G) < 0.01) {
      if (Math.abs(T + D) < 0.1 && Math.abs(C + V) < 0.1 && Math.abs(z + G) < 0.1 && Math.abs(E + B + N - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const q = (E + 1) / 2, Y = (B + 1) / 2, ie = (N + 1) / 2, k = (T + D) / 4, le = (C + V) / 4, ne = (z + G) / 4;
      return q > Y && q > ie ? q < 0.01 ? (a = 0, r = 0.707106781, d = 0.707106781) : (a = Math.sqrt(q), r = k / a, d = le / a) : Y > ie ? Y < 0.01 ? (a = 0.707106781, r = 0, d = 0.707106781) : (r = Math.sqrt(Y), a = k / r, d = ne / r) : ie < 0.01 ? (a = 0.707106781, r = 0.707106781, d = 0) : (d = Math.sqrt(ie), a = le / d, r = ne / d), this.set(a, r, d, t), this;
    }
    let F = Math.sqrt((G - z) * (G - z) + (C - V) * (C - V) + (D - T) * (D - T));
    return Math.abs(F) < 1e-3 && (F = 1), this.x = (G - z) / F, this.y = (C - V) / F, this.z = (D - T) / F, this.w = Math.acos((E + B + N - 1) / 2), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
   * value, it is replaced by the corresponding value.
   * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector4} min - The minimum x, y and z values.
   * @param {Vector4} max - The maximum x, y and z values in the desired range.
   * @return {Vector4} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = Fa(this.x, e.x, t.x), this.y = Fa(this.y, e.y, t.y), this.z = Fa(this.z, e.z, t.z), this.w = Fa(this.w, e.w, t.w), this;
  }
  /**
   * If this vector's x, y, z or w values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y, z or w values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = Fa(this.x, e, t), this.y = Fa(this.y, e, t), this.z = Fa(this.z, e, t), this.w = Fa(this.w, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampLength(e, t) {
    const a = this.length();
    return this.divideScalar(a || 1).multiplyScalar(Fa(a, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector4} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
   *
   * @return {Vector4} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector4} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector4} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector4} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector4} v1 - The first vector.
   * @param {Vector4} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerpVectors(e, t, a) {
    return this.x = e.x + (t.x - e.x) * a, this.y = e.y + (t.y - e.y) * a, this.z = e.z + (t.z - e.z) * a, this.w = e.w + (t.w - e.w) * a, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector4} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
   * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector4} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector4} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class hx extends Jg {
  /**
   * Render target options.
   *
   * @typedef {Object} RenderTarget~Options
   * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
   * @property {number} [magFilter=LinearFilter] - The mag filter.
   * @property {number} [minFilter=LinearFilter] - The min filter.
   * @property {number} [format=RGBAFormat] - The texture format.
   * @property {number} [type=UnsignedByteType] - The texture type.
   * @property {?string} [internalFormat=null] - The texture's internal format.
   * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [anisotropy=1] - The texture's anisotropy value.
   * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
   * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
   * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
   * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
   * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
   * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
   * @property {number} [samples=0] - The MSAA samples count.
   * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
   */
  /**
   * Constructs a new render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, a = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Bi(0, 0, e, t), this.scissorTest = !1, this.viewport = new Bi(0, 0, e, t);
    const r = { width: e, height: t, depth: 1 };
    a = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Ni,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, a);
    const d = new Ml(r, a.mapping, a.wrapS, a.wrapT, a.magFilter, a.minFilter, a.format, a.type, a.anisotropy, a.colorSpace);
    d.flipY = !1, d.generateMipmaps = a.generateMipmaps, d.internalFormat = a.internalFormat, this.textures = [];
    const p = a.count;
    for (let y = 0; y < p; y++)
      this.textures[y] = d.clone(), this.textures[y].isRenderTargetTexture = !0, this.textures[y].renderTarget = this;
    this.depthBuffer = a.depthBuffer, this.stencilBuffer = a.stencilBuffer, this.resolveDepthBuffer = a.resolveDepthBuffer, this.resolveStencilBuffer = a.resolveStencilBuffer, this._depthTexture = a.depthTexture, this.samples = a.samples;
  }
  /**
   * The texture representing the default color attachment.
   *
   * @type {Texture}
   */
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
  }
  /**
   * Instead of saving the depth in a renderbuffer, a texture
   * can be used instead which is useful for further processing
   * e.g. in context of post-processing.
   *
   * @type {?DepthTexture}
   * @default null
   */
  get depthTexture() {
    return this._depthTexture;
  }
  /**
   * Sets the size of this render target.
   *
   * @param {number} width - The width.
   * @param {number} height - The height.
   * @param {number} [depth=1] - The depth.
   */
  setSize(e, t, a = 1) {
    if (this.width !== e || this.height !== t || this.depth !== a) {
      this.width = e, this.height = t, this.depth = a;
      for (let r = 0, d = this.textures.length; r < d; r++)
        this.textures[r].image.width = e, this.textures[r].image.height = t, this.textures[r].image.depth = a;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  /**
   * Returns a new render target with copied values from this instance.
   *
   * @return {RenderTarget} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the settings of the given render target. This is a structural copy so
   * no resources are shared between render targets after the copy. That includes
   * all MRT textures and the depth texture.
   *
   * @param {RenderTarget} source - The render target to copy.
   * @return {RenderTarget} A reference to this instance.
   */
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let t = 0, a = e.textures.length; t < a; t++) {
      this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
      const r = Object.assign({}, e.textures[t].image);
      this.textures[t].source = new V0(r);
    }
    return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires RenderTarget#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class uf extends hx {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, a = {}) {
    super(e, t, a), this.isWebGLRenderTarget = !0;
  }
}
class rE extends Ml {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e = null, t = 1, a = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: a, depth: r }, this.magFilter = _c, this.minFilter = _c, this.wrapR = Mo, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire data texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Lz extends uf {
  /**
   * Constructs a new array render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {number} [depth=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, a = 1, r = {}) {
    super(e, t, r), this.isWebGLArrayRenderTarget = !0, this.depth = a, this.texture = new rE(null, e, t, a), this.texture.isRenderTargetTexture = !0;
  }
}
class px extends Ml {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e = null, t = 1, a = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: a, depth: r }, this.magFilter = _c, this.minFilter = _c, this.wrapR = Mo, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Gz extends uf {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {number} [depth=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, a = 1, r = {}) {
    super(e, t, r), this.isWebGL3DRenderTarget = !0, this.depth = a, this.texture = new px(null, e, t, a), this.texture.isRenderTargetTexture = !0;
  }
}
class Ac {
  /**
   * Constructs a new quaternion.
   *
   * @param {number} [x=0] - The x value of this quaternion.
   * @param {number} [y=0] - The y value of this quaternion.
   * @param {number} [z=0] - The z value of this quaternion.
   * @param {number} [w=1] - The w value of this quaternion.
   */
  constructor(e = 0, t = 0, a = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = a, this._w = r;
  }
  /**
   * Interpolates between two quaternions via SLERP. This implementation assumes the
   * quaternion data are managed  in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @param {number} t - The interpolation factor in the range `[0,1]`.
   * @see {@link Quaternion#slerp}
   */
  static slerpFlat(e, t, a, r, d, p, y) {
    let _ = a[r + 0], E = a[r + 1], T = a[r + 2], C = a[r + 3];
    const D = d[p + 0], B = d[p + 1], z = d[p + 2], V = d[p + 3];
    if (y === 0) {
      e[t + 0] = _, e[t + 1] = E, e[t + 2] = T, e[t + 3] = C;
      return;
    }
    if (y === 1) {
      e[t + 0] = D, e[t + 1] = B, e[t + 2] = z, e[t + 3] = V;
      return;
    }
    if (C !== V || _ !== D || E !== B || T !== z) {
      let G = 1 - y;
      const N = _ * D + E * B + T * z + C * V, F = N >= 0 ? 1 : -1, q = 1 - N * N;
      if (q > Number.EPSILON) {
        const ie = Math.sqrt(q), k = Math.atan2(ie, N * F);
        G = Math.sin(G * k) / ie, y = Math.sin(y * k) / ie;
      }
      const Y = y * F;
      if (_ = _ * G + D * Y, E = E * G + B * Y, T = T * G + z * Y, C = C * G + V * Y, G === 1 - y) {
        const ie = 1 / Math.sqrt(_ * _ + E * E + T * T + C * C);
        _ *= ie, E *= ie, T *= ie, C *= ie;
      }
    }
    e[t] = _, e[t + 1] = E, e[t + 2] = T, e[t + 3] = C;
  }
  /**
   * Multiplies two quaternions. This implementation assumes the quaternion data are managed
   * in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @return {Array<number>} The destination array.
   * @see {@link Quaternion#multiplyQuaternions}.
   */
  static multiplyQuaternionsFlat(e, t, a, r, d, p) {
    const y = a[r], _ = a[r + 1], E = a[r + 2], T = a[r + 3], C = d[p], D = d[p + 1], B = d[p + 2], z = d[p + 3];
    return e[t] = y * z + T * C + _ * B - E * D, e[t + 1] = _ * z + T * D + E * C - y * B, e[t + 2] = E * z + T * B + y * D - _ * C, e[t + 3] = T * z - y * C - _ * D - E * B, e;
  }
  /**
   * The x value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The y value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The z value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * The w value of this quaternion.
   *
   * @type {number}
   * @default 1
   */
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  /**
   * Sets the quaternion components.
   *
   * @param {number} x - The x value of this quaternion.
   * @param {number} y - The y value of this quaternion.
   * @param {number} z - The z value of this quaternion.
   * @param {number} w - The w value of this quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  set(e, t, a, r) {
    return this._x = e, this._y = t, this._z = a, this._w = r, this._onChangeCallback(), this;
  }
  /**
   * Returns a new quaternion with copied values from this instance.
   *
   * @return {Quaternion} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  /**
   * Copies the values of the given quaternion to this instance.
   *
   * @param {Quaternion} quaternion - The quaternion to copy.
   * @return {Quaternion} A reference to this quaternion.
   */
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the rotation specified by the given
   * Euler angles.
   *
   * @param {Euler} euler - The Euler angles.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromEuler(e, t = !0) {
    const a = e._x, r = e._y, d = e._z, p = e._order, y = Math.cos, _ = Math.sin, E = y(a / 2), T = y(r / 2), C = y(d / 2), D = _(a / 2), B = _(r / 2), z = _(d / 2);
    switch (p) {
      case "XYZ":
        this._x = D * T * C + E * B * z, this._y = E * B * C - D * T * z, this._z = E * T * z + D * B * C, this._w = E * T * C - D * B * z;
        break;
      case "YXZ":
        this._x = D * T * C + E * B * z, this._y = E * B * C - D * T * z, this._z = E * T * z - D * B * C, this._w = E * T * C + D * B * z;
        break;
      case "ZXY":
        this._x = D * T * C - E * B * z, this._y = E * B * C + D * T * z, this._z = E * T * z + D * B * C, this._w = E * T * C - D * B * z;
        break;
      case "ZYX":
        this._x = D * T * C - E * B * z, this._y = E * B * C + D * T * z, this._z = E * T * z - D * B * C, this._w = E * T * C + D * B * z;
        break;
      case "YZX":
        this._x = D * T * C + E * B * z, this._y = E * B * C + D * T * z, this._z = E * T * z - D * B * C, this._w = E * T * C - D * B * z;
        break;
      case "XZY":
        this._x = D * T * C - E * B * z, this._y = E * B * C - D * T * z, this._z = E * T * z + D * B * C, this._w = E * T * C + D * B * z;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + p);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given axis and angle.
   *
   * @param {Vector3} axis - The normalized axis.
   * @param {number} angle - The angle in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromAxisAngle(e, t) {
    const a = t / 2, r = Math.sin(a);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(a), this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromRotationMatrix(e) {
    const t = e.elements, a = t[0], r = t[4], d = t[8], p = t[1], y = t[5], _ = t[9], E = t[2], T = t[6], C = t[10], D = a + y + C;
    if (D > 0) {
      const B = 0.5 / Math.sqrt(D + 1);
      this._w = 0.25 / B, this._x = (T - _) * B, this._y = (d - E) * B, this._z = (p - r) * B;
    } else if (a > y && a > C) {
      const B = 2 * Math.sqrt(1 + a - y - C);
      this._w = (T - _) / B, this._x = 0.25 * B, this._y = (r + p) / B, this._z = (d + E) / B;
    } else if (y > C) {
      const B = 2 * Math.sqrt(1 + y - a - C);
      this._w = (d - E) / B, this._x = (r + p) / B, this._y = 0.25 * B, this._z = (_ + T) / B;
    } else {
      const B = 2 * Math.sqrt(1 + C - a - y);
      this._w = (p - r) / B, this._x = (d + E) / B, this._y = (_ + T) / B, this._z = 0.25 * B;
    }
    return this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion to the rotation required to rotate the direction vector
   * `vFrom` to the direction vector `vTo`.
   *
   * @param {Vector3} vFrom - The first (normalized) direction vector.
   * @param {Vector3} vTo - The second (normalized) direction vector.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromUnitVectors(e, t) {
    let a = e.dot(t) + 1;
    return a < Number.EPSILON ? (a = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = a) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = a)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = a), this.normalize();
  }
  /**
   * Returns the angle between this quaternion and the given one in radians.
   *
   * @param {Quaternion} q - The quaternion to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Fa(this.dot(e), -1, 1)));
  }
  /**
   * Rotates this quaternion by a given angular step to the given quaternion.
   * The method ensures that the final quaternion will not overshoot `q`.
   *
   * @param {Quaternion} q - The target quaternion.
   * @param {number} step - The angular step in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  rotateTowards(e, t) {
    const a = this.angleTo(e);
    if (a === 0) return this;
    const r = Math.min(1, t / a);
    return this.slerp(e, r), this;
  }
  /**
   * Sets this quaternion to the identity quaternion; that is, to the
   * quaternion that represents "no rotation".
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  identity() {
    return this.set(0, 0, 0, 1);
  }
  /**
   * Inverts this quaternion via {@link Quaternion#conjugate}. The
   * quaternion is assumed to have unit length.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  invert() {
    return this.conjugate();
  }
  /**
   * Returns the rotational conjugate of this quaternion. The conjugate of a
   * quaternion represents the same rotation in the opposite direction about
   * the rotational axis.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  /**
   * Calculates the dot product of this quaternion and the given one.
   *
   * @param {Quaternion} v - The quaternion to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  /**
   * Computes the squared Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector. This can be useful if you are comparing the
   * lengths of two quaternions, as this is a slightly more efficient calculation than
   * {@link Quaternion#length}.
   *
   * @return {number} The squared Euclidean length.
   */
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  /**
   * Computes the Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector.
   *
   * @return {number} The Euclidean length.
   */
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  /**
   * Normalizes this quaternion - that is, calculated the quaternion that performs
   * the same rotation as this one, but has a length equal to `1`.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  /**
   * Multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  /**
   * Pre-multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  /**
   * Multiplies the given quaternions and stores the result in this instance.
   *
   * @param {Quaternion} a - The first quaternion.
   * @param {Quaternion} b - The second quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiplyQuaternions(e, t) {
    const a = e._x, r = e._y, d = e._z, p = e._w, y = t._x, _ = t._y, E = t._z, T = t._w;
    return this._x = a * T + p * y + r * E - d * _, this._y = r * T + p * _ + d * y - a * E, this._z = d * T + p * E + a * _ - r * y, this._w = p * T - a * y - r * _ - d * E, this._onChangeCallback(), this;
  }
  /**
   * Performs a spherical linear interpolation between quaternions.
   *
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const a = this._x, r = this._y, d = this._z, p = this._w;
    let y = p * e._w + a * e._x + r * e._y + d * e._z;
    if (y < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, y = -y) : this.copy(e), y >= 1)
      return this._w = p, this._x = a, this._y = r, this._z = d, this;
    const _ = 1 - y * y;
    if (_ <= Number.EPSILON) {
      const B = 1 - t;
      return this._w = B * p + t * this._w, this._x = B * a + t * this._x, this._y = B * r + t * this._y, this._z = B * d + t * this._z, this.normalize(), this;
    }
    const E = Math.sqrt(_), T = Math.atan2(E, y), C = Math.sin((1 - t) * T) / E, D = Math.sin(t * T) / E;
    return this._w = p * C + this._w * D, this._x = a * C + this._x * D, this._y = r * C + this._y * D, this._z = d * C + this._z * D, this._onChangeCallback(), this;
  }
  /**
   * Performs a spherical linear interpolation between the given quaternions
   * and stores the result in this quaternion.
   *
   * @param {Quaternion} qa - The source quaternion.
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerpQuaternions(e, t, a) {
    return this.copy(e).slerp(t, a);
  }
  /**
   * Sets this quaternion to a uniformly random, normalized quaternion.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), a = Math.random(), r = Math.sqrt(1 - a), d = Math.sqrt(a);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      d * Math.sin(t),
      d * Math.cos(t)
    );
  }
  /**
   * Returns `true` if this quaternion is equal with the given one.
   *
   * @param {Quaternion} quaternion - The quaternion to test for equality.
   * @return {boolean} Whether this quaternion is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  /**
   * Sets this quaternion's components from the given array.
   *
   * @param {Array<number>} array - An array holding the quaternion component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this quaternion to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The quaternion components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  /**
   * Sets the components of this quaternion from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
   * @param {number} index - The index into the attribute.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the
   * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
   *
   * @return {Array<number>} The serialized quaternion.
   */
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class ve {
  /**
   * Constructs a new 3D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   */
  constructor(e = 0, t = 0, a = 0) {
    ve.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = a;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @return {Vector3} A reference to this vector.
   */
  set(e, t, a) {
    return a === void 0 && (a = this.z), this.x = e, this.y = t, this.z = a, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector3} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @param {number} value - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector3} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3} v - The vector to copy.
   * @return {Vector3} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector3} v - The vector to add.
   * @return {Vector3} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector3} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector3|Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector3} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector3} v - The vector to subtract.
   * @return {Vector3} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector3} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector3} v - The vector to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  /**
   * Multiplies the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  /**
   * Applies the given Euler rotation to this vector.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Vector3} A reference to this vector.
   */
  applyEuler(e) {
    return this.applyQuaternion(WD.setFromEuler(e));
  }
  /**
   * Applies a rotation specified by an axis and an angle to this vector.
   *
   * @param {Vector3} axis - A normalized vector representing the rotation axis.
   * @param {number} angle - The angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  applyAxisAngle(e, t) {
    return this.applyQuaternion(WD.setFromAxisAngle(e, t));
  }
  /**
   * Multiplies this vector with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix3(e) {
    const t = this.x, a = this.y, r = this.z, d = e.elements;
    return this.x = d[0] * t + d[3] * a + d[6] * r, this.y = d[1] * t + d[4] * a + d[7] * r, this.z = d[2] * t + d[5] * a + d[8] * r, this;
  }
  /**
   * Multiplies this vector by the given normal matrix and normalizes
   * the result.
   *
   * @param {Matrix3} m - The normal matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  /**
   * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
   * divides by perspective.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix4(e) {
    const t = this.x, a = this.y, r = this.z, d = e.elements, p = 1 / (d[3] * t + d[7] * a + d[11] * r + d[15]);
    return this.x = (d[0] * t + d[4] * a + d[8] * r + d[12]) * p, this.y = (d[1] * t + d[5] * a + d[9] * r + d[13]) * p, this.z = (d[2] * t + d[6] * a + d[10] * r + d[14]) * p, this;
  }
  /**
   * Applies the given Quaternion to this vector.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Vector3} A reference to this vector.
   */
  applyQuaternion(e) {
    const t = this.x, a = this.y, r = this.z, d = e.x, p = e.y, y = e.z, _ = e.w, E = 2 * (p * r - y * a), T = 2 * (y * t - d * r), C = 2 * (d * a - p * t);
    return this.x = t + _ * E + p * C - y * T, this.y = a + _ * T + y * E - d * C, this.z = r + _ * C + d * T - p * E, this;
  }
  /**
   * Projects this vector from world space into the camera's normalized
   * device coordinate (NDC) space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  /**
   * Unprojects this vector from the camera's normalized device coordinate (NDC)
   * space into world space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  /**
   * Transforms the direction of this vector by a matrix (the upper left 3 x 3
   * subset of the given 4x4 matrix and then normalizes the result.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Vector3} A reference to this vector.
   */
  transformDirection(e) {
    const t = this.x, a = this.y, r = this.z, d = e.elements;
    return this.x = d[0] * t + d[4] * a + d[8] * r, this.y = d[1] * t + d[5] * a + d[9] * r, this.z = d[2] * t + d[6] * a + d[10] * r, this.normalize();
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector3} v - The vector to divide.
   * @return {Vector3} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector3} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * If this vector's x, y or z value is greater than the given vector's x, y or z
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is less than the given vector's x, y or z
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is greater than the max vector's x, y or z
   * value, it is replaced by the corresponding value.
   * If this vector's x, y or z value is less than the min vector's x, y or z value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector3} min - The minimum x, y and z values.
   * @param {Vector3} max - The maximum x, y and z values in the desired range.
   * @return {Vector3} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = Fa(this.x, e.x, t.x), this.y = Fa(this.y, e.y, t.y), this.z = Fa(this.z, e.z, t.z), this;
  }
  /**
   * If this vector's x, y or z values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y or z values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = Fa(this.x, e, t), this.y = Fa(this.y, e, t), this.z = Fa(this.z, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampLength(e, t) {
    const a = this.length();
    return this.divideScalar(a || 1).multiplyScalar(Fa(a, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector3} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
   *
   * @return {Vector3} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector3} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector3} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector3} v1 - The first vector.
   * @param {Vector3} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerpVectors(e, t, a) {
    return this.x = e.x + (t.x - e.x) * a, this.y = e.y + (t.y - e.y) * a, this.z = e.z + (t.z - e.z) * a, this;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the cross product with.
   * @return {Vector3} The result of the cross product.
   */
  cross(e) {
    return this.crossVectors(this, e);
  }
  /**
   * Calculates the cross product of the given vectors and stores the result
   * in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  crossVectors(e, t) {
    const a = e.x, r = e.y, d = e.z, p = t.x, y = t.y, _ = t.z;
    return this.x = r * _ - d * y, this.y = d * p - a * _, this.z = a * y - r * p, this;
  }
  /**
   * Projects this vector onto the given one.
   *
   * @param {Vector3} v - The vector to project to.
   * @return {Vector3} A reference to this vector.
   */
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const a = e.dot(this) / t;
    return this.copy(e).multiplyScalar(a);
  }
  /**
   * Projects this vector onto a plane by subtracting this
   * vector projected onto the plane's normal from this vector.
   *
   * @param {Vector3} planeNormal - The plane normal.
   * @return {Vector3} A reference to this vector.
   */
  projectOnPlane(e) {
    return BT.copy(this).projectOnVector(e), this.sub(BT);
  }
  /**
   * Reflects this vector off a plane orthogonal to the given normal vector.
   *
   * @param {Vector3} normal - The (normalized) normal vector.
   * @return {Vector3} A reference to this vector.
   */
  reflect(e) {
    return this.sub(BT.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector3} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const a = this.dot(e) / t;
    return Math.acos(Fa(a, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector3} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const t = this.x - e.x, a = this.y - e.y, r = this.z - e.z;
    return t * t + a * a + r * r;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {Spherical} s - The spherical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The phi angle in radians.
   * @param {number} theta - The theta angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  setFromSphericalCoords(e, t, a) {
    const r = Math.sin(t) * e;
    return this.x = r * Math.sin(a), this.y = Math.cos(t) * e, this.z = r * Math.cos(a), this;
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {Cylindrical} c - The cylindrical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle in radians.
   * @param {number} y - The y value.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindricalCoords(e, t, a) {
    return this.x = e * Math.sin(t), this.y = a, this.z = e * Math.cos(t), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  /**
   * Sets the vector components to the scale elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), a = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = a, this.z = r, this;
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  /**
   * Sets the vector components from the given Euler angles.
   *
   * @param {Euler} e - The Euler angles to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  /**
   * Sets the vector components from the RGB components of the
   * given color.
   *
   * @param {Color} c - The color to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector3} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
   * and z value to be `array[ offset + 2 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector3} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector3} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  /**
   * Sets this vector to a uniformly random point on a unit sphere.
   *
   * @return {Vector3} A reference to this vector.
   */
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, a = Math.sqrt(1 - t * t);
    return this.x = a * Math.cos(e), this.y = t, this.z = a * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const BT = /* @__PURE__ */ new ve(), WD = /* @__PURE__ */ new Ac();
class td {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(e = new ve(1 / 0, 1 / 0, 1 / 0), t = new ve(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector3} min - The lower boundary of the box.
   * @param {Vector3} max - The upper boundary of the box.
   * @return {Box3} A reference to this bounding box.
   */
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<number>} array - An array holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, a = e.length; t < a; t += 3)
      this.expandByPoint(Fv.fromArray(e, t));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, a = e.count; t < a; t++)
      this.expandByPoint(Fv.fromBufferAttribute(e, t));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
   * @return {Box3} A reference to this bounding box.
   */
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, a = e.length; t < a; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector3} center - The center of the box.
   * @param {Vector3} size - The x, y and z dimensions of the box.
   * @return {Box3} A reference to this bounding box.
   */
  setFromCenterAndSize(e, t) {
    const a = Fv.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(a), this.max.copy(e).add(a), this;
  }
  /**
   * Computes the world-axis-aligned bounding box for the given 3D object
   * (including its children), accounting for the object's, and children's,
   * world transforms. The function may result in a larger box than strictly necessary.
   *
   * @param {Object3D} object - The 3D object to compute the bounding box for.
   * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
   * world-axis-aligned bounding box at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box3} box - The box to copy.
   * @return {Box3} A reference to this bounding box.
   */
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 3D.
   *
   * @return {Box3} A reference to this bounding box.
   */
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The size.
   */
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector3} point - The point that should be included by the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions. The depth of this box will be
   * expanded by the z component of the vector in both directions.
   *
   * @param {Vector3} vector - The vector that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  /**
   * Expands the boundaries of this box to include the given 3D object and
   * its children, accounting for the object's, and children's, world
   * transforms. The function may result in a larger box than strictly
   * necessary (unless the precise parameter is set to true).
   *
   * @param {Object3D} object - The 3D object that should expand the bounding box.
   * @param {boolean} precise - If set to `true`, the method expands the bounding box
   * as little as necessary at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const a = e.geometry;
    if (a !== void 0) {
      const d = a.getAttribute("position");
      if (t === !0 && d !== void 0 && e.isInstancedMesh !== !0)
        for (let p = 0, y = d.count; p < y; p++)
          e.isMesh === !0 ? e.getVertexPosition(p, Fv) : Fv.fromBufferAttribute(d, p), Fv.applyMatrix4(e.matrixWorld), this.expandByPoint(Fv);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), kE.copy(e.boundingBox)) : (a.boundingBox === null && a.computeBoundingBox(), kE.copy(a.boundingBox)), kE.applyMatrix4(e.matrixWorld), this.union(kE);
    }
    const r = e.children;
    for (let d = 0, p = r.length; d < p; d++)
      this.expandByObject(r[d], t);
    return this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  /**
   * Returns a point as a proportion of this box's width, height and depth.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A point as a proportion of this box's width, height and depth.
   */
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  /**
   * Returns `true` if the given bounding sphere intersects with this bounding box.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
   */
  intersectsSphere(e) {
    return this.clampPoint(e.center, Fv), Fv.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  /**
   * Returns `true` if the given plane intersects with this bounding box.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether the given plane intersects with this bounding box.
   */
  intersectsPlane(e) {
    let t, a;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, a = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, a = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, a += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, a += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, a += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, a += e.normal.z * this.min.z), t <= -e.constant && a >= -e.constant;
  }
  /**
   * Returns `true` if the given triangle intersects with this bounding box.
   *
   * @param {Triangle} triangle - The triangle to test.
   * @return {boolean} Whether the given triangle intersects with this bounding box.
   */
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(oA), WE.subVectors(this.max, oA), F_.subVectors(e.a, oA), P_.subVectors(e.b, oA), X_.subVectors(e.c, oA), B0.subVectors(P_, F_), U0.subVectors(X_, P_), AS.subVectors(F_, X_);
    let t = [
      0,
      -B0.z,
      B0.y,
      0,
      -U0.z,
      U0.y,
      0,
      -AS.z,
      AS.y,
      B0.z,
      0,
      -B0.x,
      U0.z,
      0,
      -U0.x,
      AS.z,
      0,
      -AS.x,
      -B0.y,
      B0.x,
      0,
      -U0.y,
      U0.x,
      0,
      -AS.y,
      AS.x,
      0
    ];
    return !UT(t, F_, P_, X_, WE) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !UT(t, F_, P_, X_, WE)) ? !1 : ($E.crossVectors(B0, U0), t = [$E.x, $E.y, $E.z], UT(t, F_, P_, X_, WE));
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector3} point - The point to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(e) {
    return this.clampPoint(e, Fv).distanceTo(e);
  }
  /**
   * Returns a bounding sphere that encloses this bounding box.
   *
   * @param {Sphere} target - The target sphere that is used to store the method's result.
   * @return {Sphere} The bounding sphere that encloses this bounding box.
   */
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Fv).length() * 0.5), e;
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box3} box - The bounding box to intersect with.
   * @return {Box3} A reference to this bounding box.
   */
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box3} box - The bounding box that will be unioned with this instance.
   * @return {Box3} A reference to this bounding box.
   */
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  /**
   * Transforms this bounding box by the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Box3} A reference to this bounding box.
   */
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Oy[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Oy[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Oy[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Oy[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Oy[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Oy[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Oy[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Oy[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Oy), this);
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 3D space.
   *
   * @param {Vector3} offset - The offset that should be used to translate the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box3} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Oy = [
  /* @__PURE__ */ new ve(),
  /* @__PURE__ */ new ve(),
  /* @__PURE__ */ new ve(),
  /* @__PURE__ */ new ve(),
  /* @__PURE__ */ new ve(),
  /* @__PURE__ */ new ve(),
  /* @__PURE__ */ new ve(),
  /* @__PURE__ */ new ve()
], Fv = /* @__PURE__ */ new ve(), kE = /* @__PURE__ */ new td(), F_ = /* @__PURE__ */ new ve(), P_ = /* @__PURE__ */ new ve(), X_ = /* @__PURE__ */ new ve(), B0 = /* @__PURE__ */ new ve(), U0 = /* @__PURE__ */ new ve(), AS = /* @__PURE__ */ new ve(), oA = /* @__PURE__ */ new ve(), WE = /* @__PURE__ */ new ve(), $E = /* @__PURE__ */ new ve(), ES = /* @__PURE__ */ new ve();
function UT(o, e, t, a, r) {
  for (let d = 0, p = o.length - 3; d <= p; d += 3) {
    ES.fromArray(o, d);
    const y = r.x * Math.abs(ES.x) + r.y * Math.abs(ES.y) + r.z * Math.abs(ES.z), _ = e.dot(ES), E = t.dot(ES), T = a.dot(ES);
    if (Math.max(-Math.max(_, E, T), Math.min(_, E, T)) > y)
      return !1;
  }
  return !0;
}
const Iz = /* @__PURE__ */ new td(), uA = /* @__PURE__ */ new ve(), OT = /* @__PURE__ */ new ve();
class rf {
  /**
   * Constructs a new sphere.
   *
   * @param {Vector3} [center=(0,0,0)] - The center of the sphere
   * @param {number} [radius=-1] - The radius of the sphere.
   */
  constructor(e = new ve(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  /**
   * Sets the sphere's components by copying the given values.
   *
   * @param {Vector3} center - The center.
   * @param {number} radius - The radius.
   * @return {Sphere} A reference to this sphere.
   */
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  /**
   * Computes the minimum bounding sphere for list of points.
   * If the optional center point is given, it is used as the sphere's
   * center. Otherwise, the center of the axis-aligned bounding box
   * encompassing the points is calculated.
   *
   * @param {Array<Vector3>} points - A list of points in 3D space.
   * @param {Vector3} [optionalCenter] - The center of the sphere.
   * @return {Sphere} A reference to this sphere.
   */
  setFromPoints(e, t) {
    const a = this.center;
    t !== void 0 ? a.copy(t) : Iz.setFromPoints(e).getCenter(a);
    let r = 0;
    for (let d = 0, p = e.length; d < p; d++)
      r = Math.max(r, a.distanceToSquared(e[d]));
    return this.radius = Math.sqrt(r), this;
  }
  /**
   * Copies the values of the given sphere to this instance.
   *
   * @param {Sphere} sphere - The sphere to copy.
   * @return {Sphere} A reference to this sphere.
   */
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  /**
   * Returns `true` if the sphere is empty (the radius set to a negative number).
   *
   * Spheres with a radius of `0` contain only their center point and are not
   * considered to be empty.
   *
   * @return {boolean} Whether this sphere is empty or not.
   */
  isEmpty() {
    return this.radius < 0;
  }
  /**
   * Makes this sphere empty which means in encloses a zero space in 3D.
   *
   * @return {Sphere} A reference to this sphere.
   */
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  /**
   * Returns `true` if this sphere contains the given point inclusive of
   * the surface of the sphere.
   *
   * @param {Vector3} point - The point to check.
   * @return {boolean} Whether this sphere contains the given point or not.
   */
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  /**
   * Returns the closest distance from the boundary of the sphere to the
   * given point. If the sphere contains the point, the distance will
   * be negative.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The distance to the point.
   */
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  /**
   * Returns `true` if this sphere intersects with the given one.
   *
   * @param {Sphere} sphere - The sphere to test.
   * @return {boolean} Whether this sphere intersects with the given one or not.
   */
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  /**
   * Returns `true` if this sphere intersects with the given box.
   *
   * @param {Box3} box - The box to test.
   * @return {boolean} Whether this sphere intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  /**
   * Returns `true` if this sphere intersects with the given plane.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether this sphere intersects with the given plane or not.
   */
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  /**
   * Clamps a point within the sphere. If the point is outside the sphere, it
   * will clamp it to the closest point on the edge of the sphere. Points
   * already inside the sphere will not be affected.
   *
   * @param {Vector3} point - The plane to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, t) {
    const a = this.center.distanceToSquared(e);
    return t.copy(e), a > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  /**
   * Returns a bounding box that encloses this sphere.
   *
   * @param {Box3} target - The target box that is used to store the method's result.
   * @return {Box3} The bounding box that encloses this sphere.
   */
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  /**
   * Transforms this sphere with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Sphere} A reference to this sphere.
   */
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  /**
   * Translates the sphere's center by the given offset.
   *
   * @param {Vector3} offset - The offset.
   * @return {Sphere} A reference to this sphere.
   */
  translate(e) {
    return this.center.add(e), this;
  }
  /**
   * Expands the boundaries of this sphere to include the given point.
   *
   * @param {Vector3} point - The point to include.
   * @return {Sphere} A reference to this sphere.
   */
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    uA.subVectors(e, this.center);
    const t = uA.lengthSq();
    if (t > this.radius * this.radius) {
      const a = Math.sqrt(t), r = (a - this.radius) * 0.5;
      this.center.addScaledVector(uA, r / a), this.radius += r;
    }
    return this;
  }
  /**
   * Expands this sphere to enclose both the original sphere and the given sphere.
   *
   * @param {Sphere} sphere - The sphere to include.
   * @return {Sphere} A reference to this sphere.
   */
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (OT.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(uA.copy(e.center).add(OT)), this.expandByPoint(uA.copy(e.center).sub(OT))), this);
  }
  /**
   * Returns `true` if this sphere is equal with the given one.
   *
   * @param {Sphere} sphere - The sphere to test for equality.
   * @return {boolean} Whether this bounding sphere is equal with the given one.
   */
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  /**
   * Returns a new sphere with copied values from this instance.
   *
   * @return {Sphere} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const wy = /* @__PURE__ */ new ve(), wT = /* @__PURE__ */ new ve(), eb = /* @__PURE__ */ new ve(), O0 = /* @__PURE__ */ new ve(), NT = /* @__PURE__ */ new ve(), tb = /* @__PURE__ */ new ve(), zT = /* @__PURE__ */ new ve();
class l_ {
  /**
   * Constructs a new ray.
   *
   * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
   * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
   */
  constructor(e = new ve(), t = new ve(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  /**
   * Sets the ray's components by copying the given values.
   *
   * @param {Vector3} origin - The origin.
   * @param {Vector3} direction - The direction.
   * @return {Ray} A reference to this ray.
   */
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  /**
   * Copies the values of the given ray to this instance.
   *
   * @param {Ray} ray - The ray to copy.
   * @return {Ray} A reference to this ray.
   */
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  /**
   * Returns a vector that is located at a given distance along this ray.
   *
   * @param {number} t - The distance along the ray to retrieve a position for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A position on the ray.
   */
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  /**
   * Adjusts the direction of the ray to point at the given vector in world space.
   *
   * @param {Vector3} v - The target position.
   * @return {Ray} A reference to this ray.
   */
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  /**
   * Shift the origin of this ray along its direction by the given distance.
   *
   * @param {number} t - The distance along the ray to interpolate.
   * @return {Ray} A reference to this ray.
   */
  recast(e) {
    return this.origin.copy(this.at(e, wy)), this;
  }
  /**
   * Returns the point along this ray that is closest to the given point.
   *
   * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on this ray.
   */
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const a = t.dot(this.direction);
    return a < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, a);
  }
  /**
   * Returns the distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The distance.
   */
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  /**
   * Returns the squared distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The squared distance.
   */
  distanceSqToPoint(e) {
    const t = wy.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (wy.copy(this.origin).addScaledVector(this.direction, t), wy.distanceToSquared(e));
  }
  /**
   * Returns the squared distance between this ray and the given line segment.
   *
   * @param {Vector3} v0 - The start point of the line segment.
   * @param {Vector3} v1 - The end point of the line segment.
   * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
   * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
   * @return {number} The squared distance.
   */
  distanceSqToSegment(e, t, a, r) {
    wT.copy(e).add(t).multiplyScalar(0.5), eb.copy(t).sub(e).normalize(), O0.copy(this.origin).sub(wT);
    const d = e.distanceTo(t) * 0.5, p = -this.direction.dot(eb), y = O0.dot(this.direction), _ = -O0.dot(eb), E = O0.lengthSq(), T = Math.abs(1 - p * p);
    let C, D, B, z;
    if (T > 0)
      if (C = p * _ - y, D = p * y - _, z = d * T, C >= 0)
        if (D >= -z)
          if (D <= z) {
            const V = 1 / T;
            C *= V, D *= V, B = C * (C + p * D + 2 * y) + D * (p * C + D + 2 * _) + E;
          } else
            D = d, C = Math.max(0, -(p * D + y)), B = -C * C + D * (D + 2 * _) + E;
        else
          D = -d, C = Math.max(0, -(p * D + y)), B = -C * C + D * (D + 2 * _) + E;
      else
        D <= -z ? (C = Math.max(0, -(-p * d + y)), D = C > 0 ? -d : Math.min(Math.max(-d, -_), d), B = -C * C + D * (D + 2 * _) + E) : D <= z ? (C = 0, D = Math.min(Math.max(-d, -_), d), B = D * (D + 2 * _) + E) : (C = Math.max(0, -(p * d + y)), D = C > 0 ? d : Math.min(Math.max(-d, -_), d), B = -C * C + D * (D + 2 * _) + E);
    else
      D = p > 0 ? -d : d, C = Math.max(0, -(p * D + y)), B = -C * C + D * (D + 2 * _) + E;
    return a && a.copy(this.origin).addScaledVector(this.direction, C), r && r.copy(wT).addScaledVector(eb, D), B;
  }
  /**
   * Intersects this ray with the given sphere, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectSphere(e, t) {
    wy.subVectors(e.center, this.origin);
    const a = wy.dot(this.direction), r = wy.dot(wy) - a * a, d = e.radius * e.radius;
    if (r > d) return null;
    const p = Math.sqrt(d - r), y = a - p, _ = a + p;
    return _ < 0 ? null : y < 0 ? this.at(_, t) : this.at(y, t);
  }
  /**
   * Returns `true` if this ray intersects with the given sphere.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @return {boolean} Whether this ray intersects with the given sphere or not.
   */
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  /**
   * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
   * does not intersect with the plane.
   *
   * @param {Plane} plane - The plane to compute the distance to.
   * @return {?number} Whether this ray intersects with the given sphere or not.
   */
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const a = -(this.origin.dot(e.normal) + e.constant) / t;
    return a >= 0 ? a : null;
  }
  /**
   * Intersects this ray with the given plane, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Plane} plane - The plane to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectPlane(e, t) {
    const a = this.distanceToPlane(e);
    return a === null ? null : this.at(a, t);
  }
  /**
   * Returns `true` if this ray intersects with the given plane.
   *
   * @param {Plane} plane - The plane to intersect.
   * @return {boolean} Whether this ray intersects with the given plane or not.
   */
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  /**
   * Intersects this ray with the given bounding box, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Box3} box - The box to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectBox(e, t) {
    let a, r, d, p, y, _;
    const E = 1 / this.direction.x, T = 1 / this.direction.y, C = 1 / this.direction.z, D = this.origin;
    return E >= 0 ? (a = (e.min.x - D.x) * E, r = (e.max.x - D.x) * E) : (a = (e.max.x - D.x) * E, r = (e.min.x - D.x) * E), T >= 0 ? (d = (e.min.y - D.y) * T, p = (e.max.y - D.y) * T) : (d = (e.max.y - D.y) * T, p = (e.min.y - D.y) * T), a > p || d > r || ((d > a || isNaN(a)) && (a = d), (p < r || isNaN(r)) && (r = p), C >= 0 ? (y = (e.min.z - D.z) * C, _ = (e.max.z - D.z) * C) : (y = (e.max.z - D.z) * C, _ = (e.min.z - D.z) * C), a > _ || y > r) || ((y > a || a !== a) && (a = y), (_ < r || r !== r) && (r = _), r < 0) ? null : this.at(a >= 0 ? a : r, t);
  }
  /**
   * Returns `true` if this ray intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this ray intersects with the given box or not.
   */
  intersectsBox(e) {
    return this.intersectBox(e, wy) !== null;
  }
  /**
   * Intersects this ray with the given triangle, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Vector3} a - The first vertex of the triangle.
   * @param {Vector3} b - The second vertex of the triangle.
   * @param {Vector3} c - The third vertex of the triangle.
   * @param {boolean} backfaceCulling - Whether to use backface culling or not.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectTriangle(e, t, a, r, d) {
    NT.subVectors(t, e), tb.subVectors(a, e), zT.crossVectors(NT, tb);
    let p = this.direction.dot(zT), y;
    if (p > 0) {
      if (r) return null;
      y = 1;
    } else if (p < 0)
      y = -1, p = -p;
    else
      return null;
    O0.subVectors(this.origin, e);
    const _ = y * this.direction.dot(tb.crossVectors(O0, tb));
    if (_ < 0)
      return null;
    const E = y * this.direction.dot(NT.cross(O0));
    if (E < 0 || _ + E > p)
      return null;
    const T = -y * O0.dot(zT);
    return T < 0 ? null : this.at(T / p, d);
  }
  /**
   * Transforms this ray with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix4 - The transformation matrix.
   * @return {Ray} A reference to this ray.
   */
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  /**
   * Returns `true` if this ray is equal with the given one.
   *
   * @param {Ray} ray - The ray to test for equality.
   * @return {boolean} Whether this ray is equal with the given one.
   */
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  /**
   * Returns a new ray with copied values from this instance.
   *
   * @return {Ray} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class ia {
  /**
   * Constructs a new 4x4 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   */
  constructor(e, t, a, r, d, p, y, _, E, T, C, D, B, z, V, G) {
    ia.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, a, r, d, p, y, _, E, T, C, D, B, z, V, G);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   * @return {Matrix4} A reference to this matrix.
   */
  set(e, t, a, r, d, p, y, _, E, T, C, D, B, z, V, G) {
    const N = this.elements;
    return N[0] = e, N[4] = t, N[8] = a, N[12] = r, N[1] = d, N[5] = p, N[9] = y, N[13] = _, N[2] = E, N[6] = T, N[10] = C, N[14] = D, N[3] = B, N[7] = z, N[11] = V, N[15] = G, this;
  }
  /**
   * Sets this matrix to the 4x4 identity matrix.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix4} A clone of this instance.
   */
  clone() {
    return new ia().fromArray(this.elements);
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix4} m - The matrix to copy.
   * @return {Matrix4} A reference to this matrix.
   */
  copy(e) {
    const t = this.elements, a = e.elements;
    return t[0] = a[0], t[1] = a[1], t[2] = a[2], t[3] = a[3], t[4] = a[4], t[5] = a[5], t[6] = a[6], t[7] = a[7], t[8] = a[8], t[9] = a[9], t[10] = a[10], t[11] = a[11], t[12] = a[12], t[13] = a[13], t[14] = a[14], t[15] = a[15], this;
  }
  /**
   * Copies the translation component of the given matrix
   * into this matrix's translation component.
   *
   * @param {Matrix4} m - The matrix to copy the translation component.
   * @return {Matrix4} A reference to this matrix.
   */
  copyPosition(e) {
    const t = this.elements, a = e.elements;
    return t[12] = a[12], t[13] = a[13], t[14] = a[14], this;
  }
  /**
   * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  extractBasis(e, t, a) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), a.setFromMatrixColumn(this, 2), this;
  }
  /**
   * Sets the given basis vectors to this matrix.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeBasis(e, t, a) {
    return this.set(
      e.x,
      t.x,
      a.x,
      0,
      e.y,
      t.y,
      a.y,
      0,
      e.z,
      t.z,
      a.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the rotation component of the given matrix
   * into this matrix's rotation component.
   *
   * Note: This method does not support reflection matrices.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  extractRotation(e) {
    const t = this.elements, a = e.elements, r = 1 / Y_.setFromMatrixColumn(e, 0).length(), d = 1 / Y_.setFromMatrixColumn(e, 1).length(), p = 1 / Y_.setFromMatrixColumn(e, 2).length();
    return t[0] = a[0] * r, t[1] = a[1] * r, t[2] = a[2] * r, t[3] = 0, t[4] = a[4] * d, t[5] = a[5] * d, t[6] = a[6] * d, t[7] = 0, t[8] = a[8] * p, t[9] = a[9] * p, t[10] = a[10] * p, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  /**
   * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
   * the rotation specified by the given Euler angles. The rest of
   * the matrix is set to the identity. Depending on the {@link Euler#order},
   * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}
   * for a complete list.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromEuler(e) {
    const t = this.elements, a = e.x, r = e.y, d = e.z, p = Math.cos(a), y = Math.sin(a), _ = Math.cos(r), E = Math.sin(r), T = Math.cos(d), C = Math.sin(d);
    if (e.order === "XYZ") {
      const D = p * T, B = p * C, z = y * T, V = y * C;
      t[0] = _ * T, t[4] = -_ * C, t[8] = E, t[1] = B + z * E, t[5] = D - V * E, t[9] = -y * _, t[2] = V - D * E, t[6] = z + B * E, t[10] = p * _;
    } else if (e.order === "YXZ") {
      const D = _ * T, B = _ * C, z = E * T, V = E * C;
      t[0] = D + V * y, t[4] = z * y - B, t[8] = p * E, t[1] = p * C, t[5] = p * T, t[9] = -y, t[2] = B * y - z, t[6] = V + D * y, t[10] = p * _;
    } else if (e.order === "ZXY") {
      const D = _ * T, B = _ * C, z = E * T, V = E * C;
      t[0] = D - V * y, t[4] = -p * C, t[8] = z + B * y, t[1] = B + z * y, t[5] = p * T, t[9] = V - D * y, t[2] = -p * E, t[6] = y, t[10] = p * _;
    } else if (e.order === "ZYX") {
      const D = p * T, B = p * C, z = y * T, V = y * C;
      t[0] = _ * T, t[4] = z * E - B, t[8] = D * E + V, t[1] = _ * C, t[5] = V * E + D, t[9] = B * E - z, t[2] = -E, t[6] = y * _, t[10] = p * _;
    } else if (e.order === "YZX") {
      const D = p * _, B = p * E, z = y * _, V = y * E;
      t[0] = _ * T, t[4] = V - D * C, t[8] = z * C + B, t[1] = C, t[5] = p * T, t[9] = -y * T, t[2] = -E * T, t[6] = B * C + z, t[10] = D - V * C;
    } else if (e.order === "XZY") {
      const D = p * _, B = p * E, z = y * _, V = y * E;
      t[0] = _ * T, t[4] = -C, t[8] = E * T, t[1] = D * C + V, t[5] = p * T, t[9] = B * C - z, t[2] = z * C - B, t[6] = y * T, t[10] = V * C + D;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  /**
   * Sets the rotation component of this matrix to the rotation specified by
   * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}
   * The rest of the matrix is set to the identity.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromQuaternion(e) {
    return this.compose(Vz, e, Fz);
  }
  /**
   * Sets the rotation component of the transformation matrix, looking from `eye` towards
   * `target`, and oriented by the up-direction.
   *
   * @param {Vector3} eye - The eye vector.
   * @param {Vector3} target - The target vector.
   * @param {Vector3} up - The up vector.
   * @return {Matrix4} A reference to this matrix.
   */
  lookAt(e, t, a) {
    const r = this.elements;
    return zp.subVectors(e, t), zp.lengthSq() === 0 && (zp.z = 1), zp.normalize(), w0.crossVectors(a, zp), w0.lengthSq() === 0 && (Math.abs(a.z) === 1 ? zp.x += 1e-4 : zp.z += 1e-4, zp.normalize(), w0.crossVectors(a, zp)), w0.normalize(), nb.crossVectors(zp, w0), r[0] = w0.x, r[4] = nb.x, r[8] = zp.x, r[1] = w0.y, r[5] = nb.y, r[9] = zp.y, r[2] = w0.z, r[6] = nb.z, r[10] = zp.z, this;
  }
  /**
   * Post-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 4x4 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix4} a - The first matrix.
   * @param {Matrix4} b - The second matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyMatrices(e, t) {
    const a = e.elements, r = t.elements, d = this.elements, p = a[0], y = a[4], _ = a[8], E = a[12], T = a[1], C = a[5], D = a[9], B = a[13], z = a[2], V = a[6], G = a[10], N = a[14], F = a[3], q = a[7], Y = a[11], ie = a[15], k = r[0], le = r[4], ne = r[8], Q = r[12], j = r[1], re = r[5], _e = r[9], me = r[13], Ae = r[2], He = r[6], P = r[10], te = r[14], ae = r[3], Se = r[7], ue = r[11], we = r[15];
    return d[0] = p * k + y * j + _ * Ae + E * ae, d[4] = p * le + y * re + _ * He + E * Se, d[8] = p * ne + y * _e + _ * P + E * ue, d[12] = p * Q + y * me + _ * te + E * we, d[1] = T * k + C * j + D * Ae + B * ae, d[5] = T * le + C * re + D * He + B * Se, d[9] = T * ne + C * _e + D * P + B * ue, d[13] = T * Q + C * me + D * te + B * we, d[2] = z * k + V * j + G * Ae + N * ae, d[6] = z * le + V * re + G * He + N * Se, d[10] = z * ne + V * _e + G * P + N * ue, d[14] = z * Q + V * me + G * te + N * we, d[3] = F * k + q * j + Y * Ae + ie * ae, d[7] = F * le + q * re + Y * He + ie * Se, d[11] = F * ne + q * _e + Y * P + ie * ue, d[15] = F * Q + q * me + Y * te + ie * we, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, t = e[0], a = e[4], r = e[8], d = e[12], p = e[1], y = e[5], _ = e[9], E = e[13], T = e[2], C = e[6], D = e[10], B = e[14], z = e[3], V = e[7], G = e[11], N = e[15];
    return z * (+d * _ * C - r * E * C - d * y * D + a * E * D + r * y * B - a * _ * B) + V * (+t * _ * B - t * E * D + d * p * D - r * p * B + r * E * T - d * _ * T) + G * (+t * E * C - t * y * B - d * p * C + a * p * B + d * y * T - a * E * T) + N * (-r * y * T - t * _ * C + t * y * D + r * p * C - a * p * D + a * _ * T);
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  /**
   * Sets the position component for this matrix from the given vector,
   * without affecting the rest of the matrix.
   *
   * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
   * @param {number} y - The y component of the vector.
   * @param {number} z - The z component of the vector.
   * @return {Matrix4} A reference to this matrix.
   */
  setPosition(e, t, a) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = a), this;
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  invert() {
    const e = this.elements, t = e[0], a = e[1], r = e[2], d = e[3], p = e[4], y = e[5], _ = e[6], E = e[7], T = e[8], C = e[9], D = e[10], B = e[11], z = e[12], V = e[13], G = e[14], N = e[15], F = C * G * E - V * D * E + V * _ * B - y * G * B - C * _ * N + y * D * N, q = z * D * E - T * G * E - z * _ * B + p * G * B + T * _ * N - p * D * N, Y = T * V * E - z * C * E + z * y * B - p * V * B - T * y * N + p * C * N, ie = z * C * _ - T * V * _ - z * y * D + p * V * D + T * y * G - p * C * G, k = t * F + a * q + r * Y + d * ie;
    if (k === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const le = 1 / k;
    return e[0] = F * le, e[1] = (V * D * d - C * G * d - V * r * B + a * G * B + C * r * N - a * D * N) * le, e[2] = (y * G * d - V * _ * d + V * r * E - a * G * E - y * r * N + a * _ * N) * le, e[3] = (C * _ * d - y * D * d - C * r * E + a * D * E + y * r * B - a * _ * B) * le, e[4] = q * le, e[5] = (T * G * d - z * D * d + z * r * B - t * G * B - T * r * N + t * D * N) * le, e[6] = (z * _ * d - p * G * d - z * r * E + t * G * E + p * r * N - t * _ * N) * le, e[7] = (p * D * d - T * _ * d + T * r * E - t * D * E - p * r * B + t * _ * B) * le, e[8] = Y * le, e[9] = (z * C * d - T * V * d - z * a * B + t * V * B + T * a * N - t * C * N) * le, e[10] = (p * V * d - z * y * d + z * a * E - t * V * E - p * a * N + t * y * N) * le, e[11] = (T * y * d - p * C * d - T * a * E + t * C * E + p * a * B - t * y * B) * le, e[12] = ie * le, e[13] = (T * V * r - z * C * r + z * a * D - t * V * D - T * a * G + t * C * G) * le, e[14] = (z * y * r - p * V * r - z * a * _ + t * V * _ + p * a * G - t * y * G) * le, e[15] = (p * C * r - T * y * r + T * a * _ - t * C * _ - p * a * D + t * y * D) * le, this;
  }
  /**
   * Multiplies the columns of this matrix by the given vector.
   *
   * @param {Vector3} v - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  scale(e) {
    const t = this.elements, a = e.x, r = e.y, d = e.z;
    return t[0] *= a, t[4] *= r, t[8] *= d, t[1] *= a, t[5] *= r, t[9] *= d, t[2] *= a, t[6] *= r, t[10] *= d, t[3] *= a, t[7] *= r, t[11] *= d, this;
  }
  /**
   * Gets the maximum scale value of the three axes.
   *
   * @return {number} The maximum scale.
   */
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], a = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, a, r));
  }
  /**
   * Sets this matrix as a translation transform from the given vector.
   *
   * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @param {number} z - The amount to translate in the z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeTranslation(e, t, a) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      a,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the X axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationX(e) {
    const t = Math.cos(e), a = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -a,
      0,
      0,
      a,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Y axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationY(e) {
    const t = Math.cos(e), a = Math.sin(e);
    return this.set(
      t,
      0,
      a,
      0,
      0,
      1,
      0,
      0,
      -a,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Z axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationZ(e) {
    const t = Math.cos(e), a = Math.sin(e);
    return this.set(
      t,
      -a,
      0,
      0,
      a,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the given axis by
   * the given angle.
   *
   * This is a somewhat controversial but mathematically sound alternative to
   * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.
   *
   * @param {Vector3} axis - The normalized rotation axis.
   * @param {number} angle - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationAxis(e, t) {
    const a = Math.cos(t), r = Math.sin(t), d = 1 - a, p = e.x, y = e.y, _ = e.z, E = d * p, T = d * y;
    return this.set(
      E * p + a,
      E * y - r * _,
      E * _ + r * y,
      0,
      E * y + r * _,
      T * y + a,
      T * _ - r * p,
      0,
      E * _ - r * y,
      T * _ + r * p,
      d * _ * _ + a,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a scale transformation.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @param {number} z - The amount to scale in the Z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeScale(e, t, a) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      a,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a shear transformation.
   *
   * @param {number} xy - The amount to shear X by Y.
   * @param {number} xz - The amount to shear X by Z.
   * @param {number} yx - The amount to shear Y by X.
   * @param {number} yz - The amount to shear Y by Z.
   * @param {number} zx - The amount to shear Z by X.
   * @param {number} zy - The amount to shear Z by Y.
   * @return {Matrix4} A reference to this matrix.
   */
  makeShear(e, t, a, r, d, p) {
    return this.set(
      1,
      a,
      d,
      0,
      e,
      1,
      p,
      0,
      t,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix to the transformation composed of the given position,
   * rotation (Quaternion) and scale.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  compose(e, t, a) {
    const r = this.elements, d = t._x, p = t._y, y = t._z, _ = t._w, E = d + d, T = p + p, C = y + y, D = d * E, B = d * T, z = d * C, V = p * T, G = p * C, N = y * C, F = _ * E, q = _ * T, Y = _ * C, ie = a.x, k = a.y, le = a.z;
    return r[0] = (1 - (V + N)) * ie, r[1] = (B + Y) * ie, r[2] = (z - q) * ie, r[3] = 0, r[4] = (B - Y) * k, r[5] = (1 - (D + N)) * k, r[6] = (G + F) * k, r[7] = 0, r[8] = (z + q) * le, r[9] = (G - F) * le, r[10] = (1 - (D + V)) * le, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  /**
   * Decomposes this matrix into its position, rotation and scale components
   * and provides the result in the given objects.
   *
   * Note: Not all matrices are decomposable in this way. For example, if an
   * object has a non-uniformly scaled parent, then the object's world matrix
   * may not be decomposable, and this method may not be appropriate.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  decompose(e, t, a) {
    const r = this.elements;
    let d = Y_.set(r[0], r[1], r[2]).length();
    const p = Y_.set(r[4], r[5], r[6]).length(), y = Y_.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (d = -d), e.x = r[12], e.y = r[13], e.z = r[14], Pv.copy(this);
    const E = 1 / d, T = 1 / p, C = 1 / y;
    return Pv.elements[0] *= E, Pv.elements[1] *= E, Pv.elements[2] *= E, Pv.elements[4] *= T, Pv.elements[5] *= T, Pv.elements[6] *= T, Pv.elements[8] *= C, Pv.elements[9] *= C, Pv.elements[10] *= C, t.setFromRotationMatrix(Pv), a.x = d, a.y = p, a.z = y, this;
  }
  /**
  	 * Creates a perspective projection matrix. This is used internally by
  	 * {@link PerspectiveCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makePerspective(e, t, a, r, d, p, y = Qv) {
    const _ = this.elements, E = 2 * d / (t - e), T = 2 * d / (a - r), C = (t + e) / (t - e), D = (a + r) / (a - r);
    let B, z;
    if (y === Qv)
      B = -(p + d) / (p - d), z = -2 * p * d / (p - d);
    else if (y === jA)
      B = -p / (p - d), z = -p * d / (p - d);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + y);
    return _[0] = E, _[4] = 0, _[8] = C, _[12] = 0, _[1] = 0, _[5] = T, _[9] = D, _[13] = 0, _[2] = 0, _[6] = 0, _[10] = B, _[14] = z, _[3] = 0, _[7] = 0, _[11] = -1, _[15] = 0, this;
  }
  /**
  	 * Creates a orthographic projection matrix. This is used internally by
  	 * {@link OrthographicCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makeOrthographic(e, t, a, r, d, p, y = Qv) {
    const _ = this.elements, E = 1 / (t - e), T = 1 / (a - r), C = 1 / (p - d), D = (t + e) * E, B = (a + r) * T;
    let z, V;
    if (y === Qv)
      z = (p + d) * C, V = -2 * C;
    else if (y === jA)
      z = d * C, V = -1 * C;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + y);
    return _[0] = 2 * E, _[4] = 0, _[8] = 0, _[12] = -D, _[1] = 0, _[5] = 2 * T, _[9] = 0, _[13] = -B, _[2] = 0, _[6] = 0, _[10] = V, _[14] = -z, _[3] = 0, _[7] = 0, _[11] = 0, _[15] = 1, this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix4} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const t = this.elements, a = e.elements;
    for (let r = 0; r < 16; r++)
      if (t[r] !== a[r]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix4} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let a = 0; a < 16; a++)
      this.elements[a] = e[a + t];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], t = 0) {
    const a = this.elements;
    return e[t] = a[0], e[t + 1] = a[1], e[t + 2] = a[2], e[t + 3] = a[3], e[t + 4] = a[4], e[t + 5] = a[5], e[t + 6] = a[6], e[t + 7] = a[7], e[t + 8] = a[8], e[t + 9] = a[9], e[t + 10] = a[10], e[t + 11] = a[11], e[t + 12] = a[12], e[t + 13] = a[13], e[t + 14] = a[14], e[t + 15] = a[15], e;
  }
}
const Y_ = /* @__PURE__ */ new ve(), Pv = /* @__PURE__ */ new ia(), Vz = /* @__PURE__ */ new ve(0, 0, 0), Fz = /* @__PURE__ */ new ve(1, 1, 1), w0 = /* @__PURE__ */ new ve(), nb = /* @__PURE__ */ new ve(), zp = /* @__PURE__ */ new ve(), $D = /* @__PURE__ */ new ia(), eB = /* @__PURE__ */ new Ac();
class Ip {
  /**
   * Constructs a new euler instance.
   *
   * @param {number} [x=0] - The angle of the x axis in radians.
   * @param {number} [y=0] - The angle of the y axis in radians.
   * @param {number} [z=0] - The angle of the z axis in radians.
   * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
   */
  constructor(e = 0, t = 0, a = 0, r = Ip.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = a, this._order = r;
  }
  /**
   * The angle of the x axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The angle of the y axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The angle of the z axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * A string representing the order that the rotations are applied.
   *
   * @type {string}
   * @default 'XYZ'
   */
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  /**
   * Sets the Euler components.
   *
   * @param {number} x - The angle of the x axis in radians.
   * @param {number} y - The angle of the y axis in radians.
   * @param {number} z - The angle of the z axis in radians.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  set(e, t, a, r = this._order) {
    return this._x = e, this._y = t, this._z = a, this._order = r, this._onChangeCallback(), this;
  }
  /**
   * Returns a new Euler instance with copied values from this instance.
   *
   * @return {Euler} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  /**
   * Copies the values of the given Euler instance to this instance.
   *
   * @param {Euler} euler - The Euler instance to copy.
   * @return {Euler} A reference to this Euler instance.
   */
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a pure rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromRotationMatrix(e, t = this._order, a = !0) {
    const r = e.elements, d = r[0], p = r[4], y = r[8], _ = r[1], E = r[5], T = r[9], C = r[2], D = r[6], B = r[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Fa(y, -1, 1)), Math.abs(y) < 0.9999999 ? (this._x = Math.atan2(-T, B), this._z = Math.atan2(-p, d)) : (this._x = Math.atan2(D, E), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Fa(T, -1, 1)), Math.abs(T) < 0.9999999 ? (this._y = Math.atan2(y, B), this._z = Math.atan2(_, E)) : (this._y = Math.atan2(-C, d), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Fa(D, -1, 1)), Math.abs(D) < 0.9999999 ? (this._y = Math.atan2(-C, B), this._z = Math.atan2(-p, E)) : (this._y = 0, this._z = Math.atan2(_, d));
        break;
      case "ZYX":
        this._y = Math.asin(-Fa(C, -1, 1)), Math.abs(C) < 0.9999999 ? (this._x = Math.atan2(D, B), this._z = Math.atan2(_, d)) : (this._x = 0, this._z = Math.atan2(-p, E));
        break;
      case "YZX":
        this._z = Math.asin(Fa(_, -1, 1)), Math.abs(_) < 0.9999999 ? (this._x = Math.atan2(-T, E), this._y = Math.atan2(-C, d)) : (this._x = 0, this._y = Math.atan2(y, B));
        break;
      case "XZY":
        this._z = Math.asin(-Fa(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._x = Math.atan2(D, E), this._y = Math.atan2(y, d)) : (this._x = Math.atan2(-T, B), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, a === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a normalized quaternion.
   *
   * @param {Quaternion} q - A normalized Quaternion.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromQuaternion(e, t, a) {
    return $D.makeRotationFromQuaternion(e), this.setFromRotationMatrix($D, t, a);
  }
  /**
   * Sets the angles of this Euler instance from the given vector.
   *
   * @param {Vector3} v - The vector.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  /**
   * Resets the euler angle with a new order by creating a quaternion from this
   * euler angle and then setting this euler angle with the quaternion and the
   * new order.
   *
   * Warning: This discards revolution information.
   *
   * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  reorder(e) {
    return eB.setFromEuler(this), this.setFromQuaternion(eB, e);
  }
  /**
   * Returns `true` if this Euler instance is equal with the given one.
   *
   * @param {Euler} euler - The Euler instance to test for equality.
   * @return {boolean} Whether this Euler instance is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  /**
   * Sets this Euler instance's components to values from the given array. The first three
   * entries of the array are assign to the x,y and z components. An optional fourth entry
   * defines the Euler order.
   *
   * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
   * @return {Euler} A reference to this Euler instance.
   */
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this Euler instance to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number,number,number,string>} The Euler components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Ip.DEFAULT_ORDER = "XYZ";
class A1 {
  /**
   * Constructs a new layers instance, with membership
   * initially set to layer `0`.
   */
  constructor() {
    this.mask = 1;
  }
  /**
   * Sets membership to the given layer, and remove membership all other layers.
   *
   * @param {number} layer - The layer to set.
   */
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  /**
   * Adds membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  /**
   * Adds membership to all layers.
   */
  enableAll() {
    this.mask = -1;
  }
  /**
   * Toggles the membership of the given layer.
   *
   * @param {number} layer - The layer to toggle.
   */
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  /**
   * Removes membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  /**
   * Removes the membership from all layers.
   */
  disableAll() {
    this.mask = 0;
  }
  /**
   * Returns `true` if this and the given layers object have at least one
   * layer in common.
   *
   * @param {Layers} layers - The layers to test.
   * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
   */
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  /**
   * Returns `true` if the given layer is enabled.
   *
   * @param {number} layer - The layer to test.
   * @return {boolean } Whether the given layer is enabled or not.
   */
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let Pz = 0;
const tB = /* @__PURE__ */ new ve(), q_ = /* @__PURE__ */ new Ac(), Ny = /* @__PURE__ */ new ia(), ab = /* @__PURE__ */ new ve(), cA = /* @__PURE__ */ new ve(), Xz = /* @__PURE__ */ new ve(), Yz = /* @__PURE__ */ new Ac(), nB = /* @__PURE__ */ new ve(1, 0, 0), aB = /* @__PURE__ */ new ve(0, 1, 0), iB = /* @__PURE__ */ new ve(0, 0, 1), lB = { type: "added" }, qz = { type: "removed" }, Z_ = { type: "childadded", child: null }, HT = { type: "childremoved", child: null };
class zi extends Jg {
  /**
   * Constructs a new 3D object.
   */
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Pz++ }), this.uuid = Gp(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = zi.DEFAULT_UP.clone();
    const e = new ve(), t = new Ip(), a = new Ac(), r = new ve(1, 1, 1);
    function d() {
      a.setFromEuler(t, !1);
    }
    function p() {
      t.setFromQuaternion(a, void 0, !1);
    }
    t._onChange(d), a._onChange(p), Object.defineProperties(this, {
      /**
       * Represents the object's local position.
       *
       * @name Object3D#position
       * @type {Vector3}
       * @default (0,0,0)
       */
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      /**
       * Represents the object's local rotation as Euler angles, in radians.
       *
       * @name Object3D#rotation
       * @type {Euler}
       * @default (0,0,0)
       */
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      /**
       * Represents the object's local rotation as Quaternions.
       *
       * @name Object3D#quaternion
       * @type {Quaternion}
       */
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: a
      },
      /**
       * Represents the object's local scale.
       *
       * @name Object3D#scale
       * @type {Vector3}
       * @default (1,1,1)
       */
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      /**
       * Represents the object's model-view matrix.
       *
       * @name Object3D#modelViewMatrix
       * @type {Matrix4}
       */
      modelViewMatrix: {
        value: new ia()
      },
      /**
       * Represents the object's normal matrix.
       *
       * @name Object3D#normalMatrix
       * @type {Matrix3}
       */
      normalMatrix: {
        value: new ja()
      }
    }), this.matrix = new ia(), this.matrixWorld = new ia(), this.matrixAutoUpdate = zi.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = zi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new A1(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeShadow() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onAfterShadow() {
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onAfterRender() {
  }
  /**
   * Applies the given transformation matrix to the object and updates the object's position,
   * rotation and scale.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   */
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  /**
   * Applies a rotation represented by given the quaternion to the 3D object.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Object3D} A reference to this instance.
   */
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  /**
   * Sets the given rotation represented as an axis/angle couple to the 3D object.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   */
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  /**
   * Sets the given rotation represented as Euler angles to the 3D object.
   *
   * @param {Euler} euler - The Euler angles.
   */
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  /**
   * Sets the given rotation represented as rotation matrix to the 3D object.
   *
   * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
   * a pure rotation matrix (i.e, unscaled).
   */
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  /**
   * Sets the given rotation represented as a Quaternion to the 3D object.
   *
   * @param {Quaternion} q - The Quaternion
   */
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  /**
   * Rotates the 3D object along an axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnAxis(e, t) {
    return q_.setFromAxisAngle(e, t), this.quaternion.multiply(q_), this;
  }
  /**
   * Rotates the 3D object along an axis in world space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnWorldAxis(e, t) {
    return q_.setFromAxisAngle(e, t), this.quaternion.premultiply(q_), this;
  }
  /**
   * Rotates the 3D object around its X axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateX(e) {
    return this.rotateOnAxis(nB, e);
  }
  /**
   * Rotates the 3D object around its Y axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateY(e) {
    return this.rotateOnAxis(aB, e);
  }
  /**
   * Rotates the 3D object around its Z axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateZ(e) {
    return this.rotateOnAxis(iB, e);
  }
  /**
   * Translate the 3D object by a distance along the given axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateOnAxis(e, t) {
    return tB.copy(e).applyQuaternion(this.quaternion), this.position.add(tB.multiplyScalar(t)), this;
  }
  /**
   * Translate the 3D object by a distance along its X-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateX(e) {
    return this.translateOnAxis(nB, e);
  }
  /**
   * Translate the 3D object by a distance along its Y-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateY(e) {
    return this.translateOnAxis(aB, e);
  }
  /**
   * Translate the 3D object by a distance along its Z-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateZ(e) {
    return this.translateOnAxis(iB, e);
  }
  /**
   * Converts the given vector from this 3D object's local space to world space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  /**
   * Converts the given vector from this 3D object's word space to local space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Ny.copy(this.matrixWorld).invert());
  }
  /**
   * Rotates the object to face a point in world space.
   *
   * This method does not support objects having non-uniformly-scaled parent(s).
   *
   * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
   * @param {number} [y] - The y coordinate in world space.
   * @param {number} [z] - The z coordinate in world space.
   */
  lookAt(e, t, a) {
    e.isVector3 ? ab.copy(e) : ab.set(e, t, a);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), cA.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ny.lookAt(cA, ab, this.up) : Ny.lookAt(ab, cA, this.up), this.quaternion.setFromRotationMatrix(Ny), r && (Ny.extractRotation(r.matrixWorld), q_.setFromRotationMatrix(Ny), this.quaternion.premultiply(q_.invert()));
  }
  /**
   * Adds the given 3D object as a child to this 3D object. An arbitrary number of
   * objects may be added. Any current parent on an object passed in here will be
   * removed, since an object can have at most one parent.
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to add.
   * @return {Object3D} A reference to this instance.
   */
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(lB), Z_.child = e, this.dispatchEvent(Z_), Z_.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  /**
   * Removes the given 3D object as child from this 3D object.
   * An arbitrary number of objects may be removed.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @param {Object3D} object - The 3D object to remove.
   * @return {Object3D} A reference to this instance.
   */
  remove(e) {
    if (arguments.length > 1) {
      for (let a = 0; a < arguments.length; a++)
        this.remove(arguments[a]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(qz), HT.child = e, this.dispatchEvent(HT), HT.child = null), this;
  }
  /**
   * Removes this 3D object from its current parent.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  /**
   * Removes all child objects.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  clear() {
    return this.remove(...this.children);
  }
  /**
   * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
   * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to attach.
   * @return {Object3D} A reference to this instance.
   */
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Ny.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Ny.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ny), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(lB), Z_.child = e, this.dispatchEvent(Z_), Z_.child = null, this;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching ID.
   *
   * @param {number} id - The id.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching name.
   *
   * @param {string} name - The name.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let a = 0, r = this.children.length; a < r; a++) {
      const p = this.children[a].getObjectByProperty(e, t);
      if (p !== void 0)
        return p;
    }
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns all 3D objects with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @param {Array<Object3D>} result - The method stores the result in this array.
   * @return {Array<Object3D>} The found 3D objects.
   */
  getObjectsByProperty(e, t, a = []) {
    this[e] === t && a.push(this);
    const r = this.children;
    for (let d = 0, p = r.length; d < p; d++)
      r[d].getObjectsByProperty(e, t, a);
    return a;
  }
  /**
   * Returns a vector representing the position of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's position in world space.
   */
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  /**
   * Returns a Quaternion representing the position of the 3D object in world space.
   *
   * @param {Quaternion} target - The target Quaternion the result is stored to.
   * @return {Quaternion} The 3D object's rotation in world space.
   */
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(cA, e, Xz), e;
  }
  /**
   * Returns a vector representing the scale of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's scale in world space.
   */
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(cA, Yz, e), e;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  /**
   * Abstract method to get intersections between a casted ray and this
   * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
   * implement this method in order to use raycasting.
   *
   * @abstract
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - An array holding the result of the method.
   */
  raycast() {
  }
  /**
   * Executes the callback on this 3D object and all descendants.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverse(e) {
    e(this);
    const t = this.children;
    for (let a = 0, r = t.length; a < r; a++)
      t[a].traverse(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
   * Descendants of invisible 3D objects are not traversed.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let a = 0, r = t.length; a < r; a++)
      t[a].traverseVisible(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  /**
   * Updates the transformation matrix in local space by computing it from the current
   * position, rotation and scale values.
   */
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  /**
   * Updates the transformation matrix in world space of this 3D objects and its descendants.
   *
   * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
   * local space. The computation of the local and world matrix can be controlled with the
   * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
   * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
   */
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let a = 0, r = t.length; a < r; a++)
      t[a].updateMatrixWorld(e);
  }
  /**
   * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
   * update of ancestor and descendant nodes.
   *
   * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
   * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
   */
  updateWorldMatrix(e, t) {
    const a = this.parent;
    if (e === !0 && a !== null && a.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
      const r = this.children;
      for (let d = 0, p = r.length; d < p; d++)
        r[d].updateWorldMatrix(!1, !0);
    }
  }
  /**
   * Serializes the 3D object into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized 3D object.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", a = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, a.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((y) => ({
      boxInitialized: y.boxInitialized,
      boxMin: y.box.min.toArray(),
      boxMax: y.box.max.toArray(),
      sphereInitialized: y.sphereInitialized,
      sphereRadius: y.sphere.radius,
      sphereCenter: y.sphere.center.toArray()
    })), r.maxInstanceCount = this._maxInstanceCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (r.boundingSphere = {
      center: r.boundingSphere.center.toArray(),
      radius: r.boundingSphere.radius
    }), this.boundingBox !== null && (r.boundingBox = {
      min: r.boundingBox.min.toArray(),
      max: r.boundingBox.max.toArray()
    }));
    function d(y, _) {
      return y[_.uuid] === void 0 && (y[_.uuid] = _.toJSON(e)), _.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = d(e.geometries, this.geometry);
      const y = this.geometry.parameters;
      if (y !== void 0 && y.shapes !== void 0) {
        const _ = y.shapes;
        if (Array.isArray(_))
          for (let E = 0, T = _.length; E < T; E++) {
            const C = _[E];
            d(e.shapes, C);
          }
        else
          d(e.shapes, _);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (d(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const y = [];
        for (let _ = 0, E = this.material.length; _ < E; _++)
          y.push(d(e.materials, this.material[_]));
        r.material = y;
      } else
        r.material = d(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let y = 0; y < this.children.length; y++)
        r.children.push(this.children[y].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let y = 0; y < this.animations.length; y++) {
        const _ = this.animations[y];
        r.animations.push(d(e.animations, _));
      }
    }
    if (t) {
      const y = p(e.geometries), _ = p(e.materials), E = p(e.textures), T = p(e.images), C = p(e.shapes), D = p(e.skeletons), B = p(e.animations), z = p(e.nodes);
      y.length > 0 && (a.geometries = y), _.length > 0 && (a.materials = _), E.length > 0 && (a.textures = E), T.length > 0 && (a.images = T), C.length > 0 && (a.shapes = C), D.length > 0 && (a.skeletons = D), B.length > 0 && (a.animations = B), z.length > 0 && (a.nodes = z);
    }
    return a.object = r, a;
    function p(y) {
      const _ = [];
      for (const E in y) {
        const T = y[E];
        delete T.metadata, _.push(T);
      }
      return _;
    }
  }
  /**
   * Returns a new 3D object with copied values from this instance.
   *
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
   * @return {Object3D} A clone of this instance.
   */
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  /**
   * Copies the values of the given 3D object to this instance.
   *
   * @param {Object3D} source - The 3D object to copy.
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
   * @return {Object3D} A reference to this instance.
   */
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let a = 0; a < e.children.length; a++) {
        const r = e.children[a];
        this.add(r.clone());
      }
    return this;
  }
}
zi.DEFAULT_UP = /* @__PURE__ */ new ve(0, 1, 0);
zi.DEFAULT_MATRIX_AUTO_UPDATE = !0;
zi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Xv = /* @__PURE__ */ new ve(), zy = /* @__PURE__ */ new ve(), LT = /* @__PURE__ */ new ve(), Hy = /* @__PURE__ */ new ve(), Q_ = /* @__PURE__ */ new ve(), j_ = /* @__PURE__ */ new ve(), sB = /* @__PURE__ */ new ve(), GT = /* @__PURE__ */ new ve(), IT = /* @__PURE__ */ new ve(), VT = /* @__PURE__ */ new ve(), FT = /* @__PURE__ */ new Bi(), PT = /* @__PURE__ */ new Bi(), XT = /* @__PURE__ */ new Bi();
class Xh {
  /**
   * Constructs a new triangle.
   *
   * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
   * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
   * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
   */
  constructor(e = new ve(), t = new ve(), a = new ve()) {
    this.a = e, this.b = t, this.c = a;
  }
  /**
   * Computes the normal vector of a triangle.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  static getNormal(e, t, a, r) {
    r.subVectors(a, t), Xv.subVectors(e, t), r.cross(Xv);
    const d = r.lengthSq();
    return d > 0 ? r.multiplyScalar(1 / Math.sqrt(d)) : r.set(0, 0, 0);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  static getBarycoord(e, t, a, r, d) {
    Xv.subVectors(r, t), zy.subVectors(a, t), LT.subVectors(e, t);
    const p = Xv.dot(Xv), y = Xv.dot(zy), _ = Xv.dot(LT), E = zy.dot(zy), T = zy.dot(LT), C = p * E - y * y;
    if (C === 0)
      return d.set(0, 0, 0), null;
    const D = 1 / C, B = (E * _ - y * T) * D, z = (p * T - y * _) * D;
    return d.set(1 - B - z, z, B);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  static containsPoint(e, t, a, r) {
    return this.getBarycoord(e, t, a, r, Hy) === null ? !1 : Hy.x >= 0 && Hy.y >= 0 && Hy.x + Hy.y <= 1;
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} p1 - The first corner of the triangle.
   * @param {Vector3} p2 - The second corner of the triangle.
   * @param {Vector3} p3 - The third corner of the triangle.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  static getInterpolation(e, t, a, r, d, p, y, _) {
    return this.getBarycoord(e, t, a, r, Hy) === null ? (_.x = 0, _.y = 0, "z" in _ && (_.z = 0), "w" in _ && (_.w = 0), null) : (_.setScalar(0), _.addScaledVector(d, Hy.x), _.addScaledVector(p, Hy.y), _.addScaledVector(y, Hy.z), _);
  }
  /**
   * Computes the value barycentrically interpolated for the given attribute and indices.
   *
   * @param {BufferAttribute} attr - The attribute to interpolate.
   * @param {number} i1 - Index of first vertex.
   * @param {number} i2 - Index of second vertex.
   * @param {number} i3 - Index of third vertex.
   * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The interpolated attribute value.
   */
  static getInterpolatedAttribute(e, t, a, r, d, p) {
    return FT.setScalar(0), PT.setScalar(0), XT.setScalar(0), FT.fromBufferAttribute(e, t), PT.fromBufferAttribute(e, a), XT.fromBufferAttribute(e, r), p.setScalar(0), p.addScaledVector(FT, d.x), p.addScaledVector(PT, d.y), p.addScaledVector(XT, d.z), p;
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  static isFrontFacing(e, t, a, r) {
    return Xv.subVectors(a, t), zy.subVectors(e, t), Xv.cross(zy).dot(r) < 0;
  }
  /**
   * Sets the triangle's vertices by copying the given values.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  set(e, t, a) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(a), this;
  }
  /**
   * Sets the triangle's vertices by copying the given array values.
   *
   * @param {Array<Vector3>} points - An array with 3D points.
   * @param {number} i0 - The array index representing the first corner of the triangle.
   * @param {number} i1 - The array index representing the second corner of the triangle.
   * @param {number} i2 - The array index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromPointsAndIndices(e, t, a, r) {
    return this.a.copy(e[t]), this.b.copy(e[a]), this.c.copy(e[r]), this;
  }
  /**
   * Sets the triangle's vertices by copying the given attribute values.
   *
   * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
   * @param {number} i0 - The attribute index representing the first corner of the triangle.
   * @param {number} i1 - The attribute index representing the second corner of the triangle.
   * @param {number} i2 - The attribute index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromAttributeAndIndices(e, t, a, r) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, a), this.c.fromBufferAttribute(e, r), this;
  }
  /**
   * Returns a new triangle with copied values from this instance.
   *
   * @return {Triangle} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given triangle to this instance.
   *
   * @param {Triangle} triangle - The triangle to copy.
   * @return {Triangle} A reference to this triangle.
   */
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  /**
   * Computes the area of the triangle.
   *
   * @return {number} The triangle's area.
   */
  getArea() {
    return Xv.subVectors(this.c, this.b), zy.subVectors(this.a, this.b), Xv.cross(zy).length() * 0.5;
  }
  /**
   * Computes the midpoint of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's midpoint.
   */
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  /**
   * Computes the normal of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  getNormal(e) {
    return Xh.getNormal(this.a, this.b, this.c, e);
  }
  /**
   * Computes a plane the triangle lies within.
   *
   * @param {Plane} target - The target vector that is used to store the method's result.
   * @return {Plane} The plane the triangle lies within.
   */
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  getBarycoord(e, t) {
    return Xh.getBarycoord(e, this.a, this.b, this.c, t);
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  getInterpolation(e, t, a, r, d) {
    return Xh.getInterpolation(e, this.a, this.b, this.c, t, a, r, d);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  containsPoint(e) {
    return Xh.containsPoint(e, this.a, this.b, this.c);
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  isFrontFacing(e) {
    return Xh.isFrontFacing(this.a, this.b, this.c, e);
  }
  /**
   * Returns `true` if this triangle intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this triangle intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  /**
   * Returns the closest point on the triangle to the given point.
   *
   * @param {Vector3} p - The point to compute the closest point for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the triangle.
   */
  closestPointToPoint(e, t) {
    const a = this.a, r = this.b, d = this.c;
    let p, y;
    Q_.subVectors(r, a), j_.subVectors(d, a), GT.subVectors(e, a);
    const _ = Q_.dot(GT), E = j_.dot(GT);
    if (_ <= 0 && E <= 0)
      return t.copy(a);
    IT.subVectors(e, r);
    const T = Q_.dot(IT), C = j_.dot(IT);
    if (T >= 0 && C <= T)
      return t.copy(r);
    const D = _ * C - T * E;
    if (D <= 0 && _ >= 0 && T <= 0)
      return p = _ / (_ - T), t.copy(a).addScaledVector(Q_, p);
    VT.subVectors(e, d);
    const B = Q_.dot(VT), z = j_.dot(VT);
    if (z >= 0 && B <= z)
      return t.copy(d);
    const V = B * E - _ * z;
    if (V <= 0 && E >= 0 && z <= 0)
      return y = E / (E - z), t.copy(a).addScaledVector(j_, y);
    const G = T * z - B * C;
    if (G <= 0 && C - T >= 0 && B - z >= 0)
      return sB.subVectors(d, r), y = (C - T) / (C - T + (B - z)), t.copy(r).addScaledVector(sB, y);
    const N = 1 / (G + V + D);
    return p = V * N, y = D * N, t.copy(a).addScaledVector(Q_, p).addScaledVector(j_, y);
  }
  /**
   * Returns `true` if this triangle is equal with the given one.
   *
   * @param {Triangle} triangle - The triangle to test for equality.
   * @return {boolean} Whether this triangle is equal with the given one.
   */
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const vO = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, N0 = { h: 0, s: 0, l: 0 }, ib = { h: 0, s: 0, l: 0 };
function YT(o, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? o + (e - o) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? o + (e - o) * 6 * (2 / 3 - t) : o;
}
class hn {
  /**
   * Constructs a new color.
   *
   * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
   * and that method is used throughout the rest of the documentation.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   */
  constructor(e, t, a) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, a);
  }
  /**
   * Sets the colors's components from the given values.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   * @return {Color} A reference to this color.
   */
  set(e, t, a) {
    if (t === void 0 && a === void 0) {
      const r = e;
      r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
    } else
      this.setRGB(e, t, a);
    return this;
  }
  /**
   * Sets the colors's components to the given scalar value.
   *
   * @param {number} scalar - The scalar value.
   * @return {Color} A reference to this color.
   */
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  /**
   * Sets this color from a hexadecimal value.
   *
   * @param {number} hex - The hexadecimal value.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHex(e, t = lf) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, wi.toWorkingColorSpace(this, t), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} r - Red channel value between `0.0` and `1.0`.
   * @param {number} g - Green channel value between `0.0` and `1.0`.
   * @param {number} b - Blue channel value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setRGB(e, t, a, r = wi.workingColorSpace) {
    return this.r = e, this.g = t, this.b = a, wi.toWorkingColorSpace(this, r), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHSL(e, t, a, r = wi.workingColorSpace) {
    if (e = b2(e, 1), t = Fa(t, 0, 1), a = Fa(a, 0, 1), t === 0)
      this.r = this.g = this.b = a;
    else {
      const d = a <= 0.5 ? a * (1 + t) : a + t - a * t, p = 2 * a - d;
      this.r = YT(p, d, e + 1 / 3), this.g = YT(p, d, e), this.b = YT(p, d, e - 1 / 3);
    }
    return wi.toWorkingColorSpace(this, r), this;
  }
  /**
   * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
   * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
   * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
   * all 140 color names are supported).
   *
   * @param {string} style - Color as a CSS-style string.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setStyle(e, t = lf) {
    function a(d) {
      d !== void 0 && parseFloat(d) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let d;
      const p = r[1], y = r[2];
      switch (p) {
        case "rgb":
        case "rgba":
          if (d = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(y))
            return a(d[4]), this.setRGB(
              Math.min(255, parseInt(d[1], 10)) / 255,
              Math.min(255, parseInt(d[2], 10)) / 255,
              Math.min(255, parseInt(d[3], 10)) / 255,
              t
            );
          if (d = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(y))
            return a(d[4]), this.setRGB(
              Math.min(100, parseInt(d[1], 10)) / 100,
              Math.min(100, parseInt(d[2], 10)) / 100,
              Math.min(100, parseInt(d[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (d = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(y))
            return a(d[4]), this.setHSL(
              parseFloat(d[1]) / 360,
              parseFloat(d[2]) / 100,
              parseFloat(d[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const d = r[1], p = d.length;
      if (p === 3)
        return this.setRGB(
          parseInt(d.charAt(0), 16) / 15,
          parseInt(d.charAt(1), 16) / 15,
          parseInt(d.charAt(2), 16) / 15,
          t
        );
      if (p === 6)
        return this.setHex(parseInt(d, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  /**
   * Sets this color from a color name. Faster than {@link Color#setStyle} if
   * you don't need the other CSS-style formats.
   *
   * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
   * ```js
   * Color.NAMES.aliceblue // returns 0xF0F8FF
   * ```
   *
   * @param {string} style - The color name.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setColorName(e, t = lf) {
    const a = vO[e.toLowerCase()];
    return a !== void 0 ? this.setHex(a, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  /**
   * Returns a new color with copied values from this instance.
   *
   * @return {Color} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  /**
   * Copies the values of the given color to this instance.
   *
   * @param {Color} color - The color to copy.
   * @return {Color} A reference to this color.
   */
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copySRGBToLinear(e) {
    return this.r = qy(e.r), this.g = qy(e.g), this.b = qy(e.b), this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copyLinearToSRGB(e) {
    return this.r = f1(e.r), this.g = f1(e.g), this.b = f1(e.b), this;
  }
  /**
   * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  /**
   * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  /**
   * Returns the hexadecimal value of this color.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {number} The hexadecimal value.
   */
  getHex(e = lf) {
    return wi.fromWorkingColorSpace(kf.copy(this), e), Math.round(Fa(kf.r * 255, 0, 255)) * 65536 + Math.round(Fa(kf.g * 255, 0, 255)) * 256 + Math.round(Fa(kf.b * 255, 0, 255));
  }
  /**
   * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The hexadecimal value as a string.
   */
  getHexString(e = lf) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  /**
   * Converts the colors RGB values into the HSL format and stores them into the
   * given target object.
   *
   * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {{h:number,s:number,l:number}} The HSL representation of this color.
   */
  getHSL(e, t = wi.workingColorSpace) {
    wi.fromWorkingColorSpace(kf.copy(this), t);
    const a = kf.r, r = kf.g, d = kf.b, p = Math.max(a, r, d), y = Math.min(a, r, d);
    let _, E;
    const T = (y + p) / 2;
    if (y === p)
      _ = 0, E = 0;
    else {
      const C = p - y;
      switch (E = T <= 0.5 ? C / (p + y) : C / (2 - p - y), p) {
        case a:
          _ = (r - d) / C + (r < d ? 6 : 0);
          break;
        case r:
          _ = (d - a) / C + 2;
          break;
        case d:
          _ = (a - r) / C + 4;
          break;
      }
      _ /= 6;
    }
    return e.h = _, e.s = E, e.l = T, e;
  }
  /**
   * Returns the RGB values of this color and stores them into the given target object.
   *
   * @param {Color} target - The target color that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} The RGB representation of this color.
   */
  getRGB(e, t = wi.workingColorSpace) {
    return wi.fromWorkingColorSpace(kf.copy(this), t), e.r = kf.r, e.g = kf.g, e.b = kf.b, e;
  }
  /**
   * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The CSS representation of this color.
   */
  getStyle(e = lf) {
    wi.fromWorkingColorSpace(kf.copy(this), e);
    const t = kf.r, a = kf.g, r = kf.b;
    return e !== lf ? `color(${e} ${t.toFixed(3)} ${a.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(a * 255)},${Math.round(r * 255)})`;
  }
  /**
   * Adds the given HSL values to this color's values.
   * Internally, this converts the color's RGB values to HSL, adds HSL
   * and then converts the color back to RGB.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @return {Color} A reference to this color.
   */
  offsetHSL(e, t, a) {
    return this.getHSL(N0), this.setHSL(N0.h + e, N0.s + t, N0.l + a);
  }
  /**
   * Adds the RGB values of the given color to the RGB values of this color.
   *
   * @param {Color} color - The color to add.
   * @return {Color} A reference to this color.
   */
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  /**
   * Adds the RGB values of the given colors and stores the result in this instance.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @return {Color} A reference to this color.
   */
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  /**
   * Adds the given scalar value to the RGB values of this color.
   *
   * @param {number} s - The scalar to add.
   * @return {Color} A reference to this color.
   */
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  /**
   * Subtracts the RGB values of the given color from the RGB values of this color.
   *
   * @param {Color} color - The color to subtract.
   * @return {Color} A reference to this color.
   */
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  /**
   * Multiplies the RGB values of the given color with the RGB values of this color.
   *
   * @param {Color} color - The color to multiply.
   * @return {Color} A reference to this color.
   */
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  /**
   * Multiplies the given scalar value with the RGB values of this color.
   *
   * @param {number} s - The scalar to multiply.
   * @return {Color} A reference to this color.
   */
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  /**
   * Linearly interpolates this color's RGB values toward the RGB values of the
   * given color. The alpha argument can be thought of as the ratio between
   * the two colors, where `0.0` is this color and `1.0` is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  /**
   * Linearly interpolates between the given colors and stores the result in this instance.
   * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
   * is the first and `1.0` is the second color.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpColors(e, t, a) {
    return this.r = e.r + (t.r - e.r) * a, this.g = e.g + (t.g - e.g) * a, this.b = e.b + (t.b - e.b) * a, this;
  }
  /**
   * Linearly interpolates this color's HSL values toward the HSL values of the
   * given color. It differs from {@link Color#lerp} by not interpolating straight
   * from one color to the other, but instead going through all the hues in between
   * those two colors. The alpha argument can be thought of as the ratio between
   * the two colors, where 0.0 is this color and 1.0 is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpHSL(e, t) {
    this.getHSL(N0), e.getHSL(ib);
    const a = IA(N0.h, ib.h, t), r = IA(N0.s, ib.s, t), d = IA(N0.l, ib.l, t);
    return this.setHSL(a, r, d), this;
  }
  /**
   * Sets the color's RGB components from the given 3D vector.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Color} A reference to this color.
   */
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  /**
   * Transforms this color with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix.
   * @return {Color} A reference to this color.
   */
  applyMatrix3(e) {
    const t = this.r, a = this.g, r = this.b, d = e.elements;
    return this.r = d[0] * t + d[3] * a + d[6] * r, this.g = d[1] * t + d[4] * a + d[7] * r, this.b = d[2] * t + d[5] * a + d[8] * r, this;
  }
  /**
   * Returns `true` if this color is equal with the given one.
   *
   * @param {Color} c - The color to test for equality.
   * @return {boolean} Whether this bounding color is equal with the given one.
   */
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  /**
   * Sets this color's RGB components from the given array.
   *
   * @param {Array<number>} array - An array holding the RGB values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Color} A reference to this color.
   */
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  /**
   * Writes the RGB components of this color to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the color components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The color components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  /**
   * Sets the components of this color from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding color data.
   * @param {number} index - The index into the attribute.
   * @return {Color} A reference to this color.
   */
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the color
   * as a hexadecimal value.
   *
   * @return {number} The hexadecimal value.
   */
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const kf = /* @__PURE__ */ new hn();
hn.NAMES = vO;
let Zz = 0;
class Vu extends Jg {
  /**
   * Constructs a new material.
   */
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Zz++ }), this.uuid = Gp(), this.name = "", this.type = "Material", this.blending = QS, this.side = Zg, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = fM, this.blendDst = dM, this.blendEquation = I0, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new hn(0, 0, 0), this.blendAlpha = 0, this.depthFunc = KS, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = ZC, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = LS, this.stencilZFail = LS, this.stencilZPass = LS, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  /**
   * Sets the alpha value to be used when running an alpha test. The material
   * will not be rendered if the opacity is lower than this value.
   *
   * @type {number}
   * @readonly
   * @default 0
   */
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  /**
   * An optional callback that is executed immediately before the material is used to render a 3D object.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Object3D} object - The 3D object.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * An optional callback that is executed immediately before the shader
   * program is compiled. This function is called with the shader source code
   * as a parameter. Useful for the modification of built-in materials.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}. The
   * recommended approach when customizing materials is to use `WebGPURenderer` with the new
   * Node Material system and [TSL]{@link https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language}.
   *
   * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
   * @param {WebGLRenderer} renderer - A reference to the renderer.
   */
  onBeforeCompile() {
  }
  /**
   * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
   * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
   * shader or recompile the shader for this material as needed.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @return {string} The custom program cache key.
   */
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  /**
   * This method can be used to set default values from parameter objects.
   * It is a generic implementation so it can be used with different types
   * of materials.
   *
   * @param {Object} [values] - The material values to set.
   */
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const a = e[t];
        if (a === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        r && r.isColor ? r.set(a) : r && r.isVector3 && a && a.isVector3 ? r.copy(a) : this[t] = a;
      }
  }
  /**
   * Serializes the material into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized material.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const a = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    a.uuid = this.uuid, a.type = this.type, this.name !== "" && (a.name = this.name), this.color && this.color.isColor && (a.color = this.color.getHex()), this.roughness !== void 0 && (a.roughness = this.roughness), this.metalness !== void 0 && (a.metalness = this.metalness), this.sheen !== void 0 && (a.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (a.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (a.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (a.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (a.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (a.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (a.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (a.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (a.shininess = this.shininess), this.clearcoat !== void 0 && (a.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (a.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (a.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (a.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (a.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, a.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (a.dispersion = this.dispersion), this.iridescence !== void 0 && (a.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (a.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (a.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (a.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (a.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (a.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (a.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (a.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (a.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (a.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (a.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (a.lightMap = this.lightMap.toJSON(e).uuid, a.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (a.aoMap = this.aoMap.toJSON(e).uuid, a.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (a.bumpMap = this.bumpMap.toJSON(e).uuid, a.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (a.normalMap = this.normalMap.toJSON(e).uuid, a.normalMapType = this.normalMapType, a.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (a.displacementMap = this.displacementMap.toJSON(e).uuid, a.displacementScale = this.displacementScale, a.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (a.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (a.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (a.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (a.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (a.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (a.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (a.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (a.combine = this.combine)), this.envMapRotation !== void 0 && (a.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (a.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (a.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (a.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (a.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (a.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (a.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (a.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (a.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (a.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (a.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (a.size = this.size), this.shadowSide !== null && (a.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (a.sizeAttenuation = this.sizeAttenuation), this.blending !== QS && (a.blending = this.blending), this.side !== Zg && (a.side = this.side), this.vertexColors === !0 && (a.vertexColors = !0), this.opacity < 1 && (a.opacity = this.opacity), this.transparent === !0 && (a.transparent = !0), this.blendSrc !== fM && (a.blendSrc = this.blendSrc), this.blendDst !== dM && (a.blendDst = this.blendDst), this.blendEquation !== I0 && (a.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (a.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (a.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (a.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (a.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (a.blendAlpha = this.blendAlpha), this.depthFunc !== KS && (a.depthFunc = this.depthFunc), this.depthTest === !1 && (a.depthTest = this.depthTest), this.depthWrite === !1 && (a.depthWrite = this.depthWrite), this.colorWrite === !1 && (a.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (a.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== ZC && (a.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (a.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (a.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== LS && (a.stencilFail = this.stencilFail), this.stencilZFail !== LS && (a.stencilZFail = this.stencilZFail), this.stencilZPass !== LS && (a.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (a.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (a.rotation = this.rotation), this.polygonOffset === !0 && (a.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (a.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (a.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (a.linewidth = this.linewidth), this.dashSize !== void 0 && (a.dashSize = this.dashSize), this.gapSize !== void 0 && (a.gapSize = this.gapSize), this.scale !== void 0 && (a.scale = this.scale), this.dithering === !0 && (a.dithering = !0), this.alphaTest > 0 && (a.alphaTest = this.alphaTest), this.alphaHash === !0 && (a.alphaHash = !0), this.alphaToCoverage === !0 && (a.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (a.premultipliedAlpha = !0), this.forceSinglePass === !0 && (a.forceSinglePass = !0), this.wireframe === !0 && (a.wireframe = !0), this.wireframeLinewidth > 1 && (a.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (a.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (a.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (a.flatShading = !0), this.visible === !1 && (a.visible = !1), this.toneMapped === !1 && (a.toneMapped = !1), this.fog === !1 && (a.fog = !1), Object.keys(this.userData).length > 0 && (a.userData = this.userData);
    function r(d) {
      const p = [];
      for (const y in d) {
        const _ = d[y];
        delete _.metadata, p.push(_);
      }
      return p;
    }
    if (t) {
      const d = r(e.textures), p = r(e.images);
      d.length > 0 && (a.textures = d), p.length > 0 && (a.images = p);
    }
    return a;
  }
  /**
   * Returns a new material with copied values from this instance.
   *
   * @return {Material} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given material to this instance.
   *
   * @param {Material} source - The material to copy.
   * @return {Material} A reference to this instance.
   */
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let a = null;
    if (t !== null) {
      const r = t.length;
      a = new Array(r);
      for (let d = 0; d !== r; ++d)
        a[d] = t[d].clone();
    }
    return this.clippingPlanes = a, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Material#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Setting this property to `true` indicates the engine the material
   * needs to be recompiled.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class Yh extends Vu {
  /**
   * Constructs a new mesh basic material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new hn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ip(), this.combine = aE, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Py = /* @__PURE__ */ Qz();
function Qz() {
  const o = new ArrayBuffer(4), e = new Float32Array(o), t = new Uint32Array(o), a = new Uint32Array(512), r = new Uint32Array(512);
  for (let _ = 0; _ < 256; ++_) {
    const E = _ - 127;
    E < -27 ? (a[_] = 0, a[_ | 256] = 32768, r[_] = 24, r[_ | 256] = 24) : E < -14 ? (a[_] = 1024 >> -E - 14, a[_ | 256] = 1024 >> -E - 14 | 32768, r[_] = -E - 1, r[_ | 256] = -E - 1) : E <= 15 ? (a[_] = E + 15 << 10, a[_ | 256] = E + 15 << 10 | 32768, r[_] = 13, r[_ | 256] = 13) : E < 128 ? (a[_] = 31744, a[_ | 256] = 64512, r[_] = 24, r[_ | 256] = 24) : (a[_] = 31744, a[_ | 256] = 64512, r[_] = 13, r[_ | 256] = 13);
  }
  const d = new Uint32Array(2048), p = new Uint32Array(64), y = new Uint32Array(64);
  for (let _ = 1; _ < 1024; ++_) {
    let E = _ << 13, T = 0;
    for (; (E & 8388608) === 0; )
      E <<= 1, T -= 8388608;
    E &= -8388609, T += 947912704, d[_] = E | T;
  }
  for (let _ = 1024; _ < 2048; ++_)
    d[_] = 939524096 + (_ - 1024 << 13);
  for (let _ = 1; _ < 31; ++_)
    p[_] = _ << 23;
  p[31] = 1199570944, p[32] = 2147483648;
  for (let _ = 33; _ < 63; ++_)
    p[_] = 2147483648 + (_ - 32 << 23);
  p[63] = 3347054592;
  for (let _ = 1; _ < 64; ++_)
    _ !== 32 && (y[_] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: a,
    shiftTable: r,
    mantissaTable: d,
    exponentTable: p,
    offsetTable: y
  };
}
function Ph(o) {
  Math.abs(o) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), o = Fa(o, -65504, 65504), Py.floatView[0] = o;
  const e = Py.uint32View[0], t = e >> 23 & 511;
  return Py.baseTable[t] + ((e & 8388607) >> Py.shiftTable[t]);
}
function DA(o) {
  const e = o >> 10;
  return Py.uint32View[0] = Py.mantissaTable[Py.offsetTable[e] + (o & 1023)] + Py.exponentTable[e], Py.floatView[0];
}
class XS {
  /**
   * Returns a half precision floating point value (FP16) from the given single
   * precision floating point value (FP32).
   *
   * @param {number} val - A single precision floating point value.
   * @return {number} The FP16 value.
   */
  static toHalfFloat(e) {
    return Ph(e);
  }
  /**
   * Returns a single precision floating point value (FP32) from the given half
   * precision floating point value (FP16).
   *
   * @param {number} val - A half precision floating point value.
   * @return {number} The FP32 value.
   */
  static fromHalfFloat(e) {
    return DA(e);
  }
}
const tu = /* @__PURE__ */ new ve(), lb = /* @__PURE__ */ new Ot();
let jz = 0;
class Hi {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, a = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: jz++ }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = a, this.usage = QA, this.updateRanges = [], this.gpuType = pr, this.version = 0;
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute
   * array data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the usage of this buffer attribute.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {BufferAttribute} A reference to this buffer attribute.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given buffer attribute to this instance.
   *
   * @param {BufferAttribute} source - The buffer attribute to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  /**
   * Copies a vector from the given buffer attribute to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this buffer attribute.
   * @param {BufferAttribute} attribute - The buffer attribute to copy from.
   * @param {number} index2 - The source index into the given buffer attribute.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyAt(e, t, a) {
    e *= this.itemSize, a *= t.itemSize;
    for (let r = 0, d = this.itemSize; r < d; r++)
      this.array[e + r] = t.array[a + r];
    return this;
  }
  /**
   * Copies the given array data into this buffer attribute.
   *
   * @param {(TypedArray|Array)} array - The array to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyArray(e) {
    return this.array.set(e), this;
  }
  /**
   * Applies the given 3x3 matrix to the given attribute. Works with
   * item size `2` and `3`.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, a = this.count; t < a; t++)
        lb.fromBufferAttribute(this, t), lb.applyMatrix3(e), this.setXY(t, lb.x, lb.y);
    else if (this.itemSize === 3)
      for (let t = 0, a = this.count; t < a; t++)
        tu.fromBufferAttribute(this, t), tu.applyMatrix3(e), this.setXYZ(t, tu.x, tu.y, tu.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix4(e) {
    for (let t = 0, a = this.count; t < a; t++)
      tu.fromBufferAttribute(this, t), tu.applyMatrix4(e), this.setXYZ(t, tu.x, tu.y, tu.z);
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(e) {
    for (let t = 0, a = this.count; t < a; t++)
      tu.fromBufferAttribute(this, t), tu.applyNormalMatrix(e), this.setXYZ(t, tu.x, tu.y, tu.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  transformDirection(e) {
    for (let t = 0, a = this.count; t < a; t++)
      tu.fromBufferAttribute(this, t), tu.transformDirection(e), this.setXYZ(t, tu.x, tu.y, tu.z);
    return this;
  }
  /**
   * Sets the given array data in the buffer attribute.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this buffer attribute's array.
   * @return {BufferAttribute} A reference to this instance.
   */
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(e, t) {
    let a = this.array[e * this.itemSize + t];
    return this.normalized && (a = Jd(a, this.array)), a;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setComponent(e, t, a) {
    return this.normalized && (a = Wa(a, this.array)), this.array[e * this.itemSize + t] = a, this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setX(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setY(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setZ(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setW(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXY(e, t, a) {
    return e *= this.itemSize, this.normalized && (t = Wa(t, this.array), a = Wa(a, this.array)), this.array[e + 0] = t, this.array[e + 1] = a, this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZ(e, t, a, r) {
    return e *= this.itemSize, this.normalized && (t = Wa(t, this.array), a = Wa(a, this.array), r = Wa(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = a, this.array[e + 2] = r, this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZW(e, t, a, r, d) {
    return e *= this.itemSize, this.normalized && (t = Wa(t, this.array), a = Wa(a, this.array), r = Wa(r, this.array), d = Wa(d, this.array)), this.array[e + 0] = t, this.array[e + 1] = a, this.array[e + 2] = r, this.array[e + 3] = d, this;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the attribute array data to the GPU. Can be used to perform clean-up operations after
   * the upload when attribute data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {BufferAttribute} A reference to this instance.
   */
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * @return {BufferAttribute} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== QA && (e.usage = this.usage), e;
  }
}
class Jz extends Hi {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int8Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, a) {
    super(new Int8Array(e), t, a);
  }
}
class Kz extends Hi {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint8Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, a) {
    super(new Uint8Array(e), t, a);
  }
}
class kz extends Hi {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint8ClampedArray)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, a) {
    super(new Uint8ClampedArray(e), t, a);
  }
}
class Wz extends Hi {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, a) {
    super(new Int16Array(e), t, a);
  }
}
class M2 extends Hi {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, a) {
    super(new Uint16Array(e), t, a);
  }
}
class $z extends Hi {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, a) {
    super(new Int32Array(e), t, a);
  }
}
class x2 extends Hi {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, a) {
    super(new Uint32Array(e), t, a);
  }
}
class eH extends Hi {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, a) {
    super(new Uint16Array(e), t, a), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = DA(this.array[e * this.itemSize]);
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.array[e * this.itemSize] = Ph(t), this;
  }
  getY(e) {
    let t = DA(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.array[e * this.itemSize + 1] = Ph(t), this;
  }
  getZ(e) {
    let t = DA(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.array[e * this.itemSize + 2] = Ph(t), this;
  }
  getW(e) {
    let t = DA(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.array[e * this.itemSize + 3] = Ph(t), this;
  }
  setXY(e, t, a) {
    return e *= this.itemSize, this.normalized && (t = Wa(t, this.array), a = Wa(a, this.array)), this.array[e + 0] = Ph(t), this.array[e + 1] = Ph(a), this;
  }
  setXYZ(e, t, a, r) {
    return e *= this.itemSize, this.normalized && (t = Wa(t, this.array), a = Wa(a, this.array), r = Wa(r, this.array)), this.array[e + 0] = Ph(t), this.array[e + 1] = Ph(a), this.array[e + 2] = Ph(r), this;
  }
  setXYZW(e, t, a, r, d) {
    return e *= this.itemSize, this.normalized && (t = Wa(t, this.array), a = Wa(a, this.array), r = Wa(r, this.array), d = Wa(d, this.array)), this.array[e + 0] = Ph(t), this.array[e + 1] = Ph(a), this.array[e + 2] = Ph(r), this.array[e + 3] = Ph(d), this;
  }
}
class qn extends Hi {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, a) {
    super(new Float32Array(e), t, a);
  }
}
let tH = 0;
const Pm = /* @__PURE__ */ new ia(), qT = /* @__PURE__ */ new zi(), J_ = /* @__PURE__ */ new ve(), Hp = /* @__PURE__ */ new td(), fA = /* @__PURE__ */ new td(), Sc = /* @__PURE__ */ new ve();
class Pa extends Jg {
  /**
   * Constructs a new geometry.
   */
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: tH++ }), this.uuid = Gp(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  /**
   * Returns the index of this geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
   */
  getIndex() {
    return this.index;
  }
  /**
   * Sets the given index to this geometry.
   *
   * @param {Array<number>|BufferAttribute} index - The index to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (hO(e) ? x2 : M2)(e, 1) : this.index = e, this;
  }
  /**
   * Sets the given indirect attribute to this geometry.
   *
   * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndirect(e) {
    return this.indirect = e, this;
  }
  /**
   * Returns the indirect attribute of this geometry.
   *
   * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
   */
  getIndirect() {
    return this.indirect;
  }
  /**
   * Returns the buffer attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
   * Returns `undefined` if not attribute has been found.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Sets the given attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  /**
   * Deletes the attribute for the given name.
   *
   * @param {string} name - The attribute name to delete.
   * @return {BufferGeometry} A reference to this instance.
   */
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  /**
   * Returns `true` if this geometry has an attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether this geometry has an attribute for the given name or not.
   */
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  /**
   * Adds a group to this geometry.
   *
   * @param {number} start - The first element in this draw call. That is the first
   * vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - Specifies how many vertices (or indices) are part of this group.
   * @param {number} [materialIndex=0] - The material array index to use.
   */
  addGroup(e, t, a = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: a
    });
  }
  /**
   * Clears all groups.
   */
  clearGroups() {
    this.groups = [];
  }
  /**
   * Sets the draw range for this geometry.
   *
   * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
   * For indexed BufferGeometry, `count` is the number of indices to render.
   */
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const a = this.attributes.normal;
    if (a !== void 0) {
      const d = new ja().getNormalMatrix(e);
      a.applyNormalMatrix(d), a.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  /**
   * Applies the rotation represented by the Quaternion to the geometry.
   *
   * @param {Quaternion} q - The Quaternion to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyQuaternion(e) {
    return Pm.makeRotationFromQuaternion(e), this.applyMatrix4(Pm), this;
  }
  /**
   * Rotates the geometry about the X axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateX(e) {
    return Pm.makeRotationX(e), this.applyMatrix4(Pm), this;
  }
  /**
   * Rotates the geometry about the Y axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateY(e) {
    return Pm.makeRotationY(e), this.applyMatrix4(Pm), this;
  }
  /**
   * Rotates the geometry about the Z axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateZ(e) {
    return Pm.makeRotationZ(e), this.applyMatrix4(Pm), this;
  }
  /**
   * Translates the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#position} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x offset.
   * @param {number} y - The y offset.
   * @param {number} z - The z offset.
   * @return {BufferGeometry} A reference to this instance.
   */
  translate(e, t, a) {
    return Pm.makeTranslation(e, t, a), this.applyMatrix4(Pm), this;
  }
  /**
   * Scales the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#scale} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x scale.
   * @param {number} y - The y scale.
   * @param {number} z - The z scale.
   * @return {BufferGeometry} A reference to this instance.
   */
  scale(e, t, a) {
    return Pm.makeScale(e, t, a), this.applyMatrix4(Pm), this;
  }
  /**
   * Rotates the geometry to face a point in 3D space. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
   * real-time mesh rotation.
   *
   * @param {Vector3} vector - The target point.
   * @return {BufferGeometry} A reference to this instance.
   */
  lookAt(e) {
    return qT.lookAt(e), qT.updateMatrix(), this.applyMatrix4(qT.matrix), this;
  }
  /**
   * Center the geometry based on its bounding box.
   *
   * @return {BufferGeometry} A reference to this instance.
   */
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(J_).negate(), this.translate(J_.x, J_.y, J_.z), this;
  }
  /**
   * Defines a geometry by creating a `position` attribute based on the given array of points. The array
   * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
   * set to `0`.
   *
   * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
   * data from the array. The length of the array must match the vertex count.
   *
   * @param {Array<Vector2>|Array<Vector3>} points - The points.
   * @return {BufferGeometry} A reference to this instance.
   */
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const a = [];
      for (let r = 0, d = e.length; r < d; r++) {
        const p = e[r];
        a.push(p.x, p.y, p.z || 0);
      }
      this.setAttribute("position", new qn(a, 3));
    } else {
      const a = Math.min(e.length, t.count);
      for (let r = 0; r < a; r++) {
        const d = e[r];
        t.setXYZ(r, d.x, d.y, d.z || 0);
      }
      e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0;
    }
    return this;
  }
  /**
   * Computes the bounding box of the geometry, and updates the `boundingBox` member.
   * The bounding box is not computed by the engine; it must be computed by your app.
   * You may need to recompute the bounding box if the geometry vertices are modified.
   */
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new td());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new ve(-1 / 0, -1 / 0, -1 / 0),
        new ve(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let a = 0, r = t.length; a < r; a++) {
          const d = t[a];
          Hp.setFromBufferAttribute(d), this.morphTargetsRelative ? (Sc.addVectors(this.boundingBox.min, Hp.min), this.boundingBox.expandByPoint(Sc), Sc.addVectors(this.boundingBox.max, Hp.max), this.boundingBox.expandByPoint(Sc)) : (this.boundingBox.expandByPoint(Hp.min), this.boundingBox.expandByPoint(Hp.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  /**
   * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if the geometry vertices are modified.
   */
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new rf());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new ve(), 1 / 0);
      return;
    }
    if (e) {
      const a = this.boundingSphere.center;
      if (Hp.setFromBufferAttribute(e), t)
        for (let d = 0, p = t.length; d < p; d++) {
          const y = t[d];
          fA.setFromBufferAttribute(y), this.morphTargetsRelative ? (Sc.addVectors(Hp.min, fA.min), Hp.expandByPoint(Sc), Sc.addVectors(Hp.max, fA.max), Hp.expandByPoint(Sc)) : (Hp.expandByPoint(fA.min), Hp.expandByPoint(fA.max));
        }
      Hp.getCenter(a);
      let r = 0;
      for (let d = 0, p = e.count; d < p; d++)
        Sc.fromBufferAttribute(e, d), r = Math.max(r, a.distanceToSquared(Sc));
      if (t)
        for (let d = 0, p = t.length; d < p; d++) {
          const y = t[d], _ = this.morphTargetsRelative;
          for (let E = 0, T = y.count; E < T; E++)
            Sc.fromBufferAttribute(y, E), _ && (J_.fromBufferAttribute(e, E), Sc.add(J_)), r = Math.max(r, a.distanceToSquared(Sc));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  /**
   * Calculates and adds a tangent attribute to this geometry.
   *
   * The computation is only supported for indexed geometries and if position, normal, and uv attributes
   * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
   * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
   */
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const a = t.position, r = t.normal, d = t.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Hi(new Float32Array(4 * a.count), 4));
    const p = this.getAttribute("tangent"), y = [], _ = [];
    for (let ne = 0; ne < a.count; ne++)
      y[ne] = new ve(), _[ne] = new ve();
    const E = new ve(), T = new ve(), C = new ve(), D = new Ot(), B = new Ot(), z = new Ot(), V = new ve(), G = new ve();
    function N(ne, Q, j) {
      E.fromBufferAttribute(a, ne), T.fromBufferAttribute(a, Q), C.fromBufferAttribute(a, j), D.fromBufferAttribute(d, ne), B.fromBufferAttribute(d, Q), z.fromBufferAttribute(d, j), T.sub(E), C.sub(E), B.sub(D), z.sub(D);
      const re = 1 / (B.x * z.y - z.x * B.y);
      isFinite(re) && (V.copy(T).multiplyScalar(z.y).addScaledVector(C, -B.y).multiplyScalar(re), G.copy(C).multiplyScalar(B.x).addScaledVector(T, -z.x).multiplyScalar(re), y[ne].add(V), y[Q].add(V), y[j].add(V), _[ne].add(G), _[Q].add(G), _[j].add(G));
    }
    let F = this.groups;
    F.length === 0 && (F = [{
      start: 0,
      count: e.count
    }]);
    for (let ne = 0, Q = F.length; ne < Q; ++ne) {
      const j = F[ne], re = j.start, _e = j.count;
      for (let me = re, Ae = re + _e; me < Ae; me += 3)
        N(
          e.getX(me + 0),
          e.getX(me + 1),
          e.getX(me + 2)
        );
    }
    const q = new ve(), Y = new ve(), ie = new ve(), k = new ve();
    function le(ne) {
      ie.fromBufferAttribute(r, ne), k.copy(ie);
      const Q = y[ne];
      q.copy(Q), q.sub(ie.multiplyScalar(ie.dot(Q))).normalize(), Y.crossVectors(k, Q);
      const re = Y.dot(_[ne]) < 0 ? -1 : 1;
      p.setXYZW(ne, q.x, q.y, q.z, re);
    }
    for (let ne = 0, Q = F.length; ne < Q; ++ne) {
      const j = F[ne], re = j.start, _e = j.count;
      for (let me = re, Ae = re + _e; me < Ae; me += 3)
        le(e.getX(me + 0)), le(e.getX(me + 1)), le(e.getX(me + 2));
    }
  }
  /**
   * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
   * each vertex normal to be the average of the face normals of the faces that share that vertex.
   * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
   * to be the same as the face normal.
   */
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let a = this.getAttribute("normal");
      if (a === void 0)
        a = new Hi(new Float32Array(t.count * 3), 3), this.setAttribute("normal", a);
      else
        for (let D = 0, B = a.count; D < B; D++)
          a.setXYZ(D, 0, 0, 0);
      const r = new ve(), d = new ve(), p = new ve(), y = new ve(), _ = new ve(), E = new ve(), T = new ve(), C = new ve();
      if (e)
        for (let D = 0, B = e.count; D < B; D += 3) {
          const z = e.getX(D + 0), V = e.getX(D + 1), G = e.getX(D + 2);
          r.fromBufferAttribute(t, z), d.fromBufferAttribute(t, V), p.fromBufferAttribute(t, G), T.subVectors(p, d), C.subVectors(r, d), T.cross(C), y.fromBufferAttribute(a, z), _.fromBufferAttribute(a, V), E.fromBufferAttribute(a, G), y.add(T), _.add(T), E.add(T), a.setXYZ(z, y.x, y.y, y.z), a.setXYZ(V, _.x, _.y, _.z), a.setXYZ(G, E.x, E.y, E.z);
        }
      else
        for (let D = 0, B = t.count; D < B; D += 3)
          r.fromBufferAttribute(t, D + 0), d.fromBufferAttribute(t, D + 1), p.fromBufferAttribute(t, D + 2), T.subVectors(p, d), C.subVectors(r, d), T.cross(C), a.setXYZ(D + 0, T.x, T.y, T.z), a.setXYZ(D + 1, T.x, T.y, T.z), a.setXYZ(D + 2, T.x, T.y, T.z);
      this.normalizeNormals(), a.needsUpdate = !0;
    }
  }
  /**
   * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
   * correct lighting on the geometry surfaces.
   */
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, a = e.count; t < a; t++)
      Sc.fromBufferAttribute(e, t), Sc.normalize(), e.setXYZ(t, Sc.x, Sc.y, Sc.z);
  }
  /**
   * Return a new non-index version of this indexed geometry. If the geometry
   * is already non-indexed, the method is a NOOP.
   *
   * @return {BufferGeometry} The non-indexed version of this indexed geometry.
   */
  toNonIndexed() {
    function e(y, _) {
      const E = y.array, T = y.itemSize, C = y.normalized, D = new E.constructor(_.length * T);
      let B = 0, z = 0;
      for (let V = 0, G = _.length; V < G; V++) {
        y.isInterleavedBufferAttribute ? B = _[V] * y.data.stride + y.offset : B = _[V] * T;
        for (let N = 0; N < T; N++)
          D[z++] = E[B++];
      }
      return new Hi(D, T, C);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Pa(), a = this.index.array, r = this.attributes;
    for (const y in r) {
      const _ = r[y], E = e(_, a);
      t.setAttribute(y, E);
    }
    const d = this.morphAttributes;
    for (const y in d) {
      const _ = [], E = d[y];
      for (let T = 0, C = E.length; T < C; T++) {
        const D = E[T], B = e(D, a);
        _.push(B);
      }
      t.morphAttributes[y] = _;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const p = this.groups;
    for (let y = 0, _ = p.length; y < _; y++) {
      const E = p[y];
      t.addGroup(E.start, E.count, E.materialIndex);
    }
    return t;
  }
  /**
   * Serializes the geometry into JSON.
   *
   * @return {Object} A JSON object representing the serialized geometry.
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const _ = this.parameters;
      for (const E in _)
        _[E] !== void 0 && (e[E] = _[E]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const a = this.attributes;
    for (const _ in a) {
      const E = a[_];
      e.data.attributes[_] = E.toJSON(e.data);
    }
    const r = {};
    let d = !1;
    for (const _ in this.morphAttributes) {
      const E = this.morphAttributes[_], T = [];
      for (let C = 0, D = E.length; C < D; C++) {
        const B = E[C];
        T.push(B.toJSON(e.data));
      }
      T.length > 0 && (r[_] = T, d = !0);
    }
    d && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const p = this.groups;
    p.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(p)));
    const y = this.boundingSphere;
    return y !== null && (e.data.boundingSphere = {
      center: y.center.toArray(),
      radius: y.radius
    }), e;
  }
  /**
   * Returns a new geometry with copied values from this instance.
   *
   * @return {BufferGeometry} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given geometry to this instance.
   *
   * @param {BufferGeometry} source - The geometry to copy.
   * @return {BufferGeometry} A reference to this instance.
   */
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const a = e.index;
    a !== null && this.setIndex(a.clone());
    const r = e.attributes;
    for (const E in r) {
      const T = r[E];
      this.setAttribute(E, T.clone(t));
    }
    const d = e.morphAttributes;
    for (const E in d) {
      const T = [], C = d[E];
      for (let D = 0, B = C.length; D < B; D++)
        T.push(C[D].clone(t));
      this.morphAttributes[E] = T;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const p = e.groups;
    for (let E = 0, T = p.length; E < T; E++) {
      const C = p[E];
      this.addGroup(C.start, C.count, C.materialIndex);
    }
    const y = e.boundingBox;
    y !== null && (this.boundingBox = y.clone());
    const _ = e.boundingSphere;
    return _ !== null && (this.boundingSphere = _.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires BufferGeometry#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const rB = /* @__PURE__ */ new ia(), bS = /* @__PURE__ */ new l_(), sb = /* @__PURE__ */ new rf(), oB = /* @__PURE__ */ new ve(), rb = /* @__PURE__ */ new ve(), ob = /* @__PURE__ */ new ve(), ub = /* @__PURE__ */ new ve(), ZT = /* @__PURE__ */ new ve(), cb = /* @__PURE__ */ new ve(), uB = /* @__PURE__ */ new ve(), fb = /* @__PURE__ */ new ve();
class es extends zi {
  /**
   * Constructs a new mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(e = new Pa(), t = new Yh()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  /**
   * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, a = Object.keys(t);
    if (a.length > 0) {
      const r = t[a[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let d = 0, p = r.length; d < p; d++) {
          const y = r[d].name || String(d);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[y] = d;
        }
      }
    }
  }
  /**
   * Returns the local-space position of the vertex at the given index, taking into
   * account the current animation state of both morph targets and skinning.
   *
   * @param {number} index - The vertex index.
   * @param {Vector3} target - The target object that is used to store the method's result.
   * @return {Vector3} The vertex position in local space.
   */
  getVertexPosition(e, t) {
    const a = this.geometry, r = a.attributes.position, d = a.morphAttributes.position, p = a.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const y = this.morphTargetInfluences;
    if (d && y) {
      cb.set(0, 0, 0);
      for (let _ = 0, E = d.length; _ < E; _++) {
        const T = y[_], C = d[_];
        T !== 0 && (ZT.fromBufferAttribute(C, e), p ? cb.addScaledVector(ZT, T) : cb.addScaledVector(ZT.sub(t), T));
      }
      t.add(cb);
    }
    return t;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    const a = this.geometry, r = this.material, d = this.matrixWorld;
    r !== void 0 && (a.boundingSphere === null && a.computeBoundingSphere(), sb.copy(a.boundingSphere), sb.applyMatrix4(d), bS.copy(e.ray).recast(e.near), !(sb.containsPoint(bS.origin) === !1 && (bS.intersectSphere(sb, oB) === null || bS.origin.distanceToSquared(oB) > (e.far - e.near) ** 2)) && (rB.copy(d).invert(), bS.copy(e.ray).applyMatrix4(rB), !(a.boundingBox !== null && bS.intersectsBox(a.boundingBox) === !1) && this._computeIntersections(e, t, bS)));
  }
  _computeIntersections(e, t, a) {
    let r;
    const d = this.geometry, p = this.material, y = d.index, _ = d.attributes.position, E = d.attributes.uv, T = d.attributes.uv1, C = d.attributes.normal, D = d.groups, B = d.drawRange;
    if (y !== null)
      if (Array.isArray(p))
        for (let z = 0, V = D.length; z < V; z++) {
          const G = D[z], N = p[G.materialIndex], F = Math.max(G.start, B.start), q = Math.min(y.count, Math.min(G.start + G.count, B.start + B.count));
          for (let Y = F, ie = q; Y < ie; Y += 3) {
            const k = y.getX(Y), le = y.getX(Y + 1), ne = y.getX(Y + 2);
            r = db(this, N, e, a, E, T, C, k, le, ne), r && (r.faceIndex = Math.floor(Y / 3), r.face.materialIndex = G.materialIndex, t.push(r));
          }
        }
      else {
        const z = Math.max(0, B.start), V = Math.min(y.count, B.start + B.count);
        for (let G = z, N = V; G < N; G += 3) {
          const F = y.getX(G), q = y.getX(G + 1), Y = y.getX(G + 2);
          r = db(this, p, e, a, E, T, C, F, q, Y), r && (r.faceIndex = Math.floor(G / 3), t.push(r));
        }
      }
    else if (_ !== void 0)
      if (Array.isArray(p))
        for (let z = 0, V = D.length; z < V; z++) {
          const G = D[z], N = p[G.materialIndex], F = Math.max(G.start, B.start), q = Math.min(_.count, Math.min(G.start + G.count, B.start + B.count));
          for (let Y = F, ie = q; Y < ie; Y += 3) {
            const k = Y, le = Y + 1, ne = Y + 2;
            r = db(this, N, e, a, E, T, C, k, le, ne), r && (r.faceIndex = Math.floor(Y / 3), r.face.materialIndex = G.materialIndex, t.push(r));
          }
        }
      else {
        const z = Math.max(0, B.start), V = Math.min(_.count, B.start + B.count);
        for (let G = z, N = V; G < N; G += 3) {
          const F = G, q = G + 1, Y = G + 2;
          r = db(this, p, e, a, E, T, C, F, q, Y), r && (r.faceIndex = Math.floor(G / 3), t.push(r));
        }
      }
  }
}
function nH(o, e, t, a, r, d, p, y) {
  let _;
  if (e.side === ed ? _ = a.intersectTriangle(p, d, r, !0, y) : _ = a.intersectTriangle(r, d, p, e.side === Zg, y), _ === null) return null;
  fb.copy(y), fb.applyMatrix4(o.matrixWorld);
  const E = t.ray.origin.distanceTo(fb);
  return E < t.near || E > t.far ? null : {
    distance: E,
    point: fb.clone(),
    object: o
  };
}
function db(o, e, t, a, r, d, p, y, _, E) {
  o.getVertexPosition(y, rb), o.getVertexPosition(_, ob), o.getVertexPosition(E, ub);
  const T = nH(o, e, t, a, rb, ob, ub, uB);
  if (T) {
    const C = new ve();
    Xh.getBarycoord(uB, rb, ob, ub, C), r && (T.uv = Xh.getInterpolatedAttribute(r, y, _, E, C, new Ot())), d && (T.uv1 = Xh.getInterpolatedAttribute(d, y, _, E, C, new Ot())), p && (T.normal = Xh.getInterpolatedAttribute(p, y, _, E, C, new ve()), T.normal.dot(a.direction) > 0 && T.normal.multiplyScalar(-1));
    const D = {
      a: y,
      b: _,
      c: E,
      normal: new ve(),
      materialIndex: 0
    };
    Xh.getNormal(rb, ob, ub, D.normal), T.face = D, T.barycoord = C;
  }
  return T;
}
class j0 extends Pa {
  /**
   * Constructs a new box geometry.
   *
   * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
   * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
   * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
   * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
   * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
   * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
   */
  constructor(e = 1, t = 1, a = 1, r = 1, d = 1, p = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: a,
      widthSegments: r,
      heightSegments: d,
      depthSegments: p
    };
    const y = this;
    r = Math.floor(r), d = Math.floor(d), p = Math.floor(p);
    const _ = [], E = [], T = [], C = [];
    let D = 0, B = 0;
    z("z", "y", "x", -1, -1, a, t, e, p, d, 0), z("z", "y", "x", 1, -1, a, t, -e, p, d, 1), z("x", "z", "y", 1, 1, e, a, t, r, p, 2), z("x", "z", "y", 1, -1, e, a, -t, r, p, 3), z("x", "y", "z", 1, -1, e, t, a, r, d, 4), z("x", "y", "z", -1, -1, e, t, -a, r, d, 5), this.setIndex(_), this.setAttribute("position", new qn(E, 3)), this.setAttribute("normal", new qn(T, 3)), this.setAttribute("uv", new qn(C, 2));
    function z(V, G, N, F, q, Y, ie, k, le, ne, Q) {
      const j = Y / le, re = ie / ne, _e = Y / 2, me = ie / 2, Ae = k / 2, He = le + 1, P = ne + 1;
      let te = 0, ae = 0;
      const Se = new ve();
      for (let ue = 0; ue < P; ue++) {
        const we = ue * re - me;
        for (let De = 0; De < He; De++) {
          const We = De * j - _e;
          Se[V] = We * F, Se[G] = we * q, Se[N] = Ae, E.push(Se.x, Se.y, Se.z), Se[V] = 0, Se[G] = 0, Se[N] = k > 0 ? 1 : -1, T.push(Se.x, Se.y, Se.z), C.push(De / le), C.push(1 - ue / ne), te += 1;
        }
      }
      for (let ue = 0; ue < ne; ue++)
        for (let we = 0; we < le; we++) {
          const De = D + we + He * ue, We = D + we + He * (ue + 1), Me = D + (we + 1) + He * (ue + 1), Ze = D + (we + 1) + He * ue;
          _.push(De, We, Ze), _.push(We, Me, Ze), ae += 6;
        }
      y.addGroup(B, ae, Q), B += ae, D += te;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {BoxGeometry} A new instance.
   */
  static fromJSON(e) {
    return new j0(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function E1(o) {
  const e = {};
  for (const t in o) {
    e[t] = {};
    for (const a in o[t]) {
      const r = o[t][a];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][a] = null) : e[t][a] = r.clone() : Array.isArray(r) ? e[t][a] = r.slice() : e[t][a] = r;
    }
  }
  return e;
}
function Qd(o) {
  const e = {};
  for (let t = 0; t < o.length; t++) {
    const a = E1(o[t]);
    for (const r in a)
      e[r] = a[r];
  }
  return e;
}
function aH(o) {
  const e = [];
  for (let t = 0; t < o.length; t++)
    e.push(o[t].clone());
  return e;
}
function gO(o) {
  const e = o.getRenderTarget();
  return e === null ? o.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : wi.workingColorSpace;
}
const T2 = { clone: E1, merge: Qd };
var iH = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, lH = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class iu extends Vu {
  /**
   * Constructs a new shader material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = iH, this.fragmentShader = lH, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = E1(e.uniforms), this.uniformsGroups = aH(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const r in this.uniforms) {
      const p = this.uniforms[r].value;
      p && p.isTexture ? t.uniforms[r] = {
        type: "t",
        value: p.toJSON(e).uuid
      } : p && p.isColor ? t.uniforms[r] = {
        type: "c",
        value: p.getHex()
      } : p && p.isVector2 ? t.uniforms[r] = {
        type: "v2",
        value: p.toArray()
      } : p && p.isVector3 ? t.uniforms[r] = {
        type: "v3",
        value: p.toArray()
      } : p && p.isVector4 ? t.uniforms[r] = {
        type: "v4",
        value: p.toArray()
      } : p && p.isMatrix3 ? t.uniforms[r] = {
        type: "m3",
        value: p.toArray()
      } : p && p.isMatrix4 ? t.uniforms[r] = {
        type: "m4",
        value: p.toArray()
      } : t.uniforms[r] = {
        value: p
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const a = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (a[r] = !0);
    return Object.keys(a).length > 0 && (t.extensions = a), t;
  }
}
class oE extends zi {
  /**
   * Constructs a new camera.
   */
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ia(), this.projectionMatrix = new ia(), this.projectionMatrixInverse = new ia(), this.coordinateSystem = Qv;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * This method is overwritten since cameras have a different forward vector compared to other
   * 3D objects. A camera looks down its local, negative z-axis by default.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const z0 = /* @__PURE__ */ new ve(), cB = /* @__PURE__ */ new Ot(), fB = /* @__PURE__ */ new Ot();
class Ls extends oE {
  /**
   * Constructs a new perspective camera.
   *
   * @param {number} [fov=50] - The vertical field of view.
   * @param {number} [aspect=1] - The aspect ratio.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = 50, t = 1, a = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = a, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = _1 * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Returns the focal length from the current {@link PerspectiveCamera#fov} and
   * {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The computed focal length.
   */
  getFocalLength() {
    const e = Math.tan(jS * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  /**
   * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
   *
   * @return {number} The effective FOV.
   */
  getEffectiveFOV() {
    return _1 * 2 * Math.atan(
      Math.tan(jS * 0.5 * this.fov) / this.zoom
    );
  }
  /**
   * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  /**
   * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
   * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
   */
  getViewBounds(e, t, a) {
    z0.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(z0.x, z0.y).multiplyScalar(-e / z0.z), z0.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), a.set(z0.x, z0.y).multiplyScalar(-e / z0.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
   * @returns {Vector2} The view size.
   */
  getViewSize(e, t) {
    return this.getViewBounds(e, cB, fB), t.subVectors(fB, cB);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *```
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *```
   * then for each monitor you would call it like this:
   *```js
   * const w = 1920;
   * const h = 1080;
   * const fullWidth = w * 3;
   * const fullHeight = h * 2;
   *
   * // --A--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   * // --B--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   * // --C--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   * // --D--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   * // --E--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   * // --F--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   * ```
   *
   * Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   */
  setViewOffset(e, t, a, r, d, p) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = a, this.view.offsetY = r, this.view.width = d, this.view.height = p, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(jS * 0.5 * this.fov) / this.zoom, a = 2 * t, r = this.aspect * a, d = -0.5 * r;
    const p = this.view;
    if (this.view !== null && this.view.enabled) {
      const _ = p.fullWidth, E = p.fullHeight;
      d += p.offsetX * r / _, t -= p.offsetY * a / E, r *= p.width / _, a *= p.height / E;
    }
    const y = this.filmOffset;
    y !== 0 && (d += e * y / this.getFilmWidth()), this.projectionMatrix.makePerspective(d, d + r, t, t - a, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const K_ = -90, k_ = 1;
class yO extends zi {
  /**
   * Constructs a new cube camera.
   *
   * @param {number} near - The camera's near plane.
   * @param {number} far - The camera's far plane.
   * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
   */
  constructor(e, t, a) {
    super(), this.type = "CubeCamera", this.renderTarget = a, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new Ls(K_, k_, e, t);
    r.layers = this.layers, this.add(r);
    const d = new Ls(K_, k_, e, t);
    d.layers = this.layers, this.add(d);
    const p = new Ls(K_, k_, e, t);
    p.layers = this.layers, this.add(p);
    const y = new Ls(K_, k_, e, t);
    y.layers = this.layers, this.add(y);
    const _ = new Ls(K_, k_, e, t);
    _.layers = this.layers, this.add(_);
    const E = new Ls(K_, k_, e, t);
    E.layers = this.layers, this.add(E);
  }
  /**
   * Must be called when the coordinate system of the cube camera is changed.
   */
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [a, r, d, p, y, _] = t;
    for (const E of t) this.remove(E);
    if (e === Qv)
      a.up.set(0, 1, 0), a.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), d.up.set(0, 0, -1), d.lookAt(0, 1, 0), p.up.set(0, 0, 1), p.lookAt(0, -1, 0), y.up.set(0, 1, 0), y.lookAt(0, 0, 1), _.up.set(0, 1, 0), _.lookAt(0, 0, -1);
    else if (e === jA)
      a.up.set(0, -1, 0), a.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), d.up.set(0, 0, 1), d.lookAt(0, 1, 0), p.up.set(0, 0, -1), p.lookAt(0, -1, 0), y.up.set(0, -1, 0), y.lookAt(0, 0, 1), _.up.set(0, -1, 0), _.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const E of t)
      this.add(E), E.updateMatrixWorld();
  }
  /**
   * Calling this method will render the given scene with the given renderer
   * into the cube render target of the camera.
   *
   * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
   * @param {Scene} scene - The scene to render.
   */
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: a, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [d, p, y, _, E, T] = this.children, C = e.getRenderTarget(), D = e.getActiveCubeFace(), B = e.getActiveMipmapLevel(), z = e.xr.enabled;
    e.xr.enabled = !1;
    const V = a.texture.generateMipmaps;
    a.texture.generateMipmaps = !1, e.setRenderTarget(a, 0, r), e.render(t, d), e.setRenderTarget(a, 1, r), e.render(t, p), e.setRenderTarget(a, 2, r), e.render(t, y), e.setRenderTarget(a, 3, r), e.render(t, _), e.setRenderTarget(a, 4, r), e.render(t, E), a.texture.generateMipmaps = V, e.setRenderTarget(a, 5, r), e.render(t, T), e.setRenderTarget(C, D, B), e.xr.enabled = z, a.texture.needsPMREMUpdate = !0;
  }
}
class uE extends Ml {
  /**
   * Constructs a new cube texture.
   *
   * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
   * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space value.
   */
  constructor(e = [], t = Qg, a, r, d, p, y, _, E, T) {
    super(e, t, a, r, d, p, y, _, E, T), this.isCubeTexture = !0, this.flipY = !1;
  }
  /**
   * Alias for {@link CubeTexture#image}.
   *
   * @type {Array<Image>}
   */
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class C2 extends uf {
  /**
   * Constructs a new cube render target.
   *
   * @param {number} [size=1] - The size of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const a = { width: e, height: e, depth: 1 }, r = [a, a, a, a, a, a];
    this.texture = new uE(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Ni;
  }
  /**
   * Converts the given equirectangular texture to a cube map.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Texture} texture - The equirectangular texture.
   * @return {WebGLCubeRenderTarget} A reference to this cube render target.
   */
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const a = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, r = new j0(5, 5, 5), d = new iu({
      name: "CubemapFromEquirect",
      uniforms: E1(a.uniforms),
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader,
      side: ed,
      blending: jv
    });
    d.uniforms.tEquirect.value = t;
    const p = new es(r, d), y = t.minFilter;
    return t.minFilter === qm && (t.minFilter = Ni), new yO(1, 10, this).update(e, p), t.minFilter = y, p.geometry.dispose(), p.material.dispose(), this;
  }
  /**
   * Clears this cube render target.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   */
  clear(e, t = !0, a = !0, r = !0) {
    const d = e.getRenderTarget();
    for (let p = 0; p < 6; p++)
      e.setRenderTarget(this, p), e.clear(t, a, r);
    e.setRenderTarget(d);
  }
}
class Xy extends zi {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const sH = { type: "move" };
class sM {
  /**
   * Constructs a new XR controller.
   */
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  /**
   * Returns a group representing the hand space of the XR controller.
   *
   * @return {Group} A group representing the hand space of the XR controller.
   */
  getHandSpace() {
    return this._hand === null && (this._hand = new Xy(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  /**
   * Returns a group representing the target ray space of the XR controller.
   *
   * @return {Group} A group representing the target ray space of the XR controller.
   */
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Xy(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ve(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ve()), this._targetRay;
  }
  /**
   * Returns a group representing the grip space of the XR controller.
   *
   * @return {Group} A group representing the grip space of the XR controller.
   */
  getGripSpace() {
    return this._grip === null && (this._grip = new Xy(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ve(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ve()), this._grip;
  }
  /**
   * Dispatches the given event to the groups representing
   * the different coordinate spaces of the XR controller.
   *
   * @param {Object} event - The event to dispatch.
   * @return {WebXRController} A reference to this instance.
   */
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  /**
   * Connects the controller with the given XR input source.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @return {WebXRController} A reference to this instance.
   */
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const a of e.hand.values())
          this._getHandJoint(t, a);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  /**
   * Disconnects the controller from the given XR input source.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @return {WebXRController} A reference to this instance.
   */
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  /**
   * Updates the controller with the given input source, XR frame and reference space.
   * This updates the transformations of the groups that represent the different
   * coordinate systems of the controller.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @param {XRFrame} frame - The XR frame.
   * @param {XRReferenceSpace} referenceSpace - The reference space.
   * @return {WebXRController} A reference to this instance.
   */
  update(e, t, a) {
    let r = null, d = null, p = null;
    const y = this._targetRay, _ = this._grip, E = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (E && e.hand) {
        p = !0;
        for (const V of e.hand.values()) {
          const G = t.getJointPose(V, a), N = this._getHandJoint(E, V);
          G !== null && (N.matrix.fromArray(G.transform.matrix), N.matrix.decompose(N.position, N.rotation, N.scale), N.matrixWorldNeedsUpdate = !0, N.jointRadius = G.radius), N.visible = G !== null;
        }
        const T = E.joints["index-finger-tip"], C = E.joints["thumb-tip"], D = T.position.distanceTo(C.position), B = 0.02, z = 5e-3;
        E.inputState.pinching && D > B + z ? (E.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !E.inputState.pinching && D <= B - z && (E.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        _ !== null && e.gripSpace && (d = t.getPose(e.gripSpace, a), d !== null && (_.matrix.fromArray(d.transform.matrix), _.matrix.decompose(_.position, _.rotation, _.scale), _.matrixWorldNeedsUpdate = !0, d.linearVelocity ? (_.hasLinearVelocity = !0, _.linearVelocity.copy(d.linearVelocity)) : _.hasLinearVelocity = !1, d.angularVelocity ? (_.hasAngularVelocity = !0, _.angularVelocity.copy(d.angularVelocity)) : _.hasAngularVelocity = !1));
      y !== null && (r = t.getPose(e.targetRaySpace, a), r === null && d !== null && (r = d), r !== null && (y.matrix.fromArray(r.transform.matrix), y.matrix.decompose(y.position, y.rotation, y.scale), y.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (y.hasLinearVelocity = !0, y.linearVelocity.copy(r.linearVelocity)) : y.hasLinearVelocity = !1, r.angularVelocity ? (y.hasAngularVelocity = !0, y.angularVelocity.copy(r.angularVelocity)) : y.hasAngularVelocity = !1, this.dispatchEvent(sH)));
    }
    return y !== null && (y.visible = r !== null), _ !== null && (_.visible = d !== null), E !== null && (E.visible = p !== null), this;
  }
  /**
   * Returns a group representing the hand joint for the given input joint.
   *
   * @private
   * @param {Group} hand - The group representing the hand space.
   * @param {XRHandJoint} inputjoint - The XR frame.
   * @return {Group} A group representing the hand joint for the given input joint.
   */
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const a = new Xy();
      a.matrixAutoUpdate = !1, a.visible = !1, e.joints[t.jointName] = a, e.add(a);
    }
    return e.joints[t.jointName];
  }
}
class mx {
  /**
   * Constructs a new fog.
   *
   * @param {number|Color} color - The fog's color.
   * @param {number} [density=0.00025] - Defines how fast the fog will grow dense.
   */
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new hn(e), this.density = t;
  }
  /**
   * Returns a new fog with copied values from this instance.
   *
   * @return {FogExp2} A clone of this instance.
   */
  clone() {
    return new mx(this.color, this.density);
  }
  /**
   * Serializes the fog into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized fog
   */
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class vx {
  /**
   * Constructs a new fog.
   *
   * @param {number|Color} color - The fog's color.
   * @param {number} [near=1] - The minimum distance to start applying fog.
   * @param {number} [far=1000] - The maximum distance at which fog stops being calculated and applied.
   */
  constructor(e, t = 1, a = 1e3) {
    this.isFog = !0, this.name = "", this.color = new hn(e), this.near = t, this.far = a;
  }
  /**
   * Returns a new fog with copied values from this instance.
   *
   * @return {Fog} A clone of this instance.
   */
  clone() {
    return new vx(this.color, this.near, this.far);
  }
  /**
   * Serializes the fog into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized fog
   */
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class R1 extends zi {
  /**
   * Constructs a new scene.
   */
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Ip(), this.environmentIntensity = 1, this.environmentRotation = new Ip(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
}
class cE {
  /**
   * Constructs a new interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   */
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = QA, this.updateRanges = [], this.version = 0, this.uuid = Gp();
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute array
   * data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the usage of this interleaved buffer.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {InterleavedBuffer} A reference to this interleaved buffer.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given interleaved buffer to this instance.
   *
   * @param {InterleavedBuffer} source - The interleaved buffer to copy.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  /**
   * Copies a vector from the given interleaved buffer to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this interleaved buffer.
   * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
   * @param {number} index2 - The source index into the given interleaved buffer.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copyAt(e, t, a) {
    e *= this.stride, a *= t.stride;
    for (let r = 0, d = this.stride; r < d; r++)
      this.array[e + r] = t.array[a + r];
    return this;
  }
  /**
   * Sets the given array data in the interleaved buffer.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this interleaved buffer's array.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  /**
   * Returns a new interleaved buffer with copied values from this instance.
   *
   * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
   * @return {InterleavedBuffer} A clone of this instance.
   */
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Gp()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), a = new this.constructor(t, this.stride);
    return a.setUsage(this.usage), a;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the array data to the GPU. Can be used to perform clean-up operations after
   * the upload when data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  /**
   * Serializes the interleaved buffer into JSON.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized interleaved buffer.
   */
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Gp()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Zd = /* @__PURE__ */ new ve();
class Z0 {
  /**
   * Constructs a new interleaved buffer attribute.
   *
   * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
   * @param {number} itemSize - The item size.
   * @param {number} offset - The attribute offset into the buffer.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, a, r = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = a, this.normalized = r;
  }
  /**
   * The item count of this buffer attribute.
   *
   * @type {number}
   * @readonly
   */
  get count() {
    return this.data.count;
  }
  /**
   * The array holding the interleaved buffer attribute data.
   *
   * @type {TypedArray}
   */
  get array() {
    return this.data.array;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyMatrix4(e) {
    for (let t = 0, a = this.data.count; t < a; t++)
      Zd.fromBufferAttribute(this, t), Zd.applyMatrix4(e), this.setXYZ(t, Zd.x, Zd.y, Zd.z);
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(e) {
    for (let t = 0, a = this.count; t < a; t++)
      Zd.fromBufferAttribute(this, t), Zd.applyNormalMatrix(e), this.setXYZ(t, Zd.x, Zd.y, Zd.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  transformDirection(e) {
    for (let t = 0, a = this.count; t < a; t++)
      Zd.fromBufferAttribute(this, t), Zd.transformDirection(e), this.setXYZ(t, Zd.x, Zd.y, Zd.z);
    return this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(e, t) {
    let a = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (a = Jd(a, this.array)), a;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setComponent(e, t, a) {
    return this.normalized && (a = Wa(a, this.array)), this.data.array[e * this.data.stride + this.offset + t] = a, this;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setX(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setY(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setZ(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setW(e, t) {
    return this.normalized && (t = Wa(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Jd(t, this.array)), t;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXY(e, t, a) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Wa(t, this.array), a = Wa(a, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = a, this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZ(e, t, a, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Wa(t, this.array), a = Wa(a, this.array), r = Wa(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = a, this.data.array[e + 2] = r, this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZW(e, t, a, r, d) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Wa(t, this.array), a = Wa(a, this.array), r = Wa(r, this.array), d = Wa(d, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = a, this.data.array[e + 2] = r, this.data.array[e + 3] = d, this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
   * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
   */
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let a = 0; a < this.count; a++) {
        const r = a * this.data.stride + this.offset;
        for (let d = 0; d < this.itemSize; d++)
          t.push(this.data.array[r + d]);
      }
      return new Hi(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Z0(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let a = 0; a < this.count; a++) {
        const r = a * this.data.stride + this.offset;
        for (let d = 0; d < this.itemSize; d++)
          t.push(this.data.array[r + d]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class R2 extends Vu {
  /**
   * Constructs a new sprite material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new hn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let W_;
const dA = /* @__PURE__ */ new ve(), $_ = /* @__PURE__ */ new ve(), e1 = /* @__PURE__ */ new ve(), t1 = /* @__PURE__ */ new Ot(), hA = /* @__PURE__ */ new Ot(), SO = /* @__PURE__ */ new ia(), hb = /* @__PURE__ */ new ve(), pA = /* @__PURE__ */ new ve(), pb = /* @__PURE__ */ new ve(), dB = /* @__PURE__ */ new Ot(), QT = /* @__PURE__ */ new Ot(), hB = /* @__PURE__ */ new Ot();
class _O extends zi {
  /**
   * Constructs a new sprite.
   *
   * @param {SpriteMaterial} [material] - The sprite material.
   */
  constructor(e = new R2()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", W_ === void 0) {
      W_ = new Pa();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), a = new cE(t, 5);
      W_.setIndex([0, 1, 2, 0, 2, 3]), W_.setAttribute("position", new Z0(a, 3, 0, !1)), W_.setAttribute("uv", new Z0(a, 2, 3, !1));
    }
    this.geometry = W_, this.material = e, this.center = new Ot(0.5, 0.5);
  }
  /**
   * Computes intersection points between a casted ray and this sprite.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), $_.setFromMatrixScale(this.matrixWorld), SO.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), e1.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && $_.multiplyScalar(-e1.z);
    const a = this.material.rotation;
    let r, d;
    a !== 0 && (d = Math.cos(a), r = Math.sin(a));
    const p = this.center;
    mb(hb.set(-0.5, -0.5, 0), e1, p, $_, r, d), mb(pA.set(0.5, -0.5, 0), e1, p, $_, r, d), mb(pb.set(0.5, 0.5, 0), e1, p, $_, r, d), dB.set(0, 0), QT.set(1, 0), hB.set(1, 1);
    let y = e.ray.intersectTriangle(hb, pA, pb, !1, dA);
    if (y === null && (mb(pA.set(-0.5, 0.5, 0), e1, p, $_, r, d), QT.set(0, 1), y = e.ray.intersectTriangle(hb, pb, pA, !1, dA), y === null))
      return;
    const _ = e.ray.origin.distanceTo(dA);
    _ < e.near || _ > e.far || t.push({
      distance: _,
      point: dA.clone(),
      uv: Xh.getInterpolation(dA, hb, pA, pb, dB, QT, hB, new Ot()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function mb(o, e, t, a, r, d) {
  t1.subVectors(o, t).addScalar(0.5).multiply(a), r !== void 0 ? (hA.x = d * t1.x - r * t1.y, hA.y = r * t1.x + d * t1.y) : hA.copy(t1), o.copy(e), o.x += hA.x, o.y += hA.y, o.applyMatrix4(SO);
}
const vb = /* @__PURE__ */ new ve(), pB = /* @__PURE__ */ new ve();
class AO extends zi {
  /**
   * Constructs a new LOD.
   */
  constructor() {
    super(), this.isLOD = !0, this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      /**
       * This array holds the LOD levels.
       *
       * @name LOD#levels
       * @type {Array<{object:Object3D,distance:number,hysteresis:number}>}
       */
      levels: {
        enumerable: !0,
        value: []
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let a = 0, r = t.length; a < r; a++) {
      const d = t[a];
      this.addLevel(d.object.clone(), d.distance, d.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  /**
   * Adds a mesh that will display at a certain distance and greater. Typically
   * the further away the distance, the lower the detail on the mesh.
   *
   * @param {Object3D} object - The 3D object to display at this level.
   * @param {number} [distance=0] - The distance at which to display this level of detail.
   * @param {number} [hysteresis=0] - Threshold used to avoid flickering at LOD boundaries, as a fraction of distance.
   * @return {LOD} A reference to this instance.
   */
  addLevel(e, t = 0, a = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let d;
    for (d = 0; d < r.length && !(t < r[d].distance); d++)
      ;
    return r.splice(d, 0, { distance: t, hysteresis: a, object: e }), this.add(e), this;
  }
  /**
   * Removes an existing level, based on the distance from the camera.
   * Returns `true` when the level has been removed. Otherwise `false`.
   *
   * @param {number} distance - Distance of the level to remove.
   * @return {boolean} Whether the level has been removed or not.
   */
  removeLevel(e) {
    const t = this.levels;
    for (let a = 0; a < t.length; a++)
      if (t[a].distance === e) {
        const r = t.splice(a, 1);
        return this.remove(r[0].object), !0;
      }
    return !1;
  }
  /**
   * Returns the currently active LOD level index.
   *
   * @return {number} The current active LOD level index.
   */
  getCurrentLevel() {
    return this._currentLevel;
  }
  /**
   * Returns a reference to the first 3D object that is greater than
   * the given distance.
   *
   * @param {number} distance - The LOD distance.
   * @return {Object3D|null} The found 3D object. `null` if no 3D object has been found.
   */
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let a, r;
      for (a = 1, r = t.length; a < r; a++) {
        let d = t[a].distance;
        if (t[a].object.visible && (d -= d * t[a].hysteresis), e < d)
          break;
      }
      return t[a - 1].object;
    }
    return null;
  }
  /**
   * Computes intersection points between a casted ray and this LOD.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    if (this.levels.length > 0) {
      vb.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(vb);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  /**
   * Updates the LOD by computing which LOD level should be visible according
   * to the current distance of the given camera.
   *
   * @param {Camera} camera - The camera the scene is rendered with.
   */
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      vb.setFromMatrixPosition(e.matrixWorld), pB.setFromMatrixPosition(this.matrixWorld);
      const a = vb.distanceTo(pB) / e.zoom;
      t[0].object.visible = !0;
      let r, d;
      for (r = 1, d = t.length; r < d; r++) {
        let p = t[r].distance;
        if (t[r].object.visible && (p -= p * t[r].hysteresis), a >= p)
          t[r - 1].object.visible = !1, t[r].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = r - 1; r < d; r++)
        t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const a = this.levels;
    for (let r = 0, d = a.length; r < d; r++) {
      const p = a[r];
      t.object.levels.push({
        object: p.object.uuid,
        distance: p.distance,
        hysteresis: p.hysteresis
      });
    }
    return t;
  }
}
const mB = /* @__PURE__ */ new ve(), vB = /* @__PURE__ */ new Bi(), gB = /* @__PURE__ */ new Bi(), rH = /* @__PURE__ */ new ve(), yB = /* @__PURE__ */ new ia(), gb = /* @__PURE__ */ new ve(), jT = /* @__PURE__ */ new rf(), SB = /* @__PURE__ */ new ia(), JT = /* @__PURE__ */ new l_();
class D2 extends es {
  /**
   * Constructs a new skinned mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = YC, this.bindMatrix = new ia(), this.bindMatrixInverse = new ia(), this.boundingBox = null, this.boundingSphere = null;
  }
  /**
   * Computes the bounding box of the skinned mesh, and updates {@link SkinnedMesh#boundingBox}.
   * The bounding box is not automatically computed by the engine; this method must be called by your app.
   * If the skinned mesh is animated, the bounding box should be recomputed per frame in order to reflect
   * the current animation state.
   */
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new td()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let a = 0; a < t.count; a++)
      this.getVertexPosition(a, gb), this.boundingBox.expandByPoint(gb);
  }
  /**
   * Computes the bounding sphere of the skinned mesh, and updates {@link SkinnedMesh#boundingSphere}.
   * The bounding sphere is automatically computed by the engine once when it is needed, e.g., for ray casting
   * and view frustum culling. If the skinned mesh is animated, the bounding sphere should be recomputed
   * per frame in order to reflect the current animation state.
   */
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new rf()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let a = 0; a < t.count; a++)
      this.getVertexPosition(a, gb), this.boundingSphere.expandByPoint(gb);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const a = this.material, r = this.matrixWorld;
    a !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), jT.copy(this.boundingSphere), jT.applyMatrix4(r), e.ray.intersectsSphere(jT) !== !1 && (SB.copy(r).invert(), JT.copy(e.ray).applyMatrix4(SB), !(this.boundingBox !== null && JT.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, JT)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  /**
   * Binds the given skeleton to the skinned mesh.
   *
   * @param {Skeleton} skeleton - The skeleton to bind.
   * @param {Matrix4} [bindMatrix] - The bind matrix. If no bind matrix is provided,
   * the skinned mesh's world matrix will be used instead.
   */
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  /**
   * This method sets the skinned mesh in the rest pose).
   */
  pose() {
    this.skeleton.pose();
  }
  /**
   * Normalizes the skin weights which are defined as a buffer attribute
   * in the skinned mesh's geometry.
   */
  normalizeSkinWeights() {
    const e = new Bi(), t = this.geometry.attributes.skinWeight;
    for (let a = 0, r = t.count; a < r; a++) {
      e.fromBufferAttribute(t, a);
      const d = 1 / e.manhattanLength();
      d !== 1 / 0 ? e.multiplyScalar(d) : e.set(1, 0, 0, 0), t.setXYZW(a, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === YC ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === WU ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  /**
   * Applies the bone transform associated with the given index to the given
   * vertex position. Returns the updated vector.
   *
   * @param {number} index - The vertex index.
   * @param {Vector3} target - The target object that is used to store the method's result.
   * the skinned mesh's world matrix will be used instead.
   * @return {Vector3} The updated vertex position.
   */
  applyBoneTransform(e, t) {
    const a = this.skeleton, r = this.geometry;
    vB.fromBufferAttribute(r.attributes.skinIndex, e), gB.fromBufferAttribute(r.attributes.skinWeight, e), mB.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let d = 0; d < 4; d++) {
      const p = gB.getComponent(d);
      if (p !== 0) {
        const y = vB.getComponent(d);
        yB.multiplyMatrices(a.bones[y].matrixWorld, a.boneInverses[y]), t.addScaledVector(rH.copy(mB).applyMatrix4(yB), p);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class gx extends zi {
  /**
   * Constructs a new bone.
   */
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Jv extends Ml {
  /**
   * Constructs a new data texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=NearestFilter] - The mag filter value.
   * @param {number} [minFilter=NearestFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e = null, t = 1, a = 1, r, d, p, y, _, E = _c, T = _c, C, D) {
    super(null, p, y, _, E, T, r, d, C, D), this.isDataTexture = !0, this.image = { data: e, width: t, height: a }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const _B = /* @__PURE__ */ new ia(), oH = /* @__PURE__ */ new ia();
class fE {
  /**
   * Constructs a new skeleton.
   *
   * @param {Array<Bone>} [bones] - An array of bones.
   * @param {Array<Matrix4>} [boneInverses] - An array of bone inverse matrices.
   * If not provided, these matrices will be computed automatically via {@link Skeleton#calculateInverses}.
   */
  constructor(e = [], t = []) {
    this.uuid = Gp(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  /**
   * Initializes the skeleton. This method gets automatically called by the constructor
   * but depending on how the skeleton is created it might be necessary to call this method
   * manually.
   */
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let a = 0, r = this.bones.length; a < r; a++)
        this.boneInverses.push(new ia());
    }
  }
  /**
   * Computes the bone inverse matrices. This method resets {@link Skeleton#boneInverses}
   * and fills it with new matrices.
   */
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const a = new ia();
      this.bones[e] && a.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(a);
    }
  }
  /**
   * Resets the skeleton to the base pose.
   */
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const a = this.bones[e];
      a && a.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const a = this.bones[e];
      a && (a.parent && a.parent.isBone ? (a.matrix.copy(a.parent.matrixWorld).invert(), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale));
    }
  }
  /**
   * Resets the skeleton to the base pose.
   */
  update() {
    const e = this.bones, t = this.boneInverses, a = this.boneMatrices, r = this.boneTexture;
    for (let d = 0, p = e.length; d < p; d++) {
      const y = e[d] ? e[d].matrixWorld : oH;
      _B.multiplyMatrices(y, t[d]), _B.toArray(a, d * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  /**
   * Returns a new skeleton with copied values from this instance.
   *
   * @return {Skeleton} A clone of this instance.
   */
  clone() {
    return new fE(this.bones, this.boneInverses);
  }
  /**
   * Computes a data texture for passing bone data to the vertex shader.
   *
   * @return {Skeleton} A reference of this instance.
   */
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const a = new Jv(t, e, e, xo, pr);
    return a.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = a, this;
  }
  /**
   * Searches through the skeleton's bone array and returns the first with a
   * matching name.
   *
   * @param {string} name - The name of the bone.
   * @return {Bone|undefined} The found bone. `undefined` if no bone has been found.
   */
  getBoneByName(e) {
    for (let t = 0, a = this.bones.length; t < a; t++) {
      const r = this.bones[t];
      if (r.name === e)
        return r;
    }
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  /**
   * Setups the skeleton by the given JSON and bones.
   *
   * @param {Object} json - The skeleton as serialized JSON.
   * @param {Object<string, Bone>} bones - An array of bones.
   * @return {Skeleton} A reference of this instance.
   */
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let a = 0, r = e.bones.length; a < r; a++) {
      const d = e.bones[a];
      let p = t[d];
      p === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", d), p = new gx()), this.bones.push(p), this.boneInverses.push(new ia().fromArray(e.boneInverses[a]));
    }
    return this.init(), this;
  }
  /**
   * Serializes the skeleton into JSON.
   *
   * @return {Object} A JSON object representing the serialized skeleton.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, a = this.boneInverses;
    for (let r = 0, d = t.length; r < d; r++) {
      const p = t[r];
      e.bones.push(p.uuid);
      const y = a[r];
      e.boneInverses.push(y.toArray());
    }
    return e;
  }
}
class $S extends Hi {
  /**
   * Constructs a new instanced buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   * @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
   */
  constructor(e, t, a, r = 1) {
    super(e, t, a), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const n1 = /* @__PURE__ */ new ia(), AB = /* @__PURE__ */ new ia(), yb = [], EB = /* @__PURE__ */ new td(), uH = /* @__PURE__ */ new ia(), mA = /* @__PURE__ */ new es(), vA = /* @__PURE__ */ new rf();
class B2 extends es {
  /**
   * Constructs a new instanced mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   * @param {number} count - The number of instances.
   */
  constructor(e, t, a) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new $S(new Float32Array(a * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = a, this.boundingBox = null, this.boundingSphere = null;
    for (let r = 0; r < a; r++)
      this.setMatrixAt(r, uH);
  }
  /**
   * Computes the bounding box of the instanced mesh, and updates {@link InstancedMesh#boundingBox}.
   * The bounding box is not automatically computed by the engine; this method must be called by your app.
   * You may need to recompute the bounding box if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
   */
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new td()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let a = 0; a < t; a++)
      this.getMatrixAt(a, n1), EB.copy(e.boundingBox).applyMatrix4(n1), this.boundingBox.union(EB);
  }
  /**
   * Computes the bounding sphere of the instanced mesh, and updates {@link InstancedMesh#boundingSphere}
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
   */
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new rf()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let a = 0; a < t; a++)
      this.getMatrixAt(a, n1), vA.copy(e.boundingSphere).applyMatrix4(n1), this.boundingSphere.union(vA);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  /**
   * Gets the color of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Color} color - The target object that is used to store the method's result.
   */
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  /**
   * Gets the local transformation matrix of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Matrix4} matrix - The target object that is used to store the method's result.
   */
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  /**
   * Gets the morph target weights of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Mesh} object - The target object that is used to store the method's result.
   */
  getMorphAt(e, t) {
    const a = t.morphTargetInfluences, r = this.morphTexture.source.data.data, d = a.length + 1, p = e * d + 1;
    for (let y = 0; y < a.length; y++)
      a[y] = r[p + y];
  }
  raycast(e, t) {
    const a = this.matrixWorld, r = this.count;
    if (mA.geometry = this.geometry, mA.material = this.material, mA.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), vA.copy(this.boundingSphere), vA.applyMatrix4(a), e.ray.intersectsSphere(vA) !== !1))
      for (let d = 0; d < r; d++) {
        this.getMatrixAt(d, n1), AB.multiplyMatrices(a, n1), mA.matrixWorld = AB, mA.raycast(e, yb);
        for (let p = 0, y = yb.length; p < y; p++) {
          const _ = yb[p];
          _.instanceId = d, _.object = this, t.push(_);
        }
        yb.length = 0;
      }
  }
  /**
   * Sets the given color to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#instanceColor} to `true` after updating all the colors.
   *
   * @param {number} index - The instance index.
   * @param {Color} color - The instance color.
   */
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new $S(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  /**
   * Sets the given local transformation matrix to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#instanceMatrix} to `true` after updating all the colors.
   *
   * @param {number} index - The instance index.
   * @param {Matrix4} matrix - The local transformation.
   */
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  /**
   * Sets the morph target weights to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#morphTexture} to `true` after updating all the influences.
   *
   * @param {number} index - The instance index.
   * @param {Mesh} object -  A mesh which `morphTargetInfluences` property containing the morph target weights
   * of a single instance.
   */
  setMorphAt(e, t) {
    const a = t.morphTargetInfluences, r = a.length + 1;
    this.morphTexture === null && (this.morphTexture = new Jv(new Float32Array(r * this.count), r, this.count, lE, pr));
    const d = this.morphTexture.source.data.data;
    let p = 0;
    for (let E = 0; E < a.length; E++)
      p += a[E];
    const y = this.geometry.morphTargetsRelative ? 1 : 1 - p, _ = r * e;
    d[_] = y, d.set(a, _ + 1);
  }
  updateMorphTargets() {
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null);
  }
}
const KT = /* @__PURE__ */ new ve(), cH = /* @__PURE__ */ new ve(), fH = /* @__PURE__ */ new ja();
class Pg {
  /**
   * Constructs a new plane.
   *
   * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
   * @param {number} [constant=0] - The signed distance from the origin to the plane.
   */
  constructor(e = new ve(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  /**
   * Sets the plane components by copying the given values.
   *
   * @param {Vector3} normal - The normal.
   * @param {number} constant - The constant.
   * @return {Plane} A reference to this plane.
   */
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  /**
   * Sets the plane components by defining `x`, `y`, `z` as the
   * plane normal and `w` as the constant.
   *
   * @param {number} x - The value for the normal's x component.
   * @param {number} y - The value for the normal's y component.
   * @param {number} z - The value for the normal's z component.
   * @param {number} w - The constant value.
   * @return {Plane} A reference to this plane.
   */
  setComponents(e, t, a, r) {
    return this.normal.set(e, t, a), this.constant = r, this;
  }
  /**
   * Sets the plane from the given normal and coplanar point (that is a point
   * that lies onto the plane).
   *
   * @param {Vector3} normal - The normal.
   * @param {Vector3} point - A coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  /**
   * Sets the plane from three coplanar points. The winding order is
   * assumed to be counter-clockwise, and determines the direction of
   * the plane normal.
   *
   * @param {Vector3} a - The first coplanar point.
   * @param {Vector3} b - The second coplanar point.
   * @param {Vector3} c - The third coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromCoplanarPoints(e, t, a) {
    const r = KT.subVectors(a, t).cross(cH.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  /**
   * Copies the values of the given plane to this instance.
   *
   * @param {Plane} plane - The plane to copy.
   * @return {Plane} A reference to this plane.
   */
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  /**
   * Normalizes the plane normal and adjusts the constant accordingly.
   *
   * @return {Plane} A reference to this plane.
   */
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  /**
   * Negates both the plane normal and the constant.
   *
   * @return {Plane} A reference to this plane.
   */
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  /**
   * Returns the signed distance from the given point to this plane.
   *
   * @param {Vector3} point - The point to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  /**
   * Returns the signed distance from the given sphere to this plane.
   *
   * @param {Sphere} sphere - The sphere to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  /**
   * Projects a the given point onto the plane.
   *
   * @param {Vector3} point - The point to project.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The projected point on the plane.
   */
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  /**
   * Returns the intersection point of the passed line and the plane. Returns
   * `null` if the line does not intersect. Returns the line's starting point if
   * the line is coplanar with the plane.
   *
   * @param {Line3} line - The line to compute the intersection for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectLine(e, t) {
    const a = e.delta(KT), r = this.normal.dot(a);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const d = -(e.start.dot(this.normal) + this.constant) / r;
    return d < 0 || d > 1 ? null : t.copy(e.start).addScaledVector(a, d);
  }
  /**
   * Returns `true` if the given line segment intersects with (passes through) the plane.
   *
   * @param {Line3} line - The line to test.
   * @return {boolean} Whether the given line segment intersects with the plane or not.
   */
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), a = this.distanceToPoint(e.end);
    return t < 0 && a > 0 || a < 0 && t > 0;
  }
  /**
   * Returns `true` if the given bounding box intersects with the plane.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with the plane or not.
   */
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns `true` if the given bounding sphere intersects with the plane.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
   */
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns a coplanar vector to the plane, by calculating the
   * projection of the normal at the origin onto the plane.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The coplanar point.
   */
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  /**
   * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
   *
   * The optional normal matrix can be pre-computed like so:
   * ```js
   * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
   * ```
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
   * @return {Plane} A reference to this plane.
   */
  applyMatrix4(e, t) {
    const a = t || fH.getNormalMatrix(e), r = this.coplanarPoint(KT).applyMatrix4(e), d = this.normal.applyMatrix3(a).normalize();
    return this.constant = -r.dot(d), this;
  }
  /**
   * Translates the plane by the distance defined by the given offset vector.
   * Note that this only affects the plane constant and will not affect the normal vector.
   *
   * @param {Vector3} offset - The offset vector.
   * @return {Plane} A reference to this plane.
   */
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  /**
   * Returns `true` if this plane is equal with the given one.
   *
   * @param {Plane} plane - The plane to test for equality.
   * @return {boolean} Whether this plane is equal with the given one.
   */
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  /**
   * Returns a new plane with copied values from this instance.
   *
   * @return {Plane} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const MS = /* @__PURE__ */ new rf(), Sb = /* @__PURE__ */ new ve();
class dE {
  /**
   * Constructs a new frustum.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   */
  constructor(e = new Pg(), t = new Pg(), a = new Pg(), r = new Pg(), d = new Pg(), p = new Pg()) {
    this.planes = [e, t, a, r, d, p];
  }
  /**
   * Sets the frustum planes by copying the given planes.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   * @return {Frustum} A reference to this frustum.
   */
  set(e, t, a, r, d, p) {
    const y = this.planes;
    return y[0].copy(e), y[1].copy(t), y[2].copy(a), y[3].copy(r), y[4].copy(d), y[5].copy(p), this;
  }
  /**
   * Copies the values of the given frustum to this instance.
   *
   * @param {Frustum} frustum - The frustum to copy.
   * @return {Frustum} A reference to this frustum.
   */
  copy(e) {
    const t = this.planes;
    for (let a = 0; a < 6; a++)
      t[a].copy(e.planes[a]);
    return this;
  }
  /**
   * Sets the frustum planes from the given projection matrix.
   *
   * @param {Matrix4} m - The projection matrix.
   * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
   * @return {Frustum} A reference to this frustum.
   */
  setFromProjectionMatrix(e, t = Qv) {
    const a = this.planes, r = e.elements, d = r[0], p = r[1], y = r[2], _ = r[3], E = r[4], T = r[5], C = r[6], D = r[7], B = r[8], z = r[9], V = r[10], G = r[11], N = r[12], F = r[13], q = r[14], Y = r[15];
    if (a[0].setComponents(_ - d, D - E, G - B, Y - N).normalize(), a[1].setComponents(_ + d, D + E, G + B, Y + N).normalize(), a[2].setComponents(_ + p, D + T, G + z, Y + F).normalize(), a[3].setComponents(_ - p, D - T, G - z, Y - F).normalize(), a[4].setComponents(_ - y, D - C, G - V, Y - q).normalize(), t === Qv)
      a[5].setComponents(_ + y, D + C, G + V, Y + q).normalize();
    else if (t === jA)
      a[5].setComponents(y, C, V, q).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
   *
   * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
   */
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), MS.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), MS.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(MS);
  }
  /**
   * Returns `true` if the given sprite is intersecting this frustum.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @return {boolean} Whether the sprite is intersecting this frustum or not.
   */
  intersectsSprite(e) {
    return MS.center.set(0, 0, 0), MS.radius = 0.7071067811865476, MS.applyMatrix4(e.matrixWorld), this.intersectsSphere(MS);
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting this frustum.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
   */
  intersectsSphere(e) {
    const t = this.planes, a = e.center, r = -e.radius;
    for (let d = 0; d < 6; d++)
      if (t[d].distanceToPoint(a) < r)
        return !1;
    return !0;
  }
  /**
   * Returns `true` if the given bounding box is intersecting this frustum.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box is intersecting this frustum or not.
   */
  intersectsBox(e) {
    const t = this.planes;
    for (let a = 0; a < 6; a++) {
      const r = t[a];
      if (Sb.x = r.normal.x > 0 ? e.max.x : e.min.x, Sb.y = r.normal.y > 0 ? e.max.y : e.min.y, Sb.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Sb) < 0)
        return !1;
    }
    return !0;
  }
  /**
   * Returns `true` if the given point lies within the frustum.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the point lies within this frustum or not.
   */
  containsPoint(e) {
    const t = this.planes;
    for (let a = 0; a < 6; a++)
      if (t[a].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  /**
   * Returns a new frustum with copied values from this instance.
   *
   * @return {Frustum} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
function kT(o, e) {
  return o - e;
}
function dH(o, e) {
  return o.z - e.z;
}
function hH(o, e) {
  return e.z - o.z;
}
class pH {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t, a, r) {
    const d = this.pool, p = this.list;
    this.index >= d.length && d.push({
      start: -1,
      count: -1,
      z: -1,
      index: -1
    });
    const y = d[this.index];
    p.push(y), this.index++, y.start = e, y.count = t, y.z = a, y.index = r;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const Fh = /* @__PURE__ */ new ia(), mH = /* @__PURE__ */ new hn(1, 1, 1), WT = /* @__PURE__ */ new dE(), _b = /* @__PURE__ */ new td(), xS = /* @__PURE__ */ new rf(), gA = /* @__PURE__ */ new ve(), bB = /* @__PURE__ */ new ve(), vH = /* @__PURE__ */ new ve(), $T = /* @__PURE__ */ new pH(), Wf = /* @__PURE__ */ new es(), Ab = [];
function gH(o, e, t = 0) {
  const a = e.itemSize;
  if (o.isInterleavedBufferAttribute || o.array.constructor !== e.array.constructor) {
    const r = o.count;
    for (let d = 0; d < r; d++)
      for (let p = 0; p < a; p++)
        e.setComponent(d + t, p, o.getComponent(d, p));
  } else
    e.array.set(o.array, t * a);
  e.needsUpdate = !0;
}
function TS(o, e) {
  if (o.constructor !== e.constructor) {
    const t = Math.min(o.length, e.length);
    for (let a = 0; a < t; a++)
      e[a] = o[a];
  } else {
    const t = Math.min(o.length, e.length);
    e.set(new o.constructor(o.buffer, 0, t));
  }
}
class EO extends es {
  /**
   * Constructs a new batched mesh.
   *
   * @param {number} maxInstanceCount - The maximum number of individual instances planned to be added and rendered.
   * @param {number} maxVertexCount - The maximum number of vertices to be used by all unique geometries.
   * @param {number} [maxIndexCount=maxVertexCount*2] - The maximum number of indices to be used by all unique geometries
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(e, t, a = t * 2, r) {
    super(new Pa(), r), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = !0, this._geometryInitialized = !1, this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = a, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture();
  }
  /**
   * The maximum number of individual instances that can be stored in the batch.
   *
   * @type {number}
   * @readonly
   */
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  /**
   * The instance count.
   *
   * @type {number}
   * @readonly
   */
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  /**
   * The number of unused vertices.
   *
   * @type {number}
   * @readonly
   */
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  /**
   * The number of unused indices.
   *
   * @type {number}
   * @readonly
   */
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), a = new Jv(t, e, e, xo, pr);
    this._matricesTexture = a;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e), a = new Jv(t, e, e, sE, jg);
    this._indirectTexture = a;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1), a = new Jv(t, e, e, xo, pr);
    a.colorSpace = wi.workingColorSpace, this._colorsTexture = a;
  }
  _initializeGeometry(e) {
    const t = this.geometry, a = this._maxVertexCount, r = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const d in e.attributes) {
        const p = e.getAttribute(d), { array: y, itemSize: _, normalized: E } = p, T = new y.constructor(a * _), C = new Hi(T, _, E);
        t.setAttribute(d, C);
      }
      if (e.getIndex() !== null) {
        const d = a > 65535 ? new Uint32Array(r) : new Uint16Array(r);
        t.setIndex(new Hi(d, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry attributes
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
    for (const a in t.attributes) {
      if (!e.hasAttribute(a))
        throw new Error(`THREE.BatchedMesh: Added geometry missing "${a}". All geometries must have consistent attributes.`);
      const r = e.getAttribute(a), d = t.getAttribute(a);
      if (r.itemSize !== d.itemSize || r.normalized !== d.normalized)
        throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  /**
   * Validates the instance defined by the given ID.
   *
   * @param {number} instanceId - The instance to validate.
   */
  validateInstanceId(e) {
    const t = this._instanceInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`);
  }
  /**
   * Validates the geometry defined by the given ID.
   *
   * @param {number} geometryId - The geometry to validate.
   */
  validateGeometryId(e) {
    const t = this._geometryInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`);
  }
  /**
   * Takes a sort a function that is run before render. The function takes a list of instances to
   * sort and a camera. The objects in the list include a "z" field to perform a depth-ordered sort with.
   *
   * @param {Function} func - The custom sort function.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  /**
   * Computes the bounding box, updating {@link BatchedMesh#boundingBox}.
   * Bounding boxes aren't computed by default. They need to be explicitly computed,
   * otherwise they are `null`.
   */
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new td());
    const e = this.boundingBox, t = this._instanceInfo;
    e.makeEmpty();
    for (let a = 0, r = t.length; a < r; a++) {
      if (t[a].active === !1) continue;
      const d = t[a].geometryIndex;
      this.getMatrixAt(a, Fh), this.getBoundingBoxAt(d, _b).applyMatrix4(Fh), e.union(_b);
    }
  }
  /**
   * Computes the bounding sphere, updating {@link BatchedMesh#boundingSphere}.
   * Bounding spheres aren't computed by default. They need to be explicitly computed,
   * otherwise they are `null`.
   */
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new rf());
    const e = this.boundingSphere, t = this._instanceInfo;
    e.makeEmpty();
    for (let a = 0, r = t.length; a < r; a++) {
      if (t[a].active === !1) continue;
      const d = t[a].geometryIndex;
      this.getMatrixAt(a, Fh), this.getBoundingSphereAt(d, xS).applyMatrix4(Fh), e.union(xS);
    }
  }
  /**
   * Adds a new instance to the batch using the geometry of the given ID and returns
   * a new id referring to the new instance to be used by other functions.
   *
   * @param {number} geometryId - The ID of a previously added geometry via {@link BatchedMesh#addGeometry}.
   * @return {number} The instance ID.
   */
  addInstance(e) {
    if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0)
      throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    const a = {
      visible: !0,
      active: !0,
      geometryIndex: e
    };
    let r = null;
    this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(kT), r = this._availableInstanceIds.shift(), this._instanceInfo[r] = a) : (r = this._instanceInfo.length, this._instanceInfo.push(a));
    const d = this._matricesTexture;
    Fh.identity().toArray(d.image.data, r * 16), d.needsUpdate = !0;
    const p = this._colorsTexture;
    return p && (mH.toArray(p.image.data, r * 4), p.needsUpdate = !0), this._visibilityChanged = !0, r;
  }
  /**
   * Adds the given geometry to the batch and returns the associated
   * geometry id referring to it to be used in other functions.
   *
   * @param {BufferGeometry} geometry - The geometry to add.
   * @param {number} [reservedVertexCount=-1] - Optional parameter specifying the amount of
   * vertex buffer space to reserve for the added geometry. This is necessary if it is planned
   * to set a new geometry at this index at a later time that is larger than the original geometry.
   * Defaults to the length of the given geometry vertex buffer.
   * @param {number} [reservedIndexCount=-1] - Optional parameter specifying the amount of index
   * buffer space to reserve for the added geometry. This is necessary if it is planned to set a
   * new geometry at this index at a later time that is larger than the original geometry. Defaults to
   * the length of the given geometry index buffer.
   * @return {number} The geometry ID.
   */
  addGeometry(e, t = -1, a = -1) {
    this._initializeGeometry(e), this._validateGeometry(e);
    const r = {
      // geometry information
      vertexStart: -1,
      vertexCount: -1,
      reservedVertexCount: -1,
      indexStart: -1,
      indexCount: -1,
      reservedIndexCount: -1,
      // draw range information
      start: -1,
      count: -1,
      // state
      boundingBox: null,
      boundingSphere: null,
      active: !0
    }, d = this._geometryInfo;
    r.vertexStart = this._nextVertexStart, r.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t;
    const p = e.getIndex();
    if (p !== null && (r.indexStart = this._nextIndexStart, r.reservedIndexCount = a === -1 ? p.count : a), r.indexStart !== -1 && r.indexStart + r.reservedIndexCount > this._maxIndexCount || r.vertexStart + r.reservedVertexCount > this._maxVertexCount)
      throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    let _;
    return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(kT), _ = this._availableGeometryIds.shift(), d[_] = r) : (_ = this._geometryCount, this._geometryCount++, d.push(r)), this.setGeometryAt(_, e), this._nextIndexStart = r.indexStart + r.reservedIndexCount, this._nextVertexStart = r.vertexStart + r.reservedVertexCount, _;
  }
  /**
   * Replaces the geometry at the given ID with the provided geometry. Throws an error if there
   * is not enough space reserved for geometry. Calling this will change all instances that are
   * rendering that geometry.
   *
   * @param {number} geometryId - The ID of the geometry that should be replaced with the given geometry.
   * @param {BufferGeometry} geometry - The new geometry.
   * @return {number} The geometry ID.
   */
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const a = this.geometry, r = a.getIndex() !== null, d = a.getIndex(), p = t.getIndex(), y = this._geometryInfo[e];
    if (r && p.count > y.reservedIndexCount || t.attributes.position.count > y.reservedVertexCount)
      throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
    const _ = y.vertexStart, E = y.reservedVertexCount;
    y.vertexCount = t.getAttribute("position").count;
    for (const T in a.attributes) {
      const C = t.getAttribute(T), D = a.getAttribute(T);
      gH(C, D, _);
      const B = C.itemSize;
      for (let z = C.count, V = E; z < V; z++) {
        const G = _ + z;
        for (let N = 0; N < B; N++)
          D.setComponent(G, N, 0);
      }
      D.needsUpdate = !0, D.addUpdateRange(_ * B, E * B);
    }
    if (r) {
      const T = y.indexStart, C = y.reservedIndexCount;
      y.indexCount = t.getIndex().count;
      for (let D = 0; D < p.count; D++)
        d.setX(T + D, _ + p.getX(D));
      for (let D = p.count, B = C; D < B; D++)
        d.setX(T + D, _);
      d.needsUpdate = !0, d.addUpdateRange(T, y.reservedIndexCount);
    }
    return y.start = r ? y.indexStart : y.vertexStart, y.count = r ? y.indexCount : y.vertexCount, y.boundingBox = null, t.boundingBox !== null && (y.boundingBox = t.boundingBox.clone()), y.boundingSphere = null, t.boundingSphere !== null && (y.boundingSphere = t.boundingSphere.clone()), this._visibilityChanged = !0, e;
  }
  /**
   * Deletes the geometry defined by the given ID from this batch. Any instances referencing
   * this geometry will also be removed as a side effect.
   *
   * @param {number} geometryId - The ID of the geometry to remove from the batch.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  deleteGeometry(e) {
    const t = this._geometryInfo;
    if (e >= t.length || t[e].active === !1)
      return this;
    const a = this._instanceInfo;
    for (let r = 0, d = a.length; r < d; r++)
      a[r].active && a[r].geometryIndex === e && this.deleteInstance(r);
    return t[e].active = !1, this._availableGeometryIds.push(e), this._visibilityChanged = !0, this;
  }
  /**
   * Deletes an existing instance from the batch using the given ID.
   *
   * @param {number} instanceId - The ID of the instance to remove from the batch.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  deleteInstance(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0, this;
  }
  /**
   * Repacks the sub geometries in [name] to remove any unused space remaining from
   * previously deleted geometry, freeing up space to add new geometry.
   *
   * @param {number} instanceId - The ID of the instance to remove from the batch.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  optimize() {
    let e = 0, t = 0;
    const a = this._geometryInfo, r = a.map((p, y) => y).sort((p, y) => a[p].vertexStart - a[y].vertexStart), d = this.geometry;
    for (let p = 0, y = a.length; p < y; p++) {
      const _ = r[p], E = a[_];
      if (E.active !== !1) {
        if (d.index !== null) {
          if (E.indexStart !== t) {
            const { indexStart: T, vertexStart: C, reservedIndexCount: D } = E, B = d.index, z = B.array, V = e - C;
            for (let G = T; G < T + D; G++)
              z[G] = z[G] + V;
            B.array.copyWithin(t, T, T + D), B.addUpdateRange(t, D), E.indexStart = t;
          }
          t += E.reservedIndexCount;
        }
        if (E.vertexStart !== e) {
          const { vertexStart: T, reservedVertexCount: C } = E, D = d.attributes;
          for (const B in D) {
            const z = D[B], { array: V, itemSize: G } = z;
            V.copyWithin(e * G, T * G, (T + C) * G), z.addUpdateRange(e * G, C * G);
          }
          E.vertexStart = e;
        }
        e += E.reservedVertexCount, E.start = d.index ? E.indexStart : E.vertexStart, this._nextIndexStart = d.index ? E.indexStart + E.reservedIndexCount : 0, this._nextVertexStart = E.vertexStart + E.reservedVertexCount;
      }
    }
    return this;
  }
  /**
   * Returns the bounding box for the given geometry.
   *
   * @param {number} geometryId - The ID of the geometry to return the bounding box for.
   * @param {Box3} target - The target object that is used to store the method's result.
   * @return {Box3|null} The geometry's bounding box. Returns `null` if no geometry has been found for the given ID.
   */
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const a = this.geometry, r = this._geometryInfo[e];
    if (r.boundingBox === null) {
      const d = new td(), p = a.index, y = a.attributes.position;
      for (let _ = r.start, E = r.start + r.count; _ < E; _++) {
        let T = _;
        p && (T = p.getX(T)), d.expandByPoint(gA.fromBufferAttribute(y, T));
      }
      r.boundingBox = d;
    }
    return t.copy(r.boundingBox), t;
  }
  /**
   * Returns the bounding sphere for the given geometry.
   *
   * @param {number} geometryId - The ID of the geometry to return the bounding sphere for.
   * @param {Sphere} target - The target object that is used to store the method's result.
   * @return {Sphere|null} The geometry's bounding sphere. Returns `null` if no geometry has been found for the given ID.
   */
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const a = this.geometry, r = this._geometryInfo[e];
    if (r.boundingSphere === null) {
      const d = new rf();
      this.getBoundingBoxAt(e, _b), _b.getCenter(d.center);
      const p = a.index, y = a.attributes.position;
      let _ = 0;
      for (let E = r.start, T = r.start + r.count; E < T; E++) {
        let C = E;
        p && (C = p.getX(C)), gA.fromBufferAttribute(y, C), _ = Math.max(_, d.center.distanceToSquared(gA));
      }
      d.radius = Math.sqrt(_), r.boundingSphere = d;
    }
    return t.copy(r.boundingSphere), t;
  }
  /**
   * Sets the given local transformation matrix to the defined instance.
   * Negatively scaled matrices are not supported.
   *
   * @param {number} instanceId - The ID of an instance to set the matrix of.
   * @param {Matrix4} matrix - A 4x4 matrix representing the local transformation of a single instance.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setMatrixAt(e, t) {
    this.validateInstanceId(e);
    const a = this._matricesTexture, r = this._matricesTexture.image.data;
    return t.toArray(r, e * 16), a.needsUpdate = !0, this;
  }
  /**
   * Returns the local transformation matrix of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the matrix of.
   * @param {Matrix4} matrix - The target object that is used to store the method's result.
   * @return {Matrix4} The instance's local transformation matrix.
   */
  getMatrixAt(e, t) {
    return this.validateInstanceId(e), t.fromArray(this._matricesTexture.image.data, e * 16);
  }
  /**
   * Sets the given color to the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to set the color of.
   * @param {Color} color - The color to set the instance to.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setColorAt(e, t) {
    return this.validateInstanceId(e), this._colorsTexture === null && this._initColorsTexture(), t.toArray(this._colorsTexture.image.data, e * 4), this._colorsTexture.needsUpdate = !0, this;
  }
  /**
   * Returns the color of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the color of.
   * @param {Color} color - The target object that is used to store the method's result.
   * @return {Color} The instance's color.
   */
  getColorAt(e, t) {
    return this.validateInstanceId(e), t.fromArray(this._colorsTexture.image.data, e * 4);
  }
  /**
   * Sets the visibility of the instance.
   *
   * @param {number} instanceId - The id of the instance to set the visibility of.
   * @param {boolean} visible - Whether the instance is visible or not.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setVisibleAt(e, t) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible === t ? this : (this._instanceInfo[e].visible = t, this._visibilityChanged = !0, this);
  }
  /**
   * Returns the visibility state of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the visibility state of.
   * @return {boolean} Whether the instance is visible or not.
   */
  getVisibleAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible;
  }
  /**
   * Sets the geometry ID of the instance at the given index.
   *
   * @param {number} instanceId - The ID of the instance to set the geometry ID of.
   * @param {number} geometryId - The geometry ID to be use by the instance.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setGeometryIdAt(e, t) {
    return this.validateInstanceId(e), this.validateGeometryId(t), this._instanceInfo[e].geometryIndex = t, this;
  }
  /**
   * Returns the geometry ID of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the geometry ID of.
   * @return {number} The instance's geometry ID.
   */
  getGeometryIdAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex;
  }
  /**
   * Get the range representing the subset of triangles related to the attached geometry,
   * indicating the starting offset and count, or `null` if invalid.
   *
   * @param {number} geometryId - The id of the geometry to get the range of.
   * @param {Object} [target] - The target object that is used to store the method's result.
   * @return {{
   * 	vertexStart:number,vertexCount:number,reservedVertexCount:number,
   * 	indexStart:number,indexCount:number,reservedIndexCount:number,
   * 	start:number,count:number
   * }} The result object with range data.
   */
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e);
    const a = this._geometryInfo[e];
    return t.vertexStart = a.vertexStart, t.vertexCount = a.vertexCount, t.reservedVertexCount = a.reservedVertexCount, t.indexStart = a.indexStart, t.indexCount = a.indexCount, t.reservedIndexCount = a.reservedIndexCount, t.start = a.start, t.count = a.count, t;
  }
  /**
   * Resizes the necessary buffers to support the provided number of instances.
   * If the provided arguments shrink the number of instances but there are not enough
   * unused Ids at the end of the list then an error is thrown.
   *
   * @param {number} maxInstanceCount - The max number of individual instances that can be added and rendered by the batch.
  */
  setInstanceCount(e) {
    const t = this._availableInstanceIds, a = this._instanceInfo;
    for (t.sort(kT); t[t.length - 1] === a.length; )
      a.pop(), t.pop();
    if (e < a.length)
      throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
    const r = new Int32Array(e), d = new Int32Array(e);
    TS(this._multiDrawCounts, r), TS(this._multiDrawStarts, d), this._multiDrawCounts = r, this._multiDrawStarts = d, this._maxInstanceCount = e;
    const p = this._indirectTexture, y = this._matricesTexture, _ = this._colorsTexture;
    p.dispose(), this._initIndirectTexture(), TS(p.image.data, this._indirectTexture.image.data), y.dispose(), this._initMatricesTexture(), TS(y.image.data, this._matricesTexture.image.data), _ && (_.dispose(), this._initColorsTexture(), TS(_.image.data, this._colorsTexture.image.data));
  }
  /**
   * Resizes the available space in the batch's vertex and index buffer attributes to the provided sizes.
   * If the provided arguments shrink the geometry buffers but there is not enough unused space at the
   * end of the geometry attributes then an error is thrown.
   *
   * @param {number} maxVertexCount - The maximum number of vertices to be used by all unique geometries to resize to.
   * @param {number} maxIndexCount - The maximum number of indices to be used by all unique geometries to resize to.
  */
  setGeometrySize(e, t) {
    const a = [...this._geometryInfo].filter((y) => y.active);
    if (Math.max(...a.map((y) => y.vertexStart + y.reservedVertexCount)) > e)
      throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
    if (this.geometry.index && Math.max(...a.map((_) => _.indexStart + _.reservedIndexCount)) > t)
      throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);
    const d = this.geometry;
    d.dispose(), this._maxVertexCount = e, this._maxIndexCount = t, this._geometryInitialized && (this._geometryInitialized = !1, this.geometry = new Pa(), this._initializeGeometry(d));
    const p = this.geometry;
    d.index && TS(d.index.array, p.index.array);
    for (const y in d.attributes)
      TS(d.attributes[y].array, p.attributes[y].array);
  }
  raycast(e, t) {
    const a = this._instanceInfo, r = this._geometryInfo, d = this.matrixWorld, p = this.geometry;
    Wf.material = this.material, Wf.geometry.index = p.index, Wf.geometry.attributes = p.attributes, Wf.geometry.boundingBox === null && (Wf.geometry.boundingBox = new td()), Wf.geometry.boundingSphere === null && (Wf.geometry.boundingSphere = new rf());
    for (let y = 0, _ = a.length; y < _; y++) {
      if (!a[y].visible || !a[y].active)
        continue;
      const E = a[y].geometryIndex, T = r[E];
      Wf.geometry.setDrawRange(T.start, T.count), this.getMatrixAt(y, Wf.matrixWorld).premultiply(d), this.getBoundingBoxAt(E, Wf.geometry.boundingBox), this.getBoundingSphereAt(E, Wf.geometry.boundingSphere), Wf.raycast(e, Ab);
      for (let C = 0, D = Ab.length; C < D; C++) {
        const B = Ab[C];
        B.object = this, B.batchId = y, t.push(B);
      }
      Ab.length = 0;
    }
    Wf.material = null, Wf.geometry.index = null, Wf.geometry.attributes = {}, Wf.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._geometryInfo = e._geometryInfo.map((t) => ({
      ...t,
      boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
      boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null
    })), this._instanceInfo = e._instanceInfo.map((t) => ({ ...t })), this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null);
  }
  onBeforeRender(e, t, a, r, d) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const p = r.getIndex(), y = p === null ? 1 : p.array.BYTES_PER_ELEMENT, _ = this._instanceInfo, E = this._multiDrawStarts, T = this._multiDrawCounts, C = this._geometryInfo, D = this.perObjectFrustumCulled, B = this._indirectTexture, z = B.image.data;
    D && (Fh.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse).multiply(this.matrixWorld), WT.setFromProjectionMatrix(
      Fh,
      e.coordinateSystem
    ));
    let V = 0;
    if (this.sortObjects) {
      Fh.copy(this.matrixWorld).invert(), gA.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Fh), bB.set(0, 0, -1).transformDirection(a.matrixWorld).transformDirection(Fh);
      for (let F = 0, q = _.length; F < q; F++)
        if (_[F].visible && _[F].active) {
          const Y = _[F].geometryIndex;
          this.getMatrixAt(F, Fh), this.getBoundingSphereAt(Y, xS).applyMatrix4(Fh);
          let ie = !1;
          if (D && (ie = !WT.intersectsSphere(xS)), !ie) {
            const k = C[Y], le = vH.subVectors(xS.center, gA).dot(bB);
            $T.push(k.start, k.count, le, F);
          }
        }
      const G = $T.list, N = this.customSort;
      N === null ? G.sort(d.transparent ? hH : dH) : N.call(this, G, a);
      for (let F = 0, q = G.length; F < q; F++) {
        const Y = G[F];
        E[V] = Y.start * y, T[V] = Y.count, z[V] = Y.index, V++;
      }
      $T.reset();
    } else
      for (let G = 0, N = _.length; G < N; G++)
        if (_[G].visible && _[G].active) {
          const F = _[G].geometryIndex;
          let q = !1;
          if (D && (this.getMatrixAt(G, Fh), this.getBoundingSphereAt(F, xS).applyMatrix4(Fh), q = !WT.intersectsSphere(xS)), !q) {
            const Y = C[F];
            E[V] = Y.start * y, T[V] = Y.count, z[V] = G, V++;
          }
        }
    B.needsUpdate = !0, this._multiDrawCount = V, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, a, r, d, p) {
    this.onBeforeRender(e, null, r, d, p);
  }
}
class nd extends Vu {
  /**
   * Constructs a new line basic material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new hn(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const QM = /* @__PURE__ */ new ve(), jM = /* @__PURE__ */ new ve(), MB = /* @__PURE__ */ new ia(), yA = /* @__PURE__ */ new l_(), Eb = /* @__PURE__ */ new rf(), eC = /* @__PURE__ */ new ve(), xB = /* @__PURE__ */ new ve();
class Qy extends zi {
  /**
   * Constructs a new line.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(e = new Pa(), t = new nd()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  /**
   * Computes an array of distance values which are necessary for rendering dashed lines.
   * For each vertex in the geometry, the method calculates the cumulative length from the
   * current point to the very beginning of the line.
   *
   * @return {Line} A reference to this line.
   */
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, a = [0];
      for (let r = 1, d = t.count; r < d; r++)
        QM.fromBufferAttribute(t, r - 1), jM.fromBufferAttribute(t, r), a[r] = a[r - 1], a[r] += QM.distanceTo(jM);
      e.setAttribute("lineDistance", new qn(a, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    const a = this.geometry, r = this.matrixWorld, d = e.params.Line.threshold, p = a.drawRange;
    if (a.boundingSphere === null && a.computeBoundingSphere(), Eb.copy(a.boundingSphere), Eb.applyMatrix4(r), Eb.radius += d, e.ray.intersectsSphere(Eb) === !1) return;
    MB.copy(r).invert(), yA.copy(e.ray).applyMatrix4(MB);
    const y = d / ((this.scale.x + this.scale.y + this.scale.z) / 3), _ = y * y, E = this.isLineSegments ? 2 : 1, T = a.index, D = a.attributes.position;
    if (T !== null) {
      const B = Math.max(0, p.start), z = Math.min(T.count, p.start + p.count);
      for (let V = B, G = z - 1; V < G; V += E) {
        const N = T.getX(V), F = T.getX(V + 1), q = bb(this, e, yA, _, N, F, V);
        q && t.push(q);
      }
      if (this.isLineLoop) {
        const V = T.getX(z - 1), G = T.getX(B), N = bb(this, e, yA, _, V, G, z - 1);
        N && t.push(N);
      }
    } else {
      const B = Math.max(0, p.start), z = Math.min(D.count, p.start + p.count);
      for (let V = B, G = z - 1; V < G; V += E) {
        const N = bb(this, e, yA, _, V, V + 1, V);
        N && t.push(N);
      }
      if (this.isLineLoop) {
        const V = bb(this, e, yA, _, z - 1, B, z - 1);
        V && t.push(V);
      }
    }
  }
  /**
   * Sets the values of {@link Line#morphTargetDictionary} and {@link Line#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, a = Object.keys(t);
    if (a.length > 0) {
      const r = t[a[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let d = 0, p = r.length; d < p; d++) {
          const y = r[d].name || String(d);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[y] = d;
        }
      }
    }
  }
}
function bb(o, e, t, a, r, d, p) {
  const y = o.geometry.attributes.position;
  if (QM.fromBufferAttribute(y, r), jM.fromBufferAttribute(y, d), t.distanceSqToSegment(QM, jM, eC, xB) > a) return;
  eC.applyMatrix4(o.matrixWorld);
  const E = e.ray.origin.distanceTo(eC);
  if (!(E < e.near || E > e.far))
    return {
      distance: E,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: xB.clone().applyMatrix4(o.matrixWorld),
      index: p,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: o
    };
}
const TB = /* @__PURE__ */ new ve(), CB = /* @__PURE__ */ new ve();
class kv extends Qy {
  /**
   * Constructs a new line segments.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, a = [];
      for (let r = 0, d = t.count; r < d; r += 2)
        TB.fromBufferAttribute(t, r), CB.fromBufferAttribute(t, r + 1), a[r] = r === 0 ? 0 : a[r - 1], a[r + 1] = a[r] + TB.distanceTo(CB);
      e.setAttribute("lineDistance", new qn(a, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class U2 extends Qy {
  /**
   * Constructs a new line loop.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class yx extends Vu {
  /**
   * Constructs a new points material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new hn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const RB = /* @__PURE__ */ new ia(), jC = /* @__PURE__ */ new l_(), Mb = /* @__PURE__ */ new rf(), xb = /* @__PURE__ */ new ve();
class O2 extends zi {
  /**
   * Constructs a new point cloud.
   *
   * @param {BufferGeometry} [geometry] - The points geometry.
   * @param {Material|Array<Material>} [material] - The points material.
   */
  constructor(e = new Pa(), t = new yx()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  /**
   * Computes intersection points between a casted ray and this point cloud.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    const a = this.geometry, r = this.matrixWorld, d = e.params.Points.threshold, p = a.drawRange;
    if (a.boundingSphere === null && a.computeBoundingSphere(), Mb.copy(a.boundingSphere), Mb.applyMatrix4(r), Mb.radius += d, e.ray.intersectsSphere(Mb) === !1) return;
    RB.copy(r).invert(), jC.copy(e.ray).applyMatrix4(RB);
    const y = d / ((this.scale.x + this.scale.y + this.scale.z) / 3), _ = y * y, E = a.index, C = a.attributes.position;
    if (E !== null) {
      const D = Math.max(0, p.start), B = Math.min(E.count, p.start + p.count);
      for (let z = D, V = B; z < V; z++) {
        const G = E.getX(z);
        xb.fromBufferAttribute(C, G), DB(xb, G, _, r, e, t, this);
      }
    } else {
      const D = Math.max(0, p.start), B = Math.min(C.count, p.start + p.count);
      for (let z = D, V = B; z < V; z++)
        xb.fromBufferAttribute(C, z), DB(xb, z, _, r, e, t, this);
    }
  }
  /**
   * Sets the values of {@link Points#morphTargetDictionary} and {@link Points#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, a = Object.keys(t);
    if (a.length > 0) {
      const r = t[a[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let d = 0, p = r.length; d < p; d++) {
          const y = r[d].name || String(d);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[y] = d;
        }
      }
    }
  }
}
function DB(o, e, t, a, r, d, p) {
  const y = jC.distanceSqToPoint(o);
  if (y < t) {
    const _ = new ve();
    jC.closestPointToPoint(o, _), _.applyMatrix4(a);
    const E = r.ray.origin.distanceTo(_);
    if (E < r.near || E > r.far) return;
    d.push({
      distance: E,
      distanceToRay: Math.sqrt(y),
      point: _,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: p
    });
  }
}
class bO extends Ml {
  /**
   * Constructs a new video texture.
   *
   * @param {Video} video - The video element to use as a data source for the texture.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, t, a, r, d = Ni, p = Ni, y, _, E) {
    super(e, t, a, r, d, p, y, _, E), this.isVideoTexture = !0, this.generateMipmaps = !1;
    const T = this;
    function C() {
      T.needsUpdate = !0, e.requestVideoFrameCallback(C);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(C);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  /**
   * This method is called automatically by the renderer and sets {@link Texture#needsUpdate}
   * to `true` every time a new frame is available.
   *
   * Only relevant if `requestVideoFrameCallback` is not supported in the browser.
   */
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class yH extends bO {
  /**
   * Constructs a new video frame texture.
   *
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, t, a, r, d, p, y, _) {
    super({}, e, t, a, r, d, p, y, _), this.isVideoFrameTexture = !0;
  }
  /**
   * This method overwritten with an empty implementation since
   * this type of texture is updated via `setFrame()`.
   */
  update() {
  }
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Sets the current frame of the video. This will automatically update the texture
   * so the data can be used for rendering.
   *
   * @param {VideoFrame} frame - The video frame.
   */
  setFrame(e) {
    this.image = e, this.needsUpdate = !0;
  }
}
class SH extends Ml {
  /**
   * Constructs a new framebuffer texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   */
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = _c, this.minFilter = _c, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class Sx extends Ml {
  /**
   * Constructs a new compressed texture.
   *
   * @param {Array<Object>} mipmaps - This array holds for all mipmaps (including the bases mip)
   * the data and dimensions.
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e, t, a, r, d, p, y, _, E, T, C, D) {
    super(null, p, y, _, E, T, r, d, C, D), this.isCompressedTexture = !0, this.image = { width: t, height: a }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class _H extends Sx {
  /**
   * Constructs a new compressed array texture.
   *
   * @param {Array<Object>} mipmaps - This array holds for all mipmaps (including the bases mip)
   * the data and dimensions.
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} depth - The depth of the texture.
   * @param {number} [format=RGBAFormat] - The min filter value.
   * @param {number} [type=UnsignedByteType] - The min filter value.
   */
  constructor(e, t, a, r, d, p) {
    super(e, t, a, d, p), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = Mo, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire compressed texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class AH extends Sx {
  /**
   * Constructs a new compressed texture.
   *
   * @param {Array<CompressedTexture>} images - An array of compressed textures.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   */
  constructor(e, t, a) {
    super(void 0, e[0].width, e[0].height, t, a, Qg), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class EH extends Ml {
  /**
   * Constructs a new texture.
   *
   * @param {HTMLCanvasElement} [canvas] - The HTML canvas element.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, t, a, r, d, p, y, _, E) {
    super(e, t, a, r, d, p, y, _, E), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class _x extends Ml {
  /**
   * Constructs a new depth texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [type=UnsignedIntType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {number} [format=DepthFormat] - The texture format.
   */
  constructor(e, t, a = jg, r, d, p, y = _c, _ = _c, E, T = WS) {
    if (T !== WS && T !== g1)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    super(null, r, d, p, y, _, T, a, E), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.source = new V0(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
class Wv {
  /**
   * Constructs a new curve.
   */
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null;
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definition)
   * for the given interpolation factor.
   *
   * @abstract
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definition)
   * for the given interpolation factor. Unlike {@link Curve#getPoint}, this method honors the length
   * of the curve which equidistant samples.
   *
   * @param {number} u - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPointAt(e, t) {
    const a = this.getUtoTmapping(e);
    return this.getPoint(a, t);
  }
  /**
   * This method samples the curve via {@link Curve#getPoint} and returns an array of points representing
   * the curve shape.
   *
   * @param {number} [divisions=5] - The number of divisions.
   * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
   */
  getPoints(e = 5) {
    const t = [];
    for (let a = 0; a <= e; a++)
      t.push(this.getPoint(a / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  /**
   * This method samples the curve via {@link Curve#getPointAt} and returns an array of points representing
   * the curve shape. Unlike {@link Curve#getPoints}, this method returns equi-spaced points across the entire
   * curve.
   *
   * @param {number} [divisions=5] - The number of divisions.
   * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
   */
  getSpacedPoints(e = 5) {
    const t = [];
    for (let a = 0; a <= e; a++)
      t.push(this.getPointAt(a / e));
    return t;
  }
  /**
   * Returns the total arc length of the curve.
   *
   * @return {number} The length of the curve.
   */
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  /**
   * Returns an array of cumulative segment lengths of the curve.
   *
   * @param {number} [divisions=this.arcLengthDivisions] - The number of divisions.
   * @return {Array<number>} An array holding the cumulative segment lengths.
   */
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let a, r = this.getPoint(0), d = 0;
    t.push(0);
    for (let p = 1; p <= e; p++)
      a = this.getPoint(p / e), d += a.distanceTo(r), t.push(d), r = a;
    return this.cacheArcLengths = t, t;
  }
  /**
   * Update the cumulative segment distance cache. The method must be called
   * every time curve parameters are changed. If an updated curve is part of a
   * composed curve like {@link CurvePath}, this method must be called on the
   * composed curve, too.
   */
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  /**
   * Given an interpolation factor in the range `[0,1]`, this method returns an updated
   * interpolation factor in the same range that can be ued to sample equidistant points
   * from a curve.
   *
   * @param {number} u - The interpolation factor.
   * @param {?number} distance - An optional distance on the curve.
   * @return {number} The updated interpolation factor.
   */
  getUtoTmapping(e, t = null) {
    const a = this.getLengths();
    let r = 0;
    const d = a.length;
    let p;
    t ? p = t : p = e * a[d - 1];
    let y = 0, _ = d - 1, E;
    for (; y <= _; )
      if (r = Math.floor(y + (_ - y) / 2), E = a[r] - p, E < 0)
        y = r + 1;
      else if (E > 0)
        _ = r - 1;
      else {
        _ = r;
        break;
      }
    if (r = _, a[r] === p)
      return r / (d - 1);
    const T = a[r], D = a[r + 1] - T, B = (p - T) / D;
    return (r + B) / (d - 1);
  }
  /**
   * Returns a unit vector tangent for the given interpolation factor.
   * If the derived curve does not implement its tangent derivation,
   * two points a small delta apart will be used to find its gradient
   * which seems to give a reasonable approximation.
   *
   * @param {number} t - The interpolation factor.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The tangent vector.
   */
  getTangent(e, t) {
    let r = e - 1e-4, d = e + 1e-4;
    r < 0 && (r = 0), d > 1 && (d = 1);
    const p = this.getPoint(r), y = this.getPoint(d), _ = t || (p.isVector2 ? new Ot() : new ve());
    return _.copy(y).sub(p).normalize(), _;
  }
  /**
   * Same as {@link Curve#getTangent} but with equidistant samples.
   *
   * @param {number} u - The interpolation factor.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The tangent vector.
   * @see {@link Curve#getPointAt}
   */
  getTangentAt(e, t) {
    const a = this.getUtoTmapping(e);
    return this.getTangent(a, t);
  }
  /**
   * Generates the Frenet Frames. Requires a curve definition in 3D space. Used
   * in geometries like {@link TubeGeometry} or {@link ExtrudeGeometry}.
   *
   * @param {number} segments - The number of segments.
   * @param {boolean} [closed=false] - Whether the curve is closed or not.
   * @return {{tangents: Array<Vector3>, normals: Array<Vector3>, binormals: Array<Vector3>}} The Frenet Frames.
   */
  computeFrenetFrames(e, t = !1) {
    const a = new ve(), r = [], d = [], p = [], y = new ve(), _ = new ia();
    for (let B = 0; B <= e; B++) {
      const z = B / e;
      r[B] = this.getTangentAt(z, new ve());
    }
    d[0] = new ve(), p[0] = new ve();
    let E = Number.MAX_VALUE;
    const T = Math.abs(r[0].x), C = Math.abs(r[0].y), D = Math.abs(r[0].z);
    T <= E && (E = T, a.set(1, 0, 0)), C <= E && (E = C, a.set(0, 1, 0)), D <= E && a.set(0, 0, 1), y.crossVectors(r[0], a).normalize(), d[0].crossVectors(r[0], y), p[0].crossVectors(r[0], d[0]);
    for (let B = 1; B <= e; B++) {
      if (d[B] = d[B - 1].clone(), p[B] = p[B - 1].clone(), y.crossVectors(r[B - 1], r[B]), y.length() > Number.EPSILON) {
        y.normalize();
        const z = Math.acos(Fa(r[B - 1].dot(r[B]), -1, 1));
        d[B].applyMatrix4(_.makeRotationAxis(y, z));
      }
      p[B].crossVectors(r[B], d[B]);
    }
    if (t === !0) {
      let B = Math.acos(Fa(d[0].dot(d[e]), -1, 1));
      B /= e, r[0].dot(y.crossVectors(d[0], d[e])) > 0 && (B = -B);
      for (let z = 1; z <= e; z++)
        d[z].applyMatrix4(_.makeRotationAxis(r[z], B * z)), p[z].crossVectors(r[z], d[z]);
    }
    return {
      tangents: r,
      normals: d,
      binormals: p
    };
  }
  /**
   * Returns a new curve with copied values from this instance.
   *
   * @return {Curve} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given curve to this instance.
   *
   * @param {Curve} source - The curve to copy.
   * @return {Curve} A reference to this curve.
   */
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  /**
   * Serializes the curve into JSON.
   *
   * @return {Object} A JSON object representing the serialized curve.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  /**
   * Deserializes the curve from the given JSON.
   *
   * @param {Object} json - The JSON holding the serialized curve.
   * @return {Curve} A reference to this curve.
   */
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Ax extends Wv {
  /**
   * Constructs a new ellipse curve.
   *
   * @param {number} [aX=0] - The X center of the ellipse.
   * @param {number} [aY=0] - The Y center of the ellipse.
   * @param {number} [xRadius=1] - The radius of the ellipse in the x direction.
   * @param {number} [yRadius=1] - The radius of the ellipse in the y direction.
   * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
   * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   */
  constructor(e = 0, t = 0, a = 1, r = 1, d = 0, p = Math.PI * 2, y = !1, _ = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = a, this.yRadius = r, this.aStartAngle = d, this.aEndAngle = p, this.aClockwise = y, this.aRotation = _;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Ot()) {
    const a = t, r = Math.PI * 2;
    let d = this.aEndAngle - this.aStartAngle;
    const p = Math.abs(d) < Number.EPSILON;
    for (; d < 0; ) d += r;
    for (; d > r; ) d -= r;
    d < Number.EPSILON && (p ? d = 0 : d = r), this.aClockwise === !0 && !p && (d === r ? d = -r : d = d - r);
    const y = this.aStartAngle + e * d;
    let _ = this.aX + this.xRadius * Math.cos(y), E = this.aY + this.yRadius * Math.sin(y);
    if (this.aRotation !== 0) {
      const T = Math.cos(this.aRotation), C = Math.sin(this.aRotation), D = _ - this.aX, B = E - this.aY;
      _ = D * T - B * C + this.aX, E = D * C + B * T + this.aY;
    }
    return a.set(_, E);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class MO extends Ax {
  /**
   * Constructs a new arc curve.
   *
   * @param {number} [aX=0] - The X center of the ellipse.
   * @param {number} [aY=0] - The Y center of the ellipse.
   * @param {number} [aRadius=1] - The radius of the ellipse in the x direction.
   * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
   * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
   */
  constructor(e, t, a, r, d, p) {
    super(e, t, a, a, r, d, p), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function w2() {
  let o = 0, e = 0, t = 0, a = 0;
  function r(d, p, y, _) {
    o = d, e = y, t = -3 * d + 3 * p - 2 * y - _, a = 2 * d - 2 * p + y + _;
  }
  return {
    initCatmullRom: function(d, p, y, _, E) {
      r(p, y, E * (y - d), E * (_ - p));
    },
    initNonuniformCatmullRom: function(d, p, y, _, E, T, C) {
      let D = (p - d) / E - (y - d) / (E + T) + (y - p) / T, B = (y - p) / T - (_ - p) / (T + C) + (_ - y) / C;
      D *= T, B *= T, r(p, y, D, B);
    },
    calc: function(d) {
      const p = d * d, y = p * d;
      return o + e * d + t * p + a * y;
    }
  };
}
const Tb = /* @__PURE__ */ new ve(), tC = /* @__PURE__ */ new w2(), nC = /* @__PURE__ */ new w2(), aC = /* @__PURE__ */ new w2();
class xO extends Wv {
  /**
   * Constructs a new Catmull-Rom curve.
   *
   * @param {Array<Vector3>} [points] - An array of 3D points defining the curve.
   * @param {boolean} [closed=false] - Whether the curve is closed or not.
   * @param {('centripetal'|'chordal'|'catmullrom')} [curveType='centripetal'] - The curve type.
   * @param {number} [tension=0.5] - Tension of the curve.
   */
  constructor(e = [], t = !1, a = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = a, this.tension = r;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, t = new ve()) {
    const a = t, r = this.points, d = r.length, p = (d - (this.closed ? 0 : 1)) * e;
    let y = Math.floor(p), _ = p - y;
    this.closed ? y += y > 0 ? 0 : (Math.floor(Math.abs(y) / d) + 1) * d : _ === 0 && y === d - 1 && (y = d - 2, _ = 1);
    let E, T;
    this.closed || y > 0 ? E = r[(y - 1) % d] : (Tb.subVectors(r[0], r[1]).add(r[0]), E = Tb);
    const C = r[y % d], D = r[(y + 1) % d];
    if (this.closed || y + 2 < d ? T = r[(y + 2) % d] : (Tb.subVectors(r[d - 1], r[d - 2]).add(r[d - 1]), T = Tb), this.curveType === "centripetal" || this.curveType === "chordal") {
      const B = this.curveType === "chordal" ? 0.5 : 0.25;
      let z = Math.pow(E.distanceToSquared(C), B), V = Math.pow(C.distanceToSquared(D), B), G = Math.pow(D.distanceToSquared(T), B);
      V < 1e-4 && (V = 1), z < 1e-4 && (z = V), G < 1e-4 && (G = V), tC.initNonuniformCatmullRom(E.x, C.x, D.x, T.x, z, V, G), nC.initNonuniformCatmullRom(E.y, C.y, D.y, T.y, z, V, G), aC.initNonuniformCatmullRom(E.z, C.z, D.z, T.z, z, V, G);
    } else this.curveType === "catmullrom" && (tC.initCatmullRom(E.x, C.x, D.x, T.x, this.tension), nC.initCatmullRom(E.y, C.y, D.y, T.y, this.tension), aC.initCatmullRom(E.z, C.z, D.z, T.z, this.tension));
    return a.set(
      tC.calc(_),
      nC.calc(_),
      aC.calc(_)
    ), a;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, a = e.points.length; t < a; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, a = this.points.length; t < a; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, a = e.points.length; t < a; t++) {
      const r = e.points[t];
      this.points.push(new ve().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function BB(o, e, t, a, r) {
  const d = (a - e) * 0.5, p = (r - t) * 0.5, y = o * o, _ = o * y;
  return (2 * t - 2 * a + d + p) * _ + (-3 * t + 3 * a - 2 * d - p) * y + d * o + t;
}
function bH(o, e) {
  const t = 1 - o;
  return t * t * e;
}
function MH(o, e) {
  return 2 * (1 - o) * o * e;
}
function xH(o, e) {
  return o * o * e;
}
function VA(o, e, t, a) {
  return bH(o, e) + MH(o, t) + xH(o, a);
}
function TH(o, e) {
  const t = 1 - o;
  return t * t * t * e;
}
function CH(o, e) {
  const t = 1 - o;
  return 3 * t * t * o * e;
}
function RH(o, e) {
  return 3 * (1 - o) * o * o * e;
}
function DH(o, e) {
  return o * o * o * e;
}
function FA(o, e, t, a, r) {
  return TH(o, e) + CH(o, t) + RH(o, a) + DH(o, r);
}
class N2 extends Wv {
  /**
   * Constructs a new Cubic Bezier curve.
   *
   * @param {Vector2} [v0] - The start point.
   * @param {Vector2} [v1] - The first control point.
   * @param {Vector2} [v2] - The second control point.
   * @param {Vector2} [v3] - The end point.
   */
  constructor(e = new Ot(), t = new Ot(), a = new Ot(), r = new Ot()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = a, this.v3 = r;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Ot()) {
    const a = t, r = this.v0, d = this.v1, p = this.v2, y = this.v3;
    return a.set(
      FA(e, r.x, d.x, p.x, y.x),
      FA(e, r.y, d.y, p.y, y.y)
    ), a;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class TO extends Wv {
  /**
   * Constructs a new Cubic Bezier curve.
   *
   * @param {Vector3} [v0] - The start point.
   * @param {Vector3} [v1] - The first control point.
   * @param {Vector3} [v2] - The second control point.
   * @param {Vector3} [v3] - The end point.
   */
  constructor(e = new ve(), t = new ve(), a = new ve(), r = new ve()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = a, this.v3 = r;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, t = new ve()) {
    const a = t, r = this.v0, d = this.v1, p = this.v2, y = this.v3;
    return a.set(
      FA(e, r.x, d.x, p.x, y.x),
      FA(e, r.y, d.y, p.y, y.y),
      FA(e, r.z, d.z, p.z, y.z)
    ), a;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class z2 extends Wv {
  /**
   * Constructs a new line curve.
   *
   * @param {Vector2} [v1] - The start point.
   * @param {Vector2} [v2] - The end point.
   */
  constructor(e = new Ot(), t = new Ot()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  /**
   * Returns a point on the line.
   *
   * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the line.
   */
  getPoint(e, t = new Ot()) {
    const a = t;
    return e === 1 ? a.copy(this.v2) : (a.copy(this.v2).sub(this.v1), a.multiplyScalar(e).add(this.v1)), a;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Ot()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class CO extends Wv {
  /**
   * Constructs a new line curve.
   *
   * @param {Vector3} [v1] - The start point.
   * @param {Vector3} [v2] - The end point.
   */
  constructor(e = new ve(), t = new ve()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  /**
   * Returns a point on the line.
   *
   * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the line.
   */
  getPoint(e, t = new ve()) {
    const a = t;
    return e === 1 ? a.copy(this.v2) : (a.copy(this.v2).sub(this.v1), a.multiplyScalar(e).add(this.v1)), a;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new ve()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class H2 extends Wv {
  /**
   * Constructs a new Quadratic Bezier curve.
   *
   * @param {Vector2} [v0] - The start point.
   * @param {Vector2} [v1] - The control point.
   * @param {Vector2} [v2] - The end point.
   */
  constructor(e = new Ot(), t = new Ot(), a = new Ot()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = a;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Ot()) {
    const a = t, r = this.v0, d = this.v1, p = this.v2;
    return a.set(
      VA(e, r.x, d.x, p.x),
      VA(e, r.y, d.y, p.y)
    ), a;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class L2 extends Wv {
  /**
   * Constructs a new Quadratic Bezier curve.
   *
   * @param {Vector3} [v0] - The start point.
   * @param {Vector3} [v1] - The control point.
   * @param {Vector3} [v2] - The end point.
   */
  constructor(e = new ve(), t = new ve(), a = new ve()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = a;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, t = new ve()) {
    const a = t, r = this.v0, d = this.v1, p = this.v2;
    return a.set(
      VA(e, r.x, d.x, p.x),
      VA(e, r.y, d.y, p.y),
      VA(e, r.z, d.z, p.z)
    ), a;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class G2 extends Wv {
  /**
   * Constructs a new 2D spline curve.
   *
   * @param {Array<Vector2>} [points] -  An array of 2D points defining the curve.
   */
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Ot()) {
    const a = t, r = this.points, d = (r.length - 1) * e, p = Math.floor(d), y = d - p, _ = r[p === 0 ? p : p - 1], E = r[p], T = r[p > r.length - 2 ? r.length - 1 : p + 1], C = r[p > r.length - 3 ? r.length - 1 : p + 2];
    return a.set(
      BB(y, _.x, E.x, T.x, C.x),
      BB(y, _.y, E.y, T.y, C.y)
    ), a;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, a = e.points.length; t < a; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, a = this.points.length; t < a; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, a = e.points.length; t < a; t++) {
      const r = e.points[t];
      this.points.push(new Ot().fromArray(r));
    }
    return this;
  }
}
var JM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: MO,
  CatmullRomCurve3: xO,
  CubicBezierCurve: N2,
  CubicBezierCurve3: TO,
  EllipseCurve: Ax,
  LineCurve: z2,
  LineCurve3: CO,
  QuadraticBezierCurve: H2,
  QuadraticBezierCurve3: L2,
  SplineCurve: G2
});
class RO extends Wv {
  /**
   * Constructs a new curve path.
   */
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  /**
   * Adds a curve to this curve path.
   *
   * @param {Curve} curve - The curve to add.
   */
  add(e) {
    this.curves.push(e);
  }
  /**
   * Adds a line curve to close the path.
   *
   * @return {CurvePath} A reference to this curve path.
   */
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const a = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new JM[a](t, e));
    }
    return this;
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definitions)
   * for the given interpolation factor.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {?(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPoint(e, t) {
    const a = e * this.getLength(), r = this.getCurveLengths();
    let d = 0;
    for (; d < r.length; ) {
      if (r[d] >= a) {
        const p = r[d] - a, y = this.curves[d], _ = y.getLength(), E = _ === 0 ? 0 : 1 - p / _;
        return y.getPointAt(E, t);
      }
      d++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  /**
   * Returns list of cumulative curve lengths of the defined curves.
   *
   * @return {Array<number>} The curve lengths.
   */
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let a = 0, r = this.curves.length; a < r; a++)
      t += this.curves[a].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let a = 0; a <= e; a++)
      t.push(this.getPoint(a / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let a;
    for (let r = 0, d = this.curves; r < d.length; r++) {
      const p = d[r], y = p.isEllipseCurve ? e * 2 : p.isLineCurve || p.isLineCurve3 ? 1 : p.isSplineCurve ? e * p.points.length : e, _ = p.getPoints(y);
      for (let E = 0; E < _.length; E++) {
        const T = _[E];
        a && a.equals(T) || (t.push(T), a = T);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, a = e.curves.length; t < a; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, a = this.curves.length; t < a; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, a = e.curves.length; t < a; t++) {
      const r = e.curves[t];
      this.curves.push(new JM[r.type]().fromJSON(r));
    }
    return this;
  }
}
class KA extends RO {
  /**
   * Constructs a new path.
   *
   * @param {Array<Vector2>} [points] - An array of 2D points defining the path.
   */
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Ot(), e && this.setFromPoints(e);
  }
  /**
   * Creates a path from the given list of points. The points are added
   * to the path as instances of {@link LineCurve}.
   *
   * @param {Array<Vector2>} points - An array of 2D points.
   * @return {Path} A reference to this path.
   */
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, a = e.length; t < a; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  /**
   * Moves {@link Path#currentPoint} to the given point.
   *
   * @param {number} x - The x coordinate.
   * @param {number} y - The y coordinate.
   * @return {Path} A reference to this path.
   */
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  /**
   * Adds an instance of {@link LineCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} x - The x coordinate of the end point.
   * @param {number} y - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  lineTo(e, t) {
    const a = new z2(this.currentPoint.clone(), new Ot(e, t));
    return this.curves.push(a), this.currentPoint.set(e, t), this;
  }
  /**
   * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCPx - The x coordinate of the control point.
   * @param {number} aCPy - The y coordinate of the control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  quadraticCurveTo(e, t, a, r) {
    const d = new H2(
      this.currentPoint.clone(),
      new Ot(e, t),
      new Ot(a, r)
    );
    return this.curves.push(d), this.currentPoint.set(a, r), this;
  }
  /**
   * Adds an instance of {@link CubicBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCP1x - The x coordinate of the first control point.
   * @param {number} aCP1y - The y coordinate of the first control point.
   * @param {number} aCP2x - The x coordinate of the second control point.
   * @param {number} aCP2y - The y coordinate of the second control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  bezierCurveTo(e, t, a, r, d, p) {
    const y = new N2(
      this.currentPoint.clone(),
      new Ot(e, t),
      new Ot(a, r),
      new Ot(d, p)
    );
    return this.curves.push(y), this.currentPoint.set(d, p), this;
  }
  /**
   * Adds an instance of {@link SplineCurve} to the path by connecting
   * the current point with the given list of points.
   *
   * @param {Array<Vector2>} pts - An array of points in 2D space.
   * @return {Path} A reference to this path.
   */
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), a = new G2(t);
    return this.curves.push(a), this.currentPoint.copy(e[e.length - 1]), this;
  }
  /**
   * Adds an arc as an instance of {@link EllipseCurve} to the path, positioned relative
   * to the current point.
   *
   * @param {number} aX - The x coordinate of the center of the arc offsetted from the previous curve.
   * @param {number} aY - The y coordinate of the center of the arc offsetted from the previous curve.
   * @param {number} aRadius - The radius of the arc.
   * @param {number} aStartAngle - The start angle in radians.
   * @param {number} aEndAngle - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
   * @return {Path} A reference to this path.
   */
  arc(e, t, a, r, d, p) {
    const y = this.currentPoint.x, _ = this.currentPoint.y;
    return this.absarc(
      e + y,
      t + _,
      a,
      r,
      d,
      p
    ), this;
  }
  /**
   * Adds an absolutely positioned arc as an instance of {@link EllipseCurve} to the path.
   *
   * @param {number} aX - The x coordinate of the center of the arc.
   * @param {number} aY - The y coordinate of the center of the arc.
   * @param {number} aRadius - The radius of the arc.
   * @param {number} aStartAngle - The start angle in radians.
   * @param {number} aEndAngle - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
   * @return {Path} A reference to this path.
   */
  absarc(e, t, a, r, d, p) {
    return this.absellipse(e, t, a, a, r, d, p), this;
  }
  /**
   * Adds an ellipse as an instance of {@link EllipseCurve} to the path, positioned relative
   * to the current point
   *
   * @param {number} aX - The x coordinate of the center of the ellipse offsetted from the previous curve.
   * @param {number} aY - The y coordinate of the center of the ellipse offsetted from the previous curve.
   * @param {number} xRadius - The radius of the ellipse in the x axis.
   * @param {number} yRadius - The radius of the ellipse in the y axis.
   * @param {number} aStartAngle - The start angle in radians.
   * @param {number} aEndAngle - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   * @return {Path} A reference to this path.
   */
  ellipse(e, t, a, r, d, p, y, _) {
    const E = this.currentPoint.x, T = this.currentPoint.y;
    return this.absellipse(e + E, t + T, a, r, d, p, y, _), this;
  }
  /**
   * Adds an absolutely positioned ellipse as an instance of {@link EllipseCurve} to the path.
   *
   * @param {number} aX - The x coordinate of the absolute center of the ellipse.
   * @param {number} aY - The y coordinate of the absolute center of the ellipse.
   * @param {number} xRadius - The radius of the ellipse in the x axis.
   * @param {number} yRadius - The radius of the ellipse in the y axis.
   * @param {number} aStartAngle - The start angle in radians.
   * @param {number} aEndAngle - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   * @return {Path} A reference to this path.
   */
  absellipse(e, t, a, r, d, p, y, _) {
    const E = new Ax(e, t, a, r, d, p, y, _);
    if (this.curves.length > 0) {
      const C = E.getPoint(0);
      C.equals(this.currentPoint) || this.lineTo(C.x, C.y);
    }
    this.curves.push(E);
    const T = E.getPoint(1);
    return this.currentPoint.copy(T), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class hE extends Pa {
  /**
   * Constructs a new lathe geometry.
   *
   * @param {Array<Vector2|Vector3>} [points] - An array of points in 2D space. The x-coordinate of each point
   * must be greater than zero.
   * @param {number} [segments=12] - The number of circumference segments to generate.
   * @param {number} [phiStart=0] - The starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The radian (0 to 2PI) range of the lathed section 2PI is a
   * closed lathe, less than 2PI is a portion.
   */
  constructor(e = [new Ot(0, -0.5), new Ot(0.5, 0), new Ot(0, 0.5)], t = 12, a = 0, r = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: a,
      phiLength: r
    }, t = Math.floor(t), r = Fa(r, 0, Math.PI * 2);
    const d = [], p = [], y = [], _ = [], E = [], T = 1 / t, C = new ve(), D = new Ot(), B = new ve(), z = new ve(), V = new ve();
    let G = 0, N = 0;
    for (let F = 0; F <= e.length - 1; F++)
      switch (F) {
        case 0:
          G = e[F + 1].x - e[F].x, N = e[F + 1].y - e[F].y, B.x = N * 1, B.y = -G, B.z = N * 0, V.copy(B), B.normalize(), _.push(B.x, B.y, B.z);
          break;
        case e.length - 1:
          _.push(V.x, V.y, V.z);
          break;
        default:
          G = e[F + 1].x - e[F].x, N = e[F + 1].y - e[F].y, B.x = N * 1, B.y = -G, B.z = N * 0, z.copy(B), B.x += V.x, B.y += V.y, B.z += V.z, B.normalize(), _.push(B.x, B.y, B.z), V.copy(z);
      }
    for (let F = 0; F <= t; F++) {
      const q = a + F * T * r, Y = Math.sin(q), ie = Math.cos(q);
      for (let k = 0; k <= e.length - 1; k++) {
        C.x = e[k].x * Y, C.y = e[k].y, C.z = e[k].x * ie, p.push(C.x, C.y, C.z), D.x = F / t, D.y = k / (e.length - 1), y.push(D.x, D.y);
        const le = _[3 * k + 0] * Y, ne = _[3 * k + 1], Q = _[3 * k + 0] * ie;
        E.push(le, ne, Q);
      }
    }
    for (let F = 0; F < t; F++)
      for (let q = 0; q < e.length - 1; q++) {
        const Y = q + F * e.length, ie = Y, k = Y + e.length, le = Y + e.length + 1, ne = Y + 1;
        d.push(ie, k, ne), d.push(le, ne, k);
      }
    this.setIndex(d), this.setAttribute("position", new qn(p, 3)), this.setAttribute("uv", new qn(y, 2)), this.setAttribute("normal", new qn(E, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {LatheGeometry} A new instance.
   */
  static fromJSON(e) {
    return new hE(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Ex extends hE {
  /**
   * Constructs a new capsule geometry.
   *
   * @param {number} [radius=1] - Radius of the capsule.
   * @param {number} [length=1] - Length of the middle section.
   * @param {number} [capSegments=4] - Number of curve segments used to build the caps.
   * @param {number} [radialSegments=8] - Number of segmented faces around the circumference of the capsule.
   */
  constructor(e = 1, t = 1, a = 4, r = 8) {
    const d = new KA();
    d.absarc(0, -t / 2, e, Math.PI * 1.5, 0), d.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(d.getPoints(a), r), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: a,
      radialSegments: r
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CapsuleGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Ex(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class bx extends Pa {
  /**
   * Constructs a new circle geometry.
   *
   * @param {number} [radius=1] - Radius of the circle.
   * @param {number} [segments=32] - Number of segments (triangles), minimum = `3`.
   * @param {number} [thetaStart=0] - Start angle for first segment in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta,
   * of the circular sector in radians. The default value results in a complete circle.
   */
  constructor(e = 1, t = 32, a = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: a,
      thetaLength: r
    }, t = Math.max(3, t);
    const d = [], p = [], y = [], _ = [], E = new ve(), T = new Ot();
    p.push(0, 0, 0), y.push(0, 0, 1), _.push(0.5, 0.5);
    for (let C = 0, D = 3; C <= t; C++, D += 3) {
      const B = a + C / t * r;
      E.x = e * Math.cos(B), E.y = e * Math.sin(B), p.push(E.x, E.y, E.z), y.push(0, 0, 1), T.x = (p[D] / e + 1) / 2, T.y = (p[D + 1] / e + 1) / 2, _.push(T.x, T.y);
    }
    for (let C = 1; C <= t; C++)
      d.push(C, C + 1, 0);
    this.setIndex(d), this.setAttribute("position", new qn(p, 3)), this.setAttribute("normal", new qn(y, 3)), this.setAttribute("uv", new qn(_, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CircleGeometry} A new instance.
   */
  static fromJSON(e) {
    return new bx(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class D1 extends Pa {
  /**
   * Constructs a new cylinder geometry.
   *
   * @param {number} [radiusTop=1] - Radius of the cylinder at the top.
   * @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.
   * @param {number} [height=1] - Height of the cylinder.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.
   * @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.
   * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cylinder.
   */
  constructor(e = 1, t = 1, a = 1, r = 32, d = 1, p = !1, y = 0, _ = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: a,
      radialSegments: r,
      heightSegments: d,
      openEnded: p,
      thetaStart: y,
      thetaLength: _
    };
    const E = this;
    r = Math.floor(r), d = Math.floor(d);
    const T = [], C = [], D = [], B = [];
    let z = 0;
    const V = [], G = a / 2;
    let N = 0;
    F(), p === !1 && (e > 0 && q(!0), t > 0 && q(!1)), this.setIndex(T), this.setAttribute("position", new qn(C, 3)), this.setAttribute("normal", new qn(D, 3)), this.setAttribute("uv", new qn(B, 2));
    function F() {
      const Y = new ve(), ie = new ve();
      let k = 0;
      const le = (t - e) / a;
      for (let ne = 0; ne <= d; ne++) {
        const Q = [], j = ne / d, re = j * (t - e) + e;
        for (let _e = 0; _e <= r; _e++) {
          const me = _e / r, Ae = me * _ + y, He = Math.sin(Ae), P = Math.cos(Ae);
          ie.x = re * He, ie.y = -j * a + G, ie.z = re * P, C.push(ie.x, ie.y, ie.z), Y.set(He, le, P).normalize(), D.push(Y.x, Y.y, Y.z), B.push(me, 1 - j), Q.push(z++);
        }
        V.push(Q);
      }
      for (let ne = 0; ne < r; ne++)
        for (let Q = 0; Q < d; Q++) {
          const j = V[Q][ne], re = V[Q + 1][ne], _e = V[Q + 1][ne + 1], me = V[Q][ne + 1];
          (e > 0 || Q !== 0) && (T.push(j, re, me), k += 3), (t > 0 || Q !== d - 1) && (T.push(re, _e, me), k += 3);
        }
      E.addGroup(N, k, 0), N += k;
    }
    function q(Y) {
      const ie = z, k = new Ot(), le = new ve();
      let ne = 0;
      const Q = Y === !0 ? e : t, j = Y === !0 ? 1 : -1;
      for (let _e = 1; _e <= r; _e++)
        C.push(0, G * j, 0), D.push(0, j, 0), B.push(0.5, 0.5), z++;
      const re = z;
      for (let _e = 0; _e <= r; _e++) {
        const Ae = _e / r * _ + y, He = Math.cos(Ae), P = Math.sin(Ae);
        le.x = Q * P, le.y = G * j, le.z = Q * He, C.push(le.x, le.y, le.z), D.push(0, j, 0), k.x = He * 0.5 + 0.5, k.y = P * 0.5 * j + 0.5, B.push(k.x, k.y), z++;
      }
      for (let _e = 0; _e < r; _e++) {
        const me = ie + _e, Ae = re + _e;
        Y === !0 ? T.push(Ae, Ae + 1, me) : T.push(Ae + 1, Ae, me), ne += 3;
      }
      E.addGroup(N, ne, Y === !0 ? 1 : 2), N += ne;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CylinderGeometry} A new instance.
   */
  static fromJSON(e) {
    return new D1(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Mx extends D1 {
  /**
   * Constructs a new cone geometry.
   *
   * @param {number} [radius=1] - Radius of the cone base.
   * @param {number} [height=1] - Height of the cone.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cone.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cone.
   * @param {boolean} [openEnded=false] - Whether the base of the cone is open or capped.
   * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cone.
   */
  constructor(e = 1, t = 1, a = 32, r = 1, d = !1, p = 0, y = Math.PI * 2) {
    super(0, e, t, a, r, d, p, y), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: a,
      heightSegments: r,
      openEnded: d,
      thetaStart: p,
      thetaLength: y
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {ConeGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Mx(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class J0 extends Pa {
  /**
   * Constructs a new polyhedron geometry.
   *
   * @param {Array<number>} [vertices] - A flat array of vertices describing the base shape.
   * @param {Array<number>} [indices] - A flat array of indices describing the base shape.
   * @param {number} [radius=1] - The radius of the shape.
   * @param {number} [detail=0] - How many levels to subdivide the geometry. The more detail, the smoother the shape.
   */
  constructor(e = [], t = [], a = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: a,
      detail: r
    };
    const d = [], p = [];
    y(r), E(a), T(), this.setAttribute("position", new qn(d, 3)), this.setAttribute("normal", new qn(d.slice(), 3)), this.setAttribute("uv", new qn(p, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function y(F) {
      const q = new ve(), Y = new ve(), ie = new ve();
      for (let k = 0; k < t.length; k += 3)
        B(t[k + 0], q), B(t[k + 1], Y), B(t[k + 2], ie), _(q, Y, ie, F);
    }
    function _(F, q, Y, ie) {
      const k = ie + 1, le = [];
      for (let ne = 0; ne <= k; ne++) {
        le[ne] = [];
        const Q = F.clone().lerp(Y, ne / k), j = q.clone().lerp(Y, ne / k), re = k - ne;
        for (let _e = 0; _e <= re; _e++)
          _e === 0 && ne === k ? le[ne][_e] = Q : le[ne][_e] = Q.clone().lerp(j, _e / re);
      }
      for (let ne = 0; ne < k; ne++)
        for (let Q = 0; Q < 2 * (k - ne) - 1; Q++) {
          const j = Math.floor(Q / 2);
          Q % 2 === 0 ? (D(le[ne][j + 1]), D(le[ne + 1][j]), D(le[ne][j])) : (D(le[ne][j + 1]), D(le[ne + 1][j + 1]), D(le[ne + 1][j]));
        }
    }
    function E(F) {
      const q = new ve();
      for (let Y = 0; Y < d.length; Y += 3)
        q.x = d[Y + 0], q.y = d[Y + 1], q.z = d[Y + 2], q.normalize().multiplyScalar(F), d[Y + 0] = q.x, d[Y + 1] = q.y, d[Y + 2] = q.z;
    }
    function T() {
      const F = new ve();
      for (let q = 0; q < d.length; q += 3) {
        F.x = d[q + 0], F.y = d[q + 1], F.z = d[q + 2];
        const Y = G(F) / 2 / Math.PI + 0.5, ie = N(F) / Math.PI + 0.5;
        p.push(Y, 1 - ie);
      }
      z(), C();
    }
    function C() {
      for (let F = 0; F < p.length; F += 6) {
        const q = p[F + 0], Y = p[F + 2], ie = p[F + 4], k = Math.max(q, Y, ie), le = Math.min(q, Y, ie);
        k > 0.9 && le < 0.1 && (q < 0.2 && (p[F + 0] += 1), Y < 0.2 && (p[F + 2] += 1), ie < 0.2 && (p[F + 4] += 1));
      }
    }
    function D(F) {
      d.push(F.x, F.y, F.z);
    }
    function B(F, q) {
      const Y = F * 3;
      q.x = e[Y + 0], q.y = e[Y + 1], q.z = e[Y + 2];
    }
    function z() {
      const F = new ve(), q = new ve(), Y = new ve(), ie = new ve(), k = new Ot(), le = new Ot(), ne = new Ot();
      for (let Q = 0, j = 0; Q < d.length; Q += 9, j += 6) {
        F.set(d[Q + 0], d[Q + 1], d[Q + 2]), q.set(d[Q + 3], d[Q + 4], d[Q + 5]), Y.set(d[Q + 6], d[Q + 7], d[Q + 8]), k.set(p[j + 0], p[j + 1]), le.set(p[j + 2], p[j + 3]), ne.set(p[j + 4], p[j + 5]), ie.copy(F).add(q).add(Y).divideScalar(3);
        const re = G(ie);
        V(k, j + 0, F, re), V(le, j + 2, q, re), V(ne, j + 4, Y, re);
      }
    }
    function V(F, q, Y, ie) {
      ie < 0 && F.x === 1 && (p[q] = F.x - 1), Y.x === 0 && Y.z === 0 && (p[q] = ie / 2 / Math.PI + 0.5);
    }
    function G(F) {
      return Math.atan2(F.z, -F.x);
    }
    function N(F) {
      return Math.atan2(-F.y, Math.sqrt(F.x * F.x + F.z * F.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PolyhedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new J0(e.vertices, e.indices, e.radius, e.details);
  }
}
class xx extends J0 {
  /**
   * Constructs a new dodecahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the dodecahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a dodecahedron.
   */
  constructor(e = 1, t = 0) {
    const a = (1 + Math.sqrt(5)) / 2, r = 1 / a, d = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -r,
      -a,
      0,
      -r,
      a,
      0,
      r,
      -a,
      0,
      r,
      a,
      // (1/, , 0)
      -r,
      -a,
      0,
      -r,
      a,
      0,
      r,
      -a,
      0,
      r,
      a,
      0,
      // (, 0, 1/)
      -a,
      0,
      -r,
      a,
      0,
      -r,
      -a,
      0,
      r,
      a,
      0,
      r
    ], p = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(d, p, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {DodecahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new xx(e.radius, e.detail);
  }
}
const Cb = /* @__PURE__ */ new ve(), Rb = /* @__PURE__ */ new ve(), iC = /* @__PURE__ */ new ve(), Db = /* @__PURE__ */ new Xh();
class DO extends Pa {
  /**
   * Constructs a new edges geometry.
   *
   * @param {?BufferGeometry} [geometry=null] - The geometry.
   * @param {number} [thresholdAngle=1] - An edge is only rendered if the angle (in degrees)
   * between the face normals of the adjoining faces exceeds this value.
   */
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const r = Math.pow(10, 4), d = Math.cos(jS * t), p = e.getIndex(), y = e.getAttribute("position"), _ = p ? p.count : y.count, E = [0, 0, 0], T = ["a", "b", "c"], C = new Array(3), D = {}, B = [];
      for (let z = 0; z < _; z += 3) {
        p ? (E[0] = p.getX(z), E[1] = p.getX(z + 1), E[2] = p.getX(z + 2)) : (E[0] = z, E[1] = z + 1, E[2] = z + 2);
        const { a: V, b: G, c: N } = Db;
        if (V.fromBufferAttribute(y, E[0]), G.fromBufferAttribute(y, E[1]), N.fromBufferAttribute(y, E[2]), Db.getNormal(iC), C[0] = `${Math.round(V.x * r)},${Math.round(V.y * r)},${Math.round(V.z * r)}`, C[1] = `${Math.round(G.x * r)},${Math.round(G.y * r)},${Math.round(G.z * r)}`, C[2] = `${Math.round(N.x * r)},${Math.round(N.y * r)},${Math.round(N.z * r)}`, !(C[0] === C[1] || C[1] === C[2] || C[2] === C[0]))
          for (let F = 0; F < 3; F++) {
            const q = (F + 1) % 3, Y = C[F], ie = C[q], k = Db[T[F]], le = Db[T[q]], ne = `${Y}_${ie}`, Q = `${ie}_${Y}`;
            Q in D && D[Q] ? (iC.dot(D[Q].normal) <= d && (B.push(k.x, k.y, k.z), B.push(le.x, le.y, le.z)), D[Q] = null) : ne in D || (D[ne] = {
              index0: E[F],
              index1: E[q],
              normal: iC.clone()
            });
          }
      }
      for (const z in D)
        if (D[z]) {
          const { index0: V, index1: G } = D[z];
          Cb.fromBufferAttribute(y, V), Rb.fromBufferAttribute(y, G), B.push(Cb.x, Cb.y, Cb.z), B.push(Rb.x, Rb.y, Rb.z);
        }
      this.setAttribute("position", new qn(B, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class JS extends KA {
  /**
   * Constructs a new shape.
   *
   * @param {Array<Vector2>} [points] - An array of 2D points defining the shape.
   */
  constructor(e) {
    super(e), this.uuid = Gp(), this.type = "Shape", this.holes = [];
  }
  /**
   * Returns an array representing each contour of the holes
   * as a list of 2D points.
   *
   * @param {number} divisions - The fineness of the result.
   * @return {Array<Array<Vector2>>} The holes as a series of 2D points.
   */
  getPointsHoles(e) {
    const t = [];
    for (let a = 0, r = this.holes.length; a < r; a++)
      t[a] = this.holes[a].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  /**
   * Returns an object that holds contour data for the shape and its holes as
   * arrays of 2D points.
   *
   * @param {number} divisions - The fineness of the result.
   * @return {{shape:Array<Vector2>,holes:Array<Array<Vector2>>}} An object with contour data.
   */
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, a = e.holes.length; t < a; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, a = this.holes.length; t < a; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, a = e.holes.length; t < a; t++) {
      const r = e.holes[t];
      this.holes.push(new KA().fromJSON(r));
    }
    return this;
  }
}
function BH(o, e, t = 2) {
  const a = e && e.length, r = a ? e[0] * t : o.length;
  let d = BO(o, 0, r, t, !0);
  const p = [];
  if (!d || d.next === d.prev) return p;
  let y, _, E;
  if (a && (d = zH(o, e, d, t)), o.length > 80 * t) {
    y = 1 / 0, _ = 1 / 0;
    let T = -1 / 0, C = -1 / 0;
    for (let D = t; D < r; D += t) {
      const B = o[D], z = o[D + 1];
      B < y && (y = B), z < _ && (_ = z), B > T && (T = B), z > C && (C = z);
    }
    E = Math.max(T - y, C - _), E = E !== 0 ? 32767 / E : 0;
  }
  return kA(d, p, t, y, _, E, 0), p;
}
function BO(o, e, t, a, r) {
  let d;
  if (r === ZH(o, e, t, a) > 0)
    for (let p = e; p < t; p += a) d = UB(p / a | 0, o[p], o[p + 1], d);
  else
    for (let p = t - a; p >= e; p -= a) d = UB(p / a | 0, o[p], o[p + 1], d);
  return d && b1(d, d.next) && ($A(d), d = d.next), d;
}
function e_(o, e) {
  if (!o) return o;
  e || (e = o);
  let t = o, a;
  do
    if (a = !1, !t.steiner && (b1(t, t.next) || hr(t.prev, t, t.next) === 0)) {
      if ($A(t), t = e = t.prev, t === t.next) break;
      a = !0;
    } else
      t = t.next;
  while (a || t !== e);
  return e;
}
function kA(o, e, t, a, r, d, p) {
  if (!o) return;
  !p && d && VH(o, a, r, d);
  let y = o;
  for (; o.prev !== o.next; ) {
    const _ = o.prev, E = o.next;
    if (d ? OH(o, a, r, d) : UH(o)) {
      e.push(_.i, o.i, E.i), $A(o), o = E.next, y = E.next;
      continue;
    }
    if (o = E, o === y) {
      p ? p === 1 ? (o = wH(e_(o), e), kA(o, e, t, a, r, d, 2)) : p === 2 && NH(o, e, t, a, r, d) : kA(e_(o), e, t, a, r, d, 1);
      break;
    }
  }
}
function UH(o) {
  const e = o.prev, t = o, a = o.next;
  if (hr(e, t, a) >= 0) return !1;
  const r = e.x, d = t.x, p = a.x, y = e.y, _ = t.y, E = a.y, T = Math.min(r, d, p), C = Math.min(y, _, E), D = Math.max(r, d, p), B = Math.max(y, _, E);
  let z = a.next;
  for (; z !== e; ) {
    if (z.x >= T && z.x <= D && z.y >= C && z.y <= B && BA(r, y, d, _, p, E, z.x, z.y) && hr(z.prev, z, z.next) >= 0) return !1;
    z = z.next;
  }
  return !0;
}
function OH(o, e, t, a) {
  const r = o.prev, d = o, p = o.next;
  if (hr(r, d, p) >= 0) return !1;
  const y = r.x, _ = d.x, E = p.x, T = r.y, C = d.y, D = p.y, B = Math.min(y, _, E), z = Math.min(T, C, D), V = Math.max(y, _, E), G = Math.max(T, C, D), N = JC(B, z, e, t, a), F = JC(V, G, e, t, a);
  let q = o.prevZ, Y = o.nextZ;
  for (; q && q.z >= N && Y && Y.z <= F; ) {
    if (q.x >= B && q.x <= V && q.y >= z && q.y <= G && q !== r && q !== p && BA(y, T, _, C, E, D, q.x, q.y) && hr(q.prev, q, q.next) >= 0 || (q = q.prevZ, Y.x >= B && Y.x <= V && Y.y >= z && Y.y <= G && Y !== r && Y !== p && BA(y, T, _, C, E, D, Y.x, Y.y) && hr(Y.prev, Y, Y.next) >= 0)) return !1;
    Y = Y.nextZ;
  }
  for (; q && q.z >= N; ) {
    if (q.x >= B && q.x <= V && q.y >= z && q.y <= G && q !== r && q !== p && BA(y, T, _, C, E, D, q.x, q.y) && hr(q.prev, q, q.next) >= 0) return !1;
    q = q.prevZ;
  }
  for (; Y && Y.z <= F; ) {
    if (Y.x >= B && Y.x <= V && Y.y >= z && Y.y <= G && Y !== r && Y !== p && BA(y, T, _, C, E, D, Y.x, Y.y) && hr(Y.prev, Y, Y.next) >= 0) return !1;
    Y = Y.nextZ;
  }
  return !0;
}
function wH(o, e) {
  let t = o;
  do {
    const a = t.prev, r = t.next.next;
    !b1(a, r) && OO(a, t, t.next, r) && WA(a, r) && WA(r, a) && (e.push(a.i, t.i, r.i), $A(t), $A(t.next), t = o = r), t = t.next;
  } while (t !== o);
  return e_(t);
}
function NH(o, e, t, a, r, d) {
  let p = o;
  do {
    let y = p.next.next;
    for (; y !== p.prev; ) {
      if (p.i !== y.i && XH(p, y)) {
        let _ = wO(p, y);
        p = e_(p, p.next), _ = e_(_, _.next), kA(p, e, t, a, r, d, 0), kA(_, e, t, a, r, d, 0);
        return;
      }
      y = y.next;
    }
    p = p.next;
  } while (p !== o);
}
function zH(o, e, t, a) {
  const r = [];
  for (let d = 0, p = e.length; d < p; d++) {
    const y = e[d] * a, _ = d < p - 1 ? e[d + 1] * a : o.length, E = BO(o, y, _, a, !1);
    E === E.next && (E.steiner = !0), r.push(PH(E));
  }
  r.sort(HH);
  for (let d = 0; d < r.length; d++)
    t = LH(r[d], t);
  return t;
}
function HH(o, e) {
  let t = o.x - e.x;
  if (t === 0 && (t = o.y - e.y, t === 0)) {
    const a = (o.next.y - o.y) / (o.next.x - o.x), r = (e.next.y - e.y) / (e.next.x - e.x);
    t = a - r;
  }
  return t;
}
function LH(o, e) {
  const t = GH(o, e);
  if (!t)
    return e;
  const a = wO(t, o);
  return e_(a, a.next), e_(t, t.next);
}
function GH(o, e) {
  let t = e;
  const a = o.x, r = o.y;
  let d = -1 / 0, p;
  if (b1(o, t)) return t;
  do {
    if (b1(o, t.next)) return t.next;
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      const C = t.x + (r - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (C <= a && C > d && (d = C, p = t.x < t.next.x ? t : t.next, C === a))
        return p;
    }
    t = t.next;
  } while (t !== e);
  if (!p) return null;
  const y = p, _ = p.x, E = p.y;
  let T = 1 / 0;
  t = p;
  do {
    if (a >= t.x && t.x >= _ && a !== t.x && UO(r < E ? a : d, r, _, E, r < E ? d : a, r, t.x, t.y)) {
      const C = Math.abs(r - t.y) / (a - t.x);
      WA(t, o) && (C < T || C === T && (t.x > p.x || t.x === p.x && IH(p, t))) && (p = t, T = C);
    }
    t = t.next;
  } while (t !== y);
  return p;
}
function IH(o, e) {
  return hr(o.prev, o, e.prev) < 0 && hr(e.next, o, o.next) < 0;
}
function VH(o, e, t, a) {
  let r = o;
  do
    r.z === 0 && (r.z = JC(r.x, r.y, e, t, a)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== o);
  r.prevZ.nextZ = null, r.prevZ = null, FH(r);
}
function FH(o) {
  let e, t = 1;
  do {
    let a = o, r;
    o = null;
    let d = null;
    for (e = 0; a; ) {
      e++;
      let p = a, y = 0;
      for (let E = 0; E < t && (y++, p = p.nextZ, !!p); E++)
        ;
      let _ = t;
      for (; y > 0 || _ > 0 && p; )
        y !== 0 && (_ === 0 || !p || a.z <= p.z) ? (r = a, a = a.nextZ, y--) : (r = p, p = p.nextZ, _--), d ? d.nextZ = r : o = r, r.prevZ = d, d = r;
      a = p;
    }
    d.nextZ = null, t *= 2;
  } while (e > 1);
  return o;
}
function JC(o, e, t, a, r) {
  return o = (o - t) * r | 0, e = (e - a) * r | 0, o = (o | o << 8) & 16711935, o = (o | o << 4) & 252645135, o = (o | o << 2) & 858993459, o = (o | o << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, o | e << 1;
}
function PH(o) {
  let e = o, t = o;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== o);
  return t;
}
function UO(o, e, t, a, r, d, p, y) {
  return (r - p) * (e - y) >= (o - p) * (d - y) && (o - p) * (a - y) >= (t - p) * (e - y) && (t - p) * (d - y) >= (r - p) * (a - y);
}
function BA(o, e, t, a, r, d, p, y) {
  return !(o === p && e === y) && UO(o, e, t, a, r, d, p, y);
}
function XH(o, e) {
  return o.next.i !== e.i && o.prev.i !== e.i && !YH(o, e) && // dones't intersect other edges
  (WA(o, e) && WA(e, o) && qH(o, e) && // locally visible
  (hr(o.prev, o, e.prev) || hr(o, e.prev, e)) || // does not create opposite-facing sectors
  b1(o, e) && hr(o.prev, o, o.next) > 0 && hr(e.prev, e, e.next) > 0);
}
function hr(o, e, t) {
  return (e.y - o.y) * (t.x - e.x) - (e.x - o.x) * (t.y - e.y);
}
function b1(o, e) {
  return o.x === e.x && o.y === e.y;
}
function OO(o, e, t, a) {
  const r = Ub(hr(o, e, t)), d = Ub(hr(o, e, a)), p = Ub(hr(t, a, o)), y = Ub(hr(t, a, e));
  return !!(r !== d && p !== y || r === 0 && Bb(o, t, e) || d === 0 && Bb(o, a, e) || p === 0 && Bb(t, o, a) || y === 0 && Bb(t, e, a));
}
function Bb(o, e, t) {
  return e.x <= Math.max(o.x, t.x) && e.x >= Math.min(o.x, t.x) && e.y <= Math.max(o.y, t.y) && e.y >= Math.min(o.y, t.y);
}
function Ub(o) {
  return o > 0 ? 1 : o < 0 ? -1 : 0;
}
function YH(o, e) {
  let t = o;
  do {
    if (t.i !== o.i && t.next.i !== o.i && t.i !== e.i && t.next.i !== e.i && OO(t, t.next, o, e)) return !0;
    t = t.next;
  } while (t !== o);
  return !1;
}
function WA(o, e) {
  return hr(o.prev, o, o.next) < 0 ? hr(o, e, o.next) >= 0 && hr(o, o.prev, e) >= 0 : hr(o, e, o.prev) < 0 || hr(o, o.next, e) < 0;
}
function qH(o, e) {
  let t = o, a = !1;
  const r = (o.x + e.x) / 2, d = (o.y + e.y) / 2;
  do
    t.y > d != t.next.y > d && t.next.y !== t.y && r < (t.next.x - t.x) * (d - t.y) / (t.next.y - t.y) + t.x && (a = !a), t = t.next;
  while (t !== o);
  return a;
}
function wO(o, e) {
  const t = KC(o.i, o.x, o.y), a = KC(e.i, e.x, e.y), r = o.next, d = e.prev;
  return o.next = e, e.prev = o, t.next = r, r.prev = t, a.next = t, t.prev = a, d.next = a, a.prev = d, a;
}
function UB(o, e, t, a) {
  const r = KC(o, e, t);
  return a ? (r.next = a.next, r.prev = a, a.next.prev = r, a.next = r) : (r.prev = r, r.next = r), r;
}
function $A(o) {
  o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);
}
function KC(o, e, t) {
  return {
    i: o,
    // vertex index in coordinates array
    x: e,
    y: t,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: !1
    // indicates whether this is a steiner point
  };
}
function ZH(o, e, t, a) {
  let r = 0;
  for (let d = e, p = t - a; d < t; d += a)
    r += (o[p] - o[d]) * (o[d + 1] + o[p + 1]), p = d;
  return r;
}
class QH {
  /**
   * Triangulates the given shape definition by returning an array of triangles.
   *
   * @param {Array<number>} data - An array with 2D points.
   * @param {Array<number>} holeIndices - An array with indices defining holes.
   * @param {number} [dim=2] - The number of coordinates per vertex in the input array.
   * @return {Array<number>} An array representing the triangulated faces. Each face is defined by three consecutive numbers
   * representing vertex indices.
   */
  static triangulate(e, t, a = 2) {
    return BH(e, t, a);
  }
}
class qg {
  /**
   * Calculate area of a ( 2D ) contour polygon.
   *
   * @param {Array<Vector2>} contour - An array of 2D points.
   * @return {number} The area.
   */
  static area(e) {
    const t = e.length;
    let a = 0;
    for (let r = t - 1, d = 0; d < t; r = d++)
      a += e[r].x * e[d].y - e[d].x * e[r].y;
    return a * 0.5;
  }
  /**
   * Returns `true` if the given contour uses a clockwise winding order.
   *
   * @param {Array<Vector2>} pts - An array of 2D points defining a polygon.
   * @return {boolean} Whether the given contour uses a clockwise winding order or not.
   */
  static isClockWise(e) {
    return qg.area(e) < 0;
  }
  /**
   * Triangulates the given shape definition.
   *
   * @param {Array<Vector2>} contour - An array of 2D points defining the contour.
   * @param {Array<Array<Vector2>>} holes - An array that holds arrays of 2D points defining the holes.
   * @return {Array<Array<number>>} An array that holds for each face definition an array with three indices.
   */
  static triangulateShape(e, t) {
    const a = [], r = [], d = [];
    OB(e), wB(a, e);
    let p = e.length;
    t.forEach(OB);
    for (let _ = 0; _ < t.length; _++)
      r.push(p), p += t[_].length, wB(a, t[_]);
    const y = QH.triangulate(a, r);
    for (let _ = 0; _ < y.length; _ += 3)
      d.push(y.slice(_, _ + 3));
    return d;
  }
}
function OB(o) {
  const e = o.length;
  e > 2 && o[e - 1].equals(o[0]) && o.pop();
}
function wB(o, e) {
  for (let t = 0; t < e.length; t++)
    o.push(e[t].x), o.push(e[t].y);
}
class Tx extends Pa {
  /**
   * Constructs a new extrude geometry.
   *
   * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
   * @param {ExtrudeGeometry~Options} [options] - The extrude settings.
   */
  constructor(e = new JS([new Ot(0.5, 0.5), new Ot(-0.5, 0.5), new Ot(-0.5, -0.5), new Ot(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const a = this, r = [], d = [];
    for (let y = 0, _ = e.length; y < _; y++) {
      const E = e[y];
      p(E);
    }
    this.setAttribute("position", new qn(r, 3)), this.setAttribute("uv", new qn(d, 2)), this.computeVertexNormals();
    function p(y) {
      const _ = [], E = t.curveSegments !== void 0 ? t.curveSegments : 12, T = t.steps !== void 0 ? t.steps : 1, C = t.depth !== void 0 ? t.depth : 1;
      let D = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, B = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, z = t.bevelSize !== void 0 ? t.bevelSize : B - 0.1, V = t.bevelOffset !== void 0 ? t.bevelOffset : 0, G = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const N = t.extrudePath, F = t.UVGenerator !== void 0 ? t.UVGenerator : jH;
      let q, Y = !1, ie, k, le, ne;
      N && (q = N.getSpacedPoints(T), Y = !0, D = !1, ie = N.computeFrenetFrames(T, !1), k = new ve(), le = new ve(), ne = new ve()), D || (G = 0, B = 0, z = 0, V = 0);
      const Q = y.extractPoints(E);
      let j = Q.shape;
      const re = Q.holes;
      if (!qg.isClockWise(j)) {
        j = j.reverse();
        for (let Tt = 0, St = re.length; Tt < St; Tt++) {
          const Mt = re[Tt];
          qg.isClockWise(Mt) && (re[Tt] = Mt.reverse());
        }
      }
      function me(Tt) {
        const Mt = 10000000000000001e-36;
        let kt = Tt[0];
        for (let At = 1; At <= Tt.length; At++) {
          const ce = At % Tt.length, se = Tt[ce], Xe = se.x - kt.x, dt = se.y - kt.y, Et = Xe * Xe + dt * dt, yt = Math.max(
            Math.abs(se.x),
            Math.abs(se.y),
            Math.abs(kt.x),
            Math.abs(kt.y)
          ), Jt = Mt * yt * yt;
          if (Et <= Jt) {
            Tt.splice(ce, 1), At--;
            continue;
          }
          kt = se;
        }
      }
      me(j), re.forEach(me);
      const Ae = re.length, He = j;
      for (let Tt = 0; Tt < Ae; Tt++) {
        const St = re[Tt];
        j = j.concat(St);
      }
      function P(Tt, St, Mt) {
        return St || console.error("THREE.ExtrudeGeometry: vec does not exist"), Tt.clone().addScaledVector(St, Mt);
      }
      const te = j.length;
      function ae(Tt, St, Mt) {
        let kt, At, ce;
        const se = Tt.x - St.x, Xe = Tt.y - St.y, dt = Mt.x - Tt.x, Et = Mt.y - Tt.y, yt = se * se + Xe * Xe, Jt = se * Et - Xe * dt;
        if (Math.abs(Jt) > Number.EPSILON) {
          const Xt = Math.sqrt(yt), Wt = Math.sqrt(dt * dt + Et * Et), Vn = St.x - Xe / Xt, Pt = St.y + se / Xt, pn = Mt.x - Et / Wt, gn = Mt.y + dt / Wt, nn = ((pn - Vn) * Et - (gn - Pt) * dt) / (se * Et - Xe * dt);
          kt = Vn + se * nn - Tt.x, At = Pt + Xe * nn - Tt.y;
          const jt = kt * kt + At * At;
          if (jt <= 2)
            return new Ot(kt, At);
          ce = Math.sqrt(jt / 2);
        } else {
          let Xt = !1;
          se > Number.EPSILON ? dt > Number.EPSILON && (Xt = !0) : se < -Number.EPSILON ? dt < -Number.EPSILON && (Xt = !0) : Math.sign(Xe) === Math.sign(Et) && (Xt = !0), Xt ? (kt = -Xe, At = se, ce = Math.sqrt(yt)) : (kt = se, At = Xe, ce = Math.sqrt(yt / 2));
        }
        return new Ot(kt / ce, At / ce);
      }
      const Se = [];
      for (let Tt = 0, St = He.length, Mt = St - 1, kt = Tt + 1; Tt < St; Tt++, Mt++, kt++)
        Mt === St && (Mt = 0), kt === St && (kt = 0), Se[Tt] = ae(He[Tt], He[Mt], He[kt]);
      const ue = [];
      let we, De = Se.concat();
      for (let Tt = 0, St = Ae; Tt < St; Tt++) {
        const Mt = re[Tt];
        we = [];
        for (let kt = 0, At = Mt.length, ce = At - 1, se = kt + 1; kt < At; kt++, ce++, se++)
          ce === At && (ce = 0), se === At && (se = 0), we[kt] = ae(Mt[kt], Mt[ce], Mt[se]);
        ue.push(we), De = De.concat(we);
      }
      const We = [], Me = [];
      for (let Tt = 0; Tt < G; Tt++) {
        const St = Tt / G, Mt = B * Math.cos(St * Math.PI / 2), kt = z * Math.sin(St * Math.PI / 2) + V;
        for (let At = 0, ce = He.length; At < ce; At++) {
          const se = P(He[At], Se[At], kt);
          dn(se.x, se.y, -Mt), St == 0 && We.push(se);
        }
        for (let At = 0, ce = Ae; At < ce; At++) {
          const se = re[At];
          we = ue[At];
          const Xe = [];
          for (let dt = 0, Et = se.length; dt < Et; dt++) {
            const yt = P(se[dt], we[dt], kt);
            dn(yt.x, yt.y, -Mt), St == 0 && Xe.push(yt);
          }
          St == 0 && Me.push(Xe);
        }
      }
      const Ze = qg.triangulateShape(We, Me), ct = Ze.length, Vt = z + V;
      for (let Tt = 0; Tt < te; Tt++) {
        const St = D ? P(j[Tt], De[Tt], Vt) : j[Tt];
        Y ? (le.copy(ie.normals[0]).multiplyScalar(St.x), k.copy(ie.binormals[0]).multiplyScalar(St.y), ne.copy(q[0]).add(le).add(k), dn(ne.x, ne.y, ne.z)) : dn(St.x, St.y, 0);
      }
      for (let Tt = 1; Tt <= T; Tt++)
        for (let St = 0; St < te; St++) {
          const Mt = D ? P(j[St], De[St], Vt) : j[St];
          Y ? (le.copy(ie.normals[Tt]).multiplyScalar(Mt.x), k.copy(ie.binormals[Tt]).multiplyScalar(Mt.y), ne.copy(q[Tt]).add(le).add(k), dn(ne.x, ne.y, ne.z)) : dn(Mt.x, Mt.y, C / T * Tt);
        }
      for (let Tt = G - 1; Tt >= 0; Tt--) {
        const St = Tt / G, Mt = B * Math.cos(St * Math.PI / 2), kt = z * Math.sin(St * Math.PI / 2) + V;
        for (let At = 0, ce = He.length; At < ce; At++) {
          const se = P(He[At], Se[At], kt);
          dn(se.x, se.y, C + Mt);
        }
        for (let At = 0, ce = re.length; At < ce; At++) {
          const se = re[At];
          we = ue[At];
          for (let Xe = 0, dt = se.length; Xe < dt; Xe++) {
            const Et = P(se[Xe], we[Xe], kt);
            Y ? dn(Et.x, Et.y + q[T - 1].y, q[T - 1].x + Mt) : dn(Et.x, Et.y, C + Mt);
          }
        }
      }
      Zt(), Bn();
      function Zt() {
        const Tt = r.length / 3;
        if (D) {
          let St = 0, Mt = te * St;
          for (let kt = 0; kt < ct; kt++) {
            const At = Ze[kt];
            Zn(At[2] + Mt, At[1] + Mt, At[0] + Mt);
          }
          St = T + G * 2, Mt = te * St;
          for (let kt = 0; kt < ct; kt++) {
            const At = Ze[kt];
            Zn(At[0] + Mt, At[1] + Mt, At[2] + Mt);
          }
        } else {
          for (let St = 0; St < ct; St++) {
            const Mt = Ze[St];
            Zn(Mt[2], Mt[1], Mt[0]);
          }
          for (let St = 0; St < ct; St++) {
            const Mt = Ze[St];
            Zn(Mt[0] + te * T, Mt[1] + te * T, Mt[2] + te * T);
          }
        }
        a.addGroup(Tt, r.length / 3 - Tt, 0);
      }
      function Bn() {
        const Tt = r.length / 3;
        let St = 0;
        rn(He, St), St += He.length;
        for (let Mt = 0, kt = re.length; Mt < kt; Mt++) {
          const At = re[Mt];
          rn(At, St), St += At.length;
        }
        a.addGroup(Tt, r.length / 3 - Tt, 1);
      }
      function rn(Tt, St) {
        let Mt = Tt.length;
        for (; --Mt >= 0; ) {
          const kt = Mt;
          let At = Mt - 1;
          At < 0 && (At = Tt.length - 1);
          for (let ce = 0, se = T + G * 2; ce < se; ce++) {
            const Xe = te * ce, dt = te * (ce + 1), Et = St + kt + Xe, yt = St + At + Xe, Jt = St + At + dt, Xt = St + kt + dt;
            Rn(Et, yt, Jt, Xt);
          }
        }
      }
      function dn(Tt, St, Mt) {
        _.push(Tt), _.push(St), _.push(Mt);
      }
      function Zn(Tt, St, Mt) {
        Te(Tt), Te(St), Te(Mt);
        const kt = r.length / 3, At = F.generateTopUV(a, r, kt - 3, kt - 2, kt - 1);
        Ha(At[0]), Ha(At[1]), Ha(At[2]);
      }
      function Rn(Tt, St, Mt, kt) {
        Te(Tt), Te(St), Te(kt), Te(St), Te(Mt), Te(kt);
        const At = r.length / 3, ce = F.generateSideWallUV(a, r, At - 6, At - 3, At - 2, At - 1);
        Ha(ce[0]), Ha(ce[1]), Ha(ce[3]), Ha(ce[1]), Ha(ce[2]), Ha(ce[3]);
      }
      function Te(Tt) {
        r.push(_[Tt * 3 + 0]), r.push(_[Tt * 3 + 1]), r.push(_[Tt * 3 + 2]);
      }
      function Ha(Tt) {
        d.push(Tt.x), d.push(Tt.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, a = this.parameters.options;
    return JH(t, a, e);
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @param {Array<Shape>} shapes - An array of shapes.
   * @return {ExtrudeGeometry} A new instance.
   */
  static fromJSON(e, t) {
    const a = [];
    for (let d = 0, p = e.shapes.length; d < p; d++) {
      const y = t[e.shapes[d]];
      a.push(y);
    }
    const r = e.options.extrudePath;
    return r !== void 0 && (e.options.extrudePath = new JM[r.type]().fromJSON(r)), new Tx(a, e.options);
  }
}
const jH = {
  generateTopUV: function(o, e, t, a, r) {
    const d = e[t * 3], p = e[t * 3 + 1], y = e[a * 3], _ = e[a * 3 + 1], E = e[r * 3], T = e[r * 3 + 1];
    return [
      new Ot(d, p),
      new Ot(y, _),
      new Ot(E, T)
    ];
  },
  generateSideWallUV: function(o, e, t, a, r, d) {
    const p = e[t * 3], y = e[t * 3 + 1], _ = e[t * 3 + 2], E = e[a * 3], T = e[a * 3 + 1], C = e[a * 3 + 2], D = e[r * 3], B = e[r * 3 + 1], z = e[r * 3 + 2], V = e[d * 3], G = e[d * 3 + 1], N = e[d * 3 + 2];
    return Math.abs(y - T) < Math.abs(p - E) ? [
      new Ot(p, 1 - _),
      new Ot(E, 1 - C),
      new Ot(D, 1 - z),
      new Ot(V, 1 - N)
    ] : [
      new Ot(y, 1 - _),
      new Ot(T, 1 - C),
      new Ot(B, 1 - z),
      new Ot(G, 1 - N)
    ];
  }
};
function JH(o, e, t) {
  if (t.shapes = [], Array.isArray(o))
    for (let a = 0, r = o.length; a < r; a++) {
      const d = o[a];
      t.shapes.push(d.uuid);
    }
  else
    t.shapes.push(o.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class pE extends J0 {
  /**
   * Constructs a new icosahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the icosahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a icosahedron.
   */
  constructor(e = 1, t = 0) {
    const a = (1 + Math.sqrt(5)) / 2, r = [
      -1,
      a,
      0,
      1,
      a,
      0,
      -1,
      -a,
      0,
      1,
      -a,
      0,
      0,
      -1,
      a,
      0,
      1,
      a,
      0,
      -1,
      -a,
      0,
      1,
      -a,
      a,
      0,
      -1,
      a,
      0,
      1,
      -a,
      0,
      -1,
      -a,
      0,
      1
    ], d = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(r, d, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {IcosahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new pE(e.radius, e.detail);
  }
}
class mE extends J0 {
  /**
   * Constructs a new octahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the octahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a octahedron.
   */
  constructor(e = 1, t = 0) {
    const a = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], r = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(a, r, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {OctahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new mE(e.radius, e.detail);
  }
}
class Ky extends Pa {
  /**
   * Constructs a new plane geometry.
   *
   * @param {number} [width=1] - The width along the X axis.
   * @param {number} [height=1] - The height along the Y axis
   * @param {number} [widthSegments=1] - The number of segments along the X axis.
   * @param {number} [heightSegments=1] - The number of segments along the Y axis.
   */
  constructor(e = 1, t = 1, a = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: a,
      heightSegments: r
    };
    const d = e / 2, p = t / 2, y = Math.floor(a), _ = Math.floor(r), E = y + 1, T = _ + 1, C = e / y, D = t / _, B = [], z = [], V = [], G = [];
    for (let N = 0; N < T; N++) {
      const F = N * D - p;
      for (let q = 0; q < E; q++) {
        const Y = q * C - d;
        z.push(Y, -F, 0), V.push(0, 0, 1), G.push(q / y), G.push(1 - N / _);
      }
    }
    for (let N = 0; N < _; N++)
      for (let F = 0; F < y; F++) {
        const q = F + E * N, Y = F + E * (N + 1), ie = F + 1 + E * (N + 1), k = F + 1 + E * N;
        B.push(q, Y, k), B.push(Y, ie, k);
      }
    this.setIndex(B), this.setAttribute("position", new qn(z, 3)), this.setAttribute("normal", new qn(V, 3)), this.setAttribute("uv", new qn(G, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PlaneGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Ky(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class Cx extends Pa {
  /**
   * Constructs a new ring geometry.
   *
   * @param {number} [innerRadius=0.5] - The inner radius of the ring.
   * @param {number} [outerRadius=1] - The outer radius of the ring.
   * @param {number} [thetaSegments=32] - Number of segments. A higher number means the ring will be more round. Minimum is `3`.
   * @param {number} [phiSegments=1] - Number of segments per ring segment. Minimum is `1`.
   * @param {number} [thetaStart=0] - Starting angle in radians.
   * @param {number} [thetaLength=Math.PI*2] - Central angle in radians.
   */
  constructor(e = 0.5, t = 1, a = 32, r = 1, d = 0, p = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: a,
      phiSegments: r,
      thetaStart: d,
      thetaLength: p
    }, a = Math.max(3, a), r = Math.max(1, r);
    const y = [], _ = [], E = [], T = [];
    let C = e;
    const D = (t - e) / r, B = new ve(), z = new Ot();
    for (let V = 0; V <= r; V++) {
      for (let G = 0; G <= a; G++) {
        const N = d + G / a * p;
        B.x = C * Math.cos(N), B.y = C * Math.sin(N), _.push(B.x, B.y, B.z), E.push(0, 0, 1), z.x = (B.x / t + 1) / 2, z.y = (B.y / t + 1) / 2, T.push(z.x, z.y);
      }
      C += D;
    }
    for (let V = 0; V < r; V++) {
      const G = V * (a + 1);
      for (let N = 0; N < a; N++) {
        const F = N + G, q = F, Y = F + a + 1, ie = F + a + 2, k = F + 1;
        y.push(q, Y, k), y.push(Y, ie, k);
      }
    }
    this.setIndex(y), this.setAttribute("position", new qn(_, 3)), this.setAttribute("normal", new qn(E, 3)), this.setAttribute("uv", new qn(T, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {RingGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Cx(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class Rx extends Pa {
  /**
   * Constructs a new shape geometry.
   *
   * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
   * @param {number} [curveSegments=12] - Number of segments per shape.
   */
  constructor(e = new JS([new Ot(0, 0.5), new Ot(-0.5, -0.5), new Ot(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const a = [], r = [], d = [], p = [];
    let y = 0, _ = 0;
    if (Array.isArray(e) === !1)
      E(e);
    else
      for (let T = 0; T < e.length; T++)
        E(e[T]), this.addGroup(y, _, T), y += _, _ = 0;
    this.setIndex(a), this.setAttribute("position", new qn(r, 3)), this.setAttribute("normal", new qn(d, 3)), this.setAttribute("uv", new qn(p, 2));
    function E(T) {
      const C = r.length / 3, D = T.extractPoints(t);
      let B = D.shape;
      const z = D.holes;
      qg.isClockWise(B) === !1 && (B = B.reverse());
      for (let G = 0, N = z.length; G < N; G++) {
        const F = z[G];
        qg.isClockWise(F) === !0 && (z[G] = F.reverse());
      }
      const V = qg.triangulateShape(B, z);
      for (let G = 0, N = z.length; G < N; G++) {
        const F = z[G];
        B = B.concat(F);
      }
      for (let G = 0, N = B.length; G < N; G++) {
        const F = B[G];
        r.push(F.x, F.y, 0), d.push(0, 0, 1), p.push(F.x, F.y);
      }
      for (let G = 0, N = V.length; G < N; G++) {
        const F = V[G], q = F[0] + C, Y = F[1] + C, ie = F[2] + C;
        a.push(q, Y, ie), _ += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return KH(t, e);
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @param {Array<Shape>} shapes - An array of shapes.
   * @return {ShapeGeometry} A new instance.
   */
  static fromJSON(e, t) {
    const a = [];
    for (let r = 0, d = e.shapes.length; r < d; r++) {
      const p = t[e.shapes[r]];
      a.push(p);
    }
    return new Rx(a, e.curveSegments);
  }
}
function KH(o, e) {
  if (e.shapes = [], Array.isArray(o))
    for (let t = 0, a = o.length; t < a; t++) {
      const r = o[t];
      e.shapes.push(r.uuid);
    }
  else
    e.shapes.push(o.uuid);
  return e;
}
class vE extends Pa {
  /**
   * Constructs a new sphere geometry.
   *
   * @param {number} [radius=1] - The sphere radius.
   * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
   * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
   * @param {number} [phiStart=0] - The horizontal starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
   * @param {number} [thetaStart=0] - The vertical starting angle in radians.
   * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
   */
  constructor(e = 1, t = 32, a = 16, r = 0, d = Math.PI * 2, p = 0, y = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: a,
      phiStart: r,
      phiLength: d,
      thetaStart: p,
      thetaLength: y
    }, t = Math.max(3, Math.floor(t)), a = Math.max(2, Math.floor(a));
    const _ = Math.min(p + y, Math.PI);
    let E = 0;
    const T = [], C = new ve(), D = new ve(), B = [], z = [], V = [], G = [];
    for (let N = 0; N <= a; N++) {
      const F = [], q = N / a;
      let Y = 0;
      N === 0 && p === 0 ? Y = 0.5 / t : N === a && _ === Math.PI && (Y = -0.5 / t);
      for (let ie = 0; ie <= t; ie++) {
        const k = ie / t;
        C.x = -e * Math.cos(r + k * d) * Math.sin(p + q * y), C.y = e * Math.cos(p + q * y), C.z = e * Math.sin(r + k * d) * Math.sin(p + q * y), z.push(C.x, C.y, C.z), D.copy(C).normalize(), V.push(D.x, D.y, D.z), G.push(k + Y, 1 - q), F.push(E++);
      }
      T.push(F);
    }
    for (let N = 0; N < a; N++)
      for (let F = 0; F < t; F++) {
        const q = T[N][F + 1], Y = T[N][F], ie = T[N + 1][F], k = T[N + 1][F + 1];
        (N !== 0 || p > 0) && B.push(q, Y, k), (N !== a - 1 || _ < Math.PI) && B.push(Y, ie, k);
      }
    this.setIndex(B), this.setAttribute("position", new qn(z, 3)), this.setAttribute("normal", new qn(V, 3)), this.setAttribute("uv", new qn(G, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {SphereGeometry} A new instance.
   */
  static fromJSON(e) {
    return new vE(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class Dx extends J0 {
  /**
   * Constructs a new tetrahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the tetrahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a tetrahedron.
   */
  constructor(e = 1, t = 0) {
    const a = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], r = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(a, r, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TetrahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Dx(e.radius, e.detail);
  }
}
class Bx extends Pa {
  /**
   * Constructs a new torus geometry.
   *
   * @param {number} [radius=1] - Radius of the torus, from the center of the torus to the center of the tube.
   * @param {number} [tube=0.4] - Radius of the tube. Must be smaller than `radius`.
   * @param {number} [radialSegments=12] - The number of radial segments.
   * @param {number} [tubularSegments=48] - The number of tubular segments.
   * @param {number} [arc=Math.PI*2] - Central angle in radians.
   */
  constructor(e = 1, t = 0.4, a = 12, r = 48, d = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: a,
      tubularSegments: r,
      arc: d
    }, a = Math.floor(a), r = Math.floor(r);
    const p = [], y = [], _ = [], E = [], T = new ve(), C = new ve(), D = new ve();
    for (let B = 0; B <= a; B++)
      for (let z = 0; z <= r; z++) {
        const V = z / r * d, G = B / a * Math.PI * 2;
        C.x = (e + t * Math.cos(G)) * Math.cos(V), C.y = (e + t * Math.cos(G)) * Math.sin(V), C.z = t * Math.sin(G), y.push(C.x, C.y, C.z), T.x = e * Math.cos(V), T.y = e * Math.sin(V), D.subVectors(C, T).normalize(), _.push(D.x, D.y, D.z), E.push(z / r), E.push(B / a);
      }
    for (let B = 1; B <= a; B++)
      for (let z = 1; z <= r; z++) {
        const V = (r + 1) * B + z - 1, G = (r + 1) * (B - 1) + z - 1, N = (r + 1) * (B - 1) + z, F = (r + 1) * B + z;
        p.push(V, G, F), p.push(G, N, F);
      }
    this.setIndex(p), this.setAttribute("position", new qn(y, 3)), this.setAttribute("normal", new qn(_, 3)), this.setAttribute("uv", new qn(E, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TorusGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Bx(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Ux extends Pa {
  /**
   * Constructs a new torus knot geometry.
   *
   * @param {number} [radius=1] - Radius of the torus knot.
   * @param {number} [tube=0.4] - Radius of the tube.
   * @param {number} [tubularSegments=64] - The number of tubular segments.
   * @param {number} [radialSegments=8] - The number of radial segments.
   * @param {number} [p=2] - This value determines, how many times the geometry winds around its axis of rotational symmetry.
   * @param {number} [q=3] - This value determines, how many times the geometry winds around a circle in the interior of the torus.
   */
  constructor(e = 1, t = 0.4, a = 64, r = 8, d = 2, p = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: a,
      radialSegments: r,
      p: d,
      q: p
    }, a = Math.floor(a), r = Math.floor(r);
    const y = [], _ = [], E = [], T = [], C = new ve(), D = new ve(), B = new ve(), z = new ve(), V = new ve(), G = new ve(), N = new ve();
    for (let q = 0; q <= a; ++q) {
      const Y = q / a * d * Math.PI * 2;
      F(Y, d, p, e, B), F(Y + 0.01, d, p, e, z), G.subVectors(z, B), N.addVectors(z, B), V.crossVectors(G, N), N.crossVectors(V, G), V.normalize(), N.normalize();
      for (let ie = 0; ie <= r; ++ie) {
        const k = ie / r * Math.PI * 2, le = -t * Math.cos(k), ne = t * Math.sin(k);
        C.x = B.x + (le * N.x + ne * V.x), C.y = B.y + (le * N.y + ne * V.y), C.z = B.z + (le * N.z + ne * V.z), _.push(C.x, C.y, C.z), D.subVectors(C, B).normalize(), E.push(D.x, D.y, D.z), T.push(q / a), T.push(ie / r);
      }
    }
    for (let q = 1; q <= a; q++)
      for (let Y = 1; Y <= r; Y++) {
        const ie = (r + 1) * (q - 1) + (Y - 1), k = (r + 1) * q + (Y - 1), le = (r + 1) * q + Y, ne = (r + 1) * (q - 1) + Y;
        y.push(ie, k, ne), y.push(k, le, ne);
      }
    this.setIndex(y), this.setAttribute("position", new qn(_, 3)), this.setAttribute("normal", new qn(E, 3)), this.setAttribute("uv", new qn(T, 2));
    function F(q, Y, ie, k, le) {
      const ne = Math.cos(q), Q = Math.sin(q), j = ie / Y * q, re = Math.cos(j);
      le.x = k * (2 + re) * 0.5 * ne, le.y = k * (2 + re) * Q * 0.5, le.z = k * Math.sin(j) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TorusKnotGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Ux(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class Ox extends Pa {
  /**
   * Constructs a new tube geometry.
   *
   * @param {Curve} [path=QuadraticBezierCurve3] - A 3D curve defining the path of the tube.
   * @param {number} [tubularSegments=64] - The number of segments that make up the tube.
   * @param {number} [radius=1] -The radius of the tube.
   * @param {number} [radialSegments=8] - The number of segments that make up the cross-section.
   * @param {boolean} [closed=false] - Whether the tube is closed or not.
   */
  constructor(e = new L2(new ve(-1, -1, 0), new ve(-1, 1, 0), new ve(1, 1, 0)), t = 64, a = 1, r = 8, d = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: a,
      radialSegments: r,
      closed: d
    };
    const p = e.computeFrenetFrames(t, d);
    this.tangents = p.tangents, this.normals = p.normals, this.binormals = p.binormals;
    const y = new ve(), _ = new ve(), E = new Ot();
    let T = new ve();
    const C = [], D = [], B = [], z = [];
    V(), this.setIndex(z), this.setAttribute("position", new qn(C, 3)), this.setAttribute("normal", new qn(D, 3)), this.setAttribute("uv", new qn(B, 2));
    function V() {
      for (let q = 0; q < t; q++)
        G(q);
      G(d === !1 ? t : 0), F(), N();
    }
    function G(q) {
      T = e.getPointAt(q / t, T);
      const Y = p.normals[q], ie = p.binormals[q];
      for (let k = 0; k <= r; k++) {
        const le = k / r * Math.PI * 2, ne = Math.sin(le), Q = -Math.cos(le);
        _.x = Q * Y.x + ne * ie.x, _.y = Q * Y.y + ne * ie.y, _.z = Q * Y.z + ne * ie.z, _.normalize(), D.push(_.x, _.y, _.z), y.x = T.x + a * _.x, y.y = T.y + a * _.y, y.z = T.z + a * _.z, C.push(y.x, y.y, y.z);
      }
    }
    function N() {
      for (let q = 1; q <= t; q++)
        for (let Y = 1; Y <= r; Y++) {
          const ie = (r + 1) * (q - 1) + (Y - 1), k = (r + 1) * q + (Y - 1), le = (r + 1) * q + Y, ne = (r + 1) * (q - 1) + Y;
          z.push(ie, k, ne), z.push(k, le, ne);
        }
    }
    function F() {
      for (let q = 0; q <= t; q++)
        for (let Y = 0; Y <= r; Y++)
          E.x = q / t, E.y = Y / r, B.push(E.x, E.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TubeGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Ox(
      new JM[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class NO extends Pa {
  /**
   * Constructs a new wireframe geometry.
   *
   * @param {?BufferGeometry} [geometry=null] - The geometry.
   */
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], a = /* @__PURE__ */ new Set(), r = new ve(), d = new ve();
      if (e.index !== null) {
        const p = e.attributes.position, y = e.index;
        let _ = e.groups;
        _.length === 0 && (_ = [{ start: 0, count: y.count, materialIndex: 0 }]);
        for (let E = 0, T = _.length; E < T; ++E) {
          const C = _[E], D = C.start, B = C.count;
          for (let z = D, V = D + B; z < V; z += 3)
            for (let G = 0; G < 3; G++) {
              const N = y.getX(z + G), F = y.getX(z + (G + 1) % 3);
              r.fromBufferAttribute(p, N), d.fromBufferAttribute(p, F), NB(r, d, a) === !0 && (t.push(r.x, r.y, r.z), t.push(d.x, d.y, d.z));
            }
        }
      } else {
        const p = e.attributes.position;
        for (let y = 0, _ = p.count / 3; y < _; y++)
          for (let E = 0; E < 3; E++) {
            const T = 3 * y + E, C = 3 * y + (E + 1) % 3;
            r.fromBufferAttribute(p, T), d.fromBufferAttribute(p, C), NB(r, d, a) === !0 && (t.push(r.x, r.y, r.z), t.push(d.x, d.y, d.z));
          }
      }
      this.setAttribute("position", new qn(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function NB(o, e, t) {
  const a = `${o.x},${o.y},${o.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${o.x},${o.y},${o.z}`;
  return t.has(a) === !0 || t.has(r) === !0 ? !1 : (t.add(a), t.add(r), !0);
}
var zB = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: j0,
  CapsuleGeometry: Ex,
  CircleGeometry: bx,
  ConeGeometry: Mx,
  CylinderGeometry: D1,
  DodecahedronGeometry: xx,
  EdgesGeometry: DO,
  ExtrudeGeometry: Tx,
  IcosahedronGeometry: pE,
  LatheGeometry: hE,
  OctahedronGeometry: mE,
  PlaneGeometry: Ky,
  PolyhedronGeometry: J0,
  RingGeometry: Cx,
  ShapeGeometry: Rx,
  SphereGeometry: vE,
  TetrahedronGeometry: Dx,
  TorusGeometry: Bx,
  TorusKnotGeometry: Ux,
  TubeGeometry: Ox,
  WireframeGeometry: NO
});
class zO extends Vu {
  /**
   * Constructs a new shadow material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new hn(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class HO extends iu {
  /**
   * Constructs a new raw shader material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class B1 extends Vu {
  /**
   * Constructs a new mesh standard material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new hn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Q0, this.normalScale = new Ot(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ip(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class jm extends B1 {
  /**
   * Constructs a new mesh physical material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ot(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Fa(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new hn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new hn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new hn(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  /**
   * The anisotropy strength.
   *
   * @type {number}
   * @default 0
   */
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  /**
   * Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
   * clear coat related properties to enable multilayer materials that have a
   * thin translucent layer over the base layer.
   *
   * @type {number}
   * @default 0
   */
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  /**
   * The intensity of the iridescence layer, simulating RGB color shift based on the angle between
   * the surface and the viewer, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  /**
   * Defines the strength of the angular separation of colors (chromatic aberration) transmitting
   * through a relatively clear volume. Any value zero or larger is valid, the typical range of
   * realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
   *
   * @type {number}
   * @default 0
   */
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  /**
   * The intensity of the sheen layer, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  /**
   * Degree of transmission (or optical transparency), from `0.0` to `1.0`.
   *
   * Thin, transparent or semitransparent, plastic or glass materials remain
   * largely reflective even if they are fully transmissive. The transmission
   * property can be used to model these materials.
   *
   * When transmission is non-zero, `opacity` should be  set to `1`.
   *
   * @type {number}
   * @default 0
   */
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class LO extends Vu {
  /**
   * Constructs a new mesh phong material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new hn(16777215), this.specular = new hn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Q0, this.normalScale = new Ot(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ip(), this.combine = aE, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class GO extends Vu {
  /**
   * Constructs a new mesh toon material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new hn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Q0, this.normalScale = new Ot(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class IO extends Vu {
  /**
   * Constructs a new mesh normal material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Q0, this.normalScale = new Ot(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class VO extends Vu {
  /**
   * Constructs a new mesh lambert material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new hn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new hn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Q0, this.normalScale = new Ot(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ip(), this.combine = aE, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class wx extends Vu {
  /**
   * Constructs a new mesh depth material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = aO, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class I2 extends Vu {
  /**
   * Constructs a new mesh distance material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
class FO extends Vu {
  /**
   * Constructs a new mesh matcap material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new hn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Q0, this.normalScale = new Ot(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class PO extends nd {
  /**
   * Constructs a new line dashed material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function YS(o, e) {
  return !o || o.constructor === e ? o : typeof e.BYTES_PER_ELEMENT == "number" ? new e(o) : Array.prototype.slice.call(o);
}
function XO(o) {
  return ArrayBuffer.isView(o) && !(o instanceof DataView);
}
function YO(o) {
  function e(r, d) {
    return o[r] - o[d];
  }
  const t = o.length, a = new Array(t);
  for (let r = 0; r !== t; ++r) a[r] = r;
  return a.sort(e), a;
}
function kC(o, e, t) {
  const a = o.length, r = new o.constructor(a);
  for (let d = 0, p = 0; p !== a; ++d) {
    const y = t[d] * e;
    for (let _ = 0; _ !== e; ++_)
      r[p++] = o[y + _];
  }
  return r;
}
function V2(o, e, t, a) {
  let r = 1, d = o[0];
  for (; d !== void 0 && d[a] === void 0; )
    d = o[r++];
  if (d === void 0) return;
  let p = d[a];
  if (p !== void 0)
    if (Array.isArray(p))
      do
        p = d[a], p !== void 0 && (e.push(d.time), t.push(...p)), d = o[r++];
      while (d !== void 0);
    else if (p.toArray !== void 0)
      do
        p = d[a], p !== void 0 && (e.push(d.time), p.toArray(t, t.length)), d = o[r++];
      while (d !== void 0);
    else
      do
        p = d[a], p !== void 0 && (e.push(d.time), t.push(p)), d = o[r++];
      while (d !== void 0);
}
function kH(o, e, t, a, r = 30) {
  const d = o.clone();
  d.name = e;
  const p = [];
  for (let _ = 0; _ < d.tracks.length; ++_) {
    const E = d.tracks[_], T = E.getValueSize(), C = [], D = [];
    for (let B = 0; B < E.times.length; ++B) {
      const z = E.times[B] * r;
      if (!(z < t || z >= a)) {
        C.push(E.times[B]);
        for (let V = 0; V < T; ++V)
          D.push(E.values[B * T + V]);
      }
    }
    C.length !== 0 && (E.times = YS(C, E.times.constructor), E.values = YS(D, E.values.constructor), p.push(E));
  }
  d.tracks = p;
  let y = 1 / 0;
  for (let _ = 0; _ < d.tracks.length; ++_)
    y > d.tracks[_].times[0] && (y = d.tracks[_].times[0]);
  for (let _ = 0; _ < d.tracks.length; ++_)
    d.tracks[_].shift(-1 * y);
  return d.resetDuration(), d;
}
function WH(o, e = 0, t = o, a = 30) {
  a <= 0 && (a = 30);
  const r = t.tracks.length, d = e / a;
  for (let p = 0; p < r; ++p) {
    const y = t.tracks[p], _ = y.ValueTypeName;
    if (_ === "bool" || _ === "string") continue;
    const E = o.tracks.find(function(N) {
      return N.name === y.name && N.ValueTypeName === _;
    });
    if (E === void 0) continue;
    let T = 0;
    const C = y.getValueSize();
    y.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (T = C / 3);
    let D = 0;
    const B = E.getValueSize();
    E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (D = B / 3);
    const z = y.times.length - 1;
    let V;
    if (d <= y.times[0]) {
      const N = T, F = C - T;
      V = y.values.slice(N, F);
    } else if (d >= y.times[z]) {
      const N = z * C + T, F = N + C - T;
      V = y.values.slice(N, F);
    } else {
      const N = y.createInterpolant(), F = T, q = C - T;
      N.evaluate(d), V = N.resultBuffer.slice(F, q);
    }
    _ === "quaternion" && new Ac().fromArray(V).normalize().conjugate().toArray(V);
    const G = E.times.length;
    for (let N = 0; N < G; ++N) {
      const F = N * B + D;
      if (_ === "quaternion")
        Ac.multiplyQuaternionsFlat(
          E.values,
          F,
          V,
          0,
          E.values,
          F
        );
      else {
        const q = B - D * 2;
        for (let Y = 0; Y < q; ++Y)
          E.values[F + Y] -= V[Y];
      }
    }
  }
  return o.blendMode = _2, o;
}
class $H {
  /**
   * Converts an array to a specific type
   *
   * @static
   * @param {TypedArray|Array} array - The array to convert.
   * @param {TypedArray.constructor} type - The constructor of a type array.
   * @return {TypedArray} The converted array
   */
  static convertArray(e, t) {
    return YS(e, t);
  }
  /**
   * Returns `true` if the given object is a typed array.
   *
   * @static
   * @param {any} object - The object to check.
   * @return {boolean} Whether the given object is a typed array.
   */
  static isTypedArray(e) {
    return XO(e);
  }
  /**
   * Returns an array by which times and values can be sorted.
   *
   * @static
   * @param {Array<number>} times - The keyframe time values.
   * @return {Array<number>} The array.
   */
  static getKeyframeOrder(e) {
    return YO(e);
  }
  /**
   * Sorts the given array by the previously computed order via `getKeyframeOrder()`.
   *
   * @static
   * @param {Array<number>} values - The values to sort.
   * @param {number} stride - The stride.
   * @param {Array<number>} order - The sort order.
   * @return {Array<number>} The sorted values.
   */
  static sortedArray(e, t, a) {
    return kC(e, t, a);
  }
  /**
   * Used for parsing AOS keyframe formats.
   *
   * @static
   * @param {Array<number>} jsonKeys - A list of JSON keyframes.
   * @param {Array<number>} times - This array will be filled with keyframe times by this method.
   * @param {Array<number>} values - This array will be filled with keyframe values by this method.
   * @param {string} valuePropertyName - The name of the property to use.
   */
  static flattenJSON(e, t, a, r) {
    V2(e, t, a, r);
  }
  /**
   * Creates a new clip, containing only the segment of the original clip between the given frames.
   *
   * @static
   * @param {AnimationClip} sourceClip - The values to sort.
   * @param {string} name - The name of the clip.
   * @param {number} startFrame - The start frame.
   * @param {number} endFrame - The end frame.
   * @param {number} [fps=30] - The FPS.
   * @return {AnimationClip} The new sub clip.
   */
  static subclip(e, t, a, r, d = 30) {
    return kH(e, t, a, r, d);
  }
  /**
   * Converts the keyframes of the given animation clip to an additive format.
   *
   * @static
   * @param {AnimationClip} targetClip - The clip to make additive.
   * @param {number} [referenceFrame=0] - The reference frame.
   * @param {AnimationClip} [referenceClip=targetClip] - The reference clip.
   * @param {number} [fps=30] - The FPS.
   * @return {AnimationClip} The updated clip which is now additive.
   */
  static makeClipAdditive(e, t = 0, a = e, r = 30) {
    return WH(e, t, a, r);
  }
}
class U1 {
  /**
   * Constructs a new interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, a, r) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(a), this.sampleValues = t, this.valueSize = a, this.settings = null, this.DefaultSettings_ = {};
  }
  /**
   * Evaluate the interpolant at position `t`.
   *
   * @param {number} t - The interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  evaluate(e) {
    const t = this.parameterPositions;
    let a = this._cachedIndex, r = t[a], d = t[a - 1];
    e: {
      t: {
        let p;
        n: {
          a: if (!(e < r)) {
            for (let y = a + 2; ; ) {
              if (r === void 0) {
                if (e < d) break a;
                return a = t.length, this._cachedIndex = a, this.copySampleValue_(a - 1);
              }
              if (a === y) break;
              if (d = r, r = t[++a], e < r)
                break t;
            }
            p = t.length;
            break n;
          }
          if (!(e >= d)) {
            const y = t[1];
            e < y && (a = 2, d = y);
            for (let _ = a - 2; ; ) {
              if (d === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (a === _) break;
              if (r = d, d = t[--a - 1], e >= d)
                break t;
            }
            p = a, a = 0;
            break n;
          }
          break e;
        }
        for (; a < p; ) {
          const y = a + p >>> 1;
          e < t[y] ? p = y : a = y + 1;
        }
        if (r = t[a], d = t[a - 1], d === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (r === void 0)
          return a = t.length, this._cachedIndex = a, this.copySampleValue_(a - 1);
      }
      this._cachedIndex = a, this.intervalChanged_(a, d, r);
    }
    return this.interpolate_(a, d, e, r);
  }
  /**
   * Returns the interpolation settings.
   *
   * @return {Object} The interpolation settings.
   */
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @param {number} index - An index into the sample value buffer.
   * @return {TypedArray} The result buffer.
   */
  copySampleValue_(e) {
    const t = this.resultBuffer, a = this.sampleValues, r = this.valueSize, d = e * r;
    for (let p = 0; p !== r; ++p)
      t[p] = a[d + p];
    return t;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @abstract
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   * @param {number} t1 - The next interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  interpolate_() {
    throw new Error("call to abstract method");
  }
  /**
   * Optional method that is executed when the interval has changed.
   *
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   */
  intervalChanged_() {
  }
}
class qO extends U1 {
  /**
   * Constructs a new cubic interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, a, r) {
    super(e, t, a, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: FS,
      endingEnd: FS
    };
  }
  intervalChanged_(e, t, a) {
    const r = this.parameterPositions;
    let d = e - 2, p = e + 1, y = r[d], _ = r[p];
    if (y === void 0)
      switch (this.getSettings_().endingStart) {
        case PS:
          d = e, y = 2 * t - a;
          break;
        case qA:
          d = r.length - 2, y = t + r[d] - r[d + 1];
          break;
        default:
          d = e, y = a;
      }
    if (_ === void 0)
      switch (this.getSettings_().endingEnd) {
        case PS:
          p = e, _ = 2 * a - t;
          break;
        case qA:
          p = 1, _ = a + r[1] - r[0];
          break;
        default:
          p = e - 1, _ = t;
      }
    const E = (a - t) * 0.5, T = this.valueSize;
    this._weightPrev = E / (t - y), this._weightNext = E / (_ - a), this._offsetPrev = d * T, this._offsetNext = p * T;
  }
  interpolate_(e, t, a, r) {
    const d = this.resultBuffer, p = this.sampleValues, y = this.valueSize, _ = e * y, E = _ - y, T = this._offsetPrev, C = this._offsetNext, D = this._weightPrev, B = this._weightNext, z = (a - t) / (r - t), V = z * z, G = V * z, N = -D * G + 2 * D * V - D * z, F = (1 + D) * G + (-1.5 - 2 * D) * V + (-0.5 + D) * z + 1, q = (-1 - B) * G + (1.5 + B) * V + 0.5 * z, Y = B * G - B * V;
    for (let ie = 0; ie !== y; ++ie)
      d[ie] = N * p[T + ie] + F * p[E + ie] + q * p[_ + ie] + Y * p[C + ie];
    return d;
  }
}
class F2 extends U1 {
  /**
   * Constructs a new linear interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, a, r) {
    super(e, t, a, r);
  }
  interpolate_(e, t, a, r) {
    const d = this.resultBuffer, p = this.sampleValues, y = this.valueSize, _ = e * y, E = _ - y, T = (a - t) / (r - t), C = 1 - T;
    for (let D = 0; D !== y; ++D)
      d[D] = p[E + D] * C + p[_ + D] * T;
    return d;
  }
}
class ZO extends U1 {
  /**
   * Constructs a new discrete interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, a, r) {
    super(e, t, a, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Jm {
  /**
   * Constructs a new keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, t, a, r) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = YS(t, this.TimeBufferType), this.values = YS(a, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  /**
   * Converts the keyframe track to JSON.
   *
   * @static
   * @param {KeyframeTrack} track - The keyframe track to serialize.
   * @return {Object} The serialized keyframe track as JSON.
   */
  static toJSON(e) {
    const t = e.constructor;
    let a;
    if (t.toJSON !== this.toJSON)
      a = t.toJSON(e);
    else {
      a = {
        name: e.name,
        times: YS(e.times, Array),
        values: YS(e.values, Array)
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (a.interpolation = r);
    }
    return a.type = e.ValueTypeName, a;
  }
  /**
   * Factory method for creating a new discrete interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {DiscreteInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodDiscrete(e) {
    return new ZO(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Factory method for creating a new linear interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {LinearInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodLinear(e) {
    return new F2(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Factory method for creating a new smooth interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {CubicInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodSmooth(e) {
    return new qO(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Defines the interpolation factor method for this keyframe track.
   *
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} interpolation - The interpolation type.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  setInterpolation(e) {
    let t;
    switch (e) {
      case y1:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case S1:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case iM:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const a = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(a);
      return console.warn("THREE.KeyframeTrack:", a), this;
    }
    return this.createInterpolant = t, this;
  }
  /**
   * Returns the current interpolation type.
   *
   * @return {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} The interpolation type.
   */
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return y1;
      case this.InterpolantFactoryMethodLinear:
        return S1;
      case this.InterpolantFactoryMethodSmooth:
        return iM;
    }
  }
  /**
   * Returns the value size.
   *
   * @return {number} The value size.
   */
  getValueSize() {
    return this.values.length / this.times.length;
  }
  /**
   * Moves all keyframes either forward or backward in time.
   *
   * @param {number} timeOffset - The offset to move the time values.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let a = 0, r = t.length; a !== r; ++a)
        t[a] += e;
    }
    return this;
  }
  /**
   * Scale all keyframe times by a factor (useful for frame - seconds conversions).
   *
   * @param {number} timeScale - The time scale.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let a = 0, r = t.length; a !== r; ++a)
        t[a] *= e;
    }
    return this;
  }
  /**
   * Removes keyframes before and after animation without changing any values within the defined time range.
   *
   * Note: The method does not shift around keys to the start of the track time, because for interpolated
   * keys this will change their values
   *
   * @param {number} startTime - The start time.
   * @param {number} endTime - The end time.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  trim(e, t) {
    const a = this.times, r = a.length;
    let d = 0, p = r - 1;
    for (; d !== r && a[d] < e; )
      ++d;
    for (; p !== -1 && a[p] > t; )
      --p;
    if (++p, d !== 0 || p !== r) {
      d >= p && (p = Math.max(p, 1), d = p - 1);
      const y = this.getValueSize();
      this.times = a.slice(d, p), this.values = this.values.slice(d * y, p * y);
    }
    return this;
  }
  /**
   * Performs minimal validation on the keyframe track. Returns `true` if the values
   * are valid.
   *
   * @return {boolean} Whether the keyframes are valid or not.
   */
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const a = this.times, r = this.values, d = a.length;
    d === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let p = null;
    for (let y = 0; y !== d; y++) {
      const _ = a[y];
      if (typeof _ == "number" && isNaN(_)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, y, _), e = !1;
        break;
      }
      if (p !== null && p > _) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, y, _, p), e = !1;
        break;
      }
      p = _;
    }
    if (r !== void 0 && XO(r))
      for (let y = 0, _ = r.length; y !== _; ++y) {
        const E = r[y];
        if (isNaN(E)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, y, E), e = !1;
          break;
        }
      }
    return e;
  }
  /**
   * Optimizes this keyframe track by removing equivalent sequential keys (which are
   * common in morph target sequences).
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), a = this.getValueSize(), r = this.getInterpolation() === iM, d = e.length - 1;
    let p = 1;
    for (let y = 1; y < d; ++y) {
      let _ = !1;
      const E = e[y], T = e[y + 1];
      if (E !== T && (y !== 1 || E !== e[0]))
        if (r)
          _ = !0;
        else {
          const C = y * a, D = C - a, B = C + a;
          for (let z = 0; z !== a; ++z) {
            const V = t[C + z];
            if (V !== t[D + z] || V !== t[B + z]) {
              _ = !0;
              break;
            }
          }
        }
      if (_) {
        if (y !== p) {
          e[p] = e[y];
          const C = y * a, D = p * a;
          for (let B = 0; B !== a; ++B)
            t[D + B] = t[C + B];
        }
        ++p;
      }
    }
    if (d > 0) {
      e[p] = e[d];
      for (let y = d * a, _ = p * a, E = 0; E !== a; ++E)
        t[_ + E] = t[y + E];
      ++p;
    }
    return p !== e.length ? (this.times = e.slice(0, p), this.values = t.slice(0, p * a)) : (this.times = e, this.values = t), this;
  }
  /**
   * Returns a new keyframe track with copied values from this instance.
   *
   * @return {KeyframeTrack} A clone of this instance.
   */
  clone() {
    const e = this.times.slice(), t = this.values.slice(), a = this.constructor, r = new a(this.name, e, t);
    return r.createInterpolant = this.createInterpolant, r;
  }
}
Jm.prototype.ValueTypeName = "";
Jm.prototype.TimeBufferType = Float32Array;
Jm.prototype.ValueBufferType = Float32Array;
Jm.prototype.DefaultInterpolation = S1;
class s_ extends Jm {
  /**
   * Constructs a new boolean keyframe track.
   *
   * This keyframe track type has no `interpolation` parameter because the
   * interpolation is always discrete.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   */
  constructor(e, t, a) {
    super(e, t, a);
  }
}
s_.prototype.ValueTypeName = "bool";
s_.prototype.ValueBufferType = Array;
s_.prototype.DefaultInterpolation = y1;
s_.prototype.InterpolantFactoryMethodLinear = void 0;
s_.prototype.InterpolantFactoryMethodSmooth = void 0;
class P2 extends Jm {
  /**
   * Constructs a new color keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, t, a, r) {
    super(e, t, a, r);
  }
}
P2.prototype.ValueTypeName = "color";
class t_ extends Jm {
  /**
   * Constructs a new number keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, t, a, r) {
    super(e, t, a, r);
  }
}
t_.prototype.ValueTypeName = "number";
class QO extends U1 {
  /**
   * Constructs a new SLERP interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, a, r) {
    super(e, t, a, r);
  }
  interpolate_(e, t, a, r) {
    const d = this.resultBuffer, p = this.sampleValues, y = this.valueSize, _ = (a - t) / (r - t);
    let E = e * y;
    for (let T = E + y; E !== T; E += 4)
      Ac.slerpFlat(d, 0, p, E - y, p, E, _);
    return d;
  }
}
class n_ extends Jm {
  /**
   * Constructs a new Quaternion keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, t, a, r) {
    super(e, t, a, r);
  }
  /**
   * Overwritten so the method returns Quaternion based interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {QuaternionLinearInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodLinear(e) {
    return new QO(this.times, this.values, this.getValueSize(), e);
  }
}
n_.prototype.ValueTypeName = "quaternion";
n_.prototype.InterpolantFactoryMethodSmooth = void 0;
class r_ extends Jm {
  /**
   * Constructs a new string keyframe track.
   *
   * This keyframe track type has no `interpolation` parameter because the
   * interpolation is always discrete.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   */
  constructor(e, t, a) {
    super(e, t, a);
  }
}
r_.prototype.ValueTypeName = "string";
r_.prototype.ValueBufferType = Array;
r_.prototype.DefaultInterpolation = y1;
r_.prototype.InterpolantFactoryMethodLinear = void 0;
r_.prototype.InterpolantFactoryMethodSmooth = void 0;
class a_ extends Jm {
  /**
   * Constructs a new vector keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, t, a, r) {
    super(e, t, a, r);
  }
}
a_.prototype.ValueTypeName = "vector";
class M1 {
  /**
   * Constructs a new animation clip.
   *
   * Note: Instead of instantiating an AnimationClip directly with the constructor, you can
   * use the static interface of this class for creating clips. In most cases though, animation clips
   * will automatically be created by loaders when importing animated 3D assets.
   *
   * @param {string} [name=''] - The clip's name.
   * @param {number} [duration=-1] - The clip's duration in seconds. If a negative value is passed,
   * the duration will be calculated from the passed keyframes.
   * @param {Array<KeyframeTrack>} tracks - An array of keyframe tracks.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode=NormalAnimationBlendMode] - Defines how the animation
   * is blended/combined when two or more animations are simultaneously played.
   */
  constructor(e = "", t = -1, a = [], r = fx) {
    this.name = e, this.tracks = a, this.duration = t, this.blendMode = r, this.uuid = Gp(), this.duration < 0 && this.resetDuration();
  }
  /**
   * Factory method for creating an animation clip from the given JSON.
   *
   * @static
   * @param {Object} json - The serialized animation clip.
   * @return {AnimationClip} The new animation clip.
   */
  static parse(e) {
    const t = [], a = e.tracks, r = 1 / (e.fps || 1);
    for (let p = 0, y = a.length; p !== y; ++p)
      t.push(t4(a[p]).scale(r));
    const d = new this(e.name, e.duration, t, e.blendMode);
    return d.uuid = e.uuid, d;
  }
  /**
   * Serializes the given animation clip into JSON.
   *
   * @static
   * @param {AnimationClip} clip - The animation clip to serialize.
   * @return {Object} The JSON object.
   */
  static toJSON(e) {
    const t = [], a = e.tracks, r = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let d = 0, p = a.length; d !== p; ++d)
      t.push(Jm.toJSON(a[d]));
    return r;
  }
  /**
   * Returns a new animation clip from the passed morph targets array of a
   * geometry, taking a name and the number of frames per second.
   *
   * Note: The fps parameter is required, but the animation speed can be
   * overridden via {@link AnimationAction#setDuration}.
   *
   * @static
   * @param {string} name - The name of the animation clip.
   * @param {Array<Object>} morphTargetSequence - A sequence of morph targets.
   * @param {number} fps - The Frames-Per-Second value.
   * @param {boolean} noLoop - Whether the clip should be no loop or not.
   * @return {AnimationClip} The new animation clip.
   */
  static CreateFromMorphTargetSequence(e, t, a, r) {
    const d = t.length, p = [];
    for (let y = 0; y < d; y++) {
      let _ = [], E = [];
      _.push(
        (y + d - 1) % d,
        y,
        (y + 1) % d
      ), E.push(0, 1, 0);
      const T = YO(_);
      _ = kC(_, 1, T), E = kC(E, 1, T), !r && _[0] === 0 && (_.push(d), E.push(E[0])), p.push(
        new t_(
          ".morphTargetInfluences[" + t[y].name + "]",
          _,
          E
        ).scale(1 / a)
      );
    }
    return new this(e, -1, p);
  }
  /**
   * Searches for an animation clip by name, taking as its first parameter
   * either an array of clips, or a mesh or geometry that contains an
   * array named "animations" property.
   *
   * @static
   * @param {(Array<AnimationClip>|Object3D)} objectOrClipArray - The array or object to search through.
   * @param {string} name - The name to search for.
   * @return {?AnimationClip} The found animation clip. Returns `null` if no clip has been found.
   */
  static findByName(e, t) {
    let a = e;
    if (!Array.isArray(e)) {
      const r = e;
      a = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < a.length; r++)
      if (a[r].name === t)
        return a[r];
    return null;
  }
  /**
   * Returns an array of new AnimationClips created from the morph target
   * sequences of a geometry, trying to sort morph target names into
   * animation-group-based patterns like "Walk_001, Walk_002, Run_001, Run_002...".
   *
   * See {@link MD2Loader#parse} as an example for how the method should be used.
   *
   * @static
   * @param {Array<Object>} morphTargets - A sequence of morph targets.
   * @param {number} fps - The Frames-Per-Second value.
   * @param {boolean} noLoop - Whether the clip should be no loop or not.
   * @return {Array<AnimationClip>} An array of new animation clips.
   */
  static CreateClipsFromMorphTargetSequences(e, t, a) {
    const r = {}, d = /^([\w-]*?)([\d]+)$/;
    for (let y = 0, _ = e.length; y < _; y++) {
      const E = e[y], T = E.name.match(d);
      if (T && T.length > 1) {
        const C = T[1];
        let D = r[C];
        D || (r[C] = D = []), D.push(E);
      }
    }
    const p = [];
    for (const y in r)
      p.push(this.CreateFromMorphTargetSequence(y, r[y], t, a));
    return p;
  }
  /**
   * Parses the `animation.hierarchy` format and returns a new animation clip.
   *
   * @static
   * @deprecated since r175.
   * @param {Object} animation - A serialized animation clip as JSON.
   * @param {Array<Bones>} bones - An array of bones.
   * @return {?AnimationClip} The new animation clip.
   */
  static parseAnimation(e, t) {
    if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const a = function(C, D, B, z, V) {
      if (B.length !== 0) {
        const G = [], N = [];
        V2(B, G, N, z), G.length !== 0 && V.push(new C(D, G, N));
      }
    }, r = [], d = e.name || "default", p = e.fps || 30, y = e.blendMode;
    let _ = e.length || -1;
    const E = e.hierarchy || [];
    for (let C = 0; C < E.length; C++) {
      const D = E[C].keys;
      if (!(!D || D.length === 0))
        if (D[0].morphTargets) {
          const B = {};
          let z;
          for (z = 0; z < D.length; z++)
            if (D[z].morphTargets)
              for (let V = 0; V < D[z].morphTargets.length; V++)
                B[D[z].morphTargets[V]] = -1;
          for (const V in B) {
            const G = [], N = [];
            for (let F = 0; F !== D[z].morphTargets.length; ++F) {
              const q = D[z];
              G.push(q.time), N.push(q.morphTarget === V ? 1 : 0);
            }
            r.push(new t_(".morphTargetInfluence[" + V + "]", G, N));
          }
          _ = B.length * p;
        } else {
          const B = ".bones[" + t[C].name + "]";
          a(
            a_,
            B + ".position",
            D,
            "pos",
            r
          ), a(
            n_,
            B + ".quaternion",
            D,
            "rot",
            r
          ), a(
            a_,
            B + ".scale",
            D,
            "scl",
            r
          );
        }
    }
    return r.length === 0 ? null : new this(d, _, r, y);
  }
  /**
   * Sets the duration of this clip to the duration of its longest keyframe track.
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let a = 0, r = e.length; a !== r; ++a) {
      const d = this.tracks[a];
      t = Math.max(t, d.times[d.times.length - 1]);
    }
    return this.duration = t, this;
  }
  /**
   * Trims all tracks to the clip's duration.
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  /**
   * Performs minimal validation on each track in the clip. Returns `true` if all
   * tracks are valid.
   *
   * @return {boolean} Whether the clip's keyframes are valid or not.
   */
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  /**
   * Optimizes each track by removing equivalent sequential keys (which are
   * common in morph target sequences).
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  /**
   * Returns a new animation clip with copied values from this instance.
   *
   * @return {AnimationClip} A clone of this instance.
   */
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  /**
   * Serializes this animation clip into JSON.
   *
   * @return {Object} The JSON object.
   */
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function e4(o) {
  switch (o.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return t_;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return a_;
    case "color":
      return P2;
    case "quaternion":
      return n_;
    case "bool":
    case "boolean":
      return s_;
    case "string":
      return r_;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + o);
}
function t4(o) {
  if (o.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = e4(o.type);
  if (o.times === void 0) {
    const t = [], a = [];
    V2(o.keys, t, a, "value"), o.times = t, o.values = a;
  }
  return e.parse !== void 0 ? e.parse(o) : new e(o.name, o.times, o.values, o.interpolation);
}
const Yy = {
  /**
   * Whether caching is enabled or not.
   *
   * @static
   * @type {boolean}
   * @default false
   */
  enabled: !1,
  /**
   * A dictionary that holds cached files.
   *
   * @static
   * @type {Object<string,Object>}
   */
  files: {},
  /**
   * Adds a cache entry with a key to reference the file. If this key already
   * holds a file, it is overwritten.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   * @param {Object} file -  The file to be cached.
   */
  add: function(o, e) {
    this.enabled !== !1 && (this.files[o] = e);
  },
  /**
   * Gets the cached value for the given key.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   * @return {Object|undefined} The cached file. If the key does not exist `undefined` is returned.
   */
  get: function(o) {
    if (this.enabled !== !1)
      return this.files[o];
  },
  /**
   * Removes the cached file associated with the given key.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   */
  remove: function(o) {
    delete this.files[o];
  },
  /**
   * Remove all values from the cache.
   *
   * @static
   */
  clear: function() {
    this.files = {};
  }
};
class Nx {
  /**
   * Constructs a new loading manager.
   *
   * @param {Function} [onLoad] - Executes when all items have been loaded.
   * @param {Function} [onProgress] - Executes when single items have been loaded.
   * @param {Function} [onError] - Executes when an error occurs.
   */
  constructor(e, t, a) {
    const r = this;
    let d = !1, p = 0, y = 0, _;
    const E = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = a, this.itemStart = function(T) {
      y++, d === !1 && r.onStart !== void 0 && r.onStart(T, p, y), d = !0;
    }, this.itemEnd = function(T) {
      p++, r.onProgress !== void 0 && r.onProgress(T, p, y), p === y && (d = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(T) {
      r.onError !== void 0 && r.onError(T);
    }, this.resolveURL = function(T) {
      return _ ? _(T) : T;
    }, this.setURLModifier = function(T) {
      return _ = T, this;
    }, this.addHandler = function(T, C) {
      return E.push(T, C), this;
    }, this.removeHandler = function(T) {
      const C = E.indexOf(T);
      return C !== -1 && E.splice(C, 2), this;
    }, this.getHandler = function(T) {
      for (let C = 0, D = E.length; C < D; C += 2) {
        const B = E[C], z = E[C + 1];
        if (B.global && (B.lastIndex = 0), B.test(T))
          return z;
      }
      return null;
    };
  }
}
const o1 = /* @__PURE__ */ new Nx();
class cf {
  /**
   * Constructs a new loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    this.manager = e !== void 0 ? e : o1, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  /**
   * This method needs to be implemented by all concrete loaders. It holds the
   * logic for loading assets from the backend.
   *
   * @param {string} url - The path/URL of the file to be loaded.
   * @param {Function} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
   * @param {onErrorCallback} [onError] - Executed when errors occur.
   */
  load() {
  }
  /**
   * A async version of {@link Loader#load}.
   *
   * @param {string} url - The path/URL of the file to be loaded.
   * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
   * @return {Promise} A Promise that resolves when the asset has been loaded.
   */
  loadAsync(e, t) {
    const a = this;
    return new Promise(function(r, d) {
      a.load(e, r, t, d);
    });
  }
  /**
   * This method needs to be implemented by all concrete loaders. It holds the
   * logic for parsing the asset into three.js entities.
   *
   * @param {any} data - The data to parse.
   */
  parse() {
  }
  /**
   * Sets the `crossOrigin` String to implement CORS for loading the URL
   * from a different domain that allows CORS.
   *
   * @param {string} crossOrigin - The `crossOrigin` value.
   * @return {Loader} A reference to this instance.
   */
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  /**
   * Whether the XMLHttpRequest uses credentials such as cookies, authorization
   * headers or TLS client certificates, see [XMLHttpRequest.withCredentials]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials}.
   *
   * Note: This setting has no effect if you are loading files locally or from the same domain.
   *
   * @param {boolean} value - The `withCredentials` value.
   * @return {Loader} A reference to this instance.
   */
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  /**
   * Sets the base path for the asset.
   *
   * @param {string} path - The base path.
   * @return {Loader} A reference to this instance.
   */
  setPath(e) {
    return this.path = e, this;
  }
  /**
   * Sets the base path for dependent resources like textures.
   *
   * @param {string} resourcePath - The resource path.
   * @return {Loader} A reference to this instance.
   */
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  /**
   * Sets the given request header.
   *
   * @param {Object} requestHeader - A [request header]{@link https://developer.mozilla.org/en-US/docs/Glossary/Request_header}
   * for configuring the HTTP request.
   * @return {Loader} A reference to this instance.
   */
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
cf.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Ly = {};
class n4 extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class of extends cf {
  /**
   * Constructs a new file loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e), this.mimeType = "", this.responseType = "";
  }
  /**
   * Starts loading from the given URL and pass the loaded response to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(any)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
   * @param {onErrorCallback} [onError] - Executed when errors occur.
   * @return {any|undefined} The cached resource if available.
   */
  load(e, t, a, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const d = Yy.get(e);
    if (d !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(d), this.manager.itemEnd(e);
      }, 0), d;
    if (Ly[e] !== void 0) {
      Ly[e].push({
        onLoad: t,
        onProgress: a,
        onError: r
      });
      return;
    }
    Ly[e] = [], Ly[e].push({
      onLoad: t,
      onProgress: a,
      onError: r
    });
    const p = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), y = this.mimeType, _ = this.responseType;
    fetch(p).then((E) => {
      if (E.status === 200 || E.status === 0) {
        if (E.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || E.body === void 0 || E.body.getReader === void 0)
          return E;
        const T = Ly[e], C = E.body.getReader(), D = E.headers.get("X-File-Size") || E.headers.get("Content-Length"), B = D ? parseInt(D) : 0, z = B !== 0;
        let V = 0;
        const G = new ReadableStream({
          start(N) {
            F();
            function F() {
              C.read().then(({ done: q, value: Y }) => {
                if (q)
                  N.close();
                else {
                  V += Y.byteLength;
                  const ie = new ProgressEvent("progress", { lengthComputable: z, loaded: V, total: B });
                  for (let k = 0, le = T.length; k < le; k++) {
                    const ne = T[k];
                    ne.onProgress && ne.onProgress(ie);
                  }
                  N.enqueue(Y), F();
                }
              }, (q) => {
                N.error(q);
              });
            }
          }
        });
        return new Response(G);
      } else
        throw new n4(`fetch for "${E.url}" responded with ${E.status}: ${E.statusText}`, E);
    }).then((E) => {
      switch (_) {
        case "arraybuffer":
          return E.arrayBuffer();
        case "blob":
          return E.blob();
        case "document":
          return E.text().then((T) => new DOMParser().parseFromString(T, y));
        case "json":
          return E.json();
        default:
          if (y === "")
            return E.text();
          {
            const C = /charset="?([^;"\s]*)"?/i.exec(y), D = C && C[1] ? C[1].toLowerCase() : void 0, B = new TextDecoder(D);
            return E.arrayBuffer().then((z) => B.decode(z));
          }
      }
    }).then((E) => {
      Yy.add(e, E);
      const T = Ly[e];
      delete Ly[e];
      for (let C = 0, D = T.length; C < D; C++) {
        const B = T[C];
        B.onLoad && B.onLoad(E);
      }
    }).catch((E) => {
      const T = Ly[e];
      if (T === void 0)
        throw this.manager.itemError(e), E;
      delete Ly[e];
      for (let C = 0, D = T.length; C < D; C++) {
        const B = T[C];
        B.onError && B.onError(E);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  /**
   * Sets the expected response type.
   *
   * @param {('arraybuffer'|'blob'|'document'|'json'|'')} value - The response type.
   * @return {FileLoader} A reference to this file loader.
   */
  setResponseType(e) {
    return this.responseType = e, this;
  }
  /**
   * Sets the expected mime type of the loaded file.
   *
   * @param {string} value - The mime type.
   * @return {FileLoader} A reference to this file loader.
   */
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class a4 extends cf {
  /**
   * Constructs a new animation loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and pass the loaded animations as an array
   * holding instances of {@link AnimationClip} to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Array<AnimationClip>)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(e, t, a, r) {
    const d = this, p = new of(this.manager);
    p.setPath(this.path), p.setRequestHeader(this.requestHeader), p.setWithCredentials(this.withCredentials), p.load(e, function(y) {
      try {
        t(d.parse(JSON.parse(y)));
      } catch (_) {
        r ? r(_) : console.error(_), d.manager.itemError(e);
      }
    }, a, r);
  }
  /**
   * Parses the given JSON object and returns an array of animation clips.
   *
   * @param {Object} json - The serialized animation clips.
   * @return {Array<AnimationClip>} The parsed animation clips.
   */
  parse(e) {
    const t = [];
    for (let a = 0; a < e.length; a++) {
      const r = M1.parse(e[a]);
      t.push(r);
    }
    return t;
  }
}
class i4 extends cf {
  /**
   * Constructs a new compressed texture loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and passes the loaded compressed texture
   * to the `onLoad()` callback. The method also returns a new texture object which can
   * directly be used for material creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(CompressedTexture)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {CompressedTexture} The compressed texture.
   */
  load(e, t, a, r) {
    const d = this, p = [], y = new Sx(), _ = new of(this.manager);
    _.setPath(this.path), _.setResponseType("arraybuffer"), _.setRequestHeader(this.requestHeader), _.setWithCredentials(d.withCredentials);
    let E = 0;
    function T(C) {
      _.load(e[C], function(D) {
        const B = d.parse(D, !0);
        p[C] = {
          width: B.width,
          height: B.height,
          format: B.format,
          mipmaps: B.mipmaps
        }, E += 1, E === 6 && (B.mipmapCount === 1 && (y.minFilter = Ni), y.image = p, y.format = B.format, y.needsUpdate = !0, t && t(y));
      }, a, r);
    }
    if (Array.isArray(e))
      for (let C = 0, D = e.length; C < D; ++C)
        T(C);
    else
      _.load(e, function(C) {
        const D = d.parse(C, !0);
        if (D.isCubemap) {
          const B = D.mipmaps.length / D.mipmapCount;
          for (let z = 0; z < B; z++) {
            p[z] = { mipmaps: [] };
            for (let V = 0; V < D.mipmapCount; V++)
              p[z].mipmaps.push(D.mipmaps[z * D.mipmapCount + V]), p[z].format = D.format, p[z].width = D.width, p[z].height = D.height;
          }
          y.image = p;
        } else
          y.image.width = D.width, y.image.height = D.height, y.mipmaps = D.mipmaps;
        D.mipmapCount === 1 && (y.minFilter = Ni), y.format = D.format, y.needsUpdate = !0, t && t(y);
      }, a, r);
    return y;
  }
}
class eE extends cf {
  /**
   * Constructs a new image loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and passes the loaded image
   * to the `onLoad()` callback. The method also returns a new `Image` object which can
   * directly be used for texture creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Image)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {Image} The image.
   */
  load(e, t, a, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const d = this, p = Yy.get(e);
    if (p !== void 0)
      return d.manager.itemStart(e), setTimeout(function() {
        t && t(p), d.manager.itemEnd(e);
      }, 0), p;
    const y = JA("img");
    function _() {
      T(), Yy.add(e, this), t && t(this), d.manager.itemEnd(e);
    }
    function E(C) {
      T(), r && r(C), d.manager.itemError(e), d.manager.itemEnd(e);
    }
    function T() {
      y.removeEventListener("load", _, !1), y.removeEventListener("error", E, !1);
    }
    return y.addEventListener("load", _, !1), y.addEventListener("error", E, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (y.crossOrigin = this.crossOrigin), d.manager.itemStart(e), y.src = e, y;
  }
}
class jO extends cf {
  /**
   * Constructs a new cube texture loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and pass the fully loaded cube texture
   * to the `onLoad()` callback. The method also returns a new cube texture object which can
   * directly be used for material creation. If you do it this way, the cube texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {Array<string>} urls - Array of 6 URLs to images, one for each side of the
   * cube texture. The urls should be specified in the following order: pos-x,
   * neg-x, pos-y, neg-y, pos-z, neg-z. An array of data URIs are allowed as well.
   * @param {function(CubeTexture)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {CubeTexture} The cube texture.
   */
  load(e, t, a, r) {
    const d = new uE();
    d.colorSpace = lf;
    const p = new eE(this.manager);
    p.setCrossOrigin(this.crossOrigin), p.setPath(this.path);
    let y = 0;
    function _(E) {
      p.load(e[E], function(T) {
        d.images[E] = T, y++, y === 6 && (d.needsUpdate = !0, t && t(d));
      }, void 0, r);
    }
    for (let E = 0; E < e.length; ++E)
      _(E);
    return d;
  }
}
class X2 extends cf {
  /**
   * Constructs a new data texture loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and passes the loaded data texture
   * to the `onLoad()` callback. The method also returns a new texture object which can
   * directly be used for material creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(DataTexture)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {DataTexture} The data texture.
   */
  load(e, t, a, r) {
    const d = this, p = new Jv(), y = new of(this.manager);
    return y.setResponseType("arraybuffer"), y.setRequestHeader(this.requestHeader), y.setPath(this.path), y.setWithCredentials(d.withCredentials), y.load(e, function(_) {
      let E;
      try {
        E = d.parse(_);
      } catch (T) {
        if (r !== void 0)
          r(T);
        else {
          console.error(T);
          return;
        }
      }
      E.image !== void 0 ? p.image = E.image : E.data !== void 0 && (p.image.width = E.width, p.image.height = E.height, p.image.data = E.data), p.wrapS = E.wrapS !== void 0 ? E.wrapS : Mo, p.wrapT = E.wrapT !== void 0 ? E.wrapT : Mo, p.magFilter = E.magFilter !== void 0 ? E.magFilter : Ni, p.minFilter = E.minFilter !== void 0 ? E.minFilter : Ni, p.anisotropy = E.anisotropy !== void 0 ? E.anisotropy : 1, E.colorSpace !== void 0 && (p.colorSpace = E.colorSpace), E.flipY !== void 0 && (p.flipY = E.flipY), E.format !== void 0 && (p.format = E.format), E.type !== void 0 && (p.type = E.type), E.mipmaps !== void 0 && (p.mipmaps = E.mipmaps, p.minFilter = qm), E.mipmapCount === 1 && (p.minFilter = Ni), E.generateMipmaps !== void 0 && (p.generateMipmaps = E.generateMipmaps), p.needsUpdate = !0, t && t(p, E);
    }, a, r), p;
  }
}
class JO extends cf {
  /**
   * Constructs a new texture loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and pass the fully loaded texture
   * to the `onLoad()` callback. The method also returns a new texture object which can
   * directly be used for material creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Texture)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {Texture} The texture.
   */
  load(e, t, a, r) {
    const d = new Ml(), p = new eE(this.manager);
    return p.setCrossOrigin(this.crossOrigin), p.setPath(this.path), p.load(e, function(y) {
      d.image = y, d.needsUpdate = !0, t !== void 0 && t(d);
    }, a, r), d;
  }
}
class K0 extends zi {
  /**
   * Constructs a new light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new hn(e), this.intensity = t;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
  }
}
class KO extends K0 {
  /**
   * Constructs a new hemisphere light.
   *
   * @param {(number|Color|string)} [skyColor=0xffffff] - The light's sky color.
   * @param {(number|Color|string)} [groundColor=0xffffff] - The light's ground color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t, a) {
    super(e, a), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(zi.DEFAULT_UP), this.updateMatrix(), this.groundColor = new hn(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const lC = /* @__PURE__ */ new ia(), HB = /* @__PURE__ */ new ve(), LB = /* @__PURE__ */ new ve();
class Y2 {
  /**
   * Constructs a new light shadow.
   *
   * @param {Camera} camera - The light's view of the world.
   */
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ot(512, 512), this.map = null, this.mapPass = null, this.matrix = new ia(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new dE(), this._frameExtents = new Ot(1, 1), this._viewportCount = 1, this._viewports = [
      new Bi(0, 0, 1, 1)
    ];
  }
  /**
   * Used internally by the renderer to get the number of viewports that need
   * to be rendered for this shadow.
   *
   * @return {number} The viewport count.
   */
  getViewportCount() {
    return this._viewportCount;
  }
  /**
   * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
   *
   * @return {Frustum} The shadow camera frustum.
   */
  getFrustum() {
    return this._frustum;
  }
  /**
   * Update the matrices for the camera and shadow, used internally by the renderer.
   *
   * @param {Light} light - The light for which the shadow is being rendered.
   */
  updateMatrices(e) {
    const t = this.camera, a = this.matrix;
    HB.setFromMatrixPosition(e.matrixWorld), t.position.copy(HB), LB.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(LB), t.updateMatrixWorld(), lC.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(lC), a.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), a.multiply(lC);
  }
  /**
   * Returns a viewport definition for the given viewport index.
   *
   * @param {number} viewportIndex - The viewport index.
   * @return {Vector4} The viewport.
   */
  getViewport(e) {
    return this._viewports[e];
  }
  /**
   * Returns the frame extends.
   *
   * @return {Vector2} The frame extends.
   */
  getFrameExtents() {
    return this._frameExtents;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  /**
   * Copies the values of the given light shadow instance to this instance.
   *
   * @param {LightShadow} source - The light shadow to copy.
   * @return {LightShadow} A reference to this light shadow instance.
   */
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  /**
   * Returns a new light shadow instance with copied values from this instance.
   *
   * @return {LightShadow} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Serializes the light shadow into JSON.
   *
   * @return {Object} A JSON object representing the serialized light shadow.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class l4 extends Y2 {
  /**
   * Constructs a new spot light shadow.
   */
  constructor() {
    super(new Ls(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, a = _1 * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, d = e.distance || t.far;
    (a !== t.fov || r !== t.aspect || d !== t.far) && (t.fov = a, t.aspect = r, t.far = d, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class q2 extends K0 {
  /**
   * Constructs a new spot light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, a = 0, r = Math.PI / 3, d = 0, p = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(zi.DEFAULT_UP), this.updateMatrix(), this.target = new zi(), this.distance = a, this.angle = r, this.penumbra = d, this.decay = p, this.map = null, this.shadow = new l4();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   *  Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const GB = /* @__PURE__ */ new ia(), SA = /* @__PURE__ */ new ve(), sC = /* @__PURE__ */ new ve();
class s4 extends Y2 {
  /**
   * Constructs a new point light shadow.
   */
  constructor() {
    super(new Ls(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Ot(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Bi(2, 1, 1, 1),
      // negative X
      new Bi(0, 1, 1, 1),
      // positive Z
      new Bi(3, 1, 1, 1),
      // negative Z
      new Bi(1, 1, 1, 1),
      // positive Y
      new Bi(3, 0, 1, 1),
      // negative Y
      new Bi(1, 0, 1, 1)
    ], this._cubeDirections = [
      new ve(1, 0, 0),
      new ve(-1, 0, 0),
      new ve(0, 0, 1),
      new ve(0, 0, -1),
      new ve(0, 1, 0),
      new ve(0, -1, 0)
    ], this._cubeUps = [
      new ve(0, 1, 0),
      new ve(0, 1, 0),
      new ve(0, 1, 0),
      new ve(0, 1, 0),
      new ve(0, 0, 1),
      new ve(0, 0, -1)
    ];
  }
  /**
   * Update the matrices for the camera and shadow, used internally by the renderer.
   *
   * @param {Light} light - The light for which the shadow is being rendered.
   * @param {number} [viewportIndex=0] - The viewport index.
   */
  updateMatrices(e, t = 0) {
    const a = this.camera, r = this.matrix, d = e.distance || a.far;
    d !== a.far && (a.far = d, a.updateProjectionMatrix()), SA.setFromMatrixPosition(e.matrixWorld), a.position.copy(SA), sC.copy(a.position), sC.add(this._cubeDirections[t]), a.up.copy(this._cubeUps[t]), a.lookAt(sC), a.updateMatrixWorld(), r.makeTranslation(-SA.x, -SA.y, -SA.z), GB.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse), this._frustum.setFromProjectionMatrix(GB);
  }
}
class Z2 extends K0 {
  /**
   * Constructs a new point light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, a = 0, r = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = a, this.decay = r, this.shadow = new s4();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   * Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class Zm extends oE {
  /**
   * Constructs a new orthographic camera.
   *
   * @param {number} [left=-1] - The left plane of the camera's frustum.
   * @param {number} [right=1] - The right plane of the camera's frustum.
   * @param {number} [top=1] - The top plane of the camera's frustum.
   * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = -1, t = 1, a = 1, r = -1, d = 0.1, p = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = a, this.bottom = r, this.near = d, this.far = p, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   * @see {@link PerspectiveCamera#setViewOffset}
   */
  setViewOffset(e, t, a, r, d, p) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = a, this.view.offsetY = r, this.view.width = d, this.view.height = p, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), a = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let d = a - e, p = a + e, y = r + t, _ = r - t;
    if (this.view !== null && this.view.enabled) {
      const E = (this.right - this.left) / this.view.fullWidth / this.zoom, T = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      d += E * this.view.offsetX, p = d + E * this.view.width, y -= T * this.view.offsetY, _ = y - T * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(d, p, y, _, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
class r4 extends Y2 {
  /**
   * Constructs a new directional light shadow.
   */
  constructor() {
    super(new Zm(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class Q2 extends K0 {
  /**
   * Constructs a new directional light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(zi.DEFAULT_UP), this.updateMatrix(), this.target = new zi(), this.shadow = new r4();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class kO extends K0 {
  /**
   * Constructs a new ambient light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class WO extends K0 {
  /**
   * Constructs a new area light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   * @param {number} [width=10] - The width of the light.
   * @param {number} [height=10] - The height of the light.
   */
  constructor(e, t, a = 10, r = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = a, this.height = r;
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   * Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class $O {
  /**
   * Constructs a new spherical harmonics.
   */
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new ve());
  }
  /**
   * Sets the given SH coefficients to this instance by copying
   * the values.
   *
   * @param {Array<Vector3>} coefficients - The SH coefficients.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  /**
   * Sets all SH coefficients to `0`.
   *
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  /**
   * Returns the radiance in the direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The radiance.
   */
  getAt(e, t) {
    const a = e.x, r = e.y, d = e.z, p = this.coefficients;
    return t.copy(p[0]).multiplyScalar(0.282095), t.addScaledVector(p[1], 0.488603 * r), t.addScaledVector(p[2], 0.488603 * d), t.addScaledVector(p[3], 0.488603 * a), t.addScaledVector(p[4], 1.092548 * (a * r)), t.addScaledVector(p[5], 1.092548 * (r * d)), t.addScaledVector(p[6], 0.315392 * (3 * d * d - 1)), t.addScaledVector(p[7], 1.092548 * (a * d)), t.addScaledVector(p[8], 0.546274 * (a * a - r * r)), t;
  }
  /**
   * Returns the irradiance (radiance convolved with cosine lobe) in the
   * direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The irradiance.
   */
  getIrradianceAt(e, t) {
    const a = e.x, r = e.y, d = e.z, p = this.coefficients;
    return t.copy(p[0]).multiplyScalar(0.886227), t.addScaledVector(p[1], 2 * 0.511664 * r), t.addScaledVector(p[2], 2 * 0.511664 * d), t.addScaledVector(p[3], 2 * 0.511664 * a), t.addScaledVector(p[4], 2 * 0.429043 * a * r), t.addScaledVector(p[5], 2 * 0.429043 * r * d), t.addScaledVector(p[6], 0.743125 * d * d - 0.247708), t.addScaledVector(p[7], 2 * 0.429043 * a * d), t.addScaledVector(p[8], 0.429043 * (a * a - r * r)), t;
  }
  /**
   * Adds the given SH to this instance.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  /**
   * A convenience method for performing {@link SphericalHarmonics3#add} and
   * {@link SphericalHarmonics3#scale} at once.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  addScaledSH(e, t) {
    for (let a = 0; a < 9; a++)
      this.coefficients[a].addScaledVector(e.coefficients[a], t);
    return this;
  }
  /**
   * Scales this SH by the given scale factor.
   *
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  /**
   * Linear interpolates between the given SH and this instance by the given
   * alpha factor.
   *
   * @param {SphericalHarmonics3} sh - The SH to interpolate with.
   * @param {number} alpha - The alpha factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  lerp(e, t) {
    for (let a = 0; a < 9; a++)
      this.coefficients[a].lerp(e.coefficients[a], t);
    return this;
  }
  /**
   * Returns `true` if this spherical harmonics is equal with the given one.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to test for equality.
   * @return {boolean} Whether this spherical harmonics is equal with the given one.
   */
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  /**
   * Copies the values of the given spherical harmonics to this instance.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to copy.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  copy(e) {
    return this.set(e.coefficients);
  }
  /**
   * Returns a new spherical harmonics with copied values from this instance.
   *
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Sets the SH coefficients of this instance from the given array.
   *
   * @param {Array<number>} array - An array holding the SH coefficients.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  fromArray(e, t = 0) {
    const a = this.coefficients;
    for (let r = 0; r < 9; r++)
      a[r].fromArray(e, t + r * 3);
    return this;
  }
  /**
   * Returns an array with the SH coefficients, or copies them into the provided
   * array. The coefficients are represented as numbers.
   *
   * @param {Array<number>} [array=[]] - The target array.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {Array<number>} An array with flat SH coefficients.
   */
  toArray(e = [], t = 0) {
    const a = this.coefficients;
    for (let r = 0; r < 9; r++)
      a[r].toArray(e, t + r * 3);
    return e;
  }
  /**
   * Computes the SH basis for the given normal vector.
   *
   * @param {Vector3} normal - The normal.
   * @param {Array<number>} shBasis - The target array holding the SH basis.
   */
  static getBasisAt(e, t) {
    const a = e.x, r = e.y, d = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * r, t[2] = 0.488603 * d, t[3] = 0.488603 * a, t[4] = 1.092548 * a * r, t[5] = 1.092548 * r * d, t[6] = 0.315392 * (3 * d * d - 1), t[7] = 1.092548 * a * d, t[8] = 0.546274 * (a * a - r * r);
  }
}
class ew extends K0 {
  /**
   * Constructs a new light probe.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics which represents encoded lighting information.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e = new $O(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  /**
   * Deserializes the light prove from the given JSON.
   *
   * @param {Object} json - The JSON holding the serialized light probe.
   * @return {LightProbe} A reference to this light probe.
   */
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class zx extends cf {
  /**
   * Constructs a new material loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e), this.textures = {};
  }
  /**
   * Starts loading from the given URL and pass the loaded material to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Material)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(e, t, a, r) {
    const d = this, p = new of(d.manager);
    p.setPath(d.path), p.setRequestHeader(d.requestHeader), p.setWithCredentials(d.withCredentials), p.load(e, function(y) {
      try {
        t(d.parse(JSON.parse(y)));
      } catch (_) {
        r ? r(_) : console.error(_), d.manager.itemError(e);
      }
    }, a, r);
  }
  /**
   * Parses the given JSON object and returns a material.
   *
   * @param {Object} json - The serialized material.
   * @return {Material} The parsed material.
   */
  parse(e) {
    const t = this.textures;
    function a(d) {
      return t[d] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", d), t[d];
    }
    const r = this.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new hn().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (r.dispersion = e.dispersion), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc), e.blendDst !== void 0 && (r.blendDst = e.blendDst), e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== void 0 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const d in e.uniforms) {
        const p = e.uniforms[d];
        switch (r.uniforms[d] = {}, p.type) {
          case "t":
            r.uniforms[d].value = a(p.value);
            break;
          case "c":
            r.uniforms[d].value = new hn().setHex(p.value);
            break;
          case "v2":
            r.uniforms[d].value = new Ot().fromArray(p.value);
            break;
          case "v3":
            r.uniforms[d].value = new ve().fromArray(p.value);
            break;
          case "v4":
            r.uniforms[d].value = new Bi().fromArray(p.value);
            break;
          case "m3":
            r.uniforms[d].value = new ja().fromArray(p.value);
            break;
          case "m4":
            r.uniforms[d].value = new ia().fromArray(p.value);
            break;
          default:
            r.uniforms[d].value = p.value;
        }
      }
    if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const d in e.extensions)
        r.extensions[d] = e.extensions[d];
    if (e.lights !== void 0 && (r.lights = e.lights), e.clipping !== void 0 && (r.clipping = e.clipping), e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = a(e.map)), e.matcap !== void 0 && (r.matcap = a(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = a(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = a(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = a(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let d = e.normalScale;
      Array.isArray(d) === !1 && (d = [d, d]), r.normalScale = new Ot().fromArray(d);
    }
    return e.displacementMap !== void 0 && (r.displacementMap = a(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = a(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = a(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = a(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = a(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = a(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = a(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = a(e.envMap)), e.envMapRotation !== void 0 && r.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = a(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = a(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = a(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = a(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = a(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = a(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new Ot().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = a(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = a(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = a(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = a(e.thicknessMap)), e.anisotropyMap !== void 0 && (r.anisotropyMap = a(e.anisotropyMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = a(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = a(e.sheenRoughnessMap)), r;
  }
  /**
   * Textures are not embedded in the material JSON so they have
   * to be injected before the loading process starts.
   *
   * @param {Object} value - A dictionary holding textures for material properties.
   * @return {MaterialLoader} A reference to this material loader.
   */
  setTextures(e) {
    return this.textures = e, this;
  }
  /**
   * Creates a material for the given type.
   *
   * @param {string} type - The material type.
   * @return {Material} The new material.
   */
  createMaterialFromType(e) {
    return zx.createMaterialFromType(e);
  }
  /**
   * Creates a material for the given type.
   *
   * @static
   * @param {string} type - The material type.
   * @return {Material} The new material.
   */
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: zO,
      SpriteMaterial: R2,
      RawShaderMaterial: HO,
      ShaderMaterial: iu,
      PointsMaterial: yx,
      MeshPhysicalMaterial: jm,
      MeshStandardMaterial: B1,
      MeshPhongMaterial: LO,
      MeshToonMaterial: GO,
      MeshNormalMaterial: IO,
      MeshLambertMaterial: VO,
      MeshDepthMaterial: wx,
      MeshDistanceMaterial: I2,
      MeshBasicMaterial: Yh,
      MeshMatcapMaterial: FO,
      LineDashedMaterial: PO,
      LineBasicMaterial: nd,
      Material: Vu
    };
    return new t[e]();
  }
}
class P0 {
  /**
   * Extracts the base URL from the given URL.
   *
   * @param {string} url -The URL to extract the base URL from.
   * @return {string} The extracted base URL.
   */
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  /**
   * Resolves relative URLs against the given path. Absolute paths, data urls,
   * and blob URLs will be returned as is. Invalid URLs will return an empty
   * string.
   *
   * @param {string} url -The URL to resolve.
   * @param {string} path - The base path for relative URLs to be resolved against.
   * @return {string} The resolved URL.
   */
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class tw extends Pa {
  /**
   * Constructs a new instanced buffer geometry.
   */
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class nw extends cf {
  /**
   * Constructs a new geometry loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and pass the loaded geometry to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(e, t, a, r) {
    const d = this, p = new of(d.manager);
    p.setPath(d.path), p.setRequestHeader(d.requestHeader), p.setWithCredentials(d.withCredentials), p.load(e, function(y) {
      try {
        t(d.parse(JSON.parse(y)));
      } catch (_) {
        r ? r(_) : console.error(_), d.manager.itemError(e);
      }
    }, a, r);
  }
  /**
   * Parses the given JSON object and returns a geometry.
   *
   * @param {Object} json - The serialized geometry.
   * @return {BufferGeometry} The parsed geometry.
   */
  parse(e) {
    const t = {}, a = {};
    function r(B, z) {
      if (t[z] !== void 0) return t[z];
      const G = B.interleavedBuffers[z], N = d(B, G.buffer), F = r1(G.type, N), q = new cE(F, G.stride);
      return q.uuid = G.uuid, t[z] = q, q;
    }
    function d(B, z) {
      if (a[z] !== void 0) return a[z];
      const G = B.arrayBuffers[z], N = new Uint32Array(G).buffer;
      return a[z] = N, N;
    }
    const p = e.isInstancedBufferGeometry ? new tw() : new Pa(), y = e.data.index;
    if (y !== void 0) {
      const B = r1(y.type, y.array);
      p.setIndex(new Hi(B, 1));
    }
    const _ = e.data.attributes;
    for (const B in _) {
      const z = _[B];
      let V;
      if (z.isInterleavedBufferAttribute) {
        const G = r(e.data, z.data);
        V = new Z0(G, z.itemSize, z.offset, z.normalized);
      } else {
        const G = r1(z.type, z.array), N = z.isInstancedBufferAttribute ? $S : Hi;
        V = new N(G, z.itemSize, z.normalized);
      }
      z.name !== void 0 && (V.name = z.name), z.usage !== void 0 && V.setUsage(z.usage), p.setAttribute(B, V);
    }
    const E = e.data.morphAttributes;
    if (E)
      for (const B in E) {
        const z = E[B], V = [];
        for (let G = 0, N = z.length; G < N; G++) {
          const F = z[G];
          let q;
          if (F.isInterleavedBufferAttribute) {
            const Y = r(e.data, F.data);
            q = new Z0(Y, F.itemSize, F.offset, F.normalized);
          } else {
            const Y = r1(F.type, F.array);
            q = new Hi(Y, F.itemSize, F.normalized);
          }
          F.name !== void 0 && (q.name = F.name), V.push(q);
        }
        p.morphAttributes[B] = V;
      }
    e.data.morphTargetsRelative && (p.morphTargetsRelative = !0);
    const C = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (C !== void 0)
      for (let B = 0, z = C.length; B !== z; ++B) {
        const V = C[B];
        p.addGroup(V.start, V.count, V.materialIndex);
      }
    const D = e.data.boundingSphere;
    if (D !== void 0) {
      const B = new ve();
      D.center !== void 0 && B.fromArray(D.center), p.boundingSphere = new rf(B, D.radius);
    }
    return e.name && (p.name = e.name), e.userData && (p.userData = e.userData), p;
  }
}
class o4 extends cf {
  /**
   * Constructs a new object loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and pass the loaded 3D object to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Object3D)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(e, t, a, r) {
    const d = this, p = this.path === "" ? P0.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || p;
    const y = new of(this.manager);
    y.setPath(this.path), y.setRequestHeader(this.requestHeader), y.setWithCredentials(this.withCredentials), y.load(e, function(_) {
      let E = null;
      try {
        E = JSON.parse(_);
      } catch (C) {
        r !== void 0 && r(C), console.error("THREE:ObjectLoader: Can't parse " + e + ".", C.message);
        return;
      }
      const T = E.metadata;
      if (T === void 0 || T.type === void 0 || T.type.toLowerCase() === "geometry") {
        r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      d.parse(E, t);
    }, a, r);
  }
  /**
   * Async version of {@link ObjectLoader#load}.
   *
   * @async
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @return {Promise<Object3D>} A Promise that resolves with the loaded 3D object.
   */
  async loadAsync(e, t) {
    const a = this, r = this.path === "" ? P0.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const d = new of(this.manager);
    d.setPath(this.path), d.setRequestHeader(this.requestHeader), d.setWithCredentials(this.withCredentials);
    const p = await d.loadAsync(e, t), y = JSON.parse(p), _ = y.metadata;
    if (_ === void 0 || _.type === void 0 || _.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await a.parseAsync(y);
  }
  /**
   * Parses the given JSON. This is used internally by {@link ObjectLoader#load}
   * but can also be used directly to parse a previously loaded JSON structure.
   *
   * @param {Object} json - The serialized 3D object.
   * @param {onLoad} onLoad - Executed when all resources (e.g. textures) have been fully loaded.
   * @return {Object3D} The parsed 3D object.
   */
  parse(e, t) {
    const a = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), d = this.parseGeometries(e.geometries, r), p = this.parseImages(e.images, function() {
      t !== void 0 && t(E);
    }), y = this.parseTextures(e.textures, p), _ = this.parseMaterials(e.materials, y), E = this.parseObject(e.object, d, _, y, a), T = this.parseSkeletons(e.skeletons, E);
    if (this.bindSkeletons(E, T), this.bindLightTargets(E), t !== void 0) {
      let C = !1;
      for (const D in p)
        if (p[D].data instanceof HTMLImageElement) {
          C = !0;
          break;
        }
      C === !1 && t(E);
    }
    return E;
  }
  /**
   * Async version of {@link ObjectLoader#parse}.
   *
   * @param {Object} json - The serialized 3D object.
   * @return {Promise<Object3D>} A Promise that resolves with the parsed 3D object.
   */
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), a = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, a), d = await this.parseImagesAsync(e.images), p = this.parseTextures(e.textures, d), y = this.parseMaterials(e.materials, p), _ = this.parseObject(e.object, r, y, p, t), E = this.parseSkeletons(e.skeletons, _);
    return this.bindSkeletons(_, E), this.bindLightTargets(_), _;
  }
  // internals
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let a = 0, r = e.length; a < r; a++) {
        const d = new JS().fromJSON(e[a]);
        t[d.uuid] = d;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const a = {}, r = {};
    if (t.traverse(function(d) {
      d.isBone && (r[d.uuid] = d);
    }), e !== void 0)
      for (let d = 0, p = e.length; d < p; d++) {
        const y = new fE().fromJSON(e[d], r);
        a[y.uuid] = y;
      }
    return a;
  }
  parseGeometries(e, t) {
    const a = {};
    if (e !== void 0) {
      const r = new nw();
      for (let d = 0, p = e.length; d < p; d++) {
        let y;
        const _ = e[d];
        switch (_.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            y = r.parse(_);
            break;
          default:
            _.type in zB ? y = zB[_.type].fromJSON(_, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${_.type}"`);
        }
        y.uuid = _.uuid, _.name !== void 0 && (y.name = _.name), _.userData !== void 0 && (y.userData = _.userData), a[_.uuid] = y;
      }
    }
    return a;
  }
  parseMaterials(e, t) {
    const a = {}, r = {};
    if (e !== void 0) {
      const d = new zx();
      d.setTextures(t);
      for (let p = 0, y = e.length; p < y; p++) {
        const _ = e[p];
        a[_.uuid] === void 0 && (a[_.uuid] = d.parse(_)), r[_.uuid] = a[_.uuid];
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let a = 0; a < e.length; a++) {
        const r = e[a], d = M1.parse(r);
        t[d.uuid] = d;
      }
    return t;
  }
  parseImages(e, t) {
    const a = this, r = {};
    let d;
    function p(_) {
      return a.manager.itemStart(_), d.load(_, function() {
        a.manager.itemEnd(_);
      }, void 0, function() {
        a.manager.itemError(_), a.manager.itemEnd(_);
      });
    }
    function y(_) {
      if (typeof _ == "string") {
        const E = _, T = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(E) ? E : a.resourcePath + E;
        return p(T);
      } else
        return _.data ? {
          data: r1(_.type, _.data),
          width: _.width,
          height: _.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const _ = new Nx(t);
      d = new eE(_), d.setCrossOrigin(this.crossOrigin);
      for (let E = 0, T = e.length; E < T; E++) {
        const C = e[E], D = C.url;
        if (Array.isArray(D)) {
          const B = [];
          for (let z = 0, V = D.length; z < V; z++) {
            const G = D[z], N = y(G);
            N !== null && (N instanceof HTMLImageElement ? B.push(N) : B.push(new Jv(N.data, N.width, N.height)));
          }
          r[C.uuid] = new V0(B);
        } else {
          const B = y(C.url);
          r[C.uuid] = new V0(B);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this, a = {};
    let r;
    async function d(p) {
      if (typeof p == "string") {
        const y = p, _ = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(y) ? y : t.resourcePath + y;
        return await r.loadAsync(_);
      } else
        return p.data ? {
          data: r1(p.type, p.data),
          width: p.width,
          height: p.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      r = new eE(this.manager), r.setCrossOrigin(this.crossOrigin);
      for (let p = 0, y = e.length; p < y; p++) {
        const _ = e[p], E = _.url;
        if (Array.isArray(E)) {
          const T = [];
          for (let C = 0, D = E.length; C < D; C++) {
            const B = E[C], z = await d(B);
            z !== null && (z instanceof HTMLImageElement ? T.push(z) : T.push(new Jv(z.data, z.width, z.height)));
          }
          a[_.uuid] = new V0(T);
        } else {
          const T = await d(_.url);
          a[_.uuid] = new V0(T);
        }
      }
    }
    return a;
  }
  parseTextures(e, t) {
    function a(d, p) {
      return typeof d == "number" ? d : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", d), p[d]);
    }
    const r = {};
    if (e !== void 0)
      for (let d = 0, p = e.length; d < p; d++) {
        const y = e[d];
        y.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', y.uuid), t[y.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", y.image);
        const _ = t[y.image], E = _.data;
        let T;
        Array.isArray(E) ? (T = new uE(), E.length === 6 && (T.needsUpdate = !0)) : (E && E.data ? T = new Jv() : T = new Ml(), E && (T.needsUpdate = !0)), T.source = _, T.uuid = y.uuid, y.name !== void 0 && (T.name = y.name), y.mapping !== void 0 && (T.mapping = a(y.mapping, u4)), y.channel !== void 0 && (T.channel = y.channel), y.offset !== void 0 && T.offset.fromArray(y.offset), y.repeat !== void 0 && T.repeat.fromArray(y.repeat), y.center !== void 0 && T.center.fromArray(y.center), y.rotation !== void 0 && (T.rotation = y.rotation), y.wrap !== void 0 && (T.wrapS = a(y.wrap[0], IB), T.wrapT = a(y.wrap[1], IB)), y.format !== void 0 && (T.format = y.format), y.internalFormat !== void 0 && (T.internalFormat = y.internalFormat), y.type !== void 0 && (T.type = y.type), y.colorSpace !== void 0 && (T.colorSpace = y.colorSpace), y.minFilter !== void 0 && (T.minFilter = a(y.minFilter, VB)), y.magFilter !== void 0 && (T.magFilter = a(y.magFilter, VB)), y.anisotropy !== void 0 && (T.anisotropy = y.anisotropy), y.flipY !== void 0 && (T.flipY = y.flipY), y.generateMipmaps !== void 0 && (T.generateMipmaps = y.generateMipmaps), y.premultiplyAlpha !== void 0 && (T.premultiplyAlpha = y.premultiplyAlpha), y.unpackAlignment !== void 0 && (T.unpackAlignment = y.unpackAlignment), y.compareFunction !== void 0 && (T.compareFunction = y.compareFunction), y.userData !== void 0 && (T.userData = y.userData), r[y.uuid] = T;
      }
    return r;
  }
  parseObject(e, t, a, r, d) {
    let p;
    function y(D) {
      return t[D] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", D), t[D];
    }
    function _(D) {
      if (D !== void 0) {
        if (Array.isArray(D)) {
          const B = [];
          for (let z = 0, V = D.length; z < V; z++) {
            const G = D[z];
            a[G] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", G), B.push(a[G]);
          }
          return B;
        }
        return a[D] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", D), a[D];
      }
    }
    function E(D) {
      return r[D] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", D), r[D];
    }
    let T, C;
    switch (e.type) {
      case "Scene":
        p = new R1(), e.background !== void 0 && (Number.isInteger(e.background) ? p.background = new hn(e.background) : p.background = E(e.background)), e.environment !== void 0 && (p.environment = E(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? p.fog = new vx(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (p.fog = new mx(e.fog.color, e.fog.density)), e.fog.name !== "" && (p.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (p.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (p.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && p.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (p.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && p.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        p = new Ls(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (p.focus = e.focus), e.zoom !== void 0 && (p.zoom = e.zoom), e.filmGauge !== void 0 && (p.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (p.filmOffset = e.filmOffset), e.view !== void 0 && (p.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        p = new Zm(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (p.zoom = e.zoom), e.view !== void 0 && (p.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        p = new kO(e.color, e.intensity);
        break;
      case "DirectionalLight":
        p = new Q2(e.color, e.intensity), p.target = e.target || "";
        break;
      case "PointLight":
        p = new Z2(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        p = new WO(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        p = new q2(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay), p.target = e.target || "";
        break;
      case "HemisphereLight":
        p = new KO(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        p = new ew().fromJSON(e);
        break;
      case "SkinnedMesh":
        T = y(e.geometry), C = _(e.material), p = new D2(T, C), e.bindMode !== void 0 && (p.bindMode = e.bindMode), e.bindMatrix !== void 0 && p.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (p.skeleton = e.skeleton);
        break;
      case "Mesh":
        T = y(e.geometry), C = _(e.material), p = new es(T, C);
        break;
      case "InstancedMesh":
        T = y(e.geometry), C = _(e.material);
        const D = e.count, B = e.instanceMatrix, z = e.instanceColor;
        p = new B2(T, C, D), p.instanceMatrix = new $S(new Float32Array(B.array), 16), z !== void 0 && (p.instanceColor = new $S(new Float32Array(z.array), z.itemSize));
        break;
      case "BatchedMesh":
        T = y(e.geometry), C = _(e.material), p = new EO(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, C), p.geometry = T, p.perObjectFrustumCulled = e.perObjectFrustumCulled, p.sortObjects = e.sortObjects, p._drawRanges = e.drawRanges, p._reservedRanges = e.reservedRanges, p._visibility = e.visibility, p._active = e.active, p._bounds = e.bounds.map((V) => {
          const G = new td();
          G.min.fromArray(V.boxMin), G.max.fromArray(V.boxMax);
          const N = new rf();
          return N.radius = V.sphereRadius, N.center.fromArray(V.sphereCenter), {
            boxInitialized: V.boxInitialized,
            box: G,
            sphereInitialized: V.sphereInitialized,
            sphere: N
          };
        }), p._maxInstanceCount = e.maxInstanceCount, p._maxVertexCount = e.maxVertexCount, p._maxIndexCount = e.maxIndexCount, p._geometryInitialized = e.geometryInitialized, p._geometryCount = e.geometryCount, p._matricesTexture = E(e.matricesTexture.uuid), e.colorsTexture !== void 0 && (p._colorsTexture = E(e.colorsTexture.uuid));
        break;
      case "LOD":
        p = new AO();
        break;
      case "Line":
        p = new Qy(y(e.geometry), _(e.material));
        break;
      case "LineLoop":
        p = new U2(y(e.geometry), _(e.material));
        break;
      case "LineSegments":
        p = new kv(y(e.geometry), _(e.material));
        break;
      case "PointCloud":
      case "Points":
        p = new O2(y(e.geometry), _(e.material));
        break;
      case "Sprite":
        p = new _O(_(e.material));
        break;
      case "Group":
        p = new Xy();
        break;
      case "Bone":
        p = new gx();
        break;
      default:
        p = new zi();
    }
    if (p.uuid = e.uuid, e.name !== void 0 && (p.name = e.name), e.matrix !== void 0 ? (p.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (p.matrixAutoUpdate = e.matrixAutoUpdate), p.matrixAutoUpdate && p.matrix.decompose(p.position, p.quaternion, p.scale)) : (e.position !== void 0 && p.position.fromArray(e.position), e.rotation !== void 0 && p.rotation.fromArray(e.rotation), e.quaternion !== void 0 && p.quaternion.fromArray(e.quaternion), e.scale !== void 0 && p.scale.fromArray(e.scale)), e.up !== void 0 && p.up.fromArray(e.up), e.castShadow !== void 0 && (p.castShadow = e.castShadow), e.receiveShadow !== void 0 && (p.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.intensity !== void 0 && (p.shadow.intensity = e.shadow.intensity), e.shadow.bias !== void 0 && (p.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (p.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (p.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && p.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (p.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (p.visible = e.visible), e.frustumCulled !== void 0 && (p.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (p.renderOrder = e.renderOrder), e.userData !== void 0 && (p.userData = e.userData), e.layers !== void 0 && (p.layers.mask = e.layers), e.children !== void 0) {
      const D = e.children;
      for (let B = 0; B < D.length; B++)
        p.add(this.parseObject(D[B], t, a, r, d));
    }
    if (e.animations !== void 0) {
      const D = e.animations;
      for (let B = 0; B < D.length; B++) {
        const z = D[B];
        p.animations.push(d[z]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (p.autoUpdate = e.autoUpdate);
      const D = e.levels;
      for (let B = 0; B < D.length; B++) {
        const z = D[B], V = p.getObjectByProperty("uuid", z.object);
        V !== void 0 && p.addLevel(V, z.distance, z.hysteresis);
      }
    }
    return p;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(a) {
      if (a.isSkinnedMesh === !0 && a.skeleton !== void 0) {
        const r = t[a.skeleton];
        r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", a.skeleton) : a.bind(r, a.bindMatrix);
      }
    });
  }
  bindLightTargets(e) {
    e.traverse(function(t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const a = t.target, r = e.getObjectByProperty("uuid", a);
        r !== void 0 ? t.target = r : t.target = new zi();
      }
    });
  }
}
const u4 = {
  UVMapping: X0,
  CubeReflectionMapping: Qg,
  CubeRefractionMapping: Y0,
  EquirectangularReflectionMapping: p1,
  EquirectangularRefractionMapping: YA,
  CubeUVReflectionMapping: C1
}, IB = {
  RepeatWrapping: q0,
  ClampToEdgeWrapping: Mo,
  MirroredRepeatWrapping: m1
}, VB = {
  NearestFilter: _c,
  NearestMipmapNearestFilter: ix,
  NearestMipmapLinearFilter: VS,
  LinearFilter: Ni,
  LinearMipmapNearestFilter: c1,
  LinearMipmapLinearFilter: qm
};
class aw extends cf {
  /**
   * Constructs a new image bitmap loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  /**
   * Sets the given loader options. The structure of the object must match the `options` parameter of
   * [createImageBitmap]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/createImageBitmap}.
   *
   * @param {Object} options - The loader options to set.
   * @return {ImageBitmapLoader} A reference to this image bitmap loader.
   */
  setOptions(e) {
    return this.options = e, this;
  }
  /**
   * Starts loading from the given URL and pass the loaded image bitmap to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(ImageBitmap)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {ImageBitmap|undefined} The image bitmap.
   */
  load(e, t, a, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const d = this, p = Yy.get(e);
    if (p !== void 0) {
      if (d.manager.itemStart(e), p.then) {
        p.then((E) => {
          t && t(E), d.manager.itemEnd(e);
        }).catch((E) => {
          r && r(E);
        });
        return;
      }
      return setTimeout(function() {
        t && t(p), d.manager.itemEnd(e);
      }, 0), p;
    }
    const y = {};
    y.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", y.headers = this.requestHeader;
    const _ = fetch(e, y).then(function(E) {
      return E.blob();
    }).then(function(E) {
      return createImageBitmap(E, Object.assign(d.options, { colorSpaceConversion: "none" }));
    }).then(function(E) {
      return Yy.add(e, E), t && t(E), d.manager.itemEnd(e), E;
    }).catch(function(E) {
      r && r(E), Yy.remove(e), d.manager.itemError(e), d.manager.itemEnd(e);
    });
    Yy.add(e, _), d.manager.itemStart(e);
  }
}
let Ob;
class j2 {
  /**
   * Returns the global native audio context.
   *
   * @return {AudioContext} The native audio context.
   */
  static getContext() {
    return Ob === void 0 && (Ob = new (window.AudioContext || window.webkitAudioContext)()), Ob;
  }
  /**
   * Allows to set the global native audio context from outside.
   *
   * @param {AudioContext} value - The native context to set.
   */
  static setContext(e) {
    Ob = e;
  }
}
class c4 extends cf {
  /**
   * Constructs a new audio loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and passes the loaded audio buffer
   * to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(AudioBuffer)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(e, t, a, r) {
    const d = this, p = new of(this.manager);
    p.setResponseType("arraybuffer"), p.setPath(this.path), p.setRequestHeader(this.requestHeader), p.setWithCredentials(this.withCredentials), p.load(e, function(_) {
      try {
        const E = _.slice(0);
        j2.getContext().decodeAudioData(E, function(C) {
          t(C);
        }).catch(y);
      } catch (E) {
        y(E);
      }
    }, a, r);
    function y(_) {
      r ? r(_) : console.error(_), d.manager.itemError(e);
    }
  }
}
const FB = /* @__PURE__ */ new ia(), PB = /* @__PURE__ */ new ia(), CS = /* @__PURE__ */ new ia();
class f4 {
  /**
   * Constructs a new stereo camera.
   */
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Ls(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Ls(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  /**
   * Updates the stereo camera based on the given perspective camera.
   *
   * @param {PerspectiveCamera} camera - The perspective camera.
   */
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, CS.copy(e.projectionMatrix);
      const r = t.eyeSep / 2, d = r * t.near / t.focus, p = t.near * Math.tan(jS * t.fov * 0.5) / t.zoom;
      let y, _;
      PB.elements[12] = -r, FB.elements[12] = r, y = -p * t.aspect + d, _ = p * t.aspect + d, CS.elements[0] = 2 * t.near / (_ - y), CS.elements[8] = (_ + y) / (_ - y), this.cameraL.projectionMatrix.copy(CS), y = -p * t.aspect - d, _ = p * t.aspect - d, CS.elements[0] = 2 * t.near / (_ - y), CS.elements[8] = (_ + y) / (_ - y), this.cameraR.projectionMatrix.copy(CS);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(PB), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(FB);
  }
}
class iw extends Ls {
  /**
   * Constructs a new array camera.
   *
   * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
   */
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e, this.index = 0;
  }
}
class J2 {
  /**
   * Constructs a new clock.
   *
   * @param {boolean} [autoStart=true] - Whether to automatically start the clock when
   * `getDelta()` is called for the first time.
   */
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  /**
   * Starts the clock. When `autoStart` is set to `true`, the method is automatically
   * called by the class.
   */
  start() {
    this.startTime = XB(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  /**
   * Stops the clock.
   */
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  /**
   * Returns the elapsed time in seconds.
   *
   * @return {number} The elapsed time.
   */
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  /**
   * Returns the delta time in seconds.
   *
   * @return {number} The delta time.
   */
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = XB();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function XB() {
  return performance.now();
}
const RS = /* @__PURE__ */ new ve(), YB = /* @__PURE__ */ new Ac(), d4 = /* @__PURE__ */ new ve(), DS = /* @__PURE__ */ new ve();
class h4 extends zi {
  /**
   * Constructs a new audio listener.
   */
  constructor() {
    super(), this.type = "AudioListener", this.context = j2.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new J2();
  }
  /**
   * Returns the listener's input node.
   *
   * This method is used by other audio nodes to connect to this listener.
   *
   * @return {GainNode} The input node.
   */
  getInput() {
    return this.gain;
  }
  /**
   * Removes the current filter from this listener.
   *
   * @return {AudioListener} A reference to this listener.
   */
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  /**
   * Returns the current set filter.
   *
   * @return {?AudioNode} The filter.
   */
  getFilter() {
    return this.filter;
  }
  /**
   * Sets the given filter to this listener.
   *
   * @param {AudioNode} value - The filter to set.
   * @return {AudioListener} A reference to this listener.
   */
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  /**
   * Returns the applications master volume.
   *
   * @return {number} The master volume.
   */
  getMasterVolume() {
    return this.gain.gain.value;
  }
  /**
   * Sets the applications master volume. This volume setting affects
   * all audio nodes in the scene.
   *
   * @param {number} value - The master volume to set.
   * @return {AudioListener} A reference to this listener.
   */
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, a = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(RS, YB, d4), DS.set(0, 0, -1).applyQuaternion(YB), t.positionX) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(RS.x, r), t.positionY.linearRampToValueAtTime(RS.y, r), t.positionZ.linearRampToValueAtTime(RS.z, r), t.forwardX.linearRampToValueAtTime(DS.x, r), t.forwardY.linearRampToValueAtTime(DS.y, r), t.forwardZ.linearRampToValueAtTime(DS.z, r), t.upX.linearRampToValueAtTime(a.x, r), t.upY.linearRampToValueAtTime(a.y, r), t.upZ.linearRampToValueAtTime(a.z, r);
    } else
      t.setPosition(RS.x, RS.y, RS.z), t.setOrientation(DS.x, DS.y, DS.z, a.x, a.y, a.z);
  }
}
class lw extends zi {
  /**
   * Constructs a new audio.
   *
   * @param {AudioListener} listener - The global audio listener.
   */
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  /**
   * Returns the output audio node.
   *
   * @return {GainNode} The output node.
   */
  getOutput() {
    return this.gain;
  }
  /**
   * Sets the given audio node as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `audioNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {AudioNode} audioNode - The audio node like an instance of `OscillatorNode`.
   * @return {Audio} A reference to this instance.
   */
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  /**
   * Sets the given media element as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `mediaNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {HTMLMediaElement} mediaElement - The media element.
   * @return {Audio} A reference to this instance.
   */
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  /**
   * Sets the given media stream as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `mediaStreamNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {MediaStream} mediaStream - The media stream.
   * @return {Audio} A reference to this instance.
   */
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  /**
   * Sets the given audio buffer as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `buffer` and {@link Audio#hasPlaybackControl} to `true`.
   *
   * @param {AudioBuffer} audioBuffer - The audio buffer.
   * @return {Audio} A reference to this instance.
   */
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  /**
   * Starts the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [delay=0] - The delay, in seconds, at which the audio should start playing.
   * @return {Audio|undefined} A reference to this instance.
   */
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  /**
   * Pauses the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @return {Audio|undefined} A reference to this instance.
   */
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  /**
   * Stops the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [delay=0] - The delay, in seconds, at which the audio should stop playing.
   * @return {Audio|undefined} A reference to this instance.
   */
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this;
  }
  /**
   * Connects to the audio source. This is used internally on
   * initialisation and when setting / removing filters.
   *
   * @return {Audio} A reference to this instance.
   */
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  /**
   * Disconnects to the audio source. This is used internally on
   * initialisation and when setting / removing filters.
   *
   * @return {Audio|undefined} A reference to this instance.
   */
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  /**
   * Returns the current set filters.
   *
   * @return {Array<AudioNode>} The list of filters.
   */
  getFilters() {
    return this.filters;
  }
  /**
   * Sets an array of filters and connects them with the audio source.
   *
   * @param {Array<AudioNode>} [value] - A list of filters.
   * @return {Audio} A reference to this instance.
   */
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  /**
   * Defines the detuning of oscillation in cents.
   *
   * @param {number} value - The detuning of oscillation in cents.
   * @return {Audio} A reference to this instance.
   */
  setDetune(e) {
    return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  /**
   * Returns the detuning of oscillation in cents.
   *
   * @return {number} The detuning of oscillation in cents.
   */
  getDetune() {
    return this.detune;
  }
  /**
   * Returns the first filter in the list of filters.
   *
   * @return {AudioNode|undefined} The first filter in the list of filters.
   */
  getFilter() {
    return this.getFilters()[0];
  }
  /**
   * Applies a single filter node to the audio.
   *
   * @param {AudioNode} [filter] - The filter to set.
   * @return {Audio} A reference to this instance.
   */
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  /**
   * Sets the playback rate.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [value] - The playback rate to set.
   * @return {Audio|undefined} A reference to this instance.
   */
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  /**
  	 * Returns the current playback rate.
  
  	 * @return {number} The playback rate.
  	 */
  getPlaybackRate() {
    return this.playbackRate;
  }
  /**
   * Automatically called when playback finished.
   */
  onEnded() {
    this.isPlaying = !1, this._progress = 0;
  }
  /**
   * Returns the loop flag.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @return {boolean} Whether the audio should loop or not.
   */
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  /**
   * Sets the loop flag.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {boolean} value - Whether the audio should loop or not.
   * @return {Audio|undefined} A reference to this instance.
   */
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  /**
   * Sets the loop start value which defines where in the audio buffer the replay should
   * start, in seconds.
   *
   * @param {number} value - The loop start value.
   * @return {Audio} A reference to this instance.
   */
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  /**
   * Sets the loop end value which defines where in the audio buffer the replay should
   * stop, in seconds.
   *
   * @param {number} value - The loop end value.
   * @return {Audio} A reference to this instance.
   */
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  /**
   * Returns the volume.
   *
   * @return {number} The volume.
   */
  getVolume() {
    return this.gain.gain.value;
  }
  /**
   * Sets the volume.
   *
   * @param {number} value - The volume to set.
   * @return {Audio} A reference to this instance.
   */
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  copy(e, t) {
    return super.copy(e, t), e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."), this) : (this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.hasPlaybackControl = e.hasPlaybackControl, this.sourceType = e.sourceType, this.filters = e.filters.slice(), this);
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
const BS = /* @__PURE__ */ new ve(), qB = /* @__PURE__ */ new Ac(), p4 = /* @__PURE__ */ new ve(), US = /* @__PURE__ */ new ve();
class m4 extends lw {
  /**
   * Constructs a positional audio.
   *
   * @param {AudioListener} listener - The global audio listener.
   */
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    return super.connect(), this.panner.connect(this.gain), this;
  }
  disconnect() {
    return super.disconnect(), this.panner.disconnect(this.gain), this;
  }
  getOutput() {
    return this.panner;
  }
  /**
   * Returns the current reference distance.
   *
   * @return {number} The reference distance.
   */
  getRefDistance() {
    return this.panner.refDistance;
  }
  /**
   * Defines the reference distance for reducing volume as the audio source moves
   * further from the listener  i.e. the distance at which the volume reduction
   * starts taking effect.
   *
   * @param {number} value - The reference distance to set.
   * @return {PositionalAudio} A reference to this instance.
   */
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  /**
   * Returns the current rolloff factor.
   *
   * @return {number} The rolloff factor.
   */
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  /**
   * Defines how quickly the volume is reduced as the source moves away from the listener.
   *
   * @param {number} value - The rolloff factor.
   * @return {PositionalAudio} A reference to this instance.
   */
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  /**
   * Returns the current distance model.
   *
   * @return {('linear'|'inverse'|'exponential')} The distance model.
   */
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  /**
   * Defines which algorithm to use to reduce the volume of the audio source
   * as it moves away from the listener.
   *
   * Read [the spec]{@link https://www.w3.org/TR/webaudio-1.1/#enumdef-distancemodeltype}
   * for more details.
   *
   * @param {('linear'|'inverse'|'exponential')} value - The distance model to set.
   * @return {PositionalAudio} A reference to this instance.
   */
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  /**
   * Returns the current max distance.
   *
   * @return {number} The max distance.
   */
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  /**
   * Defines the maximum distance between the audio source and the listener,
   * after which the volume is not reduced any further.
   *
   * This value is used only by the `linear` distance model.
   *
   * @param {number} value - The max distance.
   * @return {PositionalAudio} A reference to this instance.
   */
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  /**
   * Sets the directional cone in which the audio can be listened.
   *
   * @param {number} coneInnerAngle - An angle, in degrees, of a cone inside of which there will be no volume reduction.
   * @param {number} coneOuterAngle - An angle, in degrees, of a cone outside of which the volume will be reduced by a constant value, defined by the `coneOuterGain` parameter.
   * @param {number} coneOuterGain - The amount of volume reduction outside the cone defined by the `coneOuterAngle`. When set to `0`, no sound can be heard.
   * @return {PositionalAudio} A reference to this instance.
   */
  setDirectionalCone(e, t, a) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = a, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(BS, qB, p4), US.set(0, 0, 1).applyQuaternion(qB);
    const t = this.panner;
    if (t.positionX) {
      const a = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(BS.x, a), t.positionY.linearRampToValueAtTime(BS.y, a), t.positionZ.linearRampToValueAtTime(BS.z, a), t.orientationX.linearRampToValueAtTime(US.x, a), t.orientationY.linearRampToValueAtTime(US.y, a), t.orientationZ.linearRampToValueAtTime(US.z, a);
    } else
      t.setPosition(BS.x, BS.y, BS.z), t.setOrientation(US.x, US.y, US.z);
  }
}
class v4 {
  /**
   * Constructs a new audio analyzer.
   *
   * @param {Audio} audio - The audio to analyze.
   * @param {number} [fftSize=2048] - The window size in samples that is used when performing a Fast Fourier Transform (FFT) to get frequency domain data.
   */
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  /**
   * Returns an array with frequency data of the audio.
   *
   * Each item in the array represents the decibel value for a specific frequency.
   * The frequencies are spread linearly from 0 to 1/2 of the sample rate.
   * For example, for 48000 sample rate, the last item of the array will represent
   * the decibel value for 24000 Hz.
   *
   * @return {Uint8Array} The frequency data.
   */
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  /**
   * Returns the average of the frequencies returned by {@link AudioAnalyser#getFrequencyData}.
   *
   * @return {number} The average frequency.
   */
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let a = 0; a < t.length; a++)
      e += t[a];
    return e / t.length;
  }
}
class sw {
  /**
   * Constructs a new property mixer.
   *
   * @param {PropertyBinding} binding - The property binding.
   * @param {string} typeName - The keyframe track type name.
   * @param {number} valueSize - The keyframe track value size.
   */
  constructor(e, t, a) {
    this.binding = e, this.valueSize = a;
    let r, d, p;
    switch (t) {
      case "quaternion":
        r = this._slerp, d = this._slerpAdditive, p = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(a * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        r = this._select, d = this._select, p = this._setAdditiveIdentityOther, this.buffer = new Array(a * 5);
        break;
      default:
        r = this._lerp, d = this._lerpAdditive, p = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(a * 5);
    }
    this._mixBufferRegion = r, this._mixBufferRegionAdditive = d, this._setIdentity = p, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  /**
   * Accumulates data in the `incoming` region into `accu<i>`.
   *
   * @param {number} accuIndex - The accumulation index.
   * @param {number} weight - The weight.
   */
  accumulate(e, t) {
    const a = this.buffer, r = this.valueSize, d = e * r + r;
    let p = this.cumulativeWeight;
    if (p === 0) {
      for (let y = 0; y !== r; ++y)
        a[d + y] = a[y];
      p = t;
    } else {
      p += t;
      const y = t / p;
      this._mixBufferRegion(a, d, 0, y, r);
    }
    this.cumulativeWeight = p;
  }
  /**
   * Accumulates data in the `incoming` region into `add`.
   *
   * @param {number} weight - The weight.
   */
  accumulateAdditive(e) {
    const t = this.buffer, a = this.valueSize, r = a * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, a), this.cumulativeWeightAdditive += e;
  }
  /**
   * Applies the state of `accu<i>` to the binding when accus differ.
   *
   * @param {number} accuIndex - The accumulation index.
   */
  apply(e) {
    const t = this.valueSize, a = this.buffer, r = e * t + t, d = this.cumulativeWeight, p = this.cumulativeWeightAdditive, y = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, d < 1) {
      const _ = t * this._origIndex;
      this._mixBufferRegion(
        a,
        r,
        _,
        1 - d,
        t
      );
    }
    p > 0 && this._mixBufferRegionAdditive(a, r, this._addIndex * t, 1, t);
    for (let _ = t, E = t + t; _ !== E; ++_)
      if (a[_] !== a[_ + t]) {
        y.setValue(a, r);
        break;
      }
  }
  /**
   * Remembers the state of the bound property and copy it to both accus.
   */
  saveOriginalState() {
    const e = this.binding, t = this.buffer, a = this.valueSize, r = a * this._origIndex;
    e.getValue(t, r);
    for (let d = a, p = r; d !== p; ++d)
      t[d] = t[r + d % a];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  /**
   * Applies the state previously taken via {@link PropertyMixer#saveOriginalState} to the binding.
   */
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  // internals
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let a = e; a < t; a++)
      this.buffer[a] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let a = 0; a < this.valueSize; a++)
      this.buffer[t + a] = this.buffer[e + a];
  }
  // mix functions
  _select(e, t, a, r, d) {
    if (r >= 0.5)
      for (let p = 0; p !== d; ++p)
        e[t + p] = e[a + p];
  }
  _slerp(e, t, a, r) {
    Ac.slerpFlat(e, t, e, t, e, a, r);
  }
  _slerpAdditive(e, t, a, r, d) {
    const p = this._workIndex * d;
    Ac.multiplyQuaternionsFlat(e, p, e, t, e, a), Ac.slerpFlat(e, t, e, t, e, p, r);
  }
  _lerp(e, t, a, r, d) {
    const p = 1 - r;
    for (let y = 0; y !== d; ++y) {
      const _ = t + y;
      e[_] = e[_] * p + e[a + y] * r;
    }
  }
  _lerpAdditive(e, t, a, r, d) {
    for (let p = 0; p !== d; ++p) {
      const y = t + p;
      e[y] = e[y] + e[a + p] * r;
    }
  }
}
const K2 = "\\[\\]\\.:\\/", g4 = new RegExp("[" + K2 + "]", "g"), k2 = "[^" + K2 + "]", y4 = "[^" + K2.replace("\\.", "") + "]", S4 = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", k2), _4 = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", y4), A4 = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", k2), E4 = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", k2), b4 = new RegExp(
  "^" + S4 + _4 + A4 + E4 + "$"
), M4 = ["material", "materials", "bones", "map"];
class x4 {
  constructor(e, t, a) {
    const r = a || Yi.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, r);
  }
  getValue(e, t) {
    this.bind();
    const a = this._targetGroup.nCachedObjects_, r = this._bindings[a];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const a = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, d = a.length; r !== d; ++r)
      a[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, a = e.length; t !== a; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, a = e.length; t !== a; ++t)
      e[t].unbind();
  }
}
class Yi {
  /**
   * Constructs a new property binding.
   *
   * @param {Object} rootNode - The root node.
   * @param {string} path - The path.
   * @param {?Object} [parsedPath] - The parsed path.
   */
  constructor(e, t, a) {
    this.path = t, this.parsedPath = a || Yi.parseTrackName(t), this.node = Yi.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  /**
   * Factory method for creating a property binding from the given parameters.
   *
   * @static
   * @param {Object} root - The root node.
   * @param {string} path - The path.
   * @param {?Object} [parsedPath] - The parsed path.
   * @return {PropertyBinding|Composite} The created property binding or composite.
   */
  static create(e, t, a) {
    return e && e.isAnimationObjectGroup ? new Yi.Composite(e, t, a) : new Yi(e, t, a);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name - Node name to be sanitized.
   * @return {string} The sanitized node name.
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(g4, "");
  }
  /**
   * Parses the given track name (an object path to an animated property) and
   * returns an object with information about the path. Matches strings in the following forms:
   *
   * - nodeName.property
   * - nodeName.property[accessor]
   * - nodeName.material.property[accessor]
   * - uuid.property[accessor]
   * - uuid.objectName[objectIndex].propertyName[propertyIndex]
   * - parentName/nodeName.property
   * - parentName/parentName/nodeName.property[index]
   * - .bone[Armature.DEF_cog].position
   * - scene:helium_balloon_model:helium_balloon_model.position
   *
   * @static
   * @param {string} trackName - The track name to parse.
   * @return {Object} The parsed track name as an object.
   */
  static parseTrackName(e) {
    const t = b4.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const a = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, r = a.nodeName && a.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const d = a.nodeName.substring(r + 1);
      M4.indexOf(d) !== -1 && (a.nodeName = a.nodeName.substring(0, r), a.objectName = d);
    }
    if (a.propertyName === null || a.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return a;
  }
  /**
   * Searches for a node in the hierarchy of the given root object by the given
   * node name.
   *
   * @static
   * @param {Object} root - The root object.
   * @param {string|number} nodeName - The name of the node.
   * @return {?Object} The found node. Returns `null` if no object was found.
   */
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const a = e.skeleton.getBoneByName(t);
      if (a !== void 0)
        return a;
    }
    if (e.children) {
      const a = function(d) {
        for (let p = 0; p < d.length; p++) {
          const y = d[p];
          if (y.name === t || y.uuid === t)
            return y;
          const _ = a(y.children);
          if (_) return _;
        }
        return null;
      }, r = a(e.children);
      if (r)
        return r;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const a = this.resolvedProperty;
    for (let r = 0, d = a.length; r !== d; ++r)
      e[t++] = a[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const a = this.resolvedProperty;
    for (let r = 0, d = a.length; r !== d; ++r)
      a[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const a = this.resolvedProperty;
    for (let r = 0, d = a.length; r !== d; ++r)
      a[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const a = this.resolvedProperty;
    for (let r = 0, d = a.length; r !== d; ++r)
      a[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  /**
   * Creates a getter / setter pair for the property tracked by this binding.
   */
  bind() {
    let e = this.node;
    const t = this.parsedPath, a = t.objectName, r = t.propertyName;
    let d = t.propertyIndex;
    if (e || (e = Yi.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (a) {
      let E = t.objectIndex;
      switch (a) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let T = 0; T < e.length; T++)
            if (e[T].name === E) {
              E = T;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[a] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[a];
      }
      if (E !== void 0) {
        if (e[E] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[E];
      }
    }
    const p = e[r];
    if (p === void 0) {
      const E = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + E + "." + r + " but it wasn't found.", e);
      return;
    }
    let y = this.Versioning.None;
    this.targetObject = e, e.isMaterial === !0 ? y = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (y = this.Versioning.MatrixWorldNeedsUpdate);
    let _ = this.BindingType.Direct;
    if (d !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[d] !== void 0 && (d = e.morphTargetDictionary[d]);
      }
      _ = this.BindingType.ArrayElement, this.resolvedProperty = p, this.propertyIndex = d;
    } else p.fromArray !== void 0 && p.toArray !== void 0 ? (_ = this.BindingType.HasFromToArray, this.resolvedProperty = p) : Array.isArray(p) ? (_ = this.BindingType.EntireArray, this.resolvedProperty = p) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[_], this.setValue = this.SetterByBindingTypeAndVersioning[_][y];
  }
  /**
   * Unbinds the property.
   */
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Yi.Composite = x4;
Yi.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Yi.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Yi.prototype.GetterByBindingType = [
  Yi.prototype._getValue_direct,
  Yi.prototype._getValue_array,
  Yi.prototype._getValue_arrayElement,
  Yi.prototype._getValue_toArray
];
Yi.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Yi.prototype._setValue_direct,
    Yi.prototype._setValue_direct_setNeedsUpdate,
    Yi.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Yi.prototype._setValue_array,
    Yi.prototype._setValue_array_setNeedsUpdate,
    Yi.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Yi.prototype._setValue_arrayElement,
    Yi.prototype._setValue_arrayElement_setNeedsUpdate,
    Yi.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Yi.prototype._setValue_fromArray,
    Yi.prototype._setValue_fromArray_setNeedsUpdate,
    Yi.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class T4 {
  /**
   * Constructs a new animation group.
   *
   * @param {...Object3D} arguments - An arbitrary number of 3D objects that share the same animation state.
   */
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = Gp(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let a = 0, r = arguments.length; a !== r; ++a)
      e[arguments[a].uuid] = a;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  /**
   * Adds an arbitrary number of objects to this animation group.
   *
   * @param {...Object3D} arguments - The 3D objects to add.
   */
  add() {
    const e = this._objects, t = this._indicesByUUID, a = this._paths, r = this._parsedPaths, d = this._bindings, p = d.length;
    let y, _ = e.length, E = this.nCachedObjects_;
    for (let T = 0, C = arguments.length; T !== C; ++T) {
      const D = arguments[T], B = D.uuid;
      let z = t[B];
      if (z === void 0) {
        z = _++, t[B] = z, e.push(D);
        for (let V = 0, G = p; V !== G; ++V)
          d[V].push(new Yi(D, a[V], r[V]));
      } else if (z < E) {
        y = e[z];
        const V = --E, G = e[V];
        t[G.uuid] = z, e[z] = G, t[B] = V, e[V] = D;
        for (let N = 0, F = p; N !== F; ++N) {
          const q = d[N], Y = q[V];
          let ie = q[z];
          q[z] = Y, ie === void 0 && (ie = new Yi(D, a[N], r[N])), q[V] = ie;
        }
      } else e[z] !== y && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = E;
  }
  /**
   * Removes an arbitrary number of objects to this animation group
   *
   * @param {...Object3D} arguments - The 3D objects to remove.
   */
  remove() {
    const e = this._objects, t = this._indicesByUUID, a = this._bindings, r = a.length;
    let d = this.nCachedObjects_;
    for (let p = 0, y = arguments.length; p !== y; ++p) {
      const _ = arguments[p], E = _.uuid, T = t[E];
      if (T !== void 0 && T >= d) {
        const C = d++, D = e[C];
        t[D.uuid] = T, e[T] = D, t[E] = C, e[C] = _;
        for (let B = 0, z = r; B !== z; ++B) {
          const V = a[B], G = V[C], N = V[T];
          V[T] = G, V[C] = N;
        }
      }
    }
    this.nCachedObjects_ = d;
  }
  /**
   * Deallocates all memory resources for the passed 3D objects of this animation group.
   *
   * @param {...Object3D} arguments - The 3D objects to uncache.
   */
  uncache() {
    const e = this._objects, t = this._indicesByUUID, a = this._bindings, r = a.length;
    let d = this.nCachedObjects_, p = e.length;
    for (let y = 0, _ = arguments.length; y !== _; ++y) {
      const E = arguments[y], T = E.uuid, C = t[T];
      if (C !== void 0)
        if (delete t[T], C < d) {
          const D = --d, B = e[D], z = --p, V = e[z];
          t[B.uuid] = C, e[C] = B, t[V.uuid] = D, e[D] = V, e.pop();
          for (let G = 0, N = r; G !== N; ++G) {
            const F = a[G], q = F[D], Y = F[z];
            F[C] = q, F[D] = Y, F.pop();
          }
        } else {
          const D = --p, B = e[D];
          D > 0 && (t[B.uuid] = C), e[C] = B, e.pop();
          for (let z = 0, V = r; z !== V; ++z) {
            const G = a[z];
            G[C] = G[D], G.pop();
          }
        }
    }
    this.nCachedObjects_ = d;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const a = this._bindingsIndicesByPath;
    let r = a[e];
    const d = this._bindings;
    if (r !== void 0) return d[r];
    const p = this._paths, y = this._parsedPaths, _ = this._objects, E = _.length, T = this.nCachedObjects_, C = new Array(E);
    r = d.length, a[e] = r, p.push(e), y.push(t), d.push(C);
    for (let D = T, B = _.length; D !== B; ++D) {
      const z = _[D];
      C[D] = new Yi(z, e, t);
    }
    return C;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, a = t[e];
    if (a !== void 0) {
      const r = this._paths, d = this._parsedPaths, p = this._bindings, y = p.length - 1, _ = p[y], E = e[y];
      t[E] = a, p[a] = _, p.pop(), d[a] = d[y], d.pop(), r[a] = r[y], r.pop();
    }
  }
}
class rw {
  /**
   * Constructs a new animation action.
   *
   * @param {AnimationMixer} mixer - The mixer that is controlled by this action.
   * @param {AnimationClip} clip - The animation clip that holds the actual keyframes.
   * @param {?Object3D} [localRoot=null] - The root object on which this action is performed.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
   */
  constructor(e, t, a = null, r = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = a, this.blendMode = r;
    const d = t.tracks, p = d.length, y = new Array(p), _ = {
      endingStart: FS,
      endingEnd: FS
    };
    for (let E = 0; E !== p; ++E) {
      const T = d[E].createInterpolant(null);
      y[E] = T, T.settings = _;
    }
    this._interpolantSettings = _, this._interpolants = y, this._propertyBindings = new Array(p), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = eO, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  /**
   * Starts the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  play() {
    return this._mixer._activateAction(this), this;
  }
  /**
   * Stops the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  /**
   * Resets the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  /**
   * Returns `true` if the animation is running.
   *
   * @return {boolean} Whether the animation is running or not.
   */
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  /**
   * Returns `true` when {@link AnimationAction#play} has been called.
   *
   * @return {boolean} Whether the animation is scheduled or not.
   */
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  /**
   * Defines the time when the animation should start.
   *
   * @param {number} time - The start time in seconds.
   * @return {AnimationAction} A reference to this animation action.
   */
  startAt(e) {
    return this._startTime = e, this;
  }
  /**
   * Configures the loop settings for this action.
   *
   * @param {(LoopRepeat|LoopOnce|LoopPingPong)} mode - The loop mode.
   * @param {number} repetitions - The number of repetitions.
   * @return {AnimationAction} A reference to this animation action.
   */
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  /**
   * Sets the effective weight of this action.
   *
   * An action has no effect and thus an effective weight of zero when the
   * action is disabled.
   *
   * @param {number} weight - The weight to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  /**
   * Returns the effective weight of this action.
   *
   * @return {number} The effective weight.
   */
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  /**
   * Fades the animation in by increasing its weight gradually from `0` to `1`,
   * within the passed time interval.
   *
   * @param {number} duration - The duration of the fade.
   * @return {AnimationAction} A reference to this animation action.
   */
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  /**
   * Fades the animation out by decreasing its weight gradually from `1` to `0`,
   * within the passed time interval.
   *
   * @param {number} duration - The duration of the fade.
   * @return {AnimationAction} A reference to this animation action.
   */
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  /**
   * Causes this action to fade in and the given action to fade out,
   * within the passed time interval.
   *
   * @param {AnimationAction} fadeOutAction - The animation action to fade out.
   * @param {number} duration - The duration of the fade.
   * @param {boolean} [warp=false] - Whether warping should be used or not.
   * @return {AnimationAction} A reference to this animation action.
   */
  crossFadeFrom(e, t, a = !1) {
    if (e.fadeOut(t), this.fadeIn(t), a === !0) {
      const r = this._clip.duration, d = e._clip.duration, p = d / r, y = r / d;
      e.warp(1, p, t), this.warp(y, 1, t);
    }
    return this;
  }
  /**
   * Causes this action to fade out and the given action to fade in,
   * within the passed time interval.
   *
   * @param {AnimationAction} fadeInAction - The animation action to fade in.
   * @param {number} duration - The duration of the fade.
   * @param {boolean} [warp=false] - Whether warping should be used or not.
   * @return {AnimationAction} A reference to this animation action.
   */
  crossFadeTo(e, t, a = !1) {
    return e.crossFadeFrom(this, t, a);
  }
  /**
   * Stops any fading which is applied to this action.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  /**
   * Sets the effective time scale of this action.
   *
   * An action has no effect and thus an effective time scale of zero when the
   * action is paused.
   *
   * @param {number} timeScale - The time scale to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  /**
   * Returns the effective time scale of this action.
   *
   * @return {number} The effective time scale.
   */
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  /**
   * Sets the duration for a single loop of this action.
   *
   * @param {number} duration - The duration to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  /**
   * Synchronizes this action with the passed other action.
   *
   * @param {AnimationAction} action - The action to sync with.
   * @return {AnimationAction} A reference to this animation action.
   */
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  /**
   * Decelerates this animation's speed to `0` within the passed time interval.
   *
   * @param {number} duration - The duration.
   * @return {AnimationAction} A reference to this animation action.
   */
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  /**
   * Changes the playback speed, within the passed time interval, by modifying
   * {@link AnimationAction#timeScale} gradually from `startTimeScale` to
   * `endTimeScale`.
   *
   * @param {number} startTimeScale - The start time scale.
   * @param {number} endTimeScale - The end time scale.
   * @param {number} duration - The duration.
   * @return {AnimationAction} A reference to this animation action.
   */
  warp(e, t, a) {
    const r = this._mixer, d = r.time, p = this.timeScale;
    let y = this._timeScaleInterpolant;
    y === null && (y = r._lendControlInterpolant(), this._timeScaleInterpolant = y);
    const _ = y.parameterPositions, E = y.sampleValues;
    return _[0] = d, _[1] = d + a, E[0] = e / p, E[1] = t / p, this;
  }
  /**
   * Stops any scheduled warping which is applied to this action.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  /**
   * Returns the animation mixer of this animation action.
   *
   * @return {AnimationMixer} The animation mixer.
   */
  getMixer() {
    return this._mixer;
  }
  /**
   * Returns the animation clip of this animation action.
   *
   * @return {AnimationClip} The animation clip.
   */
  getClip() {
    return this._clip;
  }
  /**
   * Returns the root object of this animation action.
   *
   * @return {Object3D} The root object.
   */
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, a, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const d = this._startTime;
    if (d !== null) {
      const _ = (e - d) * a;
      _ < 0 || a === 0 ? t = 0 : (this._startTime = null, t = a * _);
    }
    t *= this._updateTimeScale(e);
    const p = this._updateTime(t), y = this._updateWeight(e);
    if (y > 0) {
      const _ = this._interpolants, E = this._propertyBindings;
      switch (this.blendMode) {
        case _2:
          for (let T = 0, C = _.length; T !== C; ++T)
            _[T].evaluate(p), E[T].accumulateAdditive(y);
          break;
        case fx:
        default:
          for (let T = 0, C = _.length; T !== C; ++T)
            _[T].evaluate(p), E[T].accumulate(r, y);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const a = this._weightInterpolant;
      if (a !== null) {
        const r = a.evaluate(e)[0];
        t *= r, e > a.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const a = this._timeScaleInterpolant;
      if (a !== null) {
        const r = a.evaluate(e)[0];
        t *= r, e > a.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, a = this.loop;
    let r = this.time + e, d = this._loopCount;
    const p = a === tO;
    if (e === 0)
      return d === -1 ? r : p && (d & 1) === 1 ? t - r : r;
    if (a === $U) {
      d === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (r >= t)
          r = t;
        else if (r < 0)
          r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (d === -1 && (e >= 0 ? (d = 0, this._setEndings(!0, this.repetitions === 0, p)) : this._setEndings(this.repetitions === 0, !0, p)), r >= t || r < 0) {
        const y = Math.floor(r / t);
        r -= t * y, d += Math.abs(y);
        const _ = this.repetitions - d;
        if (_ <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (_ === 1) {
            const E = e < 0;
            this._setEndings(E, !E, p);
          } else
            this._setEndings(!1, !1, p);
          this._loopCount = d, this.time = r, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: y
          });
        }
      } else
        this.time = r;
      if (p && (d & 1) === 1)
        return t - r;
    }
    return r;
  }
  _setEndings(e, t, a) {
    const r = this._interpolantSettings;
    a ? (r.endingStart = PS, r.endingEnd = PS) : (e ? r.endingStart = this.zeroSlopeAtStart ? PS : FS : r.endingStart = qA, t ? r.endingEnd = this.zeroSlopeAtEnd ? PS : FS : r.endingEnd = qA);
  }
  _scheduleFading(e, t, a) {
    const r = this._mixer, d = r.time;
    let p = this._weightInterpolant;
    p === null && (p = r._lendControlInterpolant(), this._weightInterpolant = p);
    const y = p.parameterPositions, _ = p.sampleValues;
    return y[0] = d, _[0] = t, y[1] = d + e, _[1] = a, this;
  }
}
const C4 = new Float32Array(1);
class R4 extends Jg {
  /**
   * Constructs a new animation mixer.
   *
   * @param {Object3D} root - The object whose animations shall be played by this mixer.
   */
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const a = e._localRoot || this._root, r = e._clip.tracks, d = r.length, p = e._propertyBindings, y = e._interpolants, _ = a.uuid, E = this._bindingsByRootAndName;
    let T = E[_];
    T === void 0 && (T = {}, E[_] = T);
    for (let C = 0; C !== d; ++C) {
      const D = r[C], B = D.name;
      let z = T[B];
      if (z !== void 0)
        ++z.referenceCount, p[C] = z;
      else {
        if (z = p[C], z !== void 0) {
          z._cacheIndex === null && (++z.referenceCount, this._addInactiveBinding(z, _, B));
          continue;
        }
        const V = t && t._propertyBindings[C].binding.parsedPath;
        z = new sw(
          Yi.create(a, B, V),
          D.ValueTypeName,
          D.getValueSize()
        ), ++z.referenceCount, this._addInactiveBinding(z, _, B), p[C] = z;
      }
      y[C].resultBuffer = z.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const a = (e._localRoot || this._root).uuid, r = e._clip.uuid, d = this._actionsByClip[r];
        this._bindAction(
          e,
          d && d.knownActions[0]
        ), this._addInactiveAction(e, r, a);
      }
      const t = e._propertyBindings;
      for (let a = 0, r = t.length; a !== r; ++a) {
        const d = t[a];
        d.useCount++ === 0 && (this._lendBinding(d), d.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let a = 0, r = t.length; a !== r; ++a) {
        const d = t[a];
        --d.useCount === 0 && (d.restoreOriginalState(), this._takeBackBinding(d));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, a) {
    const r = this._actions, d = this._actionsByClip;
    let p = d[t];
    if (p === void 0)
      p = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, d[t] = p;
    else {
      const y = p.knownActions;
      e._byClipCacheIndex = y.length, y.push(e);
    }
    e._cacheIndex = r.length, r.push(e), p.actionByRoot[a] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, a = t[t.length - 1], r = e._cacheIndex;
    a._cacheIndex = r, t[r] = a, t.pop(), e._cacheIndex = null;
    const d = e._clip.uuid, p = this._actionsByClip, y = p[d], _ = y.knownActions, E = _[_.length - 1], T = e._byClipCacheIndex;
    E._byClipCacheIndex = T, _[T] = E, _.pop(), e._byClipCacheIndex = null;
    const C = y.actionByRoot, D = (e._localRoot || this._root).uuid;
    delete C[D], _.length === 0 && delete p[d], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let a = 0, r = t.length; a !== r; ++a) {
      const d = t[a];
      --d.referenceCount === 0 && this._removeInactiveBinding(d);
    }
  }
  _lendAction(e) {
    const t = this._actions, a = e._cacheIndex, r = this._nActiveActions++, d = t[r];
    e._cacheIndex = r, t[r] = e, d._cacheIndex = a, t[a] = d;
  }
  _takeBackAction(e) {
    const t = this._actions, a = e._cacheIndex, r = --this._nActiveActions, d = t[r];
    e._cacheIndex = r, t[r] = e, d._cacheIndex = a, t[a] = d;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, a) {
    const r = this._bindingsByRootAndName, d = this._bindings;
    let p = r[t];
    p === void 0 && (p = {}, r[t] = p), p[a] = e, e._cacheIndex = d.length, d.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, a = e.binding, r = a.rootNode.uuid, d = a.path, p = this._bindingsByRootAndName, y = p[r], _ = t[t.length - 1], E = e._cacheIndex;
    _._cacheIndex = E, t[E] = _, t.pop(), delete y[d], Object.keys(y).length === 0 && delete p[r];
  }
  _lendBinding(e) {
    const t = this._bindings, a = e._cacheIndex, r = this._nActiveBindings++, d = t[r];
    e._cacheIndex = r, t[r] = e, d._cacheIndex = a, t[a] = d;
  }
  _takeBackBinding(e) {
    const t = this._bindings, a = e._cacheIndex, r = --this._nActiveBindings, d = t[r];
    e._cacheIndex = r, t[r] = e, d._cacheIndex = a, t[a] = d;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let a = e[t];
    return a === void 0 && (a = new F2(
      new Float32Array(2),
      new Float32Array(2),
      1,
      C4
    ), a.__cacheIndex = t, e[t] = a), a;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, a = e.__cacheIndex, r = --this._nActiveControlInterpolants, d = t[r];
    e.__cacheIndex = r, t[r] = e, d.__cacheIndex = a, t[a] = d;
  }
  /**
   * Returns an instance of {@link AnimationAction} for the passed clip.
   *
   * If an action fitting the clip and root parameters doesn't yet exist, it
   * will be created by this method. Calling this method several times with the
   * same clip and root parameters always returns the same action.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
   * @return {?AnimationAction} The animation action.
   */
  clipAction(e, t, a) {
    const r = t || this._root, d = r.uuid;
    let p = typeof e == "string" ? M1.findByName(r, e) : e;
    const y = p !== null ? p.uuid : e, _ = this._actionsByClip[y];
    let E = null;
    if (a === void 0 && (p !== null ? a = p.blendMode : a = fx), _ !== void 0) {
      const C = _.actionByRoot[d];
      if (C !== void 0 && C.blendMode === a)
        return C;
      E = _.knownActions[0], p === null && (p = E._clip);
    }
    if (p === null) return null;
    const T = new rw(this, p, t, a);
    return this._bindAction(T, E), this._addInactiveAction(T, y, d), T;
  }
  /**
   * Returns an existing animation action for the passed clip.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   * @return {?AnimationAction} The animation action. Returns `null` if no action was found.
   */
  existingAction(e, t) {
    const a = t || this._root, r = a.uuid, d = typeof e == "string" ? M1.findByName(a, e) : e, p = d ? d.uuid : e, y = this._actionsByClip[p];
    return y !== void 0 && y.actionByRoot[r] || null;
  }
  /**
   * Deactivates all previously scheduled actions on this mixer.
   *
   * @return {AnimationMixer} A reference to thi animation mixer.
   */
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let a = t - 1; a >= 0; --a)
      e[a].stop();
    return this;
  }
  /**
   * Advances the global mixer time and updates the animation.
   *
   * This is usually done in the render loop by passing the delta
   * time from {@link Clock} or {@link Timer}.
   *
   * @param {number} deltaTime - The delta time in seconds.
   * @return {AnimationMixer} A reference to thi animation mixer.
   */
  update(e) {
    e *= this.timeScale;
    const t = this._actions, a = this._nActiveActions, r = this.time += e, d = Math.sign(e), p = this._accuIndex ^= 1;
    for (let E = 0; E !== a; ++E)
      t[E]._update(r, e, d, p);
    const y = this._bindings, _ = this._nActiveBindings;
    for (let E = 0; E !== _; ++E)
      y[E].apply(p);
    return this;
  }
  /**
   * Sets the global mixer to a specific time and updates the animation accordingly.
   *
   * This is useful when you need to jump to an exact time in an animation. The
   * input parameter will be scaled by {@link AnimationMixer#timeScale}
   *
   * @param {number} time - The time to set in seconds.
   * @return {AnimationMixer} A reference to thi animation mixer.
   */
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  /**
   * Returns this mixer's root object.
   *
   * @return {Object3D} The mixer's root object.
   */
  getRoot() {
    return this._root;
  }
  /**
   * Deallocates all memory resources for a clip. Before using this method make
   * sure to call {@link AnimationAction#stop} for all related actions.
   *
   * @param {AnimationClip} clip - The clip to uncache.
   */
  uncacheClip(e) {
    const t = this._actions, a = e.uuid, r = this._actionsByClip, d = r[a];
    if (d !== void 0) {
      const p = d.knownActions;
      for (let y = 0, _ = p.length; y !== _; ++y) {
        const E = p[y];
        this._deactivateAction(E);
        const T = E._cacheIndex, C = t[t.length - 1];
        E._cacheIndex = null, E._byClipCacheIndex = null, C._cacheIndex = T, t[T] = C, t.pop(), this._removeInactiveBindingsForAction(E);
      }
      delete r[a];
    }
  }
  /**
   * Deallocates all memory resources for a root object. Before using this
   * method make sure to call {@link AnimationAction#stop} for all related
   * actions or alternatively {@link AnimationMixer#stopAllAction} when the
   * mixer operates on a single root.
   *
   * @param {Object3D} root - The root object to uncache.
   */
  uncacheRoot(e) {
    const t = e.uuid, a = this._actionsByClip;
    for (const p in a) {
      const y = a[p].actionByRoot, _ = y[t];
      _ !== void 0 && (this._deactivateAction(_), this._removeInactiveAction(_));
    }
    const r = this._bindingsByRootAndName, d = r[t];
    if (d !== void 0)
      for (const p in d) {
        const y = d[p];
        y.restoreOriginalState(), this._removeInactiveBinding(y);
      }
  }
  /**
   * Deallocates all memory resources for an action. The action is identified by the
   * given clip and an optional root object. Before using this method make
   * sure to call {@link AnimationAction#stop} to deactivate the action.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   */
  uncacheAction(e, t) {
    const a = this.existingAction(e, t);
    a !== null && (this._deactivateAction(a), this._removeInactiveAction(a));
  }
}
class D4 extends hx {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {number} [depth=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, a = 1, r = {}) {
    super(e, t, r), this.isRenderTarget3D = !0, this.depth = a, this.texture = new px(null, e, t, a), this.texture.isRenderTargetTexture = !0;
  }
}
class B4 extends hx {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {number} [depth=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, a = 1, r = {}) {
    super(e, t, r), this.isRenderTargetArray = !0, this.depth = a, this.texture = new rE(null, e, t, a), this.texture.isRenderTargetTexture = !0;
  }
}
class $f {
  /**
   * Constructs a new uniform.
   *
   * @param {any} value - The uniform value.
   */
  constructor(e) {
    this.value = e;
  }
  /**
   * Returns a new uniform with copied values from this instance.
   * If the value has a `clone()` method, the value is cloned as well.
   *
   * @return {Uniform} A clone of this instance.
   */
  clone() {
    return new $f(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let U4 = 0;
class O4 extends Jg {
  /**
   * Constructs a new uniforms group.
   */
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: U4++ }), this.name = "", this.usage = QA, this.uniforms = [];
  }
  /**
   * Adds the given uniform to this uniforms group.
   *
   * @param {Uniform} uniform - The uniform to add.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  add(e) {
    return this.uniforms.push(e), this;
  }
  /**
   * Removes the given uniform from this uniforms group.
   *
   * @param {Uniform} uniform - The uniform to remove.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  /**
   * Sets the name of this uniforms group.
   *
   * @param {string} name - The name to set.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  setName(e) {
    return this.name = e, this;
  }
  /**
   * Sets the usage of this uniforms group.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Copies the values of the given uniforms group to this instance.
   *
   * @param {UniformsGroup} source - The uniforms group to copy.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let a = 0, r = t.length; a < r; a++) {
      const d = Array.isArray(t[a]) ? t[a] : [t[a]];
      for (let p = 0; p < d.length; p++)
        this.uniforms.push(d[p].clone());
    }
    return this;
  }
  /**
   * Returns a new uniforms group with copied values from this instance.
   *
   * @return {UniformsGroup} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class w4 extends cE {
  /**
   * Constructs a new instanced interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   * @param {number} [meshPerAttribute=1] - Defines how often a value of this interleaved buffer should be repeated.
   */
  constructor(e, t, a = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = a;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class N4 {
  /**
   * Constructs a new GL buffer attribute.
   *
   * @param {WebGLBuffer} buffer - The native WebGL buffer.
   * @param {number} type - The native data type (e.g. `gl.FLOAT`).
   * @param {number} itemSize - The item size.
   * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
   * @param {number} count - The expected number of vertices in VBO.
   */
  constructor(e, t, a, r, d) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = a, this.elementSize = r, this.count = d, this.version = 0;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the given native WebGL buffer.
   *
   * @param {WebGLBuffer} buffer - The buffer to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setBuffer(e) {
    return this.buffer = e, this;
  }
  /**
   * Sets the given native data type and element size.
   *
   * @param {number} type - The native data type (e.g. `gl.FLOAT`).
   * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
   * @return {BufferAttribute} A reference to this instance.
   */
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  /**
   * Sets the item size.
   *
   * @param {number} itemSize - The item size.
   * @return {BufferAttribute} A reference to this instance.
   */
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  /**
   * Sets the count (the expected number of vertices in VBO).
   *
   * @param {number} count - The count.
   * @return {BufferAttribute} A reference to this instance.
   */
  setCount(e) {
    return this.count = e, this;
  }
}
const ZB = /* @__PURE__ */ new ia();
class W2 {
  /**
   * Constructs a new raycaster.
   *
   * @param {Vector3} origin - The origin vector where the ray casts from.
   * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
   * @param {number} [near=0] - All results returned are further away than near. Near can't be negative.
   * @param {number} [far=Infinity] - All results returned are closer than far. Far can't be lower than near.
   */
  constructor(e, t, a = 0, r = 1 / 0) {
    this.ray = new l_(e, t), this.near = a, this.far = r, this.camera = null, this.layers = new A1(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  /**
   * Updates the ray with a new origin and direction by copying the values from the arguments.
   *
   * @param {Vector3} origin - The origin vector where the ray casts from.
   * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
   */
  set(e, t) {
    this.ray.set(e, t);
  }
  /**
   * Uses the given coordinates and camera to compute a new origin and direction for the internal ray.
   *
   * @param {Vector2} coords - 2D coordinates of the mouse, in normalized device coordinates (NDC).
   * X and Y components should be between `-1` and `1`.
   * @param {Camera} camera - The camera from which the ray should originate.
   */
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  /**
   * Uses the given WebXR controller to compute a new origin and direction for the internal ray.
   *
   * @param {WebXRController} controller - The controller to copy the position and direction from.
   * @return {Raycaster} A reference to this raycaster.
   */
  setFromXRController(e) {
    return ZB.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(ZB), this;
  }
  /**
   * The intersection point of a raycaster intersection test.
   * @typedef {Object} Raycaster~Intersection
   * @property {number} distance - The distance from the ray's origin to the intersection point.
   * @property {number} distanceToRay -  Some 3D objects e.g. {@link Points} provide the distance of the
   * intersection to the nearest point on the ray. For other objects it will be `undefined`.
   * @property {Vector3} point - The intersection point, in world coordinates.
   * @property {Object} face - The face that has been intersected.
   * @property {number} faceIndex - The face index.
   * @property {Object3D} object - The 3D object that has been intersected.
   * @property {Vector2} uv - U,V coordinates at point of intersection.
   * @property {Vector2} uv1 - Second set of U,V coordinates at point of intersection.
   * @property {Vector3} uv1 - Interpolated normal vector at point of intersection.
   * @property {number} instanceId - The index number of the instance where the ray
   * intersects the {@link InstancedMesh}.
   */
  /**
   * Checks all intersection between the ray and the object with or without the
   * descendants. Intersections are returned sorted by distance, closest first.
   *
   * `Raycaster` delegates to the `raycast()` method of the passed 3D object, when
   * evaluating whether the ray intersects the object or not. This allows meshes to respond
   * differently to ray casting than lines or points.
   *
   * Note that for meshes, faces must be pointed towards the origin of the ray in order
   * to be detected; intersections of the ray passing through the back of a face will not
   * be detected. To raycast against both faces of an object, you'll want to set  {@link Material#side}
   * to `THREE.DoubleSide`.
   *
   * @param {Object3D} object - The 3D object to check for intersection with the ray.
   * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
   * Otherwise it only checks intersection with the object.
   * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
   * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
   */
  intersectObject(e, t = !0, a = []) {
    return WC(e, this, a, t), a.sort(QB), a;
  }
  /**
   * Checks all intersection between the ray and the objects with or without
   * the descendants. Intersections are returned sorted by distance, closest first.
   *
   * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.
   * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
   * Otherwise it only checks intersection with the object.
   * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
   * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
   */
  intersectObjects(e, t = !0, a = []) {
    for (let r = 0, d = e.length; r < d; r++)
      WC(e[r], this, a, t);
    return a.sort(QB), a;
  }
}
function QB(o, e) {
  return o.distance - e.distance;
}
function WC(o, e, t, a) {
  let r = !0;
  if (o.layers.test(e.layers) && o.raycast(e, t) === !1 && (r = !1), r === !0 && a === !0) {
    const d = o.children;
    for (let p = 0, y = d.length; p < y; p++)
      WC(d[p], e, t, !0);
  }
}
class KM {
  /**
   * Constructs a new spherical.
   *
   * @param {number} [radius=1] - The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
   * @param {number} [phi=0] - The polar angle in radians from the y (up) axis.
   * @param {number} [theta=0] - The equator/azimuthal angle in radians around the y (up) axis.
   */
  constructor(e = 1, t = 0, a = 0) {
    this.radius = e, this.phi = t, this.theta = a;
  }
  /**
   * Sets the spherical components by copying the given values.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The polar angle.
   * @param {number} theta - The azimuthal angle.
   * @return {Spherical} A reference to this spherical.
   */
  set(e, t, a) {
    return this.radius = e, this.phi = t, this.theta = a, this;
  }
  /**
   * Copies the values of the given spherical to this instance.
   *
   * @param {Spherical} other - The spherical to copy.
   * @return {Spherical} A reference to this spherical.
   */
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  /**
   * Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
   * `0.000001`.
   *
   * @return {Spherical} A reference to this spherical.
   */
  makeSafe() {
    return this.phi = Fa(this.phi, 1e-6, Math.PI - 1e-6), this;
  }
  /**
   * Sets the spherical components from the given vector which is assumed to hold
   * Cartesian coordinates.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Spherical} A reference to this spherical.
   */
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  /**
   * Sets the spherical components from the given Cartesian coordinates.
   *
   * @param {number} x - The x value.
   * @param {number} y - The x value.
   * @param {number} z - The x value.
   * @return {Spherical} A reference to this spherical.
   */
  setFromCartesianCoords(e, t, a) {
    return this.radius = Math.sqrt(e * e + t * t + a * a), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, a), this.phi = Math.acos(Fa(t / this.radius, -1, 1))), this;
  }
  /**
   * Returns a new spherical with copied values from this instance.
   *
   * @return {Spherical} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class z4 {
  /**
   * Constructs a new cylindrical.
   *
   * @param {number} [radius=1] - The distance from the origin to a point in the x-z plane.
   * @param {number} [theta=0] - A counterclockwise angle in the x-z plane measured in radians from the positive z-axis.
   * @param {number} [y=0] - The height above the x-z plane.
   */
  constructor(e = 1, t = 0, a = 0) {
    this.radius = e, this.theta = t, this.y = a;
  }
  /**
   * Sets the cylindrical components by copying the given values.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle.
   * @param {number} y - The height value.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  set(e, t, a) {
    return this.radius = e, this.theta = t, this.y = a, this;
  }
  /**
   * Copies the values of the given cylindrical to this instance.
   *
   * @param {Cylindrical} other - The cylindrical to copy.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  /**
   * Sets the cylindrical components from the given vector which is assumed to hold
   * Cartesian coordinates.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  /**
   * Sets the cylindrical components from the given Cartesian coordinates.
   *
   * @param {number} x - The x value.
   * @param {number} y - The x value.
   * @param {number} z - The x value.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  setFromCartesianCoords(e, t, a) {
    return this.radius = Math.sqrt(e * e + a * a), this.theta = Math.atan2(e, a), this.y = t, this;
  }
  /**
   * Returns a new cylindrical with copied values from this instance.
   *
   * @return {Cylindrical} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class $2 {
  /**
   * Constructs a new 2x2 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   */
  constructor(e, t, a, r) {
    $2.prototype.isMatrix2 = !0, this.elements = [
      1,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, a, r);
  }
  /**
   * Sets this matrix to the 2x2 identity matrix.
   *
   * @return {Matrix2} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix2} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let a = 0; a < 4; a++)
      this.elements[a] = e[a + t];
    return this;
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} n11 - 1-1 matrix element.
   * @param {number} n12 - 1-2 matrix element.
   * @param {number} n21 - 2-1 matrix element.
   * @param {number} n22 - 2-2 matrix element.
   * @return {Matrix2} A reference to this matrix.
   */
  set(e, t, a, r) {
    const d = this.elements;
    return d[0] = e, d[2] = t, d[1] = a, d[3] = r, this;
  }
}
const jB = /* @__PURE__ */ new Ot();
class H4 {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector2} [min=(Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector2} [max=(-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(e = new Ot(1 / 0, 1 / 0), t = new Ot(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector2} min - The lower boundary of the box.
   * @param {Vector2} max - The upper boundary of the box.
   * @return {Box2} A reference to this bounding box.
   */
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector2>} points - An array holding 2D position data as instances of {@link Vector2}.
   * @return {Box2} A reference to this bounding box.
   */
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, a = e.length; t < a; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector2} center - The center of the box.
   * @param {Vector2} size - The x and y dimensions of the box.
   * @return {Box2} A reference to this bounding box.
   */
  setFromCenterAndSize(e, t) {
    const a = jB.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(a), this.max.copy(e).add(a), this;
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box2} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box2} box - The box to copy.
   * @return {Box2} A reference to this bounding box.
   */
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 2D.
   *
   * @return {Box2} A reference to this bounding box.
   */
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The center point.
   */
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The size.
   */
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector2} point - The point that should be included by the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions.
   *
   * @param {Vector2} vector - The vector that should expand the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector2} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box2} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  /**
   * Returns a point as a proportion of this box's width and height.
   *
   * @param {Vector2} point - A point in 2D space.
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} A point as a proportion of this box's width and height.
   */
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box2} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y;
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector2} point - The point to clamp.
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The clamped point.
   */
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector2} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(e) {
    return this.clampPoint(e, jB).distanceTo(e);
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box2} box - The bounding box to intersect with.
   * @return {Box2} A reference to this bounding box.
   */
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box2} box - The bounding box that will be unioned with this instance.
   * @return {Box2} A reference to this bounding box.
   */
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 2D space.
   *
   * @param {Vector2} offset - The offset that should be used to translate the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box2} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const JB = /* @__PURE__ */ new ve(), wb = /* @__PURE__ */ new ve();
class L4 {
  /**
   * Constructs a new line segment.
   *
   * @param {Vector3} [start=(0,0,0)] - Start of the line segment.
   * @param {Vector3} [end=(0,0,0)] - End of the line segment.
   */
  constructor(e = new ve(), t = new ve()) {
    this.start = e, this.end = t;
  }
  /**
   * Sets the start and end values by copying the given vectors.
   *
   * @param {Vector3} start - The start point.
   * @param {Vector3} end - The end point.
   * @return {Line3} A reference to this line segment.
   */
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  /**
   * Copies the values of the given line segment to this instance.
   *
   * @param {Line3} line - The line segment to copy.
   * @return {Line3} A reference to this line segment.
   */
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  /**
   * Returns the center of the line segment.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  /**
   * Returns the delta vector of the line segment's start and end point.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The delta vector.
   */
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  /**
   * Returns the squared Euclidean distance between the line' start and end point.
   *
   * @return {number} The squared Euclidean distance.
   */
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  /**
   * Returns the Euclidean distance between the line' start and end point.
   *
   * @return {number} The Euclidean distance.
   */
  distance() {
    return this.start.distanceTo(this.end);
  }
  /**
   * Returns a vector at a certain position along the line segment.
   *
   * @param {number} t - A value between `[0,1]` to represent a position along the line segment.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The delta vector.
   */
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  /**
   * Returns a point parameter based on the closest point as projected on the line segment.
   *
   * @param {Vector3} point - The point for which to return a point parameter.
   * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
   * @return {number} The point parameter.
   */
  closestPointToPointParameter(e, t) {
    JB.subVectors(e, this.start), wb.subVectors(this.end, this.start);
    const a = wb.dot(wb);
    let d = wb.dot(JB) / a;
    return t && (d = Fa(d, 0, 1)), d;
  }
  /**
   * Returns the closets point on the line for a given point.
   *
   * @param {Vector3} point - The point to compute the closest point on the line for.
   * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
   * @param {Vector3} target -  The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the line.
   */
  closestPointToPoint(e, t, a) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(a).multiplyScalar(r).add(this.start);
  }
  /**
   * Applies a 4x4 transformation matrix to this line segment.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Line3} A reference to this line segment.
   */
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  /**
   * Returns `true` if this line segment is equal with the given one.
   *
   * @param {Line3} line - The line segment to test for equality.
   * @return {boolean} Whether this line segment is equal with the given one.
   */
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  /**
   * Returns a new line segment with copied values from this instance.
   *
   * @return {Line3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const KB = /* @__PURE__ */ new ve();
class G4 extends zi {
  /**
   * Constructs a new spot light helper.
   *
   * @param {HemisphereLight} light - The light to be visualized.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const a = new Pa(), r = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let p = 0, y = 1, _ = 32; p < _; p++, y++) {
      const E = p / _ * Math.PI * 2, T = y / _ * Math.PI * 2;
      r.push(
        Math.cos(E),
        Math.sin(E),
        1,
        Math.cos(T),
        Math.sin(T),
        1
      );
    }
    a.setAttribute("position", new qn(r, 3));
    const d = new nd({ fog: !1, toneMapped: !1 });
    this.cone = new kv(a, d), this.add(this.cone), this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), KB.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(KB), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const H0 = /* @__PURE__ */ new ve(), Nb = /* @__PURE__ */ new ia(), rC = /* @__PURE__ */ new ia();
class I4 extends kv {
  /**
   * Constructs a new hemisphere light helper.
   *
   * @param {Object3D} object -  Usually an instance of {@link SkinnedMesh}. However, any 3D object
   * can be used if it represents a hierarchy of bones (see {@link Bone}).
   */
  constructor(e) {
    const t = ow(e), a = new Pa(), r = [], d = [], p = new hn(0, 0, 1), y = new hn(0, 1, 0);
    for (let E = 0; E < t.length; E++) {
      const T = t[E];
      T.parent && T.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), d.push(p.r, p.g, p.b), d.push(y.r, y.g, y.b));
    }
    a.setAttribute("position", new qn(r, 3)), a.setAttribute("color", new qn(d, 3));
    const _ = new nd({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(a, _), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, a = this.geometry, r = a.getAttribute("position");
    rC.copy(this.root.matrixWorld).invert();
    for (let d = 0, p = 0; d < t.length; d++) {
      const y = t[d];
      y.parent && y.parent.isBone && (Nb.multiplyMatrices(rC, y.matrixWorld), H0.setFromMatrixPosition(Nb), r.setXYZ(p, H0.x, H0.y, H0.z), Nb.multiplyMatrices(rC, y.parent.matrixWorld), H0.setFromMatrixPosition(Nb), r.setXYZ(p + 1, H0.x, H0.y, H0.z), p += 2);
    }
    a.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function ow(o) {
  const e = [];
  o.isBone === !0 && e.push(o);
  for (let t = 0; t < o.children.length; t++)
    e.push(...ow(o.children[t]));
  return e;
}
class V4 extends es {
  /**
   * Constructs a new point light helper.
   *
   * @param {PointLight} light - The light to be visualized.
   * @param {number} [sphereSize=1] - The size of the sphere helper.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t, a) {
    const r = new vE(t, 4, 2), d = new Yh({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, d), this.light = e, this.color = a, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  /**
   * Updates the helper to match the position of the
   * light being visualized.
   */
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const F4 = /* @__PURE__ */ new ve(), kB = /* @__PURE__ */ new hn(), WB = /* @__PURE__ */ new hn();
class P4 extends zi {
  /**
   * Constructs a new hemisphere light helper.
   *
   * @param {HemisphereLight} light - The light to be visualized.
   * @param {number} [size=1] - The size of the mesh used to visualize the light.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t, a) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = a, this.type = "HemisphereLightHelper";
    const r = new mE(t);
    r.rotateY(Math.PI * 0.5), this.material = new Yh({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const d = r.getAttribute("position"), p = new Float32Array(d.count * 3);
    r.setAttribute("color", new Hi(p, 3)), this.add(new es(r, this.material)), this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      kB.copy(this.light.color), WB.copy(this.light.groundColor);
      for (let a = 0, r = t.count; a < r; a++) {
        const d = a < r / 2 ? kB : WB;
        t.setXYZ(a, d.r, d.g, d.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(F4.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class X4 extends kv {
  /**
   * Constructs a new grid helper.
   *
   * @param {number} [size=10] - The size of the grid.
   * @param {number} [divisions=10] - The number of divisions across the grid.
   * @param {number|Color|string} [color1=0x444444] - The color of the center line.
   * @param {number|Color|string} [color2=0x888888] - The color of the lines of the grid.
   */
  constructor(e = 10, t = 10, a = 4473924, r = 8947848) {
    a = new hn(a), r = new hn(r);
    const d = t / 2, p = e / t, y = e / 2, _ = [], E = [];
    for (let D = 0, B = 0, z = -y; D <= t; D++, z += p) {
      _.push(-y, 0, z, y, 0, z), _.push(z, 0, -y, z, 0, y);
      const V = D === d ? a : r;
      V.toArray(E, B), B += 3, V.toArray(E, B), B += 3, V.toArray(E, B), B += 3, V.toArray(E, B), B += 3;
    }
    const T = new Pa();
    T.setAttribute("position", new qn(_, 3)), T.setAttribute("color", new qn(E, 3));
    const C = new nd({ vertexColors: !0, toneMapped: !1 });
    super(T, C), this.type = "GridHelper";
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Y4 extends kv {
  /**
   * Constructs a new polar grid helper.
   *
   * @param {number} [radius=10] - The radius of the polar grid. This can be any positive number.
   * @param {number} [sectors=16] - The number of sectors the grid will be divided into. This can be any positive integer.
   * @param {number} [rings=16] - The number of rings. This can be any positive integer.
   * @param {number} [divisions=64] - The number of line segments used for each circle. This can be any positive integer.
   * @param {number|Color|string} [color1=0x444444] - The first color used for grid elements.
   * @param {number|Color|string} [color2=0x888888] -  The second color used for grid elements.
   */
  constructor(e = 10, t = 16, a = 8, r = 64, d = 4473924, p = 8947848) {
    d = new hn(d), p = new hn(p);
    const y = [], _ = [];
    if (t > 1)
      for (let C = 0; C < t; C++) {
        const D = C / t * (Math.PI * 2), B = Math.sin(D) * e, z = Math.cos(D) * e;
        y.push(0, 0, 0), y.push(B, 0, z);
        const V = C & 1 ? d : p;
        _.push(V.r, V.g, V.b), _.push(V.r, V.g, V.b);
      }
    for (let C = 0; C < a; C++) {
      const D = C & 1 ? d : p, B = e - e / a * C;
      for (let z = 0; z < r; z++) {
        let V = z / r * (Math.PI * 2), G = Math.sin(V) * B, N = Math.cos(V) * B;
        y.push(G, 0, N), _.push(D.r, D.g, D.b), V = (z + 1) / r * (Math.PI * 2), G = Math.sin(V) * B, N = Math.cos(V) * B, y.push(G, 0, N), _.push(D.r, D.g, D.b);
      }
    }
    const E = new Pa();
    E.setAttribute("position", new qn(y, 3)), E.setAttribute("color", new qn(_, 3));
    const T = new nd({ vertexColors: !0, toneMapped: !1 });
    super(E, T), this.type = "PolarGridHelper";
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const $B = /* @__PURE__ */ new ve(), zb = /* @__PURE__ */ new ve(), e3 = /* @__PURE__ */ new ve();
class q4 extends zi {
  /**
   * Constructs a new directional light helper.
   *
   * @param {DirectionalLight} light - The light to be visualized.
   * @param {number} [size=1] - The dimensions of the plane.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t, a) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = a, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let r = new Pa();
    r.setAttribute("position", new qn([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const d = new nd({ fog: !1, toneMapped: !1 });
    this.lightPlane = new Qy(r, d), this.add(this.lightPlane), r = new Pa(), r.setAttribute("position", new qn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Qy(r, d), this.add(this.targetLine), this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), $B.setFromMatrixPosition(this.light.matrixWorld), zb.setFromMatrixPosition(this.light.target.matrixWorld), e3.subVectors(zb, $B), this.lightPlane.lookAt(zb), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(zb), this.targetLine.scale.z = e3.length();
  }
}
const Hb = /* @__PURE__ */ new ve(), Fr = /* @__PURE__ */ new oE();
class Z4 extends kv {
  /**
   * Constructs a new arrow helper.
   *
   * @param {Camera} camera - The camera to visualize.
   */
  constructor(e) {
    const t = new Pa(), a = new nd({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], d = [], p = {};
    y("n1", "n2"), y("n2", "n4"), y("n4", "n3"), y("n3", "n1"), y("f1", "f2"), y("f2", "f4"), y("f4", "f3"), y("f3", "f1"), y("n1", "f1"), y("n2", "f2"), y("n3", "f3"), y("n4", "f4"), y("p", "n1"), y("p", "n2"), y("p", "n3"), y("p", "n4"), y("u1", "u2"), y("u2", "u3"), y("u3", "u1"), y("c", "t"), y("p", "c"), y("cn1", "cn2"), y("cn3", "cn4"), y("cf1", "cf2"), y("cf3", "cf4");
    function y(z, V) {
      _(z), _(V);
    }
    function _(z) {
      r.push(0, 0, 0), d.push(0, 0, 0), p[z] === void 0 && (p[z] = []), p[z].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new qn(r, 3)), t.setAttribute("color", new qn(d, 3)), super(t, a), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = p, this.update();
    const E = new hn(16755200), T = new hn(16711680), C = new hn(43775), D = new hn(16777215), B = new hn(3355443);
    this.setColors(E, T, C, D, B);
  }
  /**
   * Defines the colors of the helper.
   *
   * @param {Color} frustum - The frustum line color.
   * @param {Color} cone - The cone line color.
   * @param {Color} up - The up line color.
   * @param {Color} target - The target line color.
   * @param {Color} cross - The cross line color.
   */
  setColors(e, t, a, r, d) {
    const y = this.geometry.getAttribute("color");
    y.setXYZ(0, e.r, e.g, e.b), y.setXYZ(1, e.r, e.g, e.b), y.setXYZ(2, e.r, e.g, e.b), y.setXYZ(3, e.r, e.g, e.b), y.setXYZ(4, e.r, e.g, e.b), y.setXYZ(5, e.r, e.g, e.b), y.setXYZ(6, e.r, e.g, e.b), y.setXYZ(7, e.r, e.g, e.b), y.setXYZ(8, e.r, e.g, e.b), y.setXYZ(9, e.r, e.g, e.b), y.setXYZ(10, e.r, e.g, e.b), y.setXYZ(11, e.r, e.g, e.b), y.setXYZ(12, e.r, e.g, e.b), y.setXYZ(13, e.r, e.g, e.b), y.setXYZ(14, e.r, e.g, e.b), y.setXYZ(15, e.r, e.g, e.b), y.setXYZ(16, e.r, e.g, e.b), y.setXYZ(17, e.r, e.g, e.b), y.setXYZ(18, e.r, e.g, e.b), y.setXYZ(19, e.r, e.g, e.b), y.setXYZ(20, e.r, e.g, e.b), y.setXYZ(21, e.r, e.g, e.b), y.setXYZ(22, e.r, e.g, e.b), y.setXYZ(23, e.r, e.g, e.b), y.setXYZ(24, t.r, t.g, t.b), y.setXYZ(25, t.r, t.g, t.b), y.setXYZ(26, t.r, t.g, t.b), y.setXYZ(27, t.r, t.g, t.b), y.setXYZ(28, t.r, t.g, t.b), y.setXYZ(29, t.r, t.g, t.b), y.setXYZ(30, t.r, t.g, t.b), y.setXYZ(31, t.r, t.g, t.b), y.setXYZ(32, a.r, a.g, a.b), y.setXYZ(33, a.r, a.g, a.b), y.setXYZ(34, a.r, a.g, a.b), y.setXYZ(35, a.r, a.g, a.b), y.setXYZ(36, a.r, a.g, a.b), y.setXYZ(37, a.r, a.g, a.b), y.setXYZ(38, r.r, r.g, r.b), y.setXYZ(39, r.r, r.g, r.b), y.setXYZ(40, d.r, d.g, d.b), y.setXYZ(41, d.r, d.g, d.b), y.setXYZ(42, d.r, d.g, d.b), y.setXYZ(43, d.r, d.g, d.b), y.setXYZ(44, d.r, d.g, d.b), y.setXYZ(45, d.r, d.g, d.b), y.setXYZ(46, d.r, d.g, d.b), y.setXYZ(47, d.r, d.g, d.b), y.setXYZ(48, d.r, d.g, d.b), y.setXYZ(49, d.r, d.g, d.b), y.needsUpdate = !0;
  }
  /**
   * Updates the helper based on the projection matrix of the camera.
   */
  update() {
    const e = this.geometry, t = this.pointMap, a = 1, r = 1;
    Fr.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    const d = this.camera.coordinateSystem === Qv ? -1 : 0;
    bo("c", t, e, Fr, 0, 0, d), bo("t", t, e, Fr, 0, 0, 1), bo("n1", t, e, Fr, -1, -1, d), bo("n2", t, e, Fr, a, -1, d), bo("n3", t, e, Fr, -1, r, d), bo("n4", t, e, Fr, a, r, d), bo("f1", t, e, Fr, -1, -1, 1), bo("f2", t, e, Fr, a, -1, 1), bo("f3", t, e, Fr, -1, r, 1), bo("f4", t, e, Fr, a, r, 1), bo("u1", t, e, Fr, a * 0.7, r * 1.1, d), bo("u2", t, e, Fr, -1 * 0.7, r * 1.1, d), bo("u3", t, e, Fr, 0, r * 2, d), bo("cf1", t, e, Fr, -1, 0, 1), bo("cf2", t, e, Fr, a, 0, 1), bo("cf3", t, e, Fr, 0, -1, 1), bo("cf4", t, e, Fr, 0, r, 1), bo("cn1", t, e, Fr, -1, 0, d), bo("cn2", t, e, Fr, a, 0, d), bo("cn3", t, e, Fr, 0, -1, d), bo("cn4", t, e, Fr, 0, r, d), e.getAttribute("position").needsUpdate = !0;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function bo(o, e, t, a, r, d, p) {
  Hb.set(r, d, p).unproject(a);
  const y = e[o];
  if (y !== void 0) {
    const _ = t.getAttribute("position");
    for (let E = 0, T = y.length; E < T; E++)
      _.setXYZ(y[E], Hb.x, Hb.y, Hb.z);
  }
}
const Lb = /* @__PURE__ */ new td();
class Q4 extends kv {
  /**
   * Constructs a new box helper.
   *
   * @param {Object3D} [object] - The 3D object to show the world-axis-aligned bounding box.
   * @param {number|Color|string} [color=0xffff00] - The box's color.
   */
  constructor(e, t = 16776960) {
    const a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), d = new Pa();
    d.setIndex(new Hi(a, 1)), d.setAttribute("position", new Hi(r, 3)), super(d, new nd({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  /**
   * Updates the helper's geometry to match the dimensions of the object,
   * including any children.
   */
  update() {
    if (this.object !== void 0 && Lb.setFromObject(this.object), Lb.isEmpty()) return;
    const e = Lb.min, t = Lb.max, a = this.geometry.attributes.position, r = a.array;
    r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = e.x, r[4] = t.y, r[5] = t.z, r[6] = e.x, r[7] = e.y, r[8] = t.z, r[9] = t.x, r[10] = e.y, r[11] = t.z, r[12] = t.x, r[13] = t.y, r[14] = e.z, r[15] = e.x, r[16] = t.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = t.x, r[22] = e.y, r[23] = e.z, a.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  /**
   * Updates the wireframe box for the passed object.
   *
   * @param {Object3D} object - The 3D object to create the helper for.
   * @return {BoxHelper} A reference to this instance.
   */
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class j4 extends kv {
  /**
   * Constructs a new box3 helper.
   *
   * @param {Box3} box - The box to visualize.
   * @param {number|Color|string} [color=0xffff00] - The box's color.
   */
  constructor(e, t = 16776960) {
    const a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], d = new Pa();
    d.setIndex(new Hi(a, 1)), d.setAttribute("position", new qn(r, 3)), super(d, new nd({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class J4 extends Qy {
  /**
   * Constructs a new plane helper.
   *
   * @param {Plane} plane - The plane to be visualized.
   * @param {number} [size=1] - The side length of plane helper.
   * @param {number|Color|string} [hex=0xffff00] - The helper's color.
   */
  constructor(e, t = 1, a = 16776960) {
    const r = a, d = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], p = new Pa();
    p.setAttribute("position", new qn(d, 3)), p.computeBoundingSphere(), super(p, new nd({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const y = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], _ = new Pa();
    _.setAttribute("position", new qn(y, 3)), _.computeBoundingSphere(), this.add(new es(_, new Yh({ color: r, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const t3 = /* @__PURE__ */ new ve();
let Gb, oC;
class K4 extends zi {
  /**
   * Constructs a new arrow helper.
   *
   * @param {Vector3} [dir=(0, 0, 1)] - The (normalized) direction vector.
   * @param {Vector3} [origin=(0, 0, 0)] - Point at which the arrow starts.
   * @param {number} [length=1] - Length of the arrow in world units.
   * @param {(number|Color|string)} [color=0xffff00] - Color of the arrow.
   * @param {number} [headLength=length*0.2] - The length of the head of the arrow.
   * @param {number} [headWidth=headLength*0.2] - The width of the head of the arrow.
   */
  constructor(e = new ve(0, 0, 1), t = new ve(0, 0, 0), a = 1, r = 16776960, d = a * 0.2, p = d * 0.2) {
    super(), this.type = "ArrowHelper", Gb === void 0 && (Gb = new Pa(), Gb.setAttribute("position", new qn([0, 0, 0, 0, 1, 0], 3)), oC = new D1(0, 0.5, 1, 5, 1), oC.translate(0, -0.5, 0)), this.position.copy(t), this.line = new Qy(Gb, new nd({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new es(oC, new Yh({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(a, d, p);
  }
  /**
   * Sets the direction of the helper.
   *
   * @param {Vector3} dir - The normalized direction vector.
   */
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      t3.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(t3, t);
    }
  }
  /**
   * Sets the length of the helper.
   *
   * @param {number} length - Length of the arrow in world units.
   * @param {number} [headLength=length*0.2] - The length of the head of the arrow.
   * @param {number} [headWidth=headLength*0.2] - The width of the head of the arrow.
   */
  setLength(e, t = e * 0.2, a = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(a, t, a), this.cone.position.y = e, this.cone.updateMatrix();
  }
  /**
   * Sets the color of the helper.
   *
   * @param {number|Color|string} color - The color to set.
   */
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class k4 extends kv {
  /**
   * Constructs a new axes helper.
   *
   * @param {number} [size=1] - Size of the lines representing the axes.
   */
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], a = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], r = new Pa();
    r.setAttribute("position", new qn(t, 3)), r.setAttribute("color", new qn(a, 3));
    const d = new nd({ vertexColors: !0, toneMapped: !1 });
    super(r, d), this.type = "AxesHelper";
  }
  /**
   * Defines the colors of the axes helper.
   *
   * @param {number|Color|string} xAxisColor - The color for the x axis.
   * @param {number|Color|string} yAxisColor - The color for the y axis.
   * @param {number|Color|string} zAxisColor - The color for the z axis.
   * @return {AxesHelper} A reference to this axes helper.
   */
  setColors(e, t, a) {
    const r = new hn(), d = this.geometry.attributes.color.array;
    return r.set(e), r.toArray(d, 0), r.toArray(d, 3), r.set(t), r.toArray(d, 6), r.toArray(d, 9), r.set(a), r.toArray(d, 12), r.toArray(d, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class W4 {
  /**
   * Constructs a new shape path.
   */
  constructor() {
    this.type = "ShapePath", this.color = new hn(), this.subPaths = [], this.currentPath = null;
  }
  /**
   * Creates a new path and moves it current point to the given one.
   *
   * @param {number} x - The x coordinate.
   * @param {number} y - The y coordinate.
   * @return {ShapePath} A reference to this shape path.
   */
  moveTo(e, t) {
    return this.currentPath = new KA(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  /**
   * Adds an instance of {@link LineCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} x - The x coordinate of the end point.
   * @param {number} y - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  /**
   * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCPx - The x coordinate of the control point.
   * @param {number} aCPy - The y coordinate of the control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  quadraticCurveTo(e, t, a, r) {
    return this.currentPath.quadraticCurveTo(e, t, a, r), this;
  }
  /**
   * Adds an instance of {@link CubicBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCP1x - The x coordinate of the first control point.
   * @param {number} aCP1y - The y coordinate of the first control point.
   * @param {number} aCP2x - The x coordinate of the second control point.
   * @param {number} aCP2y - The y coordinate of the second control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  bezierCurveTo(e, t, a, r, d, p) {
    return this.currentPath.bezierCurveTo(e, t, a, r, d, p), this;
  }
  /**
   * Adds an instance of {@link SplineCurve} to the path by connecting
   * the current point with the given list of points.
   *
   * @param {Array<Vector2>} pts - An array of points in 2D space.
   * @return {ShapePath} A reference to this shape path.
   */
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  /**
   * Converts the paths into an array of shapes.
   *
   * @param {boolean} isCCW - By default solid shapes are  defined clockwise (CW) and holes are defined counterclockwise (CCW).
   * If this flag is set to `true`, then those are flipped.
   * @return {Array<Shape>} An array of shapes.
   */
  toShapes(e) {
    function t(N) {
      const F = [];
      for (let q = 0, Y = N.length; q < Y; q++) {
        const ie = N[q], k = new JS();
        k.curves = ie.curves, F.push(k);
      }
      return F;
    }
    function a(N, F) {
      const q = F.length;
      let Y = !1;
      for (let ie = q - 1, k = 0; k < q; ie = k++) {
        let le = F[ie], ne = F[k], Q = ne.x - le.x, j = ne.y - le.y;
        if (Math.abs(j) > Number.EPSILON) {
          if (j < 0 && (le = F[k], Q = -Q, ne = F[ie], j = -j), N.y < le.y || N.y > ne.y) continue;
          if (N.y === le.y) {
            if (N.x === le.x) return !0;
          } else {
            const re = j * (N.x - le.x) - Q * (N.y - le.y);
            if (re === 0) return !0;
            if (re < 0) continue;
            Y = !Y;
          }
        } else {
          if (N.y !== le.y) continue;
          if (ne.x <= N.x && N.x <= le.x || le.x <= N.x && N.x <= ne.x) return !0;
        }
      }
      return Y;
    }
    const r = qg.isClockWise, d = this.subPaths;
    if (d.length === 0) return [];
    let p, y, _;
    const E = [];
    if (d.length === 1)
      return y = d[0], _ = new JS(), _.curves = y.curves, E.push(_), E;
    let T = !r(d[0].getPoints());
    T = e ? !T : T;
    const C = [], D = [];
    let B = [], z = 0, V;
    D[z] = void 0, B[z] = [];
    for (let N = 0, F = d.length; N < F; N++)
      y = d[N], V = y.getPoints(), p = r(V), p = e ? !p : p, p ? (!T && D[z] && z++, D[z] = { s: new JS(), p: V }, D[z].s.curves = y.curves, T && z++, B[z] = []) : B[z].push({ h: y, p: V[0] });
    if (!D[0]) return t(d);
    if (D.length > 1) {
      let N = !1, F = 0;
      for (let q = 0, Y = D.length; q < Y; q++)
        C[q] = [];
      for (let q = 0, Y = D.length; q < Y; q++) {
        const ie = B[q];
        for (let k = 0; k < ie.length; k++) {
          const le = ie[k];
          let ne = !0;
          for (let Q = 0; Q < D.length; Q++)
            a(le.p, D[Q].p) && (q !== Q && F++, ne ? (ne = !1, C[Q].push(le)) : N = !0);
          ne && C[q].push(le);
        }
      }
      F > 0 && N === !1 && (B = C);
    }
    let G;
    for (let N = 0, F = D.length; N < F; N++) {
      _ = D[N].s, E.push(_), G = B[N];
      for (let q = 0, Y = G.length; q < Y; q++)
        _.holes.push(G[q].h);
    }
    return E;
  }
}
class $4 extends Jg {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(e, t = null) {
    super(), this.object = e, this.domElement = t, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  /**
   * Connects the controls to the DOM. This method has so called "side effects" since
   * it adds the module's event listeners to the DOM.
   *
   * @param {HTMLDOMElement} element - The DOM element to connect to.
   */
  connect(e) {
    if (e === void 0) {
      console.warn("THREE.Controls: connect() now requires an element.");
      return;
    }
    this.domElement !== null && this.disconnect(), this.domElement = e;
  }
  /**
   * Disconnects the controls from the DOM.
   */
  disconnect() {
  }
  /**
   * Call this method if you no longer want use to the controls. It frees all internal
   * resources and removes all event listeners.
   */
  dispose() {
  }
  /**
   * Controls should implement this method if they have to update their internal state
   * per simulation step.
   *
   * @param {number} [delta] - The time delta in seconds.
   */
  update() {
  }
}
function eL(o, e) {
  const t = o.image && o.image.width ? o.image.width / o.image.height : 1;
  return t > e ? (o.repeat.x = 1, o.repeat.y = t / e, o.offset.x = 0, o.offset.y = (1 - o.repeat.y) / 2) : (o.repeat.x = e / t, o.repeat.y = 1, o.offset.x = (1 - o.repeat.x) / 2, o.offset.y = 0), o;
}
function tL(o, e) {
  const t = o.image && o.image.width ? o.image.width / o.image.height : 1;
  return t > e ? (o.repeat.x = e / t, o.repeat.y = 1, o.offset.x = (1 - o.repeat.x) / 2, o.offset.y = 0) : (o.repeat.x = 1, o.repeat.y = t / e, o.offset.x = 0, o.offset.y = (1 - o.repeat.y) / 2), o;
}
function nL(o) {
  return o.repeat.x = 1, o.repeat.y = 1, o.offset.x = 0, o.offset.y = 0, o;
}
function $C(o, e, t, a) {
  const r = aL(a);
  switch (t) {
    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    case p2:
      return o * e;
    case v2:
      return o * e;
    case g2:
      return o * e * 2;
    case lE:
      return o * e / r.components * r.byteLength;
    case sE:
      return o * e / r.components * r.byteLength;
    case y2:
      return o * e * 2 / r.components * r.byteLength;
    case ux:
      return o * e * 2 / r.components * r.byteLength;
    case m2:
      return o * e * 3 / r.components * r.byteLength;
    case xo:
      return o * e * 4 / r.components * r.byteLength;
    case cx:
      return o * e * 4 / r.components * r.byteLength;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    case NA:
    case zA:
      return Math.floor((o + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case HA:
    case LA:
      return Math.floor((o + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    case AM:
    case bM:
      return Math.max(o, 16) * Math.max(e, 8) / 4;
    case _M:
    case EM:
      return Math.max(o, 8) * Math.max(e, 8) / 2;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
    case MM:
    case xM:
      return Math.floor((o + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case TM:
      return Math.floor((o + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
    case CM:
      return Math.floor((o + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case RM:
      return Math.floor((o + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case DM:
      return Math.floor((o + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case BM:
      return Math.floor((o + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case UM:
      return Math.floor((o + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case OM:
      return Math.floor((o + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case wM:
      return Math.floor((o + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case NM:
      return Math.floor((o + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case zM:
      return Math.floor((o + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case HM:
      return Math.floor((o + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case LM:
      return Math.floor((o + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case GM:
      return Math.floor((o + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case IM:
      return Math.floor((o + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case VM:
      return Math.floor((o + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
    case GA:
    case FM:
    case PM:
      return Math.ceil(o / 4) * Math.ceil(e / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
    case S2:
    case XM:
      return Math.ceil(o / 4) * Math.ceil(e / 4) * 8;
    case YM:
    case qM:
      return Math.ceil(o / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${t} format.`
  );
}
function aL(o) {
  switch (o) {
    case qh:
    case lx:
      return { byteLength: 1, components: 1 };
    case kS:
    case sx:
    case au:
      return { byteLength: 2, components: 1 };
    case rx:
    case ox:
      return { byteLength: 2, components: 4 };
    case jg:
    case iE:
    case pr:
      return { byteLength: 4, components: 1 };
    case h2:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${o}.`);
}
class iL {
  /**
   * Scales the texture as large as possible within its surface without cropping
   * or stretching the texture. The method preserves the original aspect ratio of
   * the texture. Akin to CSS `object-fit: contain`
   *
   * @param {Texture} texture - The texture.
   * @param {number} aspect - The texture's aspect ratio.
   * @return {Texture} The updated texture.
   */
  static contain(e, t) {
    return eL(e, t);
  }
  /**
   * Scales the texture to the smallest possible size to fill the surface, leaving
   * no empty space. The method preserves the original aspect ratio of the texture.
   * Akin to CSS `object-fit: cover`.
   *
   * @param {Texture} texture - The texture.
   * @param {number} aspect - The texture's aspect ratio.
   * @return {Texture} The updated texture.
   */
  static cover(e, t) {
    return tL(e, t);
  }
  /**
   * Configures the texture to the default transformation. Akin to CSS `object-fit: fill`.
   *
   * @param {Texture} texture - The texture.
   * @return {Texture} The updated texture.
   */
  static fill(e) {
    return nL(e);
  }
  /**
   * Determines how many bytes must be used to represent the texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} format - The texture's format.
   * @param {number} type - The texture's type.
   * @return {number} The byte length.
   */
  static getByteLength(e, t, a, r) {
    return $C(e, t, a, r);
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: T1
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = T1);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function uw() {
  let o = null, e = !1, t = null, a = null;
  function r(d, p) {
    t(d, p), a = o.requestAnimationFrame(r);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (a = o.requestAnimationFrame(r), e = !0);
    },
    stop: function() {
      o.cancelAnimationFrame(a), e = !1;
    },
    setAnimationLoop: function(d) {
      t = d;
    },
    setContext: function(d) {
      o = d;
    }
  };
}
function lL(o) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(y, _) {
    const E = y.array, T = y.usage, C = E.byteLength, D = o.createBuffer();
    o.bindBuffer(_, D), o.bufferData(_, E, T), y.onUploadCallback();
    let B;
    if (E instanceof Float32Array)
      B = o.FLOAT;
    else if (E instanceof Uint16Array)
      y.isFloat16BufferAttribute ? B = o.HALF_FLOAT : B = o.UNSIGNED_SHORT;
    else if (E instanceof Int16Array)
      B = o.SHORT;
    else if (E instanceof Uint32Array)
      B = o.UNSIGNED_INT;
    else if (E instanceof Int32Array)
      B = o.INT;
    else if (E instanceof Int8Array)
      B = o.BYTE;
    else if (E instanceof Uint8Array)
      B = o.UNSIGNED_BYTE;
    else if (E instanceof Uint8ClampedArray)
      B = o.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + E);
    return {
      buffer: D,
      type: B,
      bytesPerElement: E.BYTES_PER_ELEMENT,
      version: y.version,
      size: C
    };
  }
  function a(y, _, E) {
    const T = _.array, C = _.updateRanges;
    if (o.bindBuffer(E, y), C.length === 0)
      o.bufferSubData(E, 0, T);
    else {
      C.sort((B, z) => B.start - z.start);
      let D = 0;
      for (let B = 1; B < C.length; B++) {
        const z = C[D], V = C[B];
        V.start <= z.start + z.count + 1 ? z.count = Math.max(
          z.count,
          V.start + V.count - z.start
        ) : (++D, C[D] = V);
      }
      C.length = D + 1;
      for (let B = 0, z = C.length; B < z; B++) {
        const V = C[B];
        o.bufferSubData(
          E,
          V.start * T.BYTES_PER_ELEMENT,
          T,
          V.start,
          V.count
        );
      }
      _.clearUpdateRanges();
    }
    _.onUploadCallback();
  }
  function r(y) {
    return y.isInterleavedBufferAttribute && (y = y.data), e.get(y);
  }
  function d(y) {
    y.isInterleavedBufferAttribute && (y = y.data);
    const _ = e.get(y);
    _ && (o.deleteBuffer(_.buffer), e.delete(y));
  }
  function p(y, _) {
    if (y.isInterleavedBufferAttribute && (y = y.data), y.isGLBufferAttribute) {
      const T = e.get(y);
      (!T || T.version < y.version) && e.set(y, {
        buffer: y.buffer,
        type: y.type,
        bytesPerElement: y.elementSize,
        version: y.version
      });
      return;
    }
    const E = e.get(y);
    if (E === void 0)
      e.set(y, t(y, _));
    else if (E.version < y.version) {
      if (E.size !== y.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      a(E.buffer, y, _), E.version = y.version;
    }
  }
  return {
    get: r,
    remove: d,
    update: p
  };
}
var sL = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, rL = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, oL = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, uL = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, cL = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, fL = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, dL = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, hL = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, pL = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, mL = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, vL = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, gL = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, yL = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, SL = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, _L = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, AL = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, EL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, bL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, ML = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, xL = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, TL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, CL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, RL = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, DL = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, BL = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, UL = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, OL = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, wL = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, NL = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, zL = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, HL = "gl_FragColor = linearToOutputTexel( gl_FragColor );", LL = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, GL = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, IL = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, VL = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, FL = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, PL = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, XL = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, YL = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, qL = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, ZL = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, QL = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, jL = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, JL = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, KL = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, kL = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, WL = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, $L = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, e6 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, t6 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, n6 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, a6 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, i6 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, l6 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, s6 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, r6 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, o6 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, u6 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, c6 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, f6 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, d6 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, h6 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, p6 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, m6 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, v6 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, g6 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, y6 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, S6 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, _6 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, A6 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, E6 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, b6 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, M6 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, x6 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, T6 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, C6 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, R6 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, D6 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, B6 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, U6 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, O6 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, w6 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, N6 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, z6 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, H6 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, L6 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, G6 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, I6 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, V6 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, F6 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, P6 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, X6 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Y6 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, q6 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Z6 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Q6 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, j6 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, J6 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, K6 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, k6 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, W6 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, $6 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, e8 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, t8 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, n8 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, a8 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, i8 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const l8 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, s8 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, r8 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, o8 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, u8 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, c8 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, f8 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, d8 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, h8 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, p8 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, m8 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, v8 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, g8 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, y8 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, S8 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, _8 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, A8 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, E8 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, b8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, M8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, x8 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, T8 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, C8 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, R8 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, D8 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, B8 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, U8 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, O8 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, w8 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, N8 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, z8 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, H8 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, L8 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, G8 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, ii = {
  alphahash_fragment: sL,
  alphahash_pars_fragment: rL,
  alphamap_fragment: oL,
  alphamap_pars_fragment: uL,
  alphatest_fragment: cL,
  alphatest_pars_fragment: fL,
  aomap_fragment: dL,
  aomap_pars_fragment: hL,
  batching_pars_vertex: pL,
  batching_vertex: mL,
  begin_vertex: vL,
  beginnormal_vertex: gL,
  bsdfs: yL,
  iridescence_fragment: SL,
  bumpmap_pars_fragment: _L,
  clipping_planes_fragment: AL,
  clipping_planes_pars_fragment: EL,
  clipping_planes_pars_vertex: bL,
  clipping_planes_vertex: ML,
  color_fragment: xL,
  color_pars_fragment: TL,
  color_pars_vertex: CL,
  color_vertex: RL,
  common: DL,
  cube_uv_reflection_fragment: BL,
  defaultnormal_vertex: UL,
  displacementmap_pars_vertex: OL,
  displacementmap_vertex: wL,
  emissivemap_fragment: NL,
  emissivemap_pars_fragment: zL,
  colorspace_fragment: HL,
  colorspace_pars_fragment: LL,
  envmap_fragment: GL,
  envmap_common_pars_fragment: IL,
  envmap_pars_fragment: VL,
  envmap_pars_vertex: FL,
  envmap_physical_pars_fragment: WL,
  envmap_vertex: PL,
  fog_vertex: XL,
  fog_pars_vertex: YL,
  fog_fragment: qL,
  fog_pars_fragment: ZL,
  gradientmap_pars_fragment: QL,
  lightmap_pars_fragment: jL,
  lights_lambert_fragment: JL,
  lights_lambert_pars_fragment: KL,
  lights_pars_begin: kL,
  lights_toon_fragment: $L,
  lights_toon_pars_fragment: e6,
  lights_phong_fragment: t6,
  lights_phong_pars_fragment: n6,
  lights_physical_fragment: a6,
  lights_physical_pars_fragment: i6,
  lights_fragment_begin: l6,
  lights_fragment_maps: s6,
  lights_fragment_end: r6,
  logdepthbuf_fragment: o6,
  logdepthbuf_pars_fragment: u6,
  logdepthbuf_pars_vertex: c6,
  logdepthbuf_vertex: f6,
  map_fragment: d6,
  map_pars_fragment: h6,
  map_particle_fragment: p6,
  map_particle_pars_fragment: m6,
  metalnessmap_fragment: v6,
  metalnessmap_pars_fragment: g6,
  morphinstance_vertex: y6,
  morphcolor_vertex: S6,
  morphnormal_vertex: _6,
  morphtarget_pars_vertex: A6,
  morphtarget_vertex: E6,
  normal_fragment_begin: b6,
  normal_fragment_maps: M6,
  normal_pars_fragment: x6,
  normal_pars_vertex: T6,
  normal_vertex: C6,
  normalmap_pars_fragment: R6,
  clearcoat_normal_fragment_begin: D6,
  clearcoat_normal_fragment_maps: B6,
  clearcoat_pars_fragment: U6,
  iridescence_pars_fragment: O6,
  opaque_fragment: w6,
  packing: N6,
  premultiplied_alpha_fragment: z6,
  project_vertex: H6,
  dithering_fragment: L6,
  dithering_pars_fragment: G6,
  roughnessmap_fragment: I6,
  roughnessmap_pars_fragment: V6,
  shadowmap_pars_fragment: F6,
  shadowmap_pars_vertex: P6,
  shadowmap_vertex: X6,
  shadowmask_pars_fragment: Y6,
  skinbase_vertex: q6,
  skinning_pars_vertex: Z6,
  skinning_vertex: Q6,
  skinnormal_vertex: j6,
  specularmap_fragment: J6,
  specularmap_pars_fragment: K6,
  tonemapping_fragment: k6,
  tonemapping_pars_fragment: W6,
  transmission_fragment: $6,
  transmission_pars_fragment: e8,
  uv_pars_fragment: t8,
  uv_pars_vertex: n8,
  uv_vertex: a8,
  worldpos_vertex: i8,
  background_vert: l8,
  background_frag: s8,
  backgroundCube_vert: r8,
  backgroundCube_frag: o8,
  cube_vert: u8,
  cube_frag: c8,
  depth_vert: f8,
  depth_frag: d8,
  distanceRGBA_vert: h8,
  distanceRGBA_frag: p8,
  equirect_vert: m8,
  equirect_frag: v8,
  linedashed_vert: g8,
  linedashed_frag: y8,
  meshbasic_vert: S8,
  meshbasic_frag: _8,
  meshlambert_vert: A8,
  meshlambert_frag: E8,
  meshmatcap_vert: b8,
  meshmatcap_frag: M8,
  meshnormal_vert: x8,
  meshnormal_frag: T8,
  meshphong_vert: C8,
  meshphong_frag: R8,
  meshphysical_vert: D8,
  meshphysical_frag: B8,
  meshtoon_vert: U8,
  meshtoon_frag: O8,
  points_vert: w8,
  points_frag: N8,
  shadow_vert: z8,
  shadow_frag: H8,
  sprite_vert: L8,
  sprite_frag: G8
}, An = {
  common: {
    diffuse: { value: /* @__PURE__ */ new hn(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new ja() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ja() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new ja() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new ja() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new ja() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new ja() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new ja() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new ja() },
    normalScale: { value: /* @__PURE__ */ new Ot(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new ja() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new ja() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new ja() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new ja() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new hn(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new hn(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ja() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new ja() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new hn(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Ot(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new ja() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ja() },
    alphaTest: { value: 0 }
  }
}, Zv = {
  basic: {
    uniforms: /* @__PURE__ */ Qd([
      An.common,
      An.specularmap,
      An.envmap,
      An.aomap,
      An.lightmap,
      An.fog
    ]),
    vertexShader: ii.meshbasic_vert,
    fragmentShader: ii.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Qd([
      An.common,
      An.specularmap,
      An.envmap,
      An.aomap,
      An.lightmap,
      An.emissivemap,
      An.bumpmap,
      An.normalmap,
      An.displacementmap,
      An.fog,
      An.lights,
      {
        emissive: { value: /* @__PURE__ */ new hn(0) }
      }
    ]),
    vertexShader: ii.meshlambert_vert,
    fragmentShader: ii.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Qd([
      An.common,
      An.specularmap,
      An.envmap,
      An.aomap,
      An.lightmap,
      An.emissivemap,
      An.bumpmap,
      An.normalmap,
      An.displacementmap,
      An.fog,
      An.lights,
      {
        emissive: { value: /* @__PURE__ */ new hn(0) },
        specular: { value: /* @__PURE__ */ new hn(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ii.meshphong_vert,
    fragmentShader: ii.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Qd([
      An.common,
      An.envmap,
      An.aomap,
      An.lightmap,
      An.emissivemap,
      An.bumpmap,
      An.normalmap,
      An.displacementmap,
      An.roughnessmap,
      An.metalnessmap,
      An.fog,
      An.lights,
      {
        emissive: { value: /* @__PURE__ */ new hn(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ii.meshphysical_vert,
    fragmentShader: ii.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Qd([
      An.common,
      An.aomap,
      An.lightmap,
      An.emissivemap,
      An.bumpmap,
      An.normalmap,
      An.displacementmap,
      An.gradientmap,
      An.fog,
      An.lights,
      {
        emissive: { value: /* @__PURE__ */ new hn(0) }
      }
    ]),
    vertexShader: ii.meshtoon_vert,
    fragmentShader: ii.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Qd([
      An.common,
      An.bumpmap,
      An.normalmap,
      An.displacementmap,
      An.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ii.meshmatcap_vert,
    fragmentShader: ii.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Qd([
      An.points,
      An.fog
    ]),
    vertexShader: ii.points_vert,
    fragmentShader: ii.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Qd([
      An.common,
      An.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ii.linedashed_vert,
    fragmentShader: ii.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Qd([
      An.common,
      An.displacementmap
    ]),
    vertexShader: ii.depth_vert,
    fragmentShader: ii.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Qd([
      An.common,
      An.bumpmap,
      An.normalmap,
      An.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ii.meshnormal_vert,
    fragmentShader: ii.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Qd([
      An.sprite,
      An.fog
    ]),
    vertexShader: ii.sprite_vert,
    fragmentShader: ii.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new ja() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ii.background_vert,
    fragmentShader: ii.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new ja() }
    },
    vertexShader: ii.backgroundCube_vert,
    fragmentShader: ii.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ii.cube_vert,
    fragmentShader: ii.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ii.equirect_vert,
    fragmentShader: ii.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Qd([
      An.common,
      An.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new ve() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ii.distanceRGBA_vert,
    fragmentShader: ii.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Qd([
      An.lights,
      An.fog,
      {
        color: { value: /* @__PURE__ */ new hn(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ii.shadow_vert,
    fragmentShader: ii.shadow_frag
  }
};
Zv.physical = {
  uniforms: /* @__PURE__ */ Qd([
    Zv.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new ja() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new ja() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Ot(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new ja() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new ja() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new ja() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new hn(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new ja() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new ja() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new ja() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Ot() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new ja() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new hn(0) },
      specularColor: { value: /* @__PURE__ */ new hn(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new ja() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new ja() },
      anisotropyVector: { value: /* @__PURE__ */ new Ot() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new ja() }
    }
  ]),
  vertexShader: ii.meshphysical_vert,
  fragmentShader: ii.meshphysical_frag
};
const Ib = { r: 0, b: 0, g: 0 }, OS = /* @__PURE__ */ new Ip(), I8 = /* @__PURE__ */ new ia();
function V8(o, e, t, a, r, d, p) {
  const y = new hn(0);
  let _ = d === !0 ? 0 : 1, E, T, C = null, D = 0, B = null;
  function z(q) {
    let Y = q.isScene === !0 ? q.background : null;
    return Y && Y.isTexture && (Y = (q.backgroundBlurriness > 0 ? t : e).get(Y)), Y;
  }
  function V(q) {
    let Y = !1;
    const ie = z(q);
    ie === null ? N(y, _) : ie && ie.isColor && (N(ie, 1), Y = !0);
    const k = o.xr.getEnvironmentBlendMode();
    k === "additive" ? a.buffers.color.setClear(0, 0, 0, 1, p) : k === "alpha-blend" && a.buffers.color.setClear(0, 0, 0, 0, p), (o.autoClear || Y) && (a.buffers.depth.setTest(!0), a.buffers.depth.setMask(!0), a.buffers.color.setMask(!0), o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil));
  }
  function G(q, Y) {
    const ie = z(Y);
    ie && (ie.isCubeTexture || ie.mapping === C1) ? (T === void 0 && (T = new es(
      new j0(1, 1, 1),
      new iu({
        name: "BackgroundCubeMaterial",
        uniforms: E1(Zv.backgroundCube.uniforms),
        vertexShader: Zv.backgroundCube.vertexShader,
        fragmentShader: Zv.backgroundCube.fragmentShader,
        side: ed,
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        allowOverride: !1
      })
    ), T.geometry.deleteAttribute("normal"), T.geometry.deleteAttribute("uv"), T.onBeforeRender = function(k, le, ne) {
      this.matrixWorld.copyPosition(ne.matrixWorld);
    }, Object.defineProperty(T.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(T)), OS.copy(Y.backgroundRotation), OS.x *= -1, OS.y *= -1, OS.z *= -1, ie.isCubeTexture && ie.isRenderTargetTexture === !1 && (OS.y *= -1, OS.z *= -1), T.material.uniforms.envMap.value = ie, T.material.uniforms.flipEnvMap.value = ie.isCubeTexture && ie.isRenderTargetTexture === !1 ? -1 : 1, T.material.uniforms.backgroundBlurriness.value = Y.backgroundBlurriness, T.material.uniforms.backgroundIntensity.value = Y.backgroundIntensity, T.material.uniforms.backgroundRotation.value.setFromMatrix4(I8.makeRotationFromEuler(OS)), T.material.toneMapped = wi.getTransfer(ie.colorSpace) !== Nl, (C !== ie || D !== ie.version || B !== o.toneMapping) && (T.material.needsUpdate = !0, C = ie, D = ie.version, B = o.toneMapping), T.layers.enableAll(), q.unshift(T, T.geometry, T.material, 0, 0, null)) : ie && ie.isTexture && (E === void 0 && (E = new es(
      new Ky(2, 2),
      new iu({
        name: "BackgroundMaterial",
        uniforms: E1(Zv.background.uniforms),
        vertexShader: Zv.background.vertexShader,
        fragmentShader: Zv.background.fragmentShader,
        side: Zg,
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        allowOverride: !1
      })
    ), E.geometry.deleteAttribute("normal"), Object.defineProperty(E.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(E)), E.material.uniforms.t2D.value = ie, E.material.uniforms.backgroundIntensity.value = Y.backgroundIntensity, E.material.toneMapped = wi.getTransfer(ie.colorSpace) !== Nl, ie.matrixAutoUpdate === !0 && ie.updateMatrix(), E.material.uniforms.uvTransform.value.copy(ie.matrix), (C !== ie || D !== ie.version || B !== o.toneMapping) && (E.material.needsUpdate = !0, C = ie, D = ie.version, B = o.toneMapping), E.layers.enableAll(), q.unshift(E, E.geometry, E.material, 0, 0, null));
  }
  function N(q, Y) {
    q.getRGB(Ib, gO(o)), a.buffers.color.setClear(Ib.r, Ib.g, Ib.b, Y, p);
  }
  function F() {
    T !== void 0 && (T.geometry.dispose(), T.material.dispose(), T = void 0), E !== void 0 && (E.geometry.dispose(), E.material.dispose(), E = void 0);
  }
  return {
    getClearColor: function() {
      return y;
    },
    setClearColor: function(q, Y = 1) {
      y.set(q), _ = Y, N(y, _);
    },
    getClearAlpha: function() {
      return _;
    },
    setClearAlpha: function(q) {
      _ = q, N(y, _);
    },
    render: V,
    addToRenderList: G,
    dispose: F
  };
}
function F8(o, e) {
  const t = o.getParameter(o.MAX_VERTEX_ATTRIBS), a = {}, r = D(null);
  let d = r, p = !1;
  function y(j, re, _e, me, Ae) {
    let He = !1;
    const P = C(me, _e, re);
    d !== P && (d = P, E(d.object)), He = B(j, me, _e, Ae), He && z(j, me, _e, Ae), Ae !== null && e.update(Ae, o.ELEMENT_ARRAY_BUFFER), (He || p) && (p = !1, Y(j, re, _e, me), Ae !== null && o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, e.get(Ae).buffer));
  }
  function _() {
    return o.createVertexArray();
  }
  function E(j) {
    return o.bindVertexArray(j);
  }
  function T(j) {
    return o.deleteVertexArray(j);
  }
  function C(j, re, _e) {
    const me = _e.wireframe === !0;
    let Ae = a[j.id];
    Ae === void 0 && (Ae = {}, a[j.id] = Ae);
    let He = Ae[re.id];
    He === void 0 && (He = {}, Ae[re.id] = He);
    let P = He[me];
    return P === void 0 && (P = D(_()), He[me] = P), P;
  }
  function D(j) {
    const re = [], _e = [], me = [];
    for (let Ae = 0; Ae < t; Ae++)
      re[Ae] = 0, _e[Ae] = 0, me[Ae] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: re,
      enabledAttributes: _e,
      attributeDivisors: me,
      object: j,
      attributes: {},
      index: null
    };
  }
  function B(j, re, _e, me) {
    const Ae = d.attributes, He = re.attributes;
    let P = 0;
    const te = _e.getAttributes();
    for (const ae in te)
      if (te[ae].location >= 0) {
        const ue = Ae[ae];
        let we = He[ae];
        if (we === void 0 && (ae === "instanceMatrix" && j.instanceMatrix && (we = j.instanceMatrix), ae === "instanceColor" && j.instanceColor && (we = j.instanceColor)), ue === void 0 || ue.attribute !== we || we && ue.data !== we.data) return !0;
        P++;
      }
    return d.attributesNum !== P || d.index !== me;
  }
  function z(j, re, _e, me) {
    const Ae = {}, He = re.attributes;
    let P = 0;
    const te = _e.getAttributes();
    for (const ae in te)
      if (te[ae].location >= 0) {
        let ue = He[ae];
        ue === void 0 && (ae === "instanceMatrix" && j.instanceMatrix && (ue = j.instanceMatrix), ae === "instanceColor" && j.instanceColor && (ue = j.instanceColor));
        const we = {};
        we.attribute = ue, ue && ue.data && (we.data = ue.data), Ae[ae] = we, P++;
      }
    d.attributes = Ae, d.attributesNum = P, d.index = me;
  }
  function V() {
    const j = d.newAttributes;
    for (let re = 0, _e = j.length; re < _e; re++)
      j[re] = 0;
  }
  function G(j) {
    N(j, 0);
  }
  function N(j, re) {
    const _e = d.newAttributes, me = d.enabledAttributes, Ae = d.attributeDivisors;
    _e[j] = 1, me[j] === 0 && (o.enableVertexAttribArray(j), me[j] = 1), Ae[j] !== re && (o.vertexAttribDivisor(j, re), Ae[j] = re);
  }
  function F() {
    const j = d.newAttributes, re = d.enabledAttributes;
    for (let _e = 0, me = re.length; _e < me; _e++)
      re[_e] !== j[_e] && (o.disableVertexAttribArray(_e), re[_e] = 0);
  }
  function q(j, re, _e, me, Ae, He, P) {
    P === !0 ? o.vertexAttribIPointer(j, re, _e, Ae, He) : o.vertexAttribPointer(j, re, _e, me, Ae, He);
  }
  function Y(j, re, _e, me) {
    V();
    const Ae = me.attributes, He = _e.getAttributes(), P = re.defaultAttributeValues;
    for (const te in He) {
      const ae = He[te];
      if (ae.location >= 0) {
        let Se = Ae[te];
        if (Se === void 0 && (te === "instanceMatrix" && j.instanceMatrix && (Se = j.instanceMatrix), te === "instanceColor" && j.instanceColor && (Se = j.instanceColor)), Se !== void 0) {
          const ue = Se.normalized, we = Se.itemSize, De = e.get(Se);
          if (De === void 0) continue;
          const We = De.buffer, Me = De.type, Ze = De.bytesPerElement, ct = Me === o.INT || Me === o.UNSIGNED_INT || Se.gpuType === iE;
          if (Se.isInterleavedBufferAttribute) {
            const Vt = Se.data, Zt = Vt.stride, Bn = Se.offset;
            if (Vt.isInstancedInterleavedBuffer) {
              for (let rn = 0; rn < ae.locationSize; rn++)
                N(ae.location + rn, Vt.meshPerAttribute);
              j.isInstancedMesh !== !0 && me._maxInstanceCount === void 0 && (me._maxInstanceCount = Vt.meshPerAttribute * Vt.count);
            } else
              for (let rn = 0; rn < ae.locationSize; rn++)
                G(ae.location + rn);
            o.bindBuffer(o.ARRAY_BUFFER, We);
            for (let rn = 0; rn < ae.locationSize; rn++)
              q(
                ae.location + rn,
                we / ae.locationSize,
                Me,
                ue,
                Zt * Ze,
                (Bn + we / ae.locationSize * rn) * Ze,
                ct
              );
          } else {
            if (Se.isInstancedBufferAttribute) {
              for (let Vt = 0; Vt < ae.locationSize; Vt++)
                N(ae.location + Vt, Se.meshPerAttribute);
              j.isInstancedMesh !== !0 && me._maxInstanceCount === void 0 && (me._maxInstanceCount = Se.meshPerAttribute * Se.count);
            } else
              for (let Vt = 0; Vt < ae.locationSize; Vt++)
                G(ae.location + Vt);
            o.bindBuffer(o.ARRAY_BUFFER, We);
            for (let Vt = 0; Vt < ae.locationSize; Vt++)
              q(
                ae.location + Vt,
                we / ae.locationSize,
                Me,
                ue,
                we * Ze,
                we / ae.locationSize * Vt * Ze,
                ct
              );
          }
        } else if (P !== void 0) {
          const ue = P[te];
          if (ue !== void 0)
            switch (ue.length) {
              case 2:
                o.vertexAttrib2fv(ae.location, ue);
                break;
              case 3:
                o.vertexAttrib3fv(ae.location, ue);
                break;
              case 4:
                o.vertexAttrib4fv(ae.location, ue);
                break;
              default:
                o.vertexAttrib1fv(ae.location, ue);
            }
        }
      }
    }
    F();
  }
  function ie() {
    ne();
    for (const j in a) {
      const re = a[j];
      for (const _e in re) {
        const me = re[_e];
        for (const Ae in me)
          T(me[Ae].object), delete me[Ae];
        delete re[_e];
      }
      delete a[j];
    }
  }
  function k(j) {
    if (a[j.id] === void 0) return;
    const re = a[j.id];
    for (const _e in re) {
      const me = re[_e];
      for (const Ae in me)
        T(me[Ae].object), delete me[Ae];
      delete re[_e];
    }
    delete a[j.id];
  }
  function le(j) {
    for (const re in a) {
      const _e = a[re];
      if (_e[j.id] === void 0) continue;
      const me = _e[j.id];
      for (const Ae in me)
        T(me[Ae].object), delete me[Ae];
      delete _e[j.id];
    }
  }
  function ne() {
    Q(), p = !0, d !== r && (d = r, E(d.object));
  }
  function Q() {
    r.geometry = null, r.program = null, r.wireframe = !1;
  }
  return {
    setup: y,
    reset: ne,
    resetDefaultState: Q,
    dispose: ie,
    releaseStatesOfGeometry: k,
    releaseStatesOfProgram: le,
    initAttributes: V,
    enableAttribute: G,
    disableUnusedAttributes: F
  };
}
function P8(o, e, t) {
  let a;
  function r(E) {
    a = E;
  }
  function d(E, T) {
    o.drawArrays(a, E, T), t.update(T, a, 1);
  }
  function p(E, T, C) {
    C !== 0 && (o.drawArraysInstanced(a, E, T, C), t.update(T, a, C));
  }
  function y(E, T, C) {
    if (C === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(a, E, 0, T, 0, C);
    let B = 0;
    for (let z = 0; z < C; z++)
      B += T[z];
    t.update(B, a, 1);
  }
  function _(E, T, C, D) {
    if (C === 0) return;
    const B = e.get("WEBGL_multi_draw");
    if (B === null)
      for (let z = 0; z < E.length; z++)
        p(E[z], T[z], D[z]);
    else {
      B.multiDrawArraysInstancedWEBGL(a, E, 0, T, 0, D, 0, C);
      let z = 0;
      for (let V = 0; V < C; V++)
        z += T[V] * D[V];
      t.update(z, a, 1);
    }
  }
  this.setMode = r, this.render = d, this.renderInstances = p, this.renderMultiDraw = y, this.renderMultiDrawInstances = _;
}
function X8(o, e, t, a) {
  let r;
  function d() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const le = e.get("EXT_texture_filter_anisotropic");
      r = o.getParameter(le.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      r = 0;
    return r;
  }
  function p(le) {
    return !(le !== xo && a.convert(le) !== o.getParameter(o.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function y(le) {
    const ne = le === au && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(le !== qh && a.convert(le) !== o.getParameter(o.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    le !== pr && !ne);
  }
  function _(le) {
    if (le === "highp") {
      if (o.getShaderPrecisionFormat(o.VERTEX_SHADER, o.HIGH_FLOAT).precision > 0 && o.getShaderPrecisionFormat(o.FRAGMENT_SHADER, o.HIGH_FLOAT).precision > 0)
        return "highp";
      le = "mediump";
    }
    return le === "mediump" && o.getShaderPrecisionFormat(o.VERTEX_SHADER, o.MEDIUM_FLOAT).precision > 0 && o.getShaderPrecisionFormat(o.FRAGMENT_SHADER, o.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let E = t.precision !== void 0 ? t.precision : "highp";
  const T = _(E);
  T !== E && (console.warn("THREE.WebGLRenderer:", E, "not supported, using", T, "instead."), E = T);
  const C = t.logarithmicDepthBuffer === !0, D = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), B = o.getParameter(o.MAX_TEXTURE_IMAGE_UNITS), z = o.getParameter(o.MAX_VERTEX_TEXTURE_IMAGE_UNITS), V = o.getParameter(o.MAX_TEXTURE_SIZE), G = o.getParameter(o.MAX_CUBE_MAP_TEXTURE_SIZE), N = o.getParameter(o.MAX_VERTEX_ATTRIBS), F = o.getParameter(o.MAX_VERTEX_UNIFORM_VECTORS), q = o.getParameter(o.MAX_VARYING_VECTORS), Y = o.getParameter(o.MAX_FRAGMENT_UNIFORM_VECTORS), ie = z > 0, k = o.getParameter(o.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: d,
    getMaxPrecision: _,
    textureFormatReadable: p,
    textureTypeReadable: y,
    precision: E,
    logarithmicDepthBuffer: C,
    reverseDepthBuffer: D,
    maxTextures: B,
    maxVertexTextures: z,
    maxTextureSize: V,
    maxCubemapSize: G,
    maxAttributes: N,
    maxVertexUniforms: F,
    maxVaryings: q,
    maxFragmentUniforms: Y,
    vertexTextures: ie,
    maxSamples: k
  };
}
function Y8(o) {
  const e = this;
  let t = null, a = 0, r = !1, d = !1;
  const p = new Pg(), y = new ja(), _ = { value: null, needsUpdate: !1 };
  this.uniform = _, this.numPlanes = 0, this.numIntersection = 0, this.init = function(C, D) {
    const B = C.length !== 0 || D || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    a !== 0 || r;
    return r = D, a = C.length, B;
  }, this.beginShadows = function() {
    d = !0, T(null);
  }, this.endShadows = function() {
    d = !1;
  }, this.setGlobalState = function(C, D) {
    t = T(C, D, 0);
  }, this.setState = function(C, D, B) {
    const z = C.clippingPlanes, V = C.clipIntersection, G = C.clipShadows, N = o.get(C);
    if (!r || z === null || z.length === 0 || d && !G)
      d ? T(null) : E();
    else {
      const F = d ? 0 : a, q = F * 4;
      let Y = N.clippingState || null;
      _.value = Y, Y = T(z, D, q, B);
      for (let ie = 0; ie !== q; ++ie)
        Y[ie] = t[ie];
      N.clippingState = Y, this.numIntersection = V ? this.numPlanes : 0, this.numPlanes += F;
    }
  };
  function E() {
    _.value !== t && (_.value = t, _.needsUpdate = a > 0), e.numPlanes = a, e.numIntersection = 0;
  }
  function T(C, D, B, z) {
    const V = C !== null ? C.length : 0;
    let G = null;
    if (V !== 0) {
      if (G = _.value, z !== !0 || G === null) {
        const N = B + V * 4, F = D.matrixWorldInverse;
        y.getNormalMatrix(F), (G === null || G.length < N) && (G = new Float32Array(N));
        for (let q = 0, Y = B; q !== V; ++q, Y += 4)
          p.copy(C[q]).applyMatrix4(F, y), p.normal.toArray(G, Y), G[Y + 3] = p.constant;
      }
      _.value = G, _.needsUpdate = !0;
    }
    return e.numPlanes = V, e.numIntersection = 0, G;
  }
}
function q8(o) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(p, y) {
    return y === p1 ? p.mapping = Qg : y === YA && (p.mapping = Y0), p;
  }
  function a(p) {
    if (p && p.isTexture) {
      const y = p.mapping;
      if (y === p1 || y === YA)
        if (e.has(p)) {
          const _ = e.get(p).texture;
          return t(_, p.mapping);
        } else {
          const _ = p.image;
          if (_ && _.height > 0) {
            const E = new C2(_.height);
            return E.fromEquirectangularTexture(o, p), e.set(p, E), p.addEventListener("dispose", r), t(E.texture, p.mapping);
          } else
            return null;
        }
    }
    return p;
  }
  function r(p) {
    const y = p.target;
    y.removeEventListener("dispose", r);
    const _ = e.get(y);
    _ !== void 0 && (e.delete(y), _.dispose());
  }
  function d() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: a,
    dispose: d
  };
}
const u1 = 4, n3 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], IS = 20, uC = /* @__PURE__ */ new Zm(), a3 = /* @__PURE__ */ new hn();
let cC = null, fC = 0, dC = 0, hC = !1;
const GS = (1 + Math.sqrt(5)) / 2, a1 = 1 / GS, i3 = [
  /* @__PURE__ */ new ve(-GS, a1, 0),
  /* @__PURE__ */ new ve(GS, a1, 0),
  /* @__PURE__ */ new ve(-a1, 0, GS),
  /* @__PURE__ */ new ve(a1, 0, GS),
  /* @__PURE__ */ new ve(0, GS, -a1),
  /* @__PURE__ */ new ve(0, GS, a1),
  /* @__PURE__ */ new ve(-1, 1, -1),
  /* @__PURE__ */ new ve(1, 1, -1),
  /* @__PURE__ */ new ve(-1, 1, 1),
  /* @__PURE__ */ new ve(1, 1, 1)
], Z8 = /* @__PURE__ */ new ve();
class e2 {
  /**
   * Constructs a new PMREM generator.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety.
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
   * @return {WebGLRenderTarget} The resulting PMREM.
   */
  fromScene(e, t = 0, a = 0.1, r = 100, d = {}) {
    const {
      size: p = 256,
      position: y = Z8
    } = d;
    cC = this._renderer.getRenderTarget(), fC = this._renderer.getActiveCubeFace(), dC = this._renderer.getActiveMipmapLevel(), hC = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(p);
    const _ = this._allocateTargets();
    return _.depthBuffer = !0, this._sceneToCubeUV(e, a, r, _, y), t > 0 && this._blur(_, 0, 0, t), this._applyPMREM(_), this._cleanup(_), _;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
   * @return {WebGLRenderTarget} The resulting PMREM.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
   * @return {WebGLRenderTarget} The resulting PMREM.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = r3(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = s3(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(cC, fC, dC), this._renderer.xr.enabled = hC, e.scissorTest = !1, Vb(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Qg || e.mapping === Y0 ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), cC = this._renderer.getRenderTarget(), fC = this._renderer.getActiveCubeFace(), dC = this._renderer.getActiveMipmapLevel(), hC = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const a = t || this._allocateTargets();
    return this._textureToCubeUV(e, a), this._applyPMREM(a), this._cleanup(a), a;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, a = {
      magFilter: Ni,
      minFilter: Ni,
      generateMipmaps: !1,
      type: au,
      format: xo,
      colorSpace: Kv,
      depthBuffer: !1
    }, r = l3(e, t, a);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = l3(e, t, a);
      const { _lodMax: d } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Q8(d)), this._blurMaterial = j8(d, e, t);
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new es(this._lodPlanes[0], e);
    this._renderer.compile(t, uC);
  }
  _sceneToCubeUV(e, t, a, r, d) {
    const _ = new Ls(90, 1, t, a), E = [1, -1, 1, 1, 1, 1], T = [1, 1, 1, -1, -1, -1], C = this._renderer, D = C.autoClear, B = C.toneMapping;
    C.getClearColor(a3), C.toneMapping = Yg, C.autoClear = !1;
    const z = new Yh({
      name: "PMREM.Background",
      side: ed,
      depthWrite: !1,
      depthTest: !1
    }), V = new es(new j0(), z);
    let G = !1;
    const N = e.background;
    N ? N.isColor && (z.color.copy(N), e.background = null, G = !0) : (z.color.copy(a3), G = !0);
    for (let F = 0; F < 6; F++) {
      const q = F % 3;
      q === 0 ? (_.up.set(0, E[F], 0), _.position.set(d.x, d.y, d.z), _.lookAt(d.x + T[F], d.y, d.z)) : q === 1 ? (_.up.set(0, 0, E[F]), _.position.set(d.x, d.y, d.z), _.lookAt(d.x, d.y + T[F], d.z)) : (_.up.set(0, E[F], 0), _.position.set(d.x, d.y, d.z), _.lookAt(d.x, d.y, d.z + T[F]));
      const Y = this._cubeSize;
      Vb(r, q * Y, F > 2 ? Y : 0, Y, Y), C.setRenderTarget(r), G && C.render(V, _), C.render(e, _);
    }
    V.geometry.dispose(), V.material.dispose(), C.toneMapping = B, C.autoClear = D, e.background = N;
  }
  _textureToCubeUV(e, t) {
    const a = this._renderer, r = e.mapping === Qg || e.mapping === Y0;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = r3()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = s3());
    const d = r ? this._cubemapMaterial : this._equirectMaterial, p = new es(this._lodPlanes[0], d), y = d.uniforms;
    y.envMap.value = e;
    const _ = this._cubeSize;
    Vb(t, 0, 0, 3 * _, 2 * _), a.setRenderTarget(t), a.render(p, uC);
  }
  _applyPMREM(e) {
    const t = this._renderer, a = t.autoClear;
    t.autoClear = !1;
    const r = this._lodPlanes.length;
    for (let d = 1; d < r; d++) {
      const p = Math.sqrt(this._sigmas[d] * this._sigmas[d] - this._sigmas[d - 1] * this._sigmas[d - 1]), y = i3[(r - d - 1) % i3.length];
      this._blur(e, d - 1, d, p, y);
    }
    t.autoClear = a;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * @private
   * @param {WebGLRenderTarget} cubeUVRenderTarget
   * @param {number} lodIn
   * @param {number} lodOut
   * @param {number} sigma
   * @param {Vector3} [poleAxis]
   */
  _blur(e, t, a, r, d) {
    const p = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      p,
      t,
      a,
      r,
      "latitudinal",
      d
    ), this._halfBlur(
      p,
      e,
      a,
      a,
      r,
      "longitudinal",
      d
    );
  }
  _halfBlur(e, t, a, r, d, p, y) {
    const _ = this._renderer, E = this._blurMaterial;
    p !== "latitudinal" && p !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const T = 3, C = new es(this._lodPlanes[r], E), D = E.uniforms, B = this._sizeLods[a] - 1, z = isFinite(d) ? Math.PI / (2 * B) : 2 * Math.PI / (2 * IS - 1), V = d / z, G = isFinite(d) ? 1 + Math.floor(T * V) : IS;
    G > IS && console.warn(`sigmaRadians, ${d}, is too large and will clip, as it requested ${G} samples when the maximum is set to ${IS}`);
    const N = [];
    let F = 0;
    for (let le = 0; le < IS; ++le) {
      const ne = le / V, Q = Math.exp(-ne * ne / 2);
      N.push(Q), le === 0 ? F += Q : le < G && (F += 2 * Q);
    }
    for (let le = 0; le < N.length; le++)
      N[le] = N[le] / F;
    D.envMap.value = e.texture, D.samples.value = G, D.weights.value = N, D.latitudinal.value = p === "latitudinal", y && (D.poleAxis.value = y);
    const { _lodMax: q } = this;
    D.dTheta.value = z, D.mipInt.value = q - a;
    const Y = this._sizeLods[r], ie = 3 * Y * (r > q - u1 ? r - q + u1 : 0), k = 4 * (this._cubeSize - Y);
    Vb(t, ie, k, 3 * Y, 2 * Y), _.setRenderTarget(t), _.render(C, uC);
  }
}
function Q8(o) {
  const e = [], t = [], a = [];
  let r = o;
  const d = o - u1 + 1 + n3.length;
  for (let p = 0; p < d; p++) {
    const y = Math.pow(2, r);
    t.push(y);
    let _ = 1 / y;
    p > o - u1 ? _ = n3[p - o + u1 - 1] : p === 0 && (_ = 0), a.push(_);
    const E = 1 / (y - 2), T = -E, C = 1 + E, D = [T, T, C, T, C, C, T, T, C, C, T, C], B = 6, z = 6, V = 3, G = 2, N = 1, F = new Float32Array(V * z * B), q = new Float32Array(G * z * B), Y = new Float32Array(N * z * B);
    for (let k = 0; k < B; k++) {
      const le = k % 3 * 2 / 3 - 1, ne = k > 2 ? 0 : -1, Q = [
        le,
        ne,
        0,
        le + 2 / 3,
        ne,
        0,
        le + 2 / 3,
        ne + 1,
        0,
        le,
        ne,
        0,
        le + 2 / 3,
        ne + 1,
        0,
        le,
        ne + 1,
        0
      ];
      F.set(Q, V * z * k), q.set(D, G * z * k);
      const j = [k, k, k, k, k, k];
      Y.set(j, N * z * k);
    }
    const ie = new Pa();
    ie.setAttribute("position", new Hi(F, V)), ie.setAttribute("uv", new Hi(q, G)), ie.setAttribute("faceIndex", new Hi(Y, N)), e.push(ie), r > u1 && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: a };
}
function l3(o, e, t) {
  const a = new uf(o, e, t);
  return a.texture.mapping = C1, a.texture.name = "PMREM.cubeUv", a.scissorTest = !0, a;
}
function Vb(o, e, t, a, r) {
  o.viewport.set(e, t, a, r), o.scissor.set(e, t, a, r);
}
function j8(o, e, t) {
  const a = new Float32Array(IS), r = new ve(0, 1, 0);
  return new iu({
    name: "SphericalGaussianBlur",
    defines: {
      n: IS,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${o}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: a },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r }
    },
    vertexShader: eR(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: jv,
    depthTest: !1,
    depthWrite: !1
  });
}
function s3() {
  return new iu({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: eR(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: jv,
    depthTest: !1,
    depthWrite: !1
  });
}
function r3() {
  return new iu({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: eR(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: jv,
    depthTest: !1,
    depthWrite: !1
  });
}
function eR() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function J8(o) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function a(y) {
    if (y && y.isTexture) {
      const _ = y.mapping, E = _ === p1 || _ === YA, T = _ === Qg || _ === Y0;
      if (E || T) {
        let C = e.get(y);
        const D = C !== void 0 ? C.texture.pmremVersion : 0;
        if (y.isRenderTargetTexture && y.pmremVersion !== D)
          return t === null && (t = new e2(o)), C = E ? t.fromEquirectangular(y, C) : t.fromCubemap(y, C), C.texture.pmremVersion = y.pmremVersion, e.set(y, C), C.texture;
        if (C !== void 0)
          return C.texture;
        {
          const B = y.image;
          return E && B && B.height > 0 || T && B && r(B) ? (t === null && (t = new e2(o)), C = E ? t.fromEquirectangular(y) : t.fromCubemap(y), C.texture.pmremVersion = y.pmremVersion, e.set(y, C), y.addEventListener("dispose", d), C.texture) : null;
        }
      }
    }
    return y;
  }
  function r(y) {
    let _ = 0;
    const E = 6;
    for (let T = 0; T < E; T++)
      y[T] !== void 0 && _++;
    return _ === E;
  }
  function d(y) {
    const _ = y.target;
    _.removeEventListener("dispose", d);
    const E = e.get(_);
    E !== void 0 && (e.delete(_), E.dispose());
  }
  function p() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: a,
    dispose: p
  };
}
function K8(o) {
  const e = {};
  function t(a) {
    if (e[a] !== void 0)
      return e[a];
    let r;
    switch (a) {
      case "WEBGL_depth_texture":
        r = o.getExtension("WEBGL_depth_texture") || o.getExtension("MOZ_WEBGL_depth_texture") || o.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = o.getExtension("EXT_texture_filter_anisotropic") || o.getExtension("MOZ_EXT_texture_filter_anisotropic") || o.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = o.getExtension("WEBGL_compressed_texture_s3tc") || o.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || o.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = o.getExtension("WEBGL_compressed_texture_pvrtc") || o.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = o.getExtension(a);
    }
    return e[a] = r, r;
  }
  return {
    has: function(a) {
      return t(a) !== null;
    },
    init: function() {
      t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
    },
    get: function(a) {
      const r = t(a);
      return r === null && lM("THREE.WebGLRenderer: " + a + " extension not supported."), r;
    }
  };
}
function k8(o, e, t, a) {
  const r = {}, d = /* @__PURE__ */ new WeakMap();
  function p(C) {
    const D = C.target;
    D.index !== null && e.remove(D.index);
    for (const z in D.attributes)
      e.remove(D.attributes[z]);
    D.removeEventListener("dispose", p), delete r[D.id];
    const B = d.get(D);
    B && (e.remove(B), d.delete(D)), a.releaseStatesOfGeometry(D), D.isInstancedBufferGeometry === !0 && delete D._maxInstanceCount, t.memory.geometries--;
  }
  function y(C, D) {
    return r[D.id] === !0 || (D.addEventListener("dispose", p), r[D.id] = !0, t.memory.geometries++), D;
  }
  function _(C) {
    const D = C.attributes;
    for (const B in D)
      e.update(D[B], o.ARRAY_BUFFER);
  }
  function E(C) {
    const D = [], B = C.index, z = C.attributes.position;
    let V = 0;
    if (B !== null) {
      const F = B.array;
      V = B.version;
      for (let q = 0, Y = F.length; q < Y; q += 3) {
        const ie = F[q + 0], k = F[q + 1], le = F[q + 2];
        D.push(ie, k, k, le, le, ie);
      }
    } else if (z !== void 0) {
      const F = z.array;
      V = z.version;
      for (let q = 0, Y = F.length / 3 - 1; q < Y; q += 3) {
        const ie = q + 0, k = q + 1, le = q + 2;
        D.push(ie, k, k, le, le, ie);
      }
    } else
      return;
    const G = new (hO(D) ? x2 : M2)(D, 1);
    G.version = V;
    const N = d.get(C);
    N && e.remove(N), d.set(C, G);
  }
  function T(C) {
    const D = d.get(C);
    if (D) {
      const B = C.index;
      B !== null && D.version < B.version && E(C);
    } else
      E(C);
    return d.get(C);
  }
  return {
    get: y,
    update: _,
    getWireframeAttribute: T
  };
}
function W8(o, e, t) {
  let a;
  function r(D) {
    a = D;
  }
  let d, p;
  function y(D) {
    d = D.type, p = D.bytesPerElement;
  }
  function _(D, B) {
    o.drawElements(a, B, d, D * p), t.update(B, a, 1);
  }
  function E(D, B, z) {
    z !== 0 && (o.drawElementsInstanced(a, B, d, D * p, z), t.update(B, a, z));
  }
  function T(D, B, z) {
    if (z === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(a, B, 0, d, D, 0, z);
    let G = 0;
    for (let N = 0; N < z; N++)
      G += B[N];
    t.update(G, a, 1);
  }
  function C(D, B, z, V) {
    if (z === 0) return;
    const G = e.get("WEBGL_multi_draw");
    if (G === null)
      for (let N = 0; N < D.length; N++)
        E(D[N] / p, B[N], V[N]);
    else {
      G.multiDrawElementsInstancedWEBGL(a, B, 0, d, D, 0, V, 0, z);
      let N = 0;
      for (let F = 0; F < z; F++)
        N += B[F] * V[F];
      t.update(N, a, 1);
    }
  }
  this.setMode = r, this.setIndex = y, this.render = _, this.renderInstances = E, this.renderMultiDraw = T, this.renderMultiDrawInstances = C;
}
function $8(o) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function a(d, p, y) {
    switch (t.calls++, p) {
      case o.TRIANGLES:
        t.triangles += y * (d / 3);
        break;
      case o.LINES:
        t.lines += y * (d / 2);
        break;
      case o.LINE_STRIP:
        t.lines += y * (d - 1);
        break;
      case o.LINE_LOOP:
        t.lines += y * d;
        break;
      case o.POINTS:
        t.points += y * d;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", p);
        break;
    }
  }
  function r() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: a
  };
}
function e5(o, e, t) {
  const a = /* @__PURE__ */ new WeakMap(), r = new Bi();
  function d(p, y, _) {
    const E = p.morphTargetInfluences, T = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color, C = T !== void 0 ? T.length : 0;
    let D = a.get(y);
    if (D === void 0 || D.count !== C) {
      let Q = function() {
        le.dispose(), a.delete(y), y.removeEventListener("dispose", Q);
      };
      D !== void 0 && D.texture.dispose();
      const B = y.morphAttributes.position !== void 0, z = y.morphAttributes.normal !== void 0, V = y.morphAttributes.color !== void 0, G = y.morphAttributes.position || [], N = y.morphAttributes.normal || [], F = y.morphAttributes.color || [];
      let q = 0;
      B === !0 && (q = 1), z === !0 && (q = 2), V === !0 && (q = 3);
      let Y = y.attributes.position.count * q, ie = 1;
      Y > e.maxTextureSize && (ie = Math.ceil(Y / e.maxTextureSize), Y = e.maxTextureSize);
      const k = new Float32Array(Y * ie * 4 * C), le = new rE(k, Y, ie, C);
      le.type = pr, le.needsUpdate = !0;
      const ne = q * 4;
      for (let j = 0; j < C; j++) {
        const re = G[j], _e = N[j], me = F[j], Ae = Y * ie * 4 * j;
        for (let He = 0; He < re.count; He++) {
          const P = He * ne;
          B === !0 && (r.fromBufferAttribute(re, He), k[Ae + P + 0] = r.x, k[Ae + P + 1] = r.y, k[Ae + P + 2] = r.z, k[Ae + P + 3] = 0), z === !0 && (r.fromBufferAttribute(_e, He), k[Ae + P + 4] = r.x, k[Ae + P + 5] = r.y, k[Ae + P + 6] = r.z, k[Ae + P + 7] = 0), V === !0 && (r.fromBufferAttribute(me, He), k[Ae + P + 8] = r.x, k[Ae + P + 9] = r.y, k[Ae + P + 10] = r.z, k[Ae + P + 11] = me.itemSize === 4 ? r.w : 1);
        }
      }
      D = {
        count: C,
        texture: le,
        size: new Ot(Y, ie)
      }, a.set(y, D), y.addEventListener("dispose", Q);
    }
    if (p.isInstancedMesh === !0 && p.morphTexture !== null)
      _.getUniforms().setValue(o, "morphTexture", p.morphTexture, t);
    else {
      let B = 0;
      for (let V = 0; V < E.length; V++)
        B += E[V];
      const z = y.morphTargetsRelative ? 1 : 1 - B;
      _.getUniforms().setValue(o, "morphTargetBaseInfluence", z), _.getUniforms().setValue(o, "morphTargetInfluences", E);
    }
    _.getUniforms().setValue(o, "morphTargetsTexture", D.texture, t), _.getUniforms().setValue(o, "morphTargetsTextureSize", D.size);
  }
  return {
    update: d
  };
}
function t5(o, e, t, a) {
  let r = /* @__PURE__ */ new WeakMap();
  function d(_) {
    const E = a.render.frame, T = _.geometry, C = e.get(_, T);
    if (r.get(C) !== E && (e.update(C), r.set(C, E)), _.isInstancedMesh && (_.hasEventListener("dispose", y) === !1 && _.addEventListener("dispose", y), r.get(_) !== E && (t.update(_.instanceMatrix, o.ARRAY_BUFFER), _.instanceColor !== null && t.update(_.instanceColor, o.ARRAY_BUFFER), r.set(_, E))), _.isSkinnedMesh) {
      const D = _.skeleton;
      r.get(D) !== E && (D.update(), r.set(D, E));
    }
    return C;
  }
  function p() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function y(_) {
    const E = _.target;
    E.removeEventListener("dispose", y), t.remove(E.instanceMatrix), E.instanceColor !== null && t.remove(E.instanceColor);
  }
  return {
    update: d,
    dispose: p
  };
}
const cw = /* @__PURE__ */ new Ml(), o3 = /* @__PURE__ */ new _x(1, 1), fw = /* @__PURE__ */ new rE(), dw = /* @__PURE__ */ new px(), hw = /* @__PURE__ */ new uE(), u3 = [], c3 = [], f3 = new Float32Array(16), d3 = new Float32Array(9), h3 = new Float32Array(4);
function O1(o, e, t) {
  const a = o[0];
  if (a <= 0 || a > 0) return o;
  const r = e * t;
  let d = u3[r];
  if (d === void 0 && (d = new Float32Array(r), u3[r] = d), e !== 0) {
    a.toArray(d, 0);
    for (let p = 1, y = 0; p !== e; ++p)
      y += t, o[p].toArray(d, y);
  }
  return d;
}
function Fu(o, e) {
  if (o.length !== e.length) return !1;
  for (let t = 0, a = o.length; t < a; t++)
    if (o[t] !== e[t]) return !1;
  return !0;
}
function Pu(o, e) {
  for (let t = 0, a = e.length; t < a; t++)
    o[t] = e[t];
}
function Hx(o, e) {
  let t = c3[e];
  t === void 0 && (t = new Int32Array(e), c3[e] = t);
  for (let a = 0; a !== e; ++a)
    t[a] = o.allocateTextureUnit();
  return t;
}
function n5(o, e) {
  const t = this.cache;
  t[0] !== e && (o.uniform1f(this.addr, e), t[0] = e);
}
function a5(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (o.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Fu(t, e)) return;
    o.uniform2fv(this.addr, e), Pu(t, e);
  }
}
function i5(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (o.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (o.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (Fu(t, e)) return;
    o.uniform3fv(this.addr, e), Pu(t, e);
  }
}
function l5(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (o.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Fu(t, e)) return;
    o.uniform4fv(this.addr, e), Pu(t, e);
  }
}
function s5(o, e) {
  const t = this.cache, a = e.elements;
  if (a === void 0) {
    if (Fu(t, e)) return;
    o.uniformMatrix2fv(this.addr, !1, e), Pu(t, e);
  } else {
    if (Fu(t, a)) return;
    h3.set(a), o.uniformMatrix2fv(this.addr, !1, h3), Pu(t, a);
  }
}
function r5(o, e) {
  const t = this.cache, a = e.elements;
  if (a === void 0) {
    if (Fu(t, e)) return;
    o.uniformMatrix3fv(this.addr, !1, e), Pu(t, e);
  } else {
    if (Fu(t, a)) return;
    d3.set(a), o.uniformMatrix3fv(this.addr, !1, d3), Pu(t, a);
  }
}
function o5(o, e) {
  const t = this.cache, a = e.elements;
  if (a === void 0) {
    if (Fu(t, e)) return;
    o.uniformMatrix4fv(this.addr, !1, e), Pu(t, e);
  } else {
    if (Fu(t, a)) return;
    f3.set(a), o.uniformMatrix4fv(this.addr, !1, f3), Pu(t, a);
  }
}
function u5(o, e) {
  const t = this.cache;
  t[0] !== e && (o.uniform1i(this.addr, e), t[0] = e);
}
function c5(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (o.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Fu(t, e)) return;
    o.uniform2iv(this.addr, e), Pu(t, e);
  }
}
function f5(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (o.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Fu(t, e)) return;
    o.uniform3iv(this.addr, e), Pu(t, e);
  }
}
function d5(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (o.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Fu(t, e)) return;
    o.uniform4iv(this.addr, e), Pu(t, e);
  }
}
function h5(o, e) {
  const t = this.cache;
  t[0] !== e && (o.uniform1ui(this.addr, e), t[0] = e);
}
function p5(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (o.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Fu(t, e)) return;
    o.uniform2uiv(this.addr, e), Pu(t, e);
  }
}
function m5(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (o.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Fu(t, e)) return;
    o.uniform3uiv(this.addr, e), Pu(t, e);
  }
}
function v5(o, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (o.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Fu(t, e)) return;
    o.uniform4uiv(this.addr, e), Pu(t, e);
  }
}
function g5(o, e, t) {
  const a = this.cache, r = t.allocateTextureUnit();
  a[0] !== r && (o.uniform1i(this.addr, r), a[0] = r);
  let d;
  this.type === o.SAMPLER_2D_SHADOW ? (o3.compareFunction = E2, d = o3) : d = cw, t.setTexture2D(e || d, r);
}
function y5(o, e, t) {
  const a = this.cache, r = t.allocateTextureUnit();
  a[0] !== r && (o.uniform1i(this.addr, r), a[0] = r), t.setTexture3D(e || dw, r);
}
function S5(o, e, t) {
  const a = this.cache, r = t.allocateTextureUnit();
  a[0] !== r && (o.uniform1i(this.addr, r), a[0] = r), t.setTextureCube(e || hw, r);
}
function _5(o, e, t) {
  const a = this.cache, r = t.allocateTextureUnit();
  a[0] !== r && (o.uniform1i(this.addr, r), a[0] = r), t.setTexture2DArray(e || fw, r);
}
function A5(o) {
  switch (o) {
    case 5126:
      return n5;
    // FLOAT
    case 35664:
      return a5;
    // _VEC2
    case 35665:
      return i5;
    // _VEC3
    case 35666:
      return l5;
    // _VEC4
    case 35674:
      return s5;
    // _MAT2
    case 35675:
      return r5;
    // _MAT3
    case 35676:
      return o5;
    // _MAT4
    case 5124:
    case 35670:
      return u5;
    // INT, BOOL
    case 35667:
    case 35671:
      return c5;
    // _VEC2
    case 35668:
    case 35672:
      return f5;
    // _VEC3
    case 35669:
    case 35673:
      return d5;
    // _VEC4
    case 5125:
      return h5;
    // UINT
    case 36294:
      return p5;
    // _VEC2
    case 36295:
      return m5;
    // _VEC3
    case 36296:
      return v5;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return g5;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return y5;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return S5;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return _5;
  }
}
function E5(o, e) {
  o.uniform1fv(this.addr, e);
}
function b5(o, e) {
  const t = O1(e, this.size, 2);
  o.uniform2fv(this.addr, t);
}
function M5(o, e) {
  const t = O1(e, this.size, 3);
  o.uniform3fv(this.addr, t);
}
function x5(o, e) {
  const t = O1(e, this.size, 4);
  o.uniform4fv(this.addr, t);
}
function T5(o, e) {
  const t = O1(e, this.size, 4);
  o.uniformMatrix2fv(this.addr, !1, t);
}
function C5(o, e) {
  const t = O1(e, this.size, 9);
  o.uniformMatrix3fv(this.addr, !1, t);
}
function R5(o, e) {
  const t = O1(e, this.size, 16);
  o.uniformMatrix4fv(this.addr, !1, t);
}
function D5(o, e) {
  o.uniform1iv(this.addr, e);
}
function B5(o, e) {
  o.uniform2iv(this.addr, e);
}
function U5(o, e) {
  o.uniform3iv(this.addr, e);
}
function O5(o, e) {
  o.uniform4iv(this.addr, e);
}
function w5(o, e) {
  o.uniform1uiv(this.addr, e);
}
function N5(o, e) {
  o.uniform2uiv(this.addr, e);
}
function z5(o, e) {
  o.uniform3uiv(this.addr, e);
}
function H5(o, e) {
  o.uniform4uiv(this.addr, e);
}
function L5(o, e, t) {
  const a = this.cache, r = e.length, d = Hx(t, r);
  Fu(a, d) || (o.uniform1iv(this.addr, d), Pu(a, d));
  for (let p = 0; p !== r; ++p)
    t.setTexture2D(e[p] || cw, d[p]);
}
function G5(o, e, t) {
  const a = this.cache, r = e.length, d = Hx(t, r);
  Fu(a, d) || (o.uniform1iv(this.addr, d), Pu(a, d));
  for (let p = 0; p !== r; ++p)
    t.setTexture3D(e[p] || dw, d[p]);
}
function I5(o, e, t) {
  const a = this.cache, r = e.length, d = Hx(t, r);
  Fu(a, d) || (o.uniform1iv(this.addr, d), Pu(a, d));
  for (let p = 0; p !== r; ++p)
    t.setTextureCube(e[p] || hw, d[p]);
}
function V5(o, e, t) {
  const a = this.cache, r = e.length, d = Hx(t, r);
  Fu(a, d) || (o.uniform1iv(this.addr, d), Pu(a, d));
  for (let p = 0; p !== r; ++p)
    t.setTexture2DArray(e[p] || fw, d[p]);
}
function F5(o) {
  switch (o) {
    case 5126:
      return E5;
    // FLOAT
    case 35664:
      return b5;
    // _VEC2
    case 35665:
      return M5;
    // _VEC3
    case 35666:
      return x5;
    // _VEC4
    case 35674:
      return T5;
    // _MAT2
    case 35675:
      return C5;
    // _MAT3
    case 35676:
      return R5;
    // _MAT4
    case 5124:
    case 35670:
      return D5;
    // INT, BOOL
    case 35667:
    case 35671:
      return B5;
    // _VEC2
    case 35668:
    case 35672:
      return U5;
    // _VEC3
    case 35669:
    case 35673:
      return O5;
    // _VEC4
    case 5125:
      return w5;
    // UINT
    case 36294:
      return N5;
    // _VEC2
    case 36295:
      return z5;
    // _VEC3
    case 36296:
      return H5;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return L5;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return G5;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return I5;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return V5;
  }
}
class P5 {
  constructor(e, t, a) {
    this.id = e, this.addr = a, this.cache = [], this.type = t.type, this.setValue = A5(t.type);
  }
}
class X5 {
  constructor(e, t, a) {
    this.id = e, this.addr = a, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = F5(t.type);
  }
}
class Y5 {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, a) {
    const r = this.seq;
    for (let d = 0, p = r.length; d !== p; ++d) {
      const y = r[d];
      y.setValue(e, t[y.id], a);
    }
  }
}
const pC = /(\w+)(\])?(\[|\.)?/g;
function p3(o, e) {
  o.seq.push(e), o.map[e.id] = e;
}
function q5(o, e, t) {
  const a = o.name, r = a.length;
  for (pC.lastIndex = 0; ; ) {
    const d = pC.exec(a), p = pC.lastIndex;
    let y = d[1];
    const _ = d[2] === "]", E = d[3];
    if (_ && (y = y | 0), E === void 0 || E === "[" && p + 2 === r) {
      p3(t, E === void 0 ? new P5(y, o, e) : new X5(y, o, e));
      break;
    } else {
      let C = t.map[y];
      C === void 0 && (C = new Y5(y), p3(t, C)), t = C;
    }
  }
}
class rM {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const a = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < a; ++r) {
      const d = e.getActiveUniform(t, r), p = e.getUniformLocation(t, d.name);
      q5(d, p, this);
    }
  }
  setValue(e, t, a, r) {
    const d = this.map[t];
    d !== void 0 && d.setValue(e, a, r);
  }
  setOptional(e, t, a) {
    const r = t[a];
    r !== void 0 && this.setValue(e, a, r);
  }
  static upload(e, t, a, r) {
    for (let d = 0, p = t.length; d !== p; ++d) {
      const y = t[d], _ = a[y.id];
      _.needsUpdate !== !1 && y.setValue(e, _.value, r);
    }
  }
  static seqWithValue(e, t) {
    const a = [];
    for (let r = 0, d = e.length; r !== d; ++r) {
      const p = e[r];
      p.id in t && a.push(p);
    }
    return a;
  }
}
function m3(o, e, t) {
  const a = o.createShader(e);
  return o.shaderSource(a, t), o.compileShader(a), a;
}
const Z5 = 37297;
let Q5 = 0;
function j5(o, e) {
  const t = o.split(`
`), a = [], r = Math.max(e - 6, 0), d = Math.min(e + 6, t.length);
  for (let p = r; p < d; p++) {
    const y = p + 1;
    a.push(`${y === e ? ">" : " "} ${y}: ${t[p]}`);
  }
  return a.join(`
`);
}
const v3 = /* @__PURE__ */ new ja();
function J5(o) {
  wi._getMatrix(v3, wi.workingColorSpace, o);
  const e = `mat3( ${v3.elements.map((t) => t.toFixed(4))} )`;
  switch (wi.getTransfer(o)) {
    case ZA:
      return [e, "LinearTransferOETF"];
    case Nl:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", o), [e, "LinearTransferOETF"];
  }
}
function g3(o, e, t) {
  const a = o.getShaderParameter(e, o.COMPILE_STATUS), r = o.getShaderInfoLog(e).trim();
  if (a && r === "") return "";
  const d = /ERROR: 0:(\d+)/.exec(r);
  if (d) {
    const p = parseInt(d[1]);
    return t.toUpperCase() + `

` + r + `

` + j5(o.getShaderSource(e), p);
  } else
    return r;
}
function K5(o, e) {
  const t = J5(e);
  return [
    `vec4 ${o}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function k5(o, e) {
  let t;
  switch (e) {
    case ZU:
      t = "Linear";
      break;
    case QU:
      t = "Reinhard";
      break;
    case jU:
      t = "Cineon";
      break;
    case d2:
      t = "ACESFilmic";
      break;
    case KU:
      t = "AgX";
      break;
    case kU:
      t = "Neutral";
      break;
    case JU:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + o + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
const Fb = /* @__PURE__ */ new ve();
function W5() {
  wi.getLuminanceCoefficients(Fb);
  const o = Fb.x.toFixed(4), e = Fb.y.toFixed(4), t = Fb.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${o}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function $5(o) {
  return [
    o.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    o.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(UA).join(`
`);
}
function eG(o) {
  const e = [];
  for (const t in o) {
    const a = o[t];
    a !== !1 && e.push("#define " + t + " " + a);
  }
  return e.join(`
`);
}
function tG(o, e) {
  const t = {}, a = o.getProgramParameter(e, o.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < a; r++) {
    const d = o.getActiveAttrib(e, r), p = d.name;
    let y = 1;
    d.type === o.FLOAT_MAT2 && (y = 2), d.type === o.FLOAT_MAT3 && (y = 3), d.type === o.FLOAT_MAT4 && (y = 4), t[p] = {
      type: d.type,
      location: o.getAttribLocation(e, p),
      locationSize: y
    };
  }
  return t;
}
function UA(o) {
  return o !== "";
}
function y3(o, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return o.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function S3(o, e) {
  return o.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const nG = /^[ \t]*#include +<([\w\d./]+)>/gm;
function t2(o) {
  return o.replace(nG, iG);
}
const aG = /* @__PURE__ */ new Map();
function iG(o, e) {
  let t = ii[e];
  if (t === void 0) {
    const a = aG.get(e);
    if (a !== void 0)
      t = ii[a], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, a);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return t2(t);
}
const lG = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function _3(o) {
  return o.replace(lG, sG);
}
function sG(o, e, t, a) {
  let r = "";
  for (let d = parseInt(e); d < parseInt(t); d++)
    r += a.replace(/\[\s*i\s*\]/g, "[ " + d + " ]").replace(/UNROLLED_LOOP_INDEX/g, d);
  return r;
}
function A3(o) {
  let e = `precision ${o.precision} float;
	precision ${o.precision} int;
	precision ${o.precision} sampler2D;
	precision ${o.precision} samplerCube;
	precision ${o.precision} sampler3D;
	precision ${o.precision} sampler2DArray;
	precision ${o.precision} sampler2DShadow;
	precision ${o.precision} samplerCubeShadow;
	precision ${o.precision} sampler2DArrayShadow;
	precision ${o.precision} isampler2D;
	precision ${o.precision} isampler3D;
	precision ${o.precision} isamplerCube;
	precision ${o.precision} isampler2DArray;
	precision ${o.precision} usampler2D;
	precision ${o.precision} usampler3D;
	precision ${o.precision} usamplerCube;
	precision ${o.precision} usampler2DArray;
	`;
  return o.precision === "highp" ? e += `
#define HIGH_PRECISION` : o.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : o.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function rG(o) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return o.shadowMapType === ax ? e = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === wA ? e = "SHADOWMAP_TYPE_PCF_SOFT" : o.shadowMapType === qv && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function oG(o) {
  let e = "ENVMAP_TYPE_CUBE";
  if (o.envMap)
    switch (o.envMapMode) {
      case Qg:
      case Y0:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case C1:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function uG(o) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (o.envMap)
    switch (o.envMapMode) {
      case Y0:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function cG(o) {
  let e = "ENVMAP_BLENDING_NONE";
  if (o.envMap)
    switch (o.combine) {
      case aE:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case YU:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case qU:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function fG(o) {
  const e = o.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, a = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: a, maxMip: t };
}
function dG(o, e, t, a) {
  const r = o.getContext(), d = t.defines;
  let p = t.vertexShader, y = t.fragmentShader;
  const _ = rG(t), E = oG(t), T = uG(t), C = cG(t), D = fG(t), B = $5(t), z = eG(d), V = r.createProgram();
  let G, N, F = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (G = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    z
  ].filter(UA).join(`
`), G.length > 0 && (G += `
`), N = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    z
  ].filter(UA).join(`
`), N.length > 0 && (N += `
`)) : (G = [
    A3(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    z,
    t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    t.batching ? "#define USE_BATCHING" : "",
    t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + T : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + _ : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(UA).join(`
`), N = [
    A3(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    z,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + E : "",
    t.envMap ? "#define " + T : "",
    t.envMap ? "#define " + C : "",
    D ? "#define CUBEUV_TEXEL_WIDTH " + D.texelWidth : "",
    D ? "#define CUBEUV_TEXEL_HEIGHT " + D.texelHeight : "",
    D ? "#define CUBEUV_MAX_MIP " + D.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.dispersion ? "#define USE_DISPERSION" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + _ : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== Yg ? "#define TONE_MAPPING" : "",
    t.toneMapping !== Yg ? ii.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== Yg ? k5("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    ii.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    K5("linearToOutputTexel", t.outputColorSpace),
    W5(),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(UA).join(`
`)), p = t2(p), p = y3(p, t), p = S3(p, t), y = t2(y), y = y3(y, t), y = S3(y, t), p = _3(p), y = _3(y), t.isRawShaderMaterial !== !0 && (F = `#version 300 es
`, G = [
    B,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + G, N = [
    "#define varying in",
    t.glslVersion === QC ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === QC ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + N);
  const q = F + G + p, Y = F + N + y, ie = m3(r, r.VERTEX_SHADER, q), k = m3(r, r.FRAGMENT_SHADER, Y);
  r.attachShader(V, ie), r.attachShader(V, k), t.index0AttributeName !== void 0 ? r.bindAttribLocation(V, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(V, 0, "position"), r.linkProgram(V);
  function le(re) {
    if (o.debug.checkShaderErrors) {
      const _e = r.getProgramInfoLog(V).trim(), me = r.getShaderInfoLog(ie).trim(), Ae = r.getShaderInfoLog(k).trim();
      let He = !0, P = !0;
      if (r.getProgramParameter(V, r.LINK_STATUS) === !1)
        if (He = !1, typeof o.debug.onShaderError == "function")
          o.debug.onShaderError(r, V, ie, k);
        else {
          const te = g3(r, ie, "vertex"), ae = g3(r, k, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(V, r.VALIDATE_STATUS) + `

Material Name: ` + re.name + `
Material Type: ` + re.type + `

Program Info Log: ` + _e + `
` + te + `
` + ae
          );
        }
      else _e !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", _e) : (me === "" || Ae === "") && (P = !1);
      P && (re.diagnostics = {
        runnable: He,
        programLog: _e,
        vertexShader: {
          log: me,
          prefix: G
        },
        fragmentShader: {
          log: Ae,
          prefix: N
        }
      });
    }
    r.deleteShader(ie), r.deleteShader(k), ne = new rM(r, V), Q = tG(r, V);
  }
  let ne;
  this.getUniforms = function() {
    return ne === void 0 && le(this), ne;
  };
  let Q;
  this.getAttributes = function() {
    return Q === void 0 && le(this), Q;
  };
  let j = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return j === !1 && (j = r.getProgramParameter(V, Z5)), j;
  }, this.destroy = function() {
    a.releaseStatesOfProgram(this), r.deleteProgram(V), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = Q5++, this.cacheKey = e, this.usedTimes = 1, this.program = V, this.vertexShader = ie, this.fragmentShader = k, this;
}
let hG = 0;
class pG {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, a = e.fragmentShader, r = this._getShaderStage(t), d = this._getShaderStage(a), p = this._getShaderCacheForMaterial(e);
    return p.has(r) === !1 && (p.add(r), r.usedTimes++), p.has(d) === !1 && (p.add(d), d.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const a of t)
      a.usedTimes--, a.usedTimes === 0 && this.shaderCache.delete(a.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let a = t.get(e);
    return a === void 0 && (a = /* @__PURE__ */ new Set(), t.set(e, a)), a;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let a = t.get(e);
    return a === void 0 && (a = new mG(e), t.set(e, a)), a;
  }
}
class mG {
  constructor(e) {
    this.id = hG++, this.code = e, this.usedTimes = 0;
  }
}
function vG(o, e, t, a, r, d, p) {
  const y = new A1(), _ = new pG(), E = /* @__PURE__ */ new Set(), T = [], C = r.logarithmicDepthBuffer, D = r.vertexTextures;
  let B = r.precision;
  const z = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function V(Q) {
    return E.add(Q), Q === 0 ? "uv" : `uv${Q}`;
  }
  function G(Q, j, re, _e, me) {
    const Ae = _e.fog, He = me.geometry, P = Q.isMeshStandardMaterial ? _e.environment : null, te = (Q.isMeshStandardMaterial ? t : e).get(Q.envMap || P), ae = te && te.mapping === C1 ? te.image.height : null, Se = z[Q.type];
    Q.precision !== null && (B = r.getMaxPrecision(Q.precision), B !== Q.precision && console.warn("THREE.WebGLProgram.getParameters:", Q.precision, "not supported, using", B, "instead."));
    const ue = He.morphAttributes.position || He.morphAttributes.normal || He.morphAttributes.color, we = ue !== void 0 ? ue.length : 0;
    let De = 0;
    He.morphAttributes.position !== void 0 && (De = 1), He.morphAttributes.normal !== void 0 && (De = 2), He.morphAttributes.color !== void 0 && (De = 3);
    let We, Me, Ze, ct;
    if (Se) {
      const sa = Zv[Se];
      We = sa.vertexShader, Me = sa.fragmentShader;
    } else
      We = Q.vertexShader, Me = Q.fragmentShader, _.update(Q), Ze = _.getVertexShaderID(Q), ct = _.getFragmentShaderID(Q);
    const Vt = o.getRenderTarget(), Zt = o.state.buffers.depth.getReversed(), Bn = me.isInstancedMesh === !0, rn = me.isBatchedMesh === !0, dn = !!Q.map, Zn = !!Q.matcap, Rn = !!te, Te = !!Q.aoMap, Ha = !!Q.lightMap, Tt = !!Q.bumpMap, St = !!Q.normalMap, Mt = !!Q.displacementMap, kt = !!Q.emissiveMap, At = !!Q.metalnessMap, ce = !!Q.roughnessMap, se = Q.anisotropy > 0, Xe = Q.clearcoat > 0, dt = Q.dispersion > 0, Et = Q.iridescence > 0, yt = Q.sheen > 0, Jt = Q.transmission > 0, Xt = se && !!Q.anisotropyMap, Wt = Xe && !!Q.clearcoatMap, Vn = Xe && !!Q.clearcoatNormalMap, Pt = Xe && !!Q.clearcoatRoughnessMap, pn = Et && !!Q.iridescenceMap, gn = Et && !!Q.iridescenceThicknessMap, nn = yt && !!Q.sheenColorMap, jt = yt && !!Q.sheenRoughnessMap, Ue = !!Q.specularMap, ot = !!Q.specularColorMap, Ht = !!Q.specularIntensityMap, xe = Jt && !!Q.transmissionMap, Je = Jt && !!Q.thicknessMap, tt = !!Q.gradientMap, Ct = !!Q.alphaMap, $t = Q.alphaTest > 0, tn = !!Q.alphaHash, Mn = !!Q.extensions;
    let Wn = Yg;
    Q.toneMapped && (Vt === null || Vt.isXRRenderTarget === !0) && (Wn = o.toneMapping);
    const Xa = {
      shaderID: Se,
      shaderType: Q.type,
      shaderName: Q.name,
      vertexShader: We,
      fragmentShader: Me,
      defines: Q.defines,
      customVertexShaderID: Ze,
      customFragmentShaderID: ct,
      isRawShaderMaterial: Q.isRawShaderMaterial === !0,
      glslVersion: Q.glslVersion,
      precision: B,
      batching: rn,
      batchingColor: rn && me._colorsTexture !== null,
      instancing: Bn,
      instancingColor: Bn && me.instanceColor !== null,
      instancingMorph: Bn && me.morphTexture !== null,
      supportsVertexTextures: D,
      outputColorSpace: Vt === null ? o.outputColorSpace : Vt.isXRRenderTarget === !0 ? Vt.texture.colorSpace : Kv,
      alphaToCoverage: !!Q.alphaToCoverage,
      map: dn,
      matcap: Zn,
      envMap: Rn,
      envMapMode: Rn && te.mapping,
      envMapCubeUVHeight: ae,
      aoMap: Te,
      lightMap: Ha,
      bumpMap: Tt,
      normalMap: St,
      displacementMap: D && Mt,
      emissiveMap: kt,
      normalMapObjectSpace: St && Q.normalMapType === lO,
      normalMapTangentSpace: St && Q.normalMapType === Q0,
      metalnessMap: At,
      roughnessMap: ce,
      anisotropy: se,
      anisotropyMap: Xt,
      clearcoat: Xe,
      clearcoatMap: Wt,
      clearcoatNormalMap: Vn,
      clearcoatRoughnessMap: Pt,
      dispersion: dt,
      iridescence: Et,
      iridescenceMap: pn,
      iridescenceThicknessMap: gn,
      sheen: yt,
      sheenColorMap: nn,
      sheenRoughnessMap: jt,
      specularMap: Ue,
      specularColorMap: ot,
      specularIntensityMap: Ht,
      transmission: Jt,
      transmissionMap: xe,
      thicknessMap: Je,
      gradientMap: tt,
      opaque: Q.transparent === !1 && Q.blending === QS && Q.alphaToCoverage === !1,
      alphaMap: Ct,
      alphaTest: $t,
      alphaHash: tn,
      combine: Q.combine,
      //
      mapUv: dn && V(Q.map.channel),
      aoMapUv: Te && V(Q.aoMap.channel),
      lightMapUv: Ha && V(Q.lightMap.channel),
      bumpMapUv: Tt && V(Q.bumpMap.channel),
      normalMapUv: St && V(Q.normalMap.channel),
      displacementMapUv: Mt && V(Q.displacementMap.channel),
      emissiveMapUv: kt && V(Q.emissiveMap.channel),
      metalnessMapUv: At && V(Q.metalnessMap.channel),
      roughnessMapUv: ce && V(Q.roughnessMap.channel),
      anisotropyMapUv: Xt && V(Q.anisotropyMap.channel),
      clearcoatMapUv: Wt && V(Q.clearcoatMap.channel),
      clearcoatNormalMapUv: Vn && V(Q.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Pt && V(Q.clearcoatRoughnessMap.channel),
      iridescenceMapUv: pn && V(Q.iridescenceMap.channel),
      iridescenceThicknessMapUv: gn && V(Q.iridescenceThicknessMap.channel),
      sheenColorMapUv: nn && V(Q.sheenColorMap.channel),
      sheenRoughnessMapUv: jt && V(Q.sheenRoughnessMap.channel),
      specularMapUv: Ue && V(Q.specularMap.channel),
      specularColorMapUv: ot && V(Q.specularColorMap.channel),
      specularIntensityMapUv: Ht && V(Q.specularIntensityMap.channel),
      transmissionMapUv: xe && V(Q.transmissionMap.channel),
      thicknessMapUv: Je && V(Q.thicknessMap.channel),
      alphaMapUv: Ct && V(Q.alphaMap.channel),
      //
      vertexTangents: !!He.attributes.tangent && (St || se),
      vertexColors: Q.vertexColors,
      vertexAlphas: Q.vertexColors === !0 && !!He.attributes.color && He.attributes.color.itemSize === 4,
      pointsUvs: me.isPoints === !0 && !!He.attributes.uv && (dn || Ct),
      fog: !!Ae,
      useFog: Q.fog === !0,
      fogExp2: !!Ae && Ae.isFogExp2,
      flatShading: Q.flatShading === !0,
      sizeAttenuation: Q.sizeAttenuation === !0,
      logarithmicDepthBuffer: C,
      reverseDepthBuffer: Zt,
      skinning: me.isSkinnedMesh === !0,
      morphTargets: He.morphAttributes.position !== void 0,
      morphNormals: He.morphAttributes.normal !== void 0,
      morphColors: He.morphAttributes.color !== void 0,
      morphTargetsCount: we,
      morphTextureStride: De,
      numDirLights: j.directional.length,
      numPointLights: j.point.length,
      numSpotLights: j.spot.length,
      numSpotLightMaps: j.spotLightMap.length,
      numRectAreaLights: j.rectArea.length,
      numHemiLights: j.hemi.length,
      numDirLightShadows: j.directionalShadowMap.length,
      numPointLightShadows: j.pointShadowMap.length,
      numSpotLightShadows: j.spotShadowMap.length,
      numSpotLightShadowsWithMaps: j.numSpotLightShadowsWithMaps,
      numLightProbes: j.numLightProbes,
      numClippingPlanes: p.numPlanes,
      numClipIntersection: p.numIntersection,
      dithering: Q.dithering,
      shadowMapEnabled: o.shadowMap.enabled && re.length > 0,
      shadowMapType: o.shadowMap.type,
      toneMapping: Wn,
      decodeVideoTexture: dn && Q.map.isVideoTexture === !0 && wi.getTransfer(Q.map.colorSpace) === Nl,
      decodeVideoTextureEmissive: kt && Q.emissiveMap.isVideoTexture === !0 && wi.getTransfer(Q.emissiveMap.colorSpace) === Nl,
      premultipliedAlpha: Q.premultipliedAlpha,
      doubleSided: Q.side === Lp,
      flipSided: Q.side === ed,
      useDepthPacking: Q.depthPacking >= 0,
      depthPacking: Q.depthPacking || 0,
      index0AttributeName: Q.index0AttributeName,
      extensionClipCullDistance: Mn && Q.extensions.clipCullDistance === !0 && a.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (Mn && Q.extensions.multiDraw === !0 || rn) && a.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: a.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: Q.customProgramCacheKey()
    };
    return Xa.vertexUv1s = E.has(1), Xa.vertexUv2s = E.has(2), Xa.vertexUv3s = E.has(3), E.clear(), Xa;
  }
  function N(Q) {
    const j = [];
    if (Q.shaderID ? j.push(Q.shaderID) : (j.push(Q.customVertexShaderID), j.push(Q.customFragmentShaderID)), Q.defines !== void 0)
      for (const re in Q.defines)
        j.push(re), j.push(Q.defines[re]);
    return Q.isRawShaderMaterial === !1 && (F(j, Q), q(j, Q), j.push(o.outputColorSpace)), j.push(Q.customProgramCacheKey), j.join();
  }
  function F(Q, j) {
    Q.push(j.precision), Q.push(j.outputColorSpace), Q.push(j.envMapMode), Q.push(j.envMapCubeUVHeight), Q.push(j.mapUv), Q.push(j.alphaMapUv), Q.push(j.lightMapUv), Q.push(j.aoMapUv), Q.push(j.bumpMapUv), Q.push(j.normalMapUv), Q.push(j.displacementMapUv), Q.push(j.emissiveMapUv), Q.push(j.metalnessMapUv), Q.push(j.roughnessMapUv), Q.push(j.anisotropyMapUv), Q.push(j.clearcoatMapUv), Q.push(j.clearcoatNormalMapUv), Q.push(j.clearcoatRoughnessMapUv), Q.push(j.iridescenceMapUv), Q.push(j.iridescenceThicknessMapUv), Q.push(j.sheenColorMapUv), Q.push(j.sheenRoughnessMapUv), Q.push(j.specularMapUv), Q.push(j.specularColorMapUv), Q.push(j.specularIntensityMapUv), Q.push(j.transmissionMapUv), Q.push(j.thicknessMapUv), Q.push(j.combine), Q.push(j.fogExp2), Q.push(j.sizeAttenuation), Q.push(j.morphTargetsCount), Q.push(j.morphAttributeCount), Q.push(j.numDirLights), Q.push(j.numPointLights), Q.push(j.numSpotLights), Q.push(j.numSpotLightMaps), Q.push(j.numHemiLights), Q.push(j.numRectAreaLights), Q.push(j.numDirLightShadows), Q.push(j.numPointLightShadows), Q.push(j.numSpotLightShadows), Q.push(j.numSpotLightShadowsWithMaps), Q.push(j.numLightProbes), Q.push(j.shadowMapType), Q.push(j.toneMapping), Q.push(j.numClippingPlanes), Q.push(j.numClipIntersection), Q.push(j.depthPacking);
  }
  function q(Q, j) {
    y.disableAll(), j.supportsVertexTextures && y.enable(0), j.instancing && y.enable(1), j.instancingColor && y.enable(2), j.instancingMorph && y.enable(3), j.matcap && y.enable(4), j.envMap && y.enable(5), j.normalMapObjectSpace && y.enable(6), j.normalMapTangentSpace && y.enable(7), j.clearcoat && y.enable(8), j.iridescence && y.enable(9), j.alphaTest && y.enable(10), j.vertexColors && y.enable(11), j.vertexAlphas && y.enable(12), j.vertexUv1s && y.enable(13), j.vertexUv2s && y.enable(14), j.vertexUv3s && y.enable(15), j.vertexTangents && y.enable(16), j.anisotropy && y.enable(17), j.alphaHash && y.enable(18), j.batching && y.enable(19), j.dispersion && y.enable(20), j.batchingColor && y.enable(21), Q.push(y.mask), y.disableAll(), j.fog && y.enable(0), j.useFog && y.enable(1), j.flatShading && y.enable(2), j.logarithmicDepthBuffer && y.enable(3), j.reverseDepthBuffer && y.enable(4), j.skinning && y.enable(5), j.morphTargets && y.enable(6), j.morphNormals && y.enable(7), j.morphColors && y.enable(8), j.premultipliedAlpha && y.enable(9), j.shadowMapEnabled && y.enable(10), j.doubleSided && y.enable(11), j.flipSided && y.enable(12), j.useDepthPacking && y.enable(13), j.dithering && y.enable(14), j.transmission && y.enable(15), j.sheen && y.enable(16), j.opaque && y.enable(17), j.pointsUvs && y.enable(18), j.decodeVideoTexture && y.enable(19), j.decodeVideoTextureEmissive && y.enable(20), j.alphaToCoverage && y.enable(21), Q.push(y.mask);
  }
  function Y(Q) {
    const j = z[Q.type];
    let re;
    if (j) {
      const _e = Zv[j];
      re = T2.clone(_e.uniforms);
    } else
      re = Q.uniforms;
    return re;
  }
  function ie(Q, j) {
    let re;
    for (let _e = 0, me = T.length; _e < me; _e++) {
      const Ae = T[_e];
      if (Ae.cacheKey === j) {
        re = Ae, ++re.usedTimes;
        break;
      }
    }
    return re === void 0 && (re = new dG(o, j, Q, d), T.push(re)), re;
  }
  function k(Q) {
    if (--Q.usedTimes === 0) {
      const j = T.indexOf(Q);
      T[j] = T[T.length - 1], T.pop(), Q.destroy();
    }
  }
  function le(Q) {
    _.remove(Q);
  }
  function ne() {
    _.dispose();
  }
  return {
    getParameters: G,
    getProgramCacheKey: N,
    getUniforms: Y,
    acquireProgram: ie,
    releaseProgram: k,
    releaseShaderCache: le,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: T,
    dispose: ne
  };
}
function gG() {
  let o = /* @__PURE__ */ new WeakMap();
  function e(p) {
    return o.has(p);
  }
  function t(p) {
    let y = o.get(p);
    return y === void 0 && (y = {}, o.set(p, y)), y;
  }
  function a(p) {
    o.delete(p);
  }
  function r(p, y, _) {
    o.get(p)[y] = _;
  }
  function d() {
    o = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: t,
    remove: a,
    update: r,
    dispose: d
  };
}
function yG(o, e) {
  return o.groupOrder !== e.groupOrder ? o.groupOrder - e.groupOrder : o.renderOrder !== e.renderOrder ? o.renderOrder - e.renderOrder : o.material.id !== e.material.id ? o.material.id - e.material.id : o.z !== e.z ? o.z - e.z : o.id - e.id;
}
function E3(o, e) {
  return o.groupOrder !== e.groupOrder ? o.groupOrder - e.groupOrder : o.renderOrder !== e.renderOrder ? o.renderOrder - e.renderOrder : o.z !== e.z ? e.z - o.z : o.id - e.id;
}
function b3() {
  const o = [];
  let e = 0;
  const t = [], a = [], r = [];
  function d() {
    e = 0, t.length = 0, a.length = 0, r.length = 0;
  }
  function p(C, D, B, z, V, G) {
    let N = o[e];
    return N === void 0 ? (N = {
      id: C.id,
      object: C,
      geometry: D,
      material: B,
      groupOrder: z,
      renderOrder: C.renderOrder,
      z: V,
      group: G
    }, o[e] = N) : (N.id = C.id, N.object = C, N.geometry = D, N.material = B, N.groupOrder = z, N.renderOrder = C.renderOrder, N.z = V, N.group = G), e++, N;
  }
  function y(C, D, B, z, V, G) {
    const N = p(C, D, B, z, V, G);
    B.transmission > 0 ? a.push(N) : B.transparent === !0 ? r.push(N) : t.push(N);
  }
  function _(C, D, B, z, V, G) {
    const N = p(C, D, B, z, V, G);
    B.transmission > 0 ? a.unshift(N) : B.transparent === !0 ? r.unshift(N) : t.unshift(N);
  }
  function E(C, D) {
    t.length > 1 && t.sort(C || yG), a.length > 1 && a.sort(D || E3), r.length > 1 && r.sort(D || E3);
  }
  function T() {
    for (let C = e, D = o.length; C < D; C++) {
      const B = o[C];
      if (B.id === null) break;
      B.id = null, B.object = null, B.geometry = null, B.material = null, B.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: a,
    transparent: r,
    init: d,
    push: y,
    unshift: _,
    finish: T,
    sort: E
  };
}
function SG() {
  let o = /* @__PURE__ */ new WeakMap();
  function e(a, r) {
    const d = o.get(a);
    let p;
    return d === void 0 ? (p = new b3(), o.set(a, [p])) : r >= d.length ? (p = new b3(), d.push(p)) : p = d[r], p;
  }
  function t() {
    o = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function _G() {
  const o = {};
  return {
    get: function(e) {
      if (o[e.id] !== void 0)
        return o[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new ve(),
            color: new hn()
          };
          break;
        case "SpotLight":
          t = {
            position: new ve(),
            direction: new ve(),
            color: new hn(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new ve(),
            color: new hn(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new ve(),
            skyColor: new hn(),
            groundColor: new hn()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new hn(),
            position: new ve(),
            halfWidth: new ve(),
            halfHeight: new ve()
          };
          break;
      }
      return o[e.id] = t, t;
    }
  };
}
function AG() {
  const o = {};
  return {
    get: function(e) {
      if (o[e.id] !== void 0)
        return o[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ot()
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ot()
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ot(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return o[e.id] = t, t;
    }
  };
}
let EG = 0;
function bG(o, e) {
  return (e.castShadow ? 2 : 0) - (o.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (o.map ? 1 : 0);
}
function MG(o) {
  const e = new _G(), t = AG(), a = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let E = 0; E < 9; E++) a.probe.push(new ve());
  const r = new ve(), d = new ia(), p = new ia();
  function y(E) {
    let T = 0, C = 0, D = 0;
    for (let Q = 0; Q < 9; Q++) a.probe[Q].set(0, 0, 0);
    let B = 0, z = 0, V = 0, G = 0, N = 0, F = 0, q = 0, Y = 0, ie = 0, k = 0, le = 0;
    E.sort(bG);
    for (let Q = 0, j = E.length; Q < j; Q++) {
      const re = E[Q], _e = re.color, me = re.intensity, Ae = re.distance, He = re.shadow && re.shadow.map ? re.shadow.map.texture : null;
      if (re.isAmbientLight)
        T += _e.r * me, C += _e.g * me, D += _e.b * me;
      else if (re.isLightProbe) {
        for (let P = 0; P < 9; P++)
          a.probe[P].addScaledVector(re.sh.coefficients[P], me);
        le++;
      } else if (re.isDirectionalLight) {
        const P = e.get(re);
        if (P.color.copy(re.color).multiplyScalar(re.intensity), re.castShadow) {
          const te = re.shadow, ae = t.get(re);
          ae.shadowIntensity = te.intensity, ae.shadowBias = te.bias, ae.shadowNormalBias = te.normalBias, ae.shadowRadius = te.radius, ae.shadowMapSize = te.mapSize, a.directionalShadow[B] = ae, a.directionalShadowMap[B] = He, a.directionalShadowMatrix[B] = re.shadow.matrix, F++;
        }
        a.directional[B] = P, B++;
      } else if (re.isSpotLight) {
        const P = e.get(re);
        P.position.setFromMatrixPosition(re.matrixWorld), P.color.copy(_e).multiplyScalar(me), P.distance = Ae, P.coneCos = Math.cos(re.angle), P.penumbraCos = Math.cos(re.angle * (1 - re.penumbra)), P.decay = re.decay, a.spot[V] = P;
        const te = re.shadow;
        if (re.map && (a.spotLightMap[ie] = re.map, ie++, te.updateMatrices(re), re.castShadow && k++), a.spotLightMatrix[V] = te.matrix, re.castShadow) {
          const ae = t.get(re);
          ae.shadowIntensity = te.intensity, ae.shadowBias = te.bias, ae.shadowNormalBias = te.normalBias, ae.shadowRadius = te.radius, ae.shadowMapSize = te.mapSize, a.spotShadow[V] = ae, a.spotShadowMap[V] = He, Y++;
        }
        V++;
      } else if (re.isRectAreaLight) {
        const P = e.get(re);
        P.color.copy(_e).multiplyScalar(me), P.halfWidth.set(re.width * 0.5, 0, 0), P.halfHeight.set(0, re.height * 0.5, 0), a.rectArea[G] = P, G++;
      } else if (re.isPointLight) {
        const P = e.get(re);
        if (P.color.copy(re.color).multiplyScalar(re.intensity), P.distance = re.distance, P.decay = re.decay, re.castShadow) {
          const te = re.shadow, ae = t.get(re);
          ae.shadowIntensity = te.intensity, ae.shadowBias = te.bias, ae.shadowNormalBias = te.normalBias, ae.shadowRadius = te.radius, ae.shadowMapSize = te.mapSize, ae.shadowCameraNear = te.camera.near, ae.shadowCameraFar = te.camera.far, a.pointShadow[z] = ae, a.pointShadowMap[z] = He, a.pointShadowMatrix[z] = re.shadow.matrix, q++;
        }
        a.point[z] = P, z++;
      } else if (re.isHemisphereLight) {
        const P = e.get(re);
        P.skyColor.copy(re.color).multiplyScalar(me), P.groundColor.copy(re.groundColor).multiplyScalar(me), a.hemi[N] = P, N++;
      }
    }
    G > 0 && (o.has("OES_texture_float_linear") === !0 ? (a.rectAreaLTC1 = An.LTC_FLOAT_1, a.rectAreaLTC2 = An.LTC_FLOAT_2) : (a.rectAreaLTC1 = An.LTC_HALF_1, a.rectAreaLTC2 = An.LTC_HALF_2)), a.ambient[0] = T, a.ambient[1] = C, a.ambient[2] = D;
    const ne = a.hash;
    (ne.directionalLength !== B || ne.pointLength !== z || ne.spotLength !== V || ne.rectAreaLength !== G || ne.hemiLength !== N || ne.numDirectionalShadows !== F || ne.numPointShadows !== q || ne.numSpotShadows !== Y || ne.numSpotMaps !== ie || ne.numLightProbes !== le) && (a.directional.length = B, a.spot.length = V, a.rectArea.length = G, a.point.length = z, a.hemi.length = N, a.directionalShadow.length = F, a.directionalShadowMap.length = F, a.pointShadow.length = q, a.pointShadowMap.length = q, a.spotShadow.length = Y, a.spotShadowMap.length = Y, a.directionalShadowMatrix.length = F, a.pointShadowMatrix.length = q, a.spotLightMatrix.length = Y + ie - k, a.spotLightMap.length = ie, a.numSpotLightShadowsWithMaps = k, a.numLightProbes = le, ne.directionalLength = B, ne.pointLength = z, ne.spotLength = V, ne.rectAreaLength = G, ne.hemiLength = N, ne.numDirectionalShadows = F, ne.numPointShadows = q, ne.numSpotShadows = Y, ne.numSpotMaps = ie, ne.numLightProbes = le, a.version = EG++);
  }
  function _(E, T) {
    let C = 0, D = 0, B = 0, z = 0, V = 0;
    const G = T.matrixWorldInverse;
    for (let N = 0, F = E.length; N < F; N++) {
      const q = E[N];
      if (q.isDirectionalLight) {
        const Y = a.directional[C];
        Y.direction.setFromMatrixPosition(q.matrixWorld), r.setFromMatrixPosition(q.target.matrixWorld), Y.direction.sub(r), Y.direction.transformDirection(G), C++;
      } else if (q.isSpotLight) {
        const Y = a.spot[B];
        Y.position.setFromMatrixPosition(q.matrixWorld), Y.position.applyMatrix4(G), Y.direction.setFromMatrixPosition(q.matrixWorld), r.setFromMatrixPosition(q.target.matrixWorld), Y.direction.sub(r), Y.direction.transformDirection(G), B++;
      } else if (q.isRectAreaLight) {
        const Y = a.rectArea[z];
        Y.position.setFromMatrixPosition(q.matrixWorld), Y.position.applyMatrix4(G), p.identity(), d.copy(q.matrixWorld), d.premultiply(G), p.extractRotation(d), Y.halfWidth.set(q.width * 0.5, 0, 0), Y.halfHeight.set(0, q.height * 0.5, 0), Y.halfWidth.applyMatrix4(p), Y.halfHeight.applyMatrix4(p), z++;
      } else if (q.isPointLight) {
        const Y = a.point[D];
        Y.position.setFromMatrixPosition(q.matrixWorld), Y.position.applyMatrix4(G), D++;
      } else if (q.isHemisphereLight) {
        const Y = a.hemi[V];
        Y.direction.setFromMatrixPosition(q.matrixWorld), Y.direction.transformDirection(G), V++;
      }
    }
  }
  return {
    setup: y,
    setupView: _,
    state: a
  };
}
function M3(o) {
  const e = new MG(o), t = [], a = [];
  function r(T) {
    E.camera = T, t.length = 0, a.length = 0;
  }
  function d(T) {
    t.push(T);
  }
  function p(T) {
    a.push(T);
  }
  function y() {
    e.setup(t);
  }
  function _(T) {
    e.setupView(t, T);
  }
  const E = {
    lightsArray: t,
    shadowsArray: a,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: r,
    state: E,
    setupLights: y,
    setupLightsView: _,
    pushLight: d,
    pushShadow: p
  };
}
function xG(o) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(r, d = 0) {
    const p = e.get(r);
    let y;
    return p === void 0 ? (y = new M3(o), e.set(r, [y])) : d >= p.length ? (y = new M3(o), p.push(y)) : y = p[d], y;
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: a
  };
}
const TG = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, CG = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function RG(o, e, t) {
  let a = new dE();
  const r = new Ot(), d = new Ot(), p = new Bi(), y = new wx({ depthPacking: iO }), _ = new I2(), E = {}, T = t.maxTextureSize, C = { [Zg]: ed, [ed]: Zg, [Lp]: Lp }, D = new iu({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Ot() },
      radius: { value: 4 }
    },
    vertexShader: TG,
    fragmentShader: CG
  }), B = D.clone();
  B.defines.HORIZONTAL_PASS = 1;
  const z = new Pa();
  z.setAttribute(
    "position",
    new Hi(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const V = new es(z, D), G = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = ax;
  let N = this.type;
  this.render = function(k, le, ne) {
    if (G.enabled === !1 || G.autoUpdate === !1 && G.needsUpdate === !1 || k.length === 0) return;
    const Q = o.getRenderTarget(), j = o.getActiveCubeFace(), re = o.getActiveMipmapLevel(), _e = o.state;
    _e.setBlending(jv), _e.buffers.color.setClear(1, 1, 1, 1), _e.buffers.depth.setTest(!0), _e.setScissorTest(!1);
    const me = N !== qv && this.type === qv, Ae = N === qv && this.type !== qv;
    for (let He = 0, P = k.length; He < P; He++) {
      const te = k[He], ae = te.shadow;
      if (ae === void 0) {
        console.warn("THREE.WebGLShadowMap:", te, "has no shadow.");
        continue;
      }
      if (ae.autoUpdate === !1 && ae.needsUpdate === !1) continue;
      r.copy(ae.mapSize);
      const Se = ae.getFrameExtents();
      if (r.multiply(Se), d.copy(ae.mapSize), (r.x > T || r.y > T) && (r.x > T && (d.x = Math.floor(T / Se.x), r.x = d.x * Se.x, ae.mapSize.x = d.x), r.y > T && (d.y = Math.floor(T / Se.y), r.y = d.y * Se.y, ae.mapSize.y = d.y)), ae.map === null || me === !0 || Ae === !0) {
        const we = this.type !== qv ? { minFilter: _c, magFilter: _c } : {};
        ae.map !== null && ae.map.dispose(), ae.map = new uf(r.x, r.y, we), ae.map.texture.name = te.name + ".shadowMap", ae.camera.updateProjectionMatrix();
      }
      o.setRenderTarget(ae.map), o.clear();
      const ue = ae.getViewportCount();
      for (let we = 0; we < ue; we++) {
        const De = ae.getViewport(we);
        p.set(
          d.x * De.x,
          d.y * De.y,
          d.x * De.z,
          d.y * De.w
        ), _e.viewport(p), ae.updateMatrices(te, we), a = ae.getFrustum(), Y(le, ne, ae.camera, te, this.type);
      }
      ae.isPointLightShadow !== !0 && this.type === qv && F(ae, ne), ae.needsUpdate = !1;
    }
    N = this.type, G.needsUpdate = !1, o.setRenderTarget(Q, j, re);
  };
  function F(k, le) {
    const ne = e.update(V);
    D.defines.VSM_SAMPLES !== k.blurSamples && (D.defines.VSM_SAMPLES = k.blurSamples, B.defines.VSM_SAMPLES = k.blurSamples, D.needsUpdate = !0, B.needsUpdate = !0), k.mapPass === null && (k.mapPass = new uf(r.x, r.y)), D.uniforms.shadow_pass.value = k.map.texture, D.uniforms.resolution.value = k.mapSize, D.uniforms.radius.value = k.radius, o.setRenderTarget(k.mapPass), o.clear(), o.renderBufferDirect(le, null, ne, D, V, null), B.uniforms.shadow_pass.value = k.mapPass.texture, B.uniforms.resolution.value = k.mapSize, B.uniforms.radius.value = k.radius, o.setRenderTarget(k.map), o.clear(), o.renderBufferDirect(le, null, ne, B, V, null);
  }
  function q(k, le, ne, Q) {
    let j = null;
    const re = ne.isPointLight === !0 ? k.customDistanceMaterial : k.customDepthMaterial;
    if (re !== void 0)
      j = re;
    else if (j = ne.isPointLight === !0 ? _ : y, o.localClippingEnabled && le.clipShadows === !0 && Array.isArray(le.clippingPlanes) && le.clippingPlanes.length !== 0 || le.displacementMap && le.displacementScale !== 0 || le.alphaMap && le.alphaTest > 0 || le.map && le.alphaTest > 0) {
      const _e = j.uuid, me = le.uuid;
      let Ae = E[_e];
      Ae === void 0 && (Ae = {}, E[_e] = Ae);
      let He = Ae[me];
      He === void 0 && (He = j.clone(), Ae[me] = He, le.addEventListener("dispose", ie)), j = He;
    }
    if (j.visible = le.visible, j.wireframe = le.wireframe, Q === qv ? j.side = le.shadowSide !== null ? le.shadowSide : le.side : j.side = le.shadowSide !== null ? le.shadowSide : C[le.side], j.alphaMap = le.alphaMap, j.alphaTest = le.alphaTest, j.map = le.map, j.clipShadows = le.clipShadows, j.clippingPlanes = le.clippingPlanes, j.clipIntersection = le.clipIntersection, j.displacementMap = le.displacementMap, j.displacementScale = le.displacementScale, j.displacementBias = le.displacementBias, j.wireframeLinewidth = le.wireframeLinewidth, j.linewidth = le.linewidth, ne.isPointLight === !0 && j.isMeshDistanceMaterial === !0) {
      const _e = o.properties.get(j);
      _e.light = ne;
    }
    return j;
  }
  function Y(k, le, ne, Q, j) {
    if (k.visible === !1) return;
    if (k.layers.test(le.layers) && (k.isMesh || k.isLine || k.isPoints) && (k.castShadow || k.receiveShadow && j === qv) && (!k.frustumCulled || a.intersectsObject(k))) {
      k.modelViewMatrix.multiplyMatrices(ne.matrixWorldInverse, k.matrixWorld);
      const me = e.update(k), Ae = k.material;
      if (Array.isArray(Ae)) {
        const He = me.groups;
        for (let P = 0, te = He.length; P < te; P++) {
          const ae = He[P], Se = Ae[ae.materialIndex];
          if (Se && Se.visible) {
            const ue = q(k, Se, Q, j);
            k.onBeforeShadow(o, k, le, ne, me, ue, ae), o.renderBufferDirect(ne, null, me, ue, k, ae), k.onAfterShadow(o, k, le, ne, me, ue, ae);
          }
        }
      } else if (Ae.visible) {
        const He = q(k, Ae, Q, j);
        k.onBeforeShadow(o, k, le, ne, me, He, null), o.renderBufferDirect(ne, null, me, He, k, null), k.onAfterShadow(o, k, le, ne, me, He, null);
      }
    }
    const _e = k.children;
    for (let me = 0, Ae = _e.length; me < Ae; me++)
      Y(_e[me], le, ne, Q, j);
  }
  function ie(k) {
    k.target.removeEventListener("dispose", ie);
    for (const ne in E) {
      const Q = E[ne], j = k.target.uuid;
      j in Q && (Q[j].dispose(), delete Q[j]);
    }
  }
}
const DG = {
  [hM]: pM,
  [mM]: yM,
  [vM]: SM,
  [KS]: gM,
  [pM]: hM,
  [yM]: mM,
  [SM]: vM,
  [gM]: KS
};
function BG(o, e) {
  function t() {
    let xe = !1;
    const Je = new Bi();
    let tt = null;
    const Ct = new Bi(0, 0, 0, 0);
    return {
      setMask: function($t) {
        tt !== $t && !xe && (o.colorMask($t, $t, $t, $t), tt = $t);
      },
      setLocked: function($t) {
        xe = $t;
      },
      setClear: function($t, tn, Mn, Wn, Xa) {
        Xa === !0 && ($t *= Wn, tn *= Wn, Mn *= Wn), Je.set($t, tn, Mn, Wn), Ct.equals(Je) === !1 && (o.clearColor($t, tn, Mn, Wn), Ct.copy(Je));
      },
      reset: function() {
        xe = !1, tt = null, Ct.set(-1, 0, 0, 0);
      }
    };
  }
  function a() {
    let xe = !1, Je = !1, tt = null, Ct = null, $t = null;
    return {
      setReversed: function(tn) {
        if (Je !== tn) {
          const Mn = e.get("EXT_clip_control");
          tn ? Mn.clipControlEXT(Mn.LOWER_LEFT_EXT, Mn.ZERO_TO_ONE_EXT) : Mn.clipControlEXT(Mn.LOWER_LEFT_EXT, Mn.NEGATIVE_ONE_TO_ONE_EXT), Je = tn;
          const Wn = $t;
          $t = null, this.setClear(Wn);
        }
      },
      getReversed: function() {
        return Je;
      },
      setTest: function(tn) {
        tn ? Vt(o.DEPTH_TEST) : Zt(o.DEPTH_TEST);
      },
      setMask: function(tn) {
        tt !== tn && !xe && (o.depthMask(tn), tt = tn);
      },
      setFunc: function(tn) {
        if (Je && (tn = DG[tn]), Ct !== tn) {
          switch (tn) {
            case hM:
              o.depthFunc(o.NEVER);
              break;
            case pM:
              o.depthFunc(o.ALWAYS);
              break;
            case mM:
              o.depthFunc(o.LESS);
              break;
            case KS:
              o.depthFunc(o.LEQUAL);
              break;
            case vM:
              o.depthFunc(o.EQUAL);
              break;
            case gM:
              o.depthFunc(o.GEQUAL);
              break;
            case yM:
              o.depthFunc(o.GREATER);
              break;
            case SM:
              o.depthFunc(o.NOTEQUAL);
              break;
            default:
              o.depthFunc(o.LEQUAL);
          }
          Ct = tn;
        }
      },
      setLocked: function(tn) {
        xe = tn;
      },
      setClear: function(tn) {
        $t !== tn && (Je && (tn = 1 - tn), o.clearDepth(tn), $t = tn);
      },
      reset: function() {
        xe = !1, tt = null, Ct = null, $t = null, Je = !1;
      }
    };
  }
  function r() {
    let xe = !1, Je = null, tt = null, Ct = null, $t = null, tn = null, Mn = null, Wn = null, Xa = null;
    return {
      setTest: function(sa) {
        xe || (sa ? Vt(o.STENCIL_TEST) : Zt(o.STENCIL_TEST));
      },
      setMask: function(sa) {
        Je !== sa && !xe && (o.stencilMask(sa), Je = sa);
      },
      setFunc: function(sa, ul, xa) {
        (tt !== sa || Ct !== ul || $t !== xa) && (o.stencilFunc(sa, ul, xa), tt = sa, Ct = ul, $t = xa);
      },
      setOp: function(sa, ul, xa) {
        (tn !== sa || Mn !== ul || Wn !== xa) && (o.stencilOp(sa, ul, xa), tn = sa, Mn = ul, Wn = xa);
      },
      setLocked: function(sa) {
        xe = sa;
      },
      setClear: function(sa) {
        Xa !== sa && (o.clearStencil(sa), Xa = sa);
      },
      reset: function() {
        xe = !1, Je = null, tt = null, Ct = null, $t = null, tn = null, Mn = null, Wn = null, Xa = null;
      }
    };
  }
  const d = new t(), p = new a(), y = new r(), _ = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap();
  let T = {}, C = {}, D = /* @__PURE__ */ new WeakMap(), B = [], z = null, V = !1, G = null, N = null, F = null, q = null, Y = null, ie = null, k = null, le = new hn(0, 0, 0), ne = 0, Q = !1, j = null, re = null, _e = null, me = null, Ae = null;
  const He = o.getParameter(o.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let P = !1, te = 0;
  const ae = o.getParameter(o.VERSION);
  ae.indexOf("WebGL") !== -1 ? (te = parseFloat(/^WebGL (\d)/.exec(ae)[1]), P = te >= 1) : ae.indexOf("OpenGL ES") !== -1 && (te = parseFloat(/^OpenGL ES (\d)/.exec(ae)[1]), P = te >= 2);
  let Se = null, ue = {};
  const we = o.getParameter(o.SCISSOR_BOX), De = o.getParameter(o.VIEWPORT), We = new Bi().fromArray(we), Me = new Bi().fromArray(De);
  function Ze(xe, Je, tt, Ct) {
    const $t = new Uint8Array(4), tn = o.createTexture();
    o.bindTexture(xe, tn), o.texParameteri(xe, o.TEXTURE_MIN_FILTER, o.NEAREST), o.texParameteri(xe, o.TEXTURE_MAG_FILTER, o.NEAREST);
    for (let Mn = 0; Mn < tt; Mn++)
      xe === o.TEXTURE_3D || xe === o.TEXTURE_2D_ARRAY ? o.texImage3D(Je, 0, o.RGBA, 1, 1, Ct, 0, o.RGBA, o.UNSIGNED_BYTE, $t) : o.texImage2D(Je + Mn, 0, o.RGBA, 1, 1, 0, o.RGBA, o.UNSIGNED_BYTE, $t);
    return tn;
  }
  const ct = {};
  ct[o.TEXTURE_2D] = Ze(o.TEXTURE_2D, o.TEXTURE_2D, 1), ct[o.TEXTURE_CUBE_MAP] = Ze(o.TEXTURE_CUBE_MAP, o.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ct[o.TEXTURE_2D_ARRAY] = Ze(o.TEXTURE_2D_ARRAY, o.TEXTURE_2D_ARRAY, 1, 1), ct[o.TEXTURE_3D] = Ze(o.TEXTURE_3D, o.TEXTURE_3D, 1, 1), d.setClear(0, 0, 0, 1), p.setClear(1), y.setClear(0), Vt(o.DEPTH_TEST), p.setFunc(KS), Tt(!1), St(FC), Vt(o.CULL_FACE), Te(jv);
  function Vt(xe) {
    T[xe] !== !0 && (o.enable(xe), T[xe] = !0);
  }
  function Zt(xe) {
    T[xe] !== !1 && (o.disable(xe), T[xe] = !1);
  }
  function Bn(xe, Je) {
    return C[xe] !== Je ? (o.bindFramebuffer(xe, Je), C[xe] = Je, xe === o.DRAW_FRAMEBUFFER && (C[o.FRAMEBUFFER] = Je), xe === o.FRAMEBUFFER && (C[o.DRAW_FRAMEBUFFER] = Je), !0) : !1;
  }
  function rn(xe, Je) {
    let tt = B, Ct = !1;
    if (xe) {
      tt = D.get(Je), tt === void 0 && (tt = [], D.set(Je, tt));
      const $t = xe.textures;
      if (tt.length !== $t.length || tt[0] !== o.COLOR_ATTACHMENT0) {
        for (let tn = 0, Mn = $t.length; tn < Mn; tn++)
          tt[tn] = o.COLOR_ATTACHMENT0 + tn;
        tt.length = $t.length, Ct = !0;
      }
    } else
      tt[0] !== o.BACK && (tt[0] = o.BACK, Ct = !0);
    Ct && o.drawBuffers(tt);
  }
  function dn(xe) {
    return z !== xe ? (o.useProgram(xe), z = xe, !0) : !1;
  }
  const Zn = {
    [I0]: o.FUNC_ADD,
    [CU]: o.FUNC_SUBTRACT,
    [RU]: o.FUNC_REVERSE_SUBTRACT
  };
  Zn[DU] = o.MIN, Zn[BU] = o.MAX;
  const Rn = {
    [UU]: o.ZERO,
    [OU]: o.ONE,
    [wU]: o.SRC_COLOR,
    [fM]: o.SRC_ALPHA,
    [IU]: o.SRC_ALPHA_SATURATE,
    [LU]: o.DST_COLOR,
    [zU]: o.DST_ALPHA,
    [NU]: o.ONE_MINUS_SRC_COLOR,
    [dM]: o.ONE_MINUS_SRC_ALPHA,
    [GU]: o.ONE_MINUS_DST_COLOR,
    [HU]: o.ONE_MINUS_DST_ALPHA,
    [VU]: o.CONSTANT_COLOR,
    [FU]: o.ONE_MINUS_CONSTANT_COLOR,
    [PU]: o.CONSTANT_ALPHA,
    [XU]: o.ONE_MINUS_CONSTANT_ALPHA
  };
  function Te(xe, Je, tt, Ct, $t, tn, Mn, Wn, Xa, sa) {
    if (xe === jv) {
      V === !0 && (Zt(o.BLEND), V = !1);
      return;
    }
    if (V === !1 && (Vt(o.BLEND), V = !0), xe !== TU) {
      if (xe !== G || sa !== Q) {
        if ((N !== I0 || Y !== I0) && (o.blendEquation(o.FUNC_ADD), N = I0, Y = I0), sa)
          switch (xe) {
            case QS:
              o.blendFuncSeparate(o.ONE, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA);
              break;
            case cM:
              o.blendFunc(o.ONE, o.ONE);
              break;
            case PC:
              o.blendFuncSeparate(o.ZERO, o.ONE_MINUS_SRC_COLOR, o.ZERO, o.ONE);
              break;
            case XC:
              o.blendFuncSeparate(o.ZERO, o.SRC_COLOR, o.ZERO, o.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", xe);
              break;
          }
        else
          switch (xe) {
            case QS:
              o.blendFuncSeparate(o.SRC_ALPHA, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA);
              break;
            case cM:
              o.blendFunc(o.SRC_ALPHA, o.ONE);
              break;
            case PC:
              o.blendFuncSeparate(o.ZERO, o.ONE_MINUS_SRC_COLOR, o.ZERO, o.ONE);
              break;
            case XC:
              o.blendFunc(o.ZERO, o.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", xe);
              break;
          }
        F = null, q = null, ie = null, k = null, le.set(0, 0, 0), ne = 0, G = xe, Q = sa;
      }
      return;
    }
    $t = $t || Je, tn = tn || tt, Mn = Mn || Ct, (Je !== N || $t !== Y) && (o.blendEquationSeparate(Zn[Je], Zn[$t]), N = Je, Y = $t), (tt !== F || Ct !== q || tn !== ie || Mn !== k) && (o.blendFuncSeparate(Rn[tt], Rn[Ct], Rn[tn], Rn[Mn]), F = tt, q = Ct, ie = tn, k = Mn), (Wn.equals(le) === !1 || Xa !== ne) && (o.blendColor(Wn.r, Wn.g, Wn.b, Xa), le.copy(Wn), ne = Xa), G = xe, Q = !1;
  }
  function Ha(xe, Je) {
    xe.side === Lp ? Zt(o.CULL_FACE) : Vt(o.CULL_FACE);
    let tt = xe.side === ed;
    Je && (tt = !tt), Tt(tt), xe.blending === QS && xe.transparent === !1 ? Te(jv) : Te(xe.blending, xe.blendEquation, xe.blendSrc, xe.blendDst, xe.blendEquationAlpha, xe.blendSrcAlpha, xe.blendDstAlpha, xe.blendColor, xe.blendAlpha, xe.premultipliedAlpha), p.setFunc(xe.depthFunc), p.setTest(xe.depthTest), p.setMask(xe.depthWrite), d.setMask(xe.colorWrite);
    const Ct = xe.stencilWrite;
    y.setTest(Ct), Ct && (y.setMask(xe.stencilWriteMask), y.setFunc(xe.stencilFunc, xe.stencilRef, xe.stencilFuncMask), y.setOp(xe.stencilFail, xe.stencilZFail, xe.stencilZPass)), kt(xe.polygonOffset, xe.polygonOffsetFactor, xe.polygonOffsetUnits), xe.alphaToCoverage === !0 ? Vt(o.SAMPLE_ALPHA_TO_COVERAGE) : Zt(o.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Tt(xe) {
    j !== xe && (xe ? o.frontFace(o.CW) : o.frontFace(o.CCW), j = xe);
  }
  function St(xe) {
    xe !== bU ? (Vt(o.CULL_FACE), xe !== re && (xe === FC ? o.cullFace(o.BACK) : xe === MU ? o.cullFace(o.FRONT) : o.cullFace(o.FRONT_AND_BACK))) : Zt(o.CULL_FACE), re = xe;
  }
  function Mt(xe) {
    xe !== _e && (P && o.lineWidth(xe), _e = xe);
  }
  function kt(xe, Je, tt) {
    xe ? (Vt(o.POLYGON_OFFSET_FILL), (me !== Je || Ae !== tt) && (o.polygonOffset(Je, tt), me = Je, Ae = tt)) : Zt(o.POLYGON_OFFSET_FILL);
  }
  function At(xe) {
    xe ? Vt(o.SCISSOR_TEST) : Zt(o.SCISSOR_TEST);
  }
  function ce(xe) {
    xe === void 0 && (xe = o.TEXTURE0 + He - 1), Se !== xe && (o.activeTexture(xe), Se = xe);
  }
  function se(xe, Je, tt) {
    tt === void 0 && (Se === null ? tt = o.TEXTURE0 + He - 1 : tt = Se);
    let Ct = ue[tt];
    Ct === void 0 && (Ct = { type: void 0, texture: void 0 }, ue[tt] = Ct), (Ct.type !== xe || Ct.texture !== Je) && (Se !== tt && (o.activeTexture(tt), Se = tt), o.bindTexture(xe, Je || ct[xe]), Ct.type = xe, Ct.texture = Je);
  }
  function Xe() {
    const xe = ue[Se];
    xe !== void 0 && xe.type !== void 0 && (o.bindTexture(xe.type, null), xe.type = void 0, xe.texture = void 0);
  }
  function dt() {
    try {
      o.compressedTexImage2D(...arguments);
    } catch (xe) {
      console.error("THREE.WebGLState:", xe);
    }
  }
  function Et() {
    try {
      o.compressedTexImage3D(...arguments);
    } catch (xe) {
      console.error("THREE.WebGLState:", xe);
    }
  }
  function yt() {
    try {
      o.texSubImage2D(...arguments);
    } catch (xe) {
      console.error("THREE.WebGLState:", xe);
    }
  }
  function Jt() {
    try {
      o.texSubImage3D(...arguments);
    } catch (xe) {
      console.error("THREE.WebGLState:", xe);
    }
  }
  function Xt() {
    try {
      o.compressedTexSubImage2D(...arguments);
    } catch (xe) {
      console.error("THREE.WebGLState:", xe);
    }
  }
  function Wt() {
    try {
      o.compressedTexSubImage3D(...arguments);
    } catch (xe) {
      console.error("THREE.WebGLState:", xe);
    }
  }
  function Vn() {
    try {
      o.texStorage2D(...arguments);
    } catch (xe) {
      console.error("THREE.WebGLState:", xe);
    }
  }
  function Pt() {
    try {
      o.texStorage3D(...arguments);
    } catch (xe) {
      console.error("THREE.WebGLState:", xe);
    }
  }
  function pn() {
    try {
      o.texImage2D(...arguments);
    } catch (xe) {
      console.error("THREE.WebGLState:", xe);
    }
  }
  function gn() {
    try {
      o.texImage3D(...arguments);
    } catch (xe) {
      console.error("THREE.WebGLState:", xe);
    }
  }
  function nn(xe) {
    We.equals(xe) === !1 && (o.scissor(xe.x, xe.y, xe.z, xe.w), We.copy(xe));
  }
  function jt(xe) {
    Me.equals(xe) === !1 && (o.viewport(xe.x, xe.y, xe.z, xe.w), Me.copy(xe));
  }
  function Ue(xe, Je) {
    let tt = E.get(Je);
    tt === void 0 && (tt = /* @__PURE__ */ new WeakMap(), E.set(Je, tt));
    let Ct = tt.get(xe);
    Ct === void 0 && (Ct = o.getUniformBlockIndex(Je, xe.name), tt.set(xe, Ct));
  }
  function ot(xe, Je) {
    const Ct = E.get(Je).get(xe);
    _.get(Je) !== Ct && (o.uniformBlockBinding(Je, Ct, xe.__bindingPointIndex), _.set(Je, Ct));
  }
  function Ht() {
    o.disable(o.BLEND), o.disable(o.CULL_FACE), o.disable(o.DEPTH_TEST), o.disable(o.POLYGON_OFFSET_FILL), o.disable(o.SCISSOR_TEST), o.disable(o.STENCIL_TEST), o.disable(o.SAMPLE_ALPHA_TO_COVERAGE), o.blendEquation(o.FUNC_ADD), o.blendFunc(o.ONE, o.ZERO), o.blendFuncSeparate(o.ONE, o.ZERO, o.ONE, o.ZERO), o.blendColor(0, 0, 0, 0), o.colorMask(!0, !0, !0, !0), o.clearColor(0, 0, 0, 0), o.depthMask(!0), o.depthFunc(o.LESS), p.setReversed(!1), o.clearDepth(1), o.stencilMask(4294967295), o.stencilFunc(o.ALWAYS, 0, 4294967295), o.stencilOp(o.KEEP, o.KEEP, o.KEEP), o.clearStencil(0), o.cullFace(o.BACK), o.frontFace(o.CCW), o.polygonOffset(0, 0), o.activeTexture(o.TEXTURE0), o.bindFramebuffer(o.FRAMEBUFFER, null), o.bindFramebuffer(o.DRAW_FRAMEBUFFER, null), o.bindFramebuffer(o.READ_FRAMEBUFFER, null), o.useProgram(null), o.lineWidth(1), o.scissor(0, 0, o.canvas.width, o.canvas.height), o.viewport(0, 0, o.canvas.width, o.canvas.height), T = {}, Se = null, ue = {}, C = {}, D = /* @__PURE__ */ new WeakMap(), B = [], z = null, V = !1, G = null, N = null, F = null, q = null, Y = null, ie = null, k = null, le = new hn(0, 0, 0), ne = 0, Q = !1, j = null, re = null, _e = null, me = null, Ae = null, We.set(0, 0, o.canvas.width, o.canvas.height), Me.set(0, 0, o.canvas.width, o.canvas.height), d.reset(), p.reset(), y.reset();
  }
  return {
    buffers: {
      color: d,
      depth: p,
      stencil: y
    },
    enable: Vt,
    disable: Zt,
    bindFramebuffer: Bn,
    drawBuffers: rn,
    useProgram: dn,
    setBlending: Te,
    setMaterial: Ha,
    setFlipSided: Tt,
    setCullFace: St,
    setLineWidth: Mt,
    setPolygonOffset: kt,
    setScissorTest: At,
    activeTexture: ce,
    bindTexture: se,
    unbindTexture: Xe,
    compressedTexImage2D: dt,
    compressedTexImage3D: Et,
    texImage2D: pn,
    texImage3D: gn,
    updateUBOMapping: Ue,
    uniformBlockBinding: ot,
    texStorage2D: Vn,
    texStorage3D: Pt,
    texSubImage2D: yt,
    texSubImage3D: Jt,
    compressedTexSubImage2D: Xt,
    compressedTexSubImage3D: Wt,
    scissor: nn,
    viewport: jt,
    reset: Ht
  };
}
function UG(o, e, t, a, r, d, p) {
  const y = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, _ = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), E = new Ot(), T = /* @__PURE__ */ new WeakMap();
  let C;
  const D = /* @__PURE__ */ new WeakMap();
  let B = !1;
  try {
    B = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function z(ce, se) {
    return B ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(ce, se)
    ) : JA("canvas");
  }
  function V(ce, se, Xe) {
    let dt = 1;
    const Et = At(ce);
    if ((Et.width > Xe || Et.height > Xe) && (dt = Xe / Math.max(Et.width, Et.height)), dt < 1)
      if (typeof HTMLImageElement < "u" && ce instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && ce instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && ce instanceof ImageBitmap || typeof VideoFrame < "u" && ce instanceof VideoFrame) {
        const yt = Math.floor(dt * Et.width), Jt = Math.floor(dt * Et.height);
        C === void 0 && (C = z(yt, Jt));
        const Xt = se ? z(yt, Jt) : C;
        return Xt.width = yt, Xt.height = Jt, Xt.getContext("2d").drawImage(ce, 0, 0, yt, Jt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Et.width + "x" + Et.height + ") to (" + yt + "x" + Jt + ")."), Xt;
      } else
        return "data" in ce && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Et.width + "x" + Et.height + ")."), ce;
    return ce;
  }
  function G(ce) {
    return ce.generateMipmaps;
  }
  function N(ce) {
    o.generateMipmap(ce);
  }
  function F(ce) {
    return ce.isWebGLCubeRenderTarget ? o.TEXTURE_CUBE_MAP : ce.isWebGL3DRenderTarget ? o.TEXTURE_3D : ce.isWebGLArrayRenderTarget || ce.isCompressedArrayTexture ? o.TEXTURE_2D_ARRAY : o.TEXTURE_2D;
  }
  function q(ce, se, Xe, dt, Et = !1) {
    if (ce !== null) {
      if (o[ce] !== void 0) return o[ce];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + ce + "'");
    }
    let yt = se;
    if (se === o.RED && (Xe === o.FLOAT && (yt = o.R32F), Xe === o.HALF_FLOAT && (yt = o.R16F), Xe === o.UNSIGNED_BYTE && (yt = o.R8)), se === o.RED_INTEGER && (Xe === o.UNSIGNED_BYTE && (yt = o.R8UI), Xe === o.UNSIGNED_SHORT && (yt = o.R16UI), Xe === o.UNSIGNED_INT && (yt = o.R32UI), Xe === o.BYTE && (yt = o.R8I), Xe === o.SHORT && (yt = o.R16I), Xe === o.INT && (yt = o.R32I)), se === o.RG && (Xe === o.FLOAT && (yt = o.RG32F), Xe === o.HALF_FLOAT && (yt = o.RG16F), Xe === o.UNSIGNED_BYTE && (yt = o.RG8)), se === o.RG_INTEGER && (Xe === o.UNSIGNED_BYTE && (yt = o.RG8UI), Xe === o.UNSIGNED_SHORT && (yt = o.RG16UI), Xe === o.UNSIGNED_INT && (yt = o.RG32UI), Xe === o.BYTE && (yt = o.RG8I), Xe === o.SHORT && (yt = o.RG16I), Xe === o.INT && (yt = o.RG32I)), se === o.RGB_INTEGER && (Xe === o.UNSIGNED_BYTE && (yt = o.RGB8UI), Xe === o.UNSIGNED_SHORT && (yt = o.RGB16UI), Xe === o.UNSIGNED_INT && (yt = o.RGB32UI), Xe === o.BYTE && (yt = o.RGB8I), Xe === o.SHORT && (yt = o.RGB16I), Xe === o.INT && (yt = o.RGB32I)), se === o.RGBA_INTEGER && (Xe === o.UNSIGNED_BYTE && (yt = o.RGBA8UI), Xe === o.UNSIGNED_SHORT && (yt = o.RGBA16UI), Xe === o.UNSIGNED_INT && (yt = o.RGBA32UI), Xe === o.BYTE && (yt = o.RGBA8I), Xe === o.SHORT && (yt = o.RGBA16I), Xe === o.INT && (yt = o.RGBA32I)), se === o.RGB && Xe === o.UNSIGNED_INT_5_9_9_9_REV && (yt = o.RGB9_E5), se === o.RGBA) {
      const Jt = Et ? ZA : wi.getTransfer(dt);
      Xe === o.FLOAT && (yt = o.RGBA32F), Xe === o.HALF_FLOAT && (yt = o.RGBA16F), Xe === o.UNSIGNED_BYTE && (yt = Jt === Nl ? o.SRGB8_ALPHA8 : o.RGBA8), Xe === o.UNSIGNED_SHORT_4_4_4_4 && (yt = o.RGBA4), Xe === o.UNSIGNED_SHORT_5_5_5_1 && (yt = o.RGB5_A1);
    }
    return (yt === o.R16F || yt === o.R32F || yt === o.RG16F || yt === o.RG32F || yt === o.RGBA16F || yt === o.RGBA32F) && e.get("EXT_color_buffer_float"), yt;
  }
  function Y(ce, se) {
    let Xe;
    return ce ? se === null || se === jg || se === v1 ? Xe = o.DEPTH24_STENCIL8 : se === pr ? Xe = o.DEPTH32F_STENCIL8 : se === kS && (Xe = o.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : se === null || se === jg || se === v1 ? Xe = o.DEPTH_COMPONENT24 : se === pr ? Xe = o.DEPTH_COMPONENT32F : se === kS && (Xe = o.DEPTH_COMPONENT16), Xe;
  }
  function ie(ce, se) {
    return G(ce) === !0 || ce.isFramebufferTexture && ce.minFilter !== _c && ce.minFilter !== Ni ? Math.log2(Math.max(se.width, se.height)) + 1 : ce.mipmaps !== void 0 && ce.mipmaps.length > 0 ? ce.mipmaps.length : ce.isCompressedTexture && Array.isArray(ce.image) ? se.mipmaps.length : 1;
  }
  function k(ce) {
    const se = ce.target;
    se.removeEventListener("dispose", k), ne(se), se.isVideoTexture && T.delete(se);
  }
  function le(ce) {
    const se = ce.target;
    se.removeEventListener("dispose", le), j(se);
  }
  function ne(ce) {
    const se = a.get(ce);
    if (se.__webglInit === void 0) return;
    const Xe = ce.source, dt = D.get(Xe);
    if (dt) {
      const Et = dt[se.__cacheKey];
      Et.usedTimes--, Et.usedTimes === 0 && Q(ce), Object.keys(dt).length === 0 && D.delete(Xe);
    }
    a.remove(ce);
  }
  function Q(ce) {
    const se = a.get(ce);
    o.deleteTexture(se.__webglTexture);
    const Xe = ce.source, dt = D.get(Xe);
    delete dt[se.__cacheKey], p.memory.textures--;
  }
  function j(ce) {
    const se = a.get(ce);
    if (ce.depthTexture && (ce.depthTexture.dispose(), a.remove(ce.depthTexture)), ce.isWebGLCubeRenderTarget)
      for (let dt = 0; dt < 6; dt++) {
        if (Array.isArray(se.__webglFramebuffer[dt]))
          for (let Et = 0; Et < se.__webglFramebuffer[dt].length; Et++) o.deleteFramebuffer(se.__webglFramebuffer[dt][Et]);
        else
          o.deleteFramebuffer(se.__webglFramebuffer[dt]);
        se.__webglDepthbuffer && o.deleteRenderbuffer(se.__webglDepthbuffer[dt]);
      }
    else {
      if (Array.isArray(se.__webglFramebuffer))
        for (let dt = 0; dt < se.__webglFramebuffer.length; dt++) o.deleteFramebuffer(se.__webglFramebuffer[dt]);
      else
        o.deleteFramebuffer(se.__webglFramebuffer);
      if (se.__webglDepthbuffer && o.deleteRenderbuffer(se.__webglDepthbuffer), se.__webglMultisampledFramebuffer && o.deleteFramebuffer(se.__webglMultisampledFramebuffer), se.__webglColorRenderbuffer)
        for (let dt = 0; dt < se.__webglColorRenderbuffer.length; dt++)
          se.__webglColorRenderbuffer[dt] && o.deleteRenderbuffer(se.__webglColorRenderbuffer[dt]);
      se.__webglDepthRenderbuffer && o.deleteRenderbuffer(se.__webglDepthRenderbuffer);
    }
    const Xe = ce.textures;
    for (let dt = 0, Et = Xe.length; dt < Et; dt++) {
      const yt = a.get(Xe[dt]);
      yt.__webglTexture && (o.deleteTexture(yt.__webglTexture), p.memory.textures--), a.remove(Xe[dt]);
    }
    a.remove(ce);
  }
  let re = 0;
  function _e() {
    re = 0;
  }
  function me() {
    const ce = re;
    return ce >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + ce + " texture units while this GPU supports only " + r.maxTextures), re += 1, ce;
  }
  function Ae(ce) {
    const se = [];
    return se.push(ce.wrapS), se.push(ce.wrapT), se.push(ce.wrapR || 0), se.push(ce.magFilter), se.push(ce.minFilter), se.push(ce.anisotropy), se.push(ce.internalFormat), se.push(ce.format), se.push(ce.type), se.push(ce.generateMipmaps), se.push(ce.premultiplyAlpha), se.push(ce.flipY), se.push(ce.unpackAlignment), se.push(ce.colorSpace), se.join();
  }
  function He(ce, se) {
    const Xe = a.get(ce);
    if (ce.isVideoTexture && Mt(ce), ce.isRenderTargetTexture === !1 && ce.version > 0 && Xe.__version !== ce.version) {
      const dt = ce.image;
      if (dt === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (dt.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        Me(Xe, ce, se);
        return;
      }
    }
    t.bindTexture(o.TEXTURE_2D, Xe.__webglTexture, o.TEXTURE0 + se);
  }
  function P(ce, se) {
    const Xe = a.get(ce);
    if (ce.version > 0 && Xe.__version !== ce.version) {
      Me(Xe, ce, se);
      return;
    }
    t.bindTexture(o.TEXTURE_2D_ARRAY, Xe.__webglTexture, o.TEXTURE0 + se);
  }
  function te(ce, se) {
    const Xe = a.get(ce);
    if (ce.version > 0 && Xe.__version !== ce.version) {
      Me(Xe, ce, se);
      return;
    }
    t.bindTexture(o.TEXTURE_3D, Xe.__webglTexture, o.TEXTURE0 + se);
  }
  function ae(ce, se) {
    const Xe = a.get(ce);
    if (ce.version > 0 && Xe.__version !== ce.version) {
      Ze(Xe, ce, se);
      return;
    }
    t.bindTexture(o.TEXTURE_CUBE_MAP, Xe.__webglTexture, o.TEXTURE0 + se);
  }
  const Se = {
    [q0]: o.REPEAT,
    [Mo]: o.CLAMP_TO_EDGE,
    [m1]: o.MIRRORED_REPEAT
  }, ue = {
    [_c]: o.NEAREST,
    [ix]: o.NEAREST_MIPMAP_NEAREST,
    [VS]: o.NEAREST_MIPMAP_LINEAR,
    [Ni]: o.LINEAR,
    [c1]: o.LINEAR_MIPMAP_NEAREST,
    [qm]: o.LINEAR_MIPMAP_LINEAR
  }, we = {
    [sO]: o.NEVER,
    [dO]: o.ALWAYS,
    [rO]: o.LESS,
    [E2]: o.LEQUAL,
    [oO]: o.EQUAL,
    [fO]: o.GEQUAL,
    [uO]: o.GREATER,
    [cO]: o.NOTEQUAL
  };
  function De(ce, se) {
    if (se.type === pr && e.has("OES_texture_float_linear") === !1 && (se.magFilter === Ni || se.magFilter === c1 || se.magFilter === VS || se.magFilter === qm || se.minFilter === Ni || se.minFilter === c1 || se.minFilter === VS || se.minFilter === qm) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), o.texParameteri(ce, o.TEXTURE_WRAP_S, Se[se.wrapS]), o.texParameteri(ce, o.TEXTURE_WRAP_T, Se[se.wrapT]), (ce === o.TEXTURE_3D || ce === o.TEXTURE_2D_ARRAY) && o.texParameteri(ce, o.TEXTURE_WRAP_R, Se[se.wrapR]), o.texParameteri(ce, o.TEXTURE_MAG_FILTER, ue[se.magFilter]), o.texParameteri(ce, o.TEXTURE_MIN_FILTER, ue[se.minFilter]), se.compareFunction && (o.texParameteri(ce, o.TEXTURE_COMPARE_MODE, o.COMPARE_REF_TO_TEXTURE), o.texParameteri(ce, o.TEXTURE_COMPARE_FUNC, we[se.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (se.magFilter === _c || se.minFilter !== VS && se.minFilter !== qm || se.type === pr && e.has("OES_texture_float_linear") === !1) return;
      if (se.anisotropy > 1 || a.get(se).__currentAnisotropy) {
        const Xe = e.get("EXT_texture_filter_anisotropic");
        o.texParameterf(ce, Xe.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(se.anisotropy, r.getMaxAnisotropy())), a.get(se).__currentAnisotropy = se.anisotropy;
      }
    }
  }
  function We(ce, se) {
    let Xe = !1;
    ce.__webglInit === void 0 && (ce.__webglInit = !0, se.addEventListener("dispose", k));
    const dt = se.source;
    let Et = D.get(dt);
    Et === void 0 && (Et = {}, D.set(dt, Et));
    const yt = Ae(se);
    if (yt !== ce.__cacheKey) {
      Et[yt] === void 0 && (Et[yt] = {
        texture: o.createTexture(),
        usedTimes: 0
      }, p.memory.textures++, Xe = !0), Et[yt].usedTimes++;
      const Jt = Et[ce.__cacheKey];
      Jt !== void 0 && (Et[ce.__cacheKey].usedTimes--, Jt.usedTimes === 0 && Q(se)), ce.__cacheKey = yt, ce.__webglTexture = Et[yt].texture;
    }
    return Xe;
  }
  function Me(ce, se, Xe) {
    let dt = o.TEXTURE_2D;
    (se.isDataArrayTexture || se.isCompressedArrayTexture) && (dt = o.TEXTURE_2D_ARRAY), se.isData3DTexture && (dt = o.TEXTURE_3D);
    const Et = We(ce, se), yt = se.source;
    t.bindTexture(dt, ce.__webglTexture, o.TEXTURE0 + Xe);
    const Jt = a.get(yt);
    if (yt.version !== Jt.__version || Et === !0) {
      t.activeTexture(o.TEXTURE0 + Xe);
      const Xt = wi.getPrimaries(wi.workingColorSpace), Wt = se.colorSpace === Fy ? null : wi.getPrimaries(se.colorSpace), Vn = se.colorSpace === Fy || Xt === Wt ? o.NONE : o.BROWSER_DEFAULT_WEBGL;
      o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, se.flipY), o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, se.premultiplyAlpha), o.pixelStorei(o.UNPACK_ALIGNMENT, se.unpackAlignment), o.pixelStorei(o.UNPACK_COLORSPACE_CONVERSION_WEBGL, Vn);
      let Pt = V(se.image, !1, r.maxTextureSize);
      Pt = kt(se, Pt);
      const pn = d.convert(se.format, se.colorSpace), gn = d.convert(se.type);
      let nn = q(se.internalFormat, pn, gn, se.colorSpace, se.isVideoTexture);
      De(dt, se);
      let jt;
      const Ue = se.mipmaps, ot = se.isVideoTexture !== !0, Ht = Jt.__version === void 0 || Et === !0, xe = yt.dataReady, Je = ie(se, Pt);
      if (se.isDepthTexture)
        nn = Y(se.format === g1, se.type), Ht && (ot ? t.texStorage2D(o.TEXTURE_2D, 1, nn, Pt.width, Pt.height) : t.texImage2D(o.TEXTURE_2D, 0, nn, Pt.width, Pt.height, 0, pn, gn, null));
      else if (se.isDataTexture)
        if (Ue.length > 0) {
          ot && Ht && t.texStorage2D(o.TEXTURE_2D, Je, nn, Ue[0].width, Ue[0].height);
          for (let tt = 0, Ct = Ue.length; tt < Ct; tt++)
            jt = Ue[tt], ot ? xe && t.texSubImage2D(o.TEXTURE_2D, tt, 0, 0, jt.width, jt.height, pn, gn, jt.data) : t.texImage2D(o.TEXTURE_2D, tt, nn, jt.width, jt.height, 0, pn, gn, jt.data);
          se.generateMipmaps = !1;
        } else
          ot ? (Ht && t.texStorage2D(o.TEXTURE_2D, Je, nn, Pt.width, Pt.height), xe && t.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, Pt.width, Pt.height, pn, gn, Pt.data)) : t.texImage2D(o.TEXTURE_2D, 0, nn, Pt.width, Pt.height, 0, pn, gn, Pt.data);
      else if (se.isCompressedTexture)
        if (se.isCompressedArrayTexture) {
          ot && Ht && t.texStorage3D(o.TEXTURE_2D_ARRAY, Je, nn, Ue[0].width, Ue[0].height, Pt.depth);
          for (let tt = 0, Ct = Ue.length; tt < Ct; tt++)
            if (jt = Ue[tt], se.format !== xo)
              if (pn !== null)
                if (ot) {
                  if (xe)
                    if (se.layerUpdates.size > 0) {
                      const $t = $C(jt.width, jt.height, se.format, se.type);
                      for (const tn of se.layerUpdates) {
                        const Mn = jt.data.subarray(
                          tn * $t / jt.data.BYTES_PER_ELEMENT,
                          (tn + 1) * $t / jt.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(o.TEXTURE_2D_ARRAY, tt, 0, 0, tn, jt.width, jt.height, 1, pn, Mn);
                      }
                      se.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(o.TEXTURE_2D_ARRAY, tt, 0, 0, 0, jt.width, jt.height, Pt.depth, pn, jt.data);
                } else
                  t.compressedTexImage3D(o.TEXTURE_2D_ARRAY, tt, nn, jt.width, jt.height, Pt.depth, 0, jt.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              ot ? xe && t.texSubImage3D(o.TEXTURE_2D_ARRAY, tt, 0, 0, 0, jt.width, jt.height, Pt.depth, pn, gn, jt.data) : t.texImage3D(o.TEXTURE_2D_ARRAY, tt, nn, jt.width, jt.height, Pt.depth, 0, pn, gn, jt.data);
        } else {
          ot && Ht && t.texStorage2D(o.TEXTURE_2D, Je, nn, Ue[0].width, Ue[0].height);
          for (let tt = 0, Ct = Ue.length; tt < Ct; tt++)
            jt = Ue[tt], se.format !== xo ? pn !== null ? ot ? xe && t.compressedTexSubImage2D(o.TEXTURE_2D, tt, 0, 0, jt.width, jt.height, pn, jt.data) : t.compressedTexImage2D(o.TEXTURE_2D, tt, nn, jt.width, jt.height, 0, jt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ot ? xe && t.texSubImage2D(o.TEXTURE_2D, tt, 0, 0, jt.width, jt.height, pn, gn, jt.data) : t.texImage2D(o.TEXTURE_2D, tt, nn, jt.width, jt.height, 0, pn, gn, jt.data);
        }
      else if (se.isDataArrayTexture)
        if (ot) {
          if (Ht && t.texStorage3D(o.TEXTURE_2D_ARRAY, Je, nn, Pt.width, Pt.height, Pt.depth), xe)
            if (se.layerUpdates.size > 0) {
              const tt = $C(Pt.width, Pt.height, se.format, se.type);
              for (const Ct of se.layerUpdates) {
                const $t = Pt.data.subarray(
                  Ct * tt / Pt.data.BYTES_PER_ELEMENT,
                  (Ct + 1) * tt / Pt.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(o.TEXTURE_2D_ARRAY, 0, 0, 0, Ct, Pt.width, Pt.height, 1, pn, gn, $t);
              }
              se.clearLayerUpdates();
            } else
              t.texSubImage3D(o.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Pt.width, Pt.height, Pt.depth, pn, gn, Pt.data);
        } else
          t.texImage3D(o.TEXTURE_2D_ARRAY, 0, nn, Pt.width, Pt.height, Pt.depth, 0, pn, gn, Pt.data);
      else if (se.isData3DTexture)
        ot ? (Ht && t.texStorage3D(o.TEXTURE_3D, Je, nn, Pt.width, Pt.height, Pt.depth), xe && t.texSubImage3D(o.TEXTURE_3D, 0, 0, 0, 0, Pt.width, Pt.height, Pt.depth, pn, gn, Pt.data)) : t.texImage3D(o.TEXTURE_3D, 0, nn, Pt.width, Pt.height, Pt.depth, 0, pn, gn, Pt.data);
      else if (se.isFramebufferTexture) {
        if (Ht)
          if (ot)
            t.texStorage2D(o.TEXTURE_2D, Je, nn, Pt.width, Pt.height);
          else {
            let tt = Pt.width, Ct = Pt.height;
            for (let $t = 0; $t < Je; $t++)
              t.texImage2D(o.TEXTURE_2D, $t, nn, tt, Ct, 0, pn, gn, null), tt >>= 1, Ct >>= 1;
          }
      } else if (Ue.length > 0) {
        if (ot && Ht) {
          const tt = At(Ue[0]);
          t.texStorage2D(o.TEXTURE_2D, Je, nn, tt.width, tt.height);
        }
        for (let tt = 0, Ct = Ue.length; tt < Ct; tt++)
          jt = Ue[tt], ot ? xe && t.texSubImage2D(o.TEXTURE_2D, tt, 0, 0, pn, gn, jt) : t.texImage2D(o.TEXTURE_2D, tt, nn, pn, gn, jt);
        se.generateMipmaps = !1;
      } else if (ot) {
        if (Ht) {
          const tt = At(Pt);
          t.texStorage2D(o.TEXTURE_2D, Je, nn, tt.width, tt.height);
        }
        xe && t.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, pn, gn, Pt);
      } else
        t.texImage2D(o.TEXTURE_2D, 0, nn, pn, gn, Pt);
      G(se) && N(dt), Jt.__version = yt.version, se.onUpdate && se.onUpdate(se);
    }
    ce.__version = se.version;
  }
  function Ze(ce, se, Xe) {
    if (se.image.length !== 6) return;
    const dt = We(ce, se), Et = se.source;
    t.bindTexture(o.TEXTURE_CUBE_MAP, ce.__webglTexture, o.TEXTURE0 + Xe);
    const yt = a.get(Et);
    if (Et.version !== yt.__version || dt === !0) {
      t.activeTexture(o.TEXTURE0 + Xe);
      const Jt = wi.getPrimaries(wi.workingColorSpace), Xt = se.colorSpace === Fy ? null : wi.getPrimaries(se.colorSpace), Wt = se.colorSpace === Fy || Jt === Xt ? o.NONE : o.BROWSER_DEFAULT_WEBGL;
      o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, se.flipY), o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, se.premultiplyAlpha), o.pixelStorei(o.UNPACK_ALIGNMENT, se.unpackAlignment), o.pixelStorei(o.UNPACK_COLORSPACE_CONVERSION_WEBGL, Wt);
      const Vn = se.isCompressedTexture || se.image[0].isCompressedTexture, Pt = se.image[0] && se.image[0].isDataTexture, pn = [];
      for (let Ct = 0; Ct < 6; Ct++)
        !Vn && !Pt ? pn[Ct] = V(se.image[Ct], !0, r.maxCubemapSize) : pn[Ct] = Pt ? se.image[Ct].image : se.image[Ct], pn[Ct] = kt(se, pn[Ct]);
      const gn = pn[0], nn = d.convert(se.format, se.colorSpace), jt = d.convert(se.type), Ue = q(se.internalFormat, nn, jt, se.colorSpace), ot = se.isVideoTexture !== !0, Ht = yt.__version === void 0 || dt === !0, xe = Et.dataReady;
      let Je = ie(se, gn);
      De(o.TEXTURE_CUBE_MAP, se);
      let tt;
      if (Vn) {
        ot && Ht && t.texStorage2D(o.TEXTURE_CUBE_MAP, Je, Ue, gn.width, gn.height);
        for (let Ct = 0; Ct < 6; Ct++) {
          tt = pn[Ct].mipmaps;
          for (let $t = 0; $t < tt.length; $t++) {
            const tn = tt[$t];
            se.format !== xo ? nn !== null ? ot ? xe && t.compressedTexSubImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, $t, 0, 0, tn.width, tn.height, nn, tn.data) : t.compressedTexImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, $t, Ue, tn.width, tn.height, 0, tn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : ot ? xe && t.texSubImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, $t, 0, 0, tn.width, tn.height, nn, jt, tn.data) : t.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, $t, Ue, tn.width, tn.height, 0, nn, jt, tn.data);
          }
        }
      } else {
        if (tt = se.mipmaps, ot && Ht) {
          tt.length > 0 && Je++;
          const Ct = At(pn[0]);
          t.texStorage2D(o.TEXTURE_CUBE_MAP, Je, Ue, Ct.width, Ct.height);
        }
        for (let Ct = 0; Ct < 6; Ct++)
          if (Pt) {
            ot ? xe && t.texSubImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, 0, 0, 0, pn[Ct].width, pn[Ct].height, nn, jt, pn[Ct].data) : t.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, 0, Ue, pn[Ct].width, pn[Ct].height, 0, nn, jt, pn[Ct].data);
            for (let $t = 0; $t < tt.length; $t++) {
              const Mn = tt[$t].image[Ct].image;
              ot ? xe && t.texSubImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, $t + 1, 0, 0, Mn.width, Mn.height, nn, jt, Mn.data) : t.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, $t + 1, Ue, Mn.width, Mn.height, 0, nn, jt, Mn.data);
            }
          } else {
            ot ? xe && t.texSubImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, 0, 0, 0, nn, jt, pn[Ct]) : t.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, 0, Ue, nn, jt, pn[Ct]);
            for (let $t = 0; $t < tt.length; $t++) {
              const tn = tt[$t];
              ot ? xe && t.texSubImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, $t + 1, 0, 0, nn, jt, tn.image[Ct]) : t.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + Ct, $t + 1, Ue, nn, jt, tn.image[Ct]);
            }
          }
      }
      G(se) && N(o.TEXTURE_CUBE_MAP), yt.__version = Et.version, se.onUpdate && se.onUpdate(se);
    }
    ce.__version = se.version;
  }
  function ct(ce, se, Xe, dt, Et, yt) {
    const Jt = d.convert(Xe.format, Xe.colorSpace), Xt = d.convert(Xe.type), Wt = q(Xe.internalFormat, Jt, Xt, Xe.colorSpace), Vn = a.get(se), Pt = a.get(Xe);
    if (Pt.__renderTarget = se, !Vn.__hasExternalTextures) {
      const pn = Math.max(1, se.width >> yt), gn = Math.max(1, se.height >> yt);
      Et === o.TEXTURE_3D || Et === o.TEXTURE_2D_ARRAY ? t.texImage3D(Et, yt, Wt, pn, gn, se.depth, 0, Jt, Xt, null) : t.texImage2D(Et, yt, Wt, pn, gn, 0, Jt, Xt, null);
    }
    t.bindFramebuffer(o.FRAMEBUFFER, ce), St(se) ? y.framebufferTexture2DMultisampleEXT(o.FRAMEBUFFER, dt, Et, Pt.__webglTexture, 0, Tt(se)) : (Et === o.TEXTURE_2D || Et >= o.TEXTURE_CUBE_MAP_POSITIVE_X && Et <= o.TEXTURE_CUBE_MAP_NEGATIVE_Z) && o.framebufferTexture2D(o.FRAMEBUFFER, dt, Et, Pt.__webglTexture, yt), t.bindFramebuffer(o.FRAMEBUFFER, null);
  }
  function Vt(ce, se, Xe) {
    if (o.bindRenderbuffer(o.RENDERBUFFER, ce), se.depthBuffer) {
      const dt = se.depthTexture, Et = dt && dt.isDepthTexture ? dt.type : null, yt = Y(se.stencilBuffer, Et), Jt = se.stencilBuffer ? o.DEPTH_STENCIL_ATTACHMENT : o.DEPTH_ATTACHMENT, Xt = Tt(se);
      St(se) ? y.renderbufferStorageMultisampleEXT(o.RENDERBUFFER, Xt, yt, se.width, se.height) : Xe ? o.renderbufferStorageMultisample(o.RENDERBUFFER, Xt, yt, se.width, se.height) : o.renderbufferStorage(o.RENDERBUFFER, yt, se.width, se.height), o.framebufferRenderbuffer(o.FRAMEBUFFER, Jt, o.RENDERBUFFER, ce);
    } else {
      const dt = se.textures;
      for (let Et = 0; Et < dt.length; Et++) {
        const yt = dt[Et], Jt = d.convert(yt.format, yt.colorSpace), Xt = d.convert(yt.type), Wt = q(yt.internalFormat, Jt, Xt, yt.colorSpace), Vn = Tt(se);
        Xe && St(se) === !1 ? o.renderbufferStorageMultisample(o.RENDERBUFFER, Vn, Wt, se.width, se.height) : St(se) ? y.renderbufferStorageMultisampleEXT(o.RENDERBUFFER, Vn, Wt, se.width, se.height) : o.renderbufferStorage(o.RENDERBUFFER, Wt, se.width, se.height);
      }
    }
    o.bindRenderbuffer(o.RENDERBUFFER, null);
  }
  function Zt(ce, se) {
    if (se && se.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(o.FRAMEBUFFER, ce), !(se.depthTexture && se.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const dt = a.get(se.depthTexture);
    dt.__renderTarget = se, (!dt.__webglTexture || se.depthTexture.image.width !== se.width || se.depthTexture.image.height !== se.height) && (se.depthTexture.image.width = se.width, se.depthTexture.image.height = se.height, se.depthTexture.needsUpdate = !0), He(se.depthTexture, 0);
    const Et = dt.__webglTexture, yt = Tt(se);
    if (se.depthTexture.format === WS)
      St(se) ? y.framebufferTexture2DMultisampleEXT(o.FRAMEBUFFER, o.DEPTH_ATTACHMENT, o.TEXTURE_2D, Et, 0, yt) : o.framebufferTexture2D(o.FRAMEBUFFER, o.DEPTH_ATTACHMENT, o.TEXTURE_2D, Et, 0);
    else if (se.depthTexture.format === g1)
      St(se) ? y.framebufferTexture2DMultisampleEXT(o.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.TEXTURE_2D, Et, 0, yt) : o.framebufferTexture2D(o.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.TEXTURE_2D, Et, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Bn(ce) {
    const se = a.get(ce), Xe = ce.isWebGLCubeRenderTarget === !0;
    if (se.__boundDepthTexture !== ce.depthTexture) {
      const dt = ce.depthTexture;
      if (se.__depthDisposeCallback && se.__depthDisposeCallback(), dt) {
        const Et = () => {
          delete se.__boundDepthTexture, delete se.__depthDisposeCallback, dt.removeEventListener("dispose", Et);
        };
        dt.addEventListener("dispose", Et), se.__depthDisposeCallback = Et;
      }
      se.__boundDepthTexture = dt;
    }
    if (ce.depthTexture && !se.__autoAllocateDepthBuffer) {
      if (Xe) throw new Error("target.depthTexture not supported in Cube render targets");
      Zt(se.__webglFramebuffer, ce);
    } else if (Xe) {
      se.__webglDepthbuffer = [];
      for (let dt = 0; dt < 6; dt++)
        if (t.bindFramebuffer(o.FRAMEBUFFER, se.__webglFramebuffer[dt]), se.__webglDepthbuffer[dt] === void 0)
          se.__webglDepthbuffer[dt] = o.createRenderbuffer(), Vt(se.__webglDepthbuffer[dt], ce, !1);
        else {
          const Et = ce.stencilBuffer ? o.DEPTH_STENCIL_ATTACHMENT : o.DEPTH_ATTACHMENT, yt = se.__webglDepthbuffer[dt];
          o.bindRenderbuffer(o.RENDERBUFFER, yt), o.framebufferRenderbuffer(o.FRAMEBUFFER, Et, o.RENDERBUFFER, yt);
        }
    } else if (t.bindFramebuffer(o.FRAMEBUFFER, se.__webglFramebuffer), se.__webglDepthbuffer === void 0)
      se.__webglDepthbuffer = o.createRenderbuffer(), Vt(se.__webglDepthbuffer, ce, !1);
    else {
      const dt = ce.stencilBuffer ? o.DEPTH_STENCIL_ATTACHMENT : o.DEPTH_ATTACHMENT, Et = se.__webglDepthbuffer;
      o.bindRenderbuffer(o.RENDERBUFFER, Et), o.framebufferRenderbuffer(o.FRAMEBUFFER, dt, o.RENDERBUFFER, Et);
    }
    t.bindFramebuffer(o.FRAMEBUFFER, null);
  }
  function rn(ce, se, Xe) {
    const dt = a.get(ce);
    se !== void 0 && ct(dt.__webglFramebuffer, ce, ce.texture, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, 0), Xe !== void 0 && Bn(ce);
  }
  function dn(ce) {
    const se = ce.texture, Xe = a.get(ce), dt = a.get(se);
    ce.addEventListener("dispose", le);
    const Et = ce.textures, yt = ce.isWebGLCubeRenderTarget === !0, Jt = Et.length > 1;
    if (Jt || (dt.__webglTexture === void 0 && (dt.__webglTexture = o.createTexture()), dt.__version = se.version, p.memory.textures++), yt) {
      Xe.__webglFramebuffer = [];
      for (let Xt = 0; Xt < 6; Xt++)
        if (se.mipmaps && se.mipmaps.length > 0) {
          Xe.__webglFramebuffer[Xt] = [];
          for (let Wt = 0; Wt < se.mipmaps.length; Wt++)
            Xe.__webglFramebuffer[Xt][Wt] = o.createFramebuffer();
        } else
          Xe.__webglFramebuffer[Xt] = o.createFramebuffer();
    } else {
      if (se.mipmaps && se.mipmaps.length > 0) {
        Xe.__webglFramebuffer = [];
        for (let Xt = 0; Xt < se.mipmaps.length; Xt++)
          Xe.__webglFramebuffer[Xt] = o.createFramebuffer();
      } else
        Xe.__webglFramebuffer = o.createFramebuffer();
      if (Jt)
        for (let Xt = 0, Wt = Et.length; Xt < Wt; Xt++) {
          const Vn = a.get(Et[Xt]);
          Vn.__webglTexture === void 0 && (Vn.__webglTexture = o.createTexture(), p.memory.textures++);
        }
      if (ce.samples > 0 && St(ce) === !1) {
        Xe.__webglMultisampledFramebuffer = o.createFramebuffer(), Xe.__webglColorRenderbuffer = [], t.bindFramebuffer(o.FRAMEBUFFER, Xe.__webglMultisampledFramebuffer);
        for (let Xt = 0; Xt < Et.length; Xt++) {
          const Wt = Et[Xt];
          Xe.__webglColorRenderbuffer[Xt] = o.createRenderbuffer(), o.bindRenderbuffer(o.RENDERBUFFER, Xe.__webglColorRenderbuffer[Xt]);
          const Vn = d.convert(Wt.format, Wt.colorSpace), Pt = d.convert(Wt.type), pn = q(Wt.internalFormat, Vn, Pt, Wt.colorSpace, ce.isXRRenderTarget === !0), gn = Tt(ce);
          o.renderbufferStorageMultisample(o.RENDERBUFFER, gn, pn, ce.width, ce.height), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0 + Xt, o.RENDERBUFFER, Xe.__webglColorRenderbuffer[Xt]);
        }
        o.bindRenderbuffer(o.RENDERBUFFER, null), ce.depthBuffer && (Xe.__webglDepthRenderbuffer = o.createRenderbuffer(), Vt(Xe.__webglDepthRenderbuffer, ce, !0)), t.bindFramebuffer(o.FRAMEBUFFER, null);
      }
    }
    if (yt) {
      t.bindTexture(o.TEXTURE_CUBE_MAP, dt.__webglTexture), De(o.TEXTURE_CUBE_MAP, se);
      for (let Xt = 0; Xt < 6; Xt++)
        if (se.mipmaps && se.mipmaps.length > 0)
          for (let Wt = 0; Wt < se.mipmaps.length; Wt++)
            ct(Xe.__webglFramebuffer[Xt][Wt], ce, se, o.COLOR_ATTACHMENT0, o.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, Wt);
        else
          ct(Xe.__webglFramebuffer[Xt], ce, se, o.COLOR_ATTACHMENT0, o.TEXTURE_CUBE_MAP_POSITIVE_X + Xt, 0);
      G(se) && N(o.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Jt) {
      for (let Xt = 0, Wt = Et.length; Xt < Wt; Xt++) {
        const Vn = Et[Xt], Pt = a.get(Vn);
        t.bindTexture(o.TEXTURE_2D, Pt.__webglTexture), De(o.TEXTURE_2D, Vn), ct(Xe.__webglFramebuffer, ce, Vn, o.COLOR_ATTACHMENT0 + Xt, o.TEXTURE_2D, 0), G(Vn) && N(o.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Xt = o.TEXTURE_2D;
      if ((ce.isWebGL3DRenderTarget || ce.isWebGLArrayRenderTarget) && (Xt = ce.isWebGL3DRenderTarget ? o.TEXTURE_3D : o.TEXTURE_2D_ARRAY), t.bindTexture(Xt, dt.__webglTexture), De(Xt, se), se.mipmaps && se.mipmaps.length > 0)
        for (let Wt = 0; Wt < se.mipmaps.length; Wt++)
          ct(Xe.__webglFramebuffer[Wt], ce, se, o.COLOR_ATTACHMENT0, Xt, Wt);
      else
        ct(Xe.__webglFramebuffer, ce, se, o.COLOR_ATTACHMENT0, Xt, 0);
      G(se) && N(Xt), t.unbindTexture();
    }
    ce.depthBuffer && Bn(ce);
  }
  function Zn(ce) {
    const se = ce.textures;
    for (let Xe = 0, dt = se.length; Xe < dt; Xe++) {
      const Et = se[Xe];
      if (G(Et)) {
        const yt = F(ce), Jt = a.get(Et).__webglTexture;
        t.bindTexture(yt, Jt), N(yt), t.unbindTexture();
      }
    }
  }
  const Rn = [], Te = [];
  function Ha(ce) {
    if (ce.samples > 0) {
      if (St(ce) === !1) {
        const se = ce.textures, Xe = ce.width, dt = ce.height;
        let Et = o.COLOR_BUFFER_BIT;
        const yt = ce.stencilBuffer ? o.DEPTH_STENCIL_ATTACHMENT : o.DEPTH_ATTACHMENT, Jt = a.get(ce), Xt = se.length > 1;
        if (Xt)
          for (let Wt = 0; Wt < se.length; Wt++)
            t.bindFramebuffer(o.FRAMEBUFFER, Jt.__webglMultisampledFramebuffer), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0 + Wt, o.RENDERBUFFER, null), t.bindFramebuffer(o.FRAMEBUFFER, Jt.__webglFramebuffer), o.framebufferTexture2D(o.DRAW_FRAMEBUFFER, o.COLOR_ATTACHMENT0 + Wt, o.TEXTURE_2D, null, 0);
        t.bindFramebuffer(o.READ_FRAMEBUFFER, Jt.__webglMultisampledFramebuffer), t.bindFramebuffer(o.DRAW_FRAMEBUFFER, Jt.__webglFramebuffer);
        for (let Wt = 0; Wt < se.length; Wt++) {
          if (ce.resolveDepthBuffer && (ce.depthBuffer && (Et |= o.DEPTH_BUFFER_BIT), ce.stencilBuffer && ce.resolveStencilBuffer && (Et |= o.STENCIL_BUFFER_BIT)), Xt) {
            o.framebufferRenderbuffer(o.READ_FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.RENDERBUFFER, Jt.__webglColorRenderbuffer[Wt]);
            const Vn = a.get(se[Wt]).__webglTexture;
            o.framebufferTexture2D(o.DRAW_FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, Vn, 0);
          }
          o.blitFramebuffer(0, 0, Xe, dt, 0, 0, Xe, dt, Et, o.NEAREST), _ === !0 && (Rn.length = 0, Te.length = 0, Rn.push(o.COLOR_ATTACHMENT0 + Wt), ce.depthBuffer && ce.resolveDepthBuffer === !1 && (Rn.push(yt), Te.push(yt), o.invalidateFramebuffer(o.DRAW_FRAMEBUFFER, Te)), o.invalidateFramebuffer(o.READ_FRAMEBUFFER, Rn));
        }
        if (t.bindFramebuffer(o.READ_FRAMEBUFFER, null), t.bindFramebuffer(o.DRAW_FRAMEBUFFER, null), Xt)
          for (let Wt = 0; Wt < se.length; Wt++) {
            t.bindFramebuffer(o.FRAMEBUFFER, Jt.__webglMultisampledFramebuffer), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0 + Wt, o.RENDERBUFFER, Jt.__webglColorRenderbuffer[Wt]);
            const Vn = a.get(se[Wt]).__webglTexture;
            t.bindFramebuffer(o.FRAMEBUFFER, Jt.__webglFramebuffer), o.framebufferTexture2D(o.DRAW_FRAMEBUFFER, o.COLOR_ATTACHMENT0 + Wt, o.TEXTURE_2D, Vn, 0);
          }
        t.bindFramebuffer(o.DRAW_FRAMEBUFFER, Jt.__webglMultisampledFramebuffer);
      } else if (ce.depthBuffer && ce.resolveDepthBuffer === !1 && _) {
        const se = ce.stencilBuffer ? o.DEPTH_STENCIL_ATTACHMENT : o.DEPTH_ATTACHMENT;
        o.invalidateFramebuffer(o.DRAW_FRAMEBUFFER, [se]);
      }
    }
  }
  function Tt(ce) {
    return Math.min(r.maxSamples, ce.samples);
  }
  function St(ce) {
    const se = a.get(ce);
    return ce.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && se.__useRenderToTexture !== !1;
  }
  function Mt(ce) {
    const se = p.render.frame;
    T.get(ce) !== se && (T.set(ce, se), ce.update());
  }
  function kt(ce, se) {
    const Xe = ce.colorSpace, dt = ce.format, Et = ce.type;
    return ce.isCompressedTexture === !0 || ce.isVideoTexture === !0 || Xe !== Kv && Xe !== Fy && (wi.getTransfer(Xe) === Nl ? (dt !== xo || Et !== qh) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", Xe)), se;
  }
  function At(ce) {
    return typeof HTMLImageElement < "u" && ce instanceof HTMLImageElement ? (E.width = ce.naturalWidth || ce.width, E.height = ce.naturalHeight || ce.height) : typeof VideoFrame < "u" && ce instanceof VideoFrame ? (E.width = ce.displayWidth, E.height = ce.displayHeight) : (E.width = ce.width, E.height = ce.height), E;
  }
  this.allocateTextureUnit = me, this.resetTextureUnits = _e, this.setTexture2D = He, this.setTexture2DArray = P, this.setTexture3D = te, this.setTextureCube = ae, this.rebindTextures = rn, this.setupRenderTarget = dn, this.updateRenderTargetMipmap = Zn, this.updateMultisampleRenderTarget = Ha, this.setupDepthRenderbuffer = Bn, this.setupFrameBufferTexture = ct, this.useMultisampledRTT = St;
}
function pw(o, e) {
  function t(a, r = Fy) {
    let d;
    const p = wi.getTransfer(r);
    if (a === qh) return o.UNSIGNED_BYTE;
    if (a === rx) return o.UNSIGNED_SHORT_4_4_4_4;
    if (a === ox) return o.UNSIGNED_SHORT_5_5_5_1;
    if (a === h2) return o.UNSIGNED_INT_5_9_9_9_REV;
    if (a === lx) return o.BYTE;
    if (a === sx) return o.SHORT;
    if (a === kS) return o.UNSIGNED_SHORT;
    if (a === iE) return o.INT;
    if (a === jg) return o.UNSIGNED_INT;
    if (a === pr) return o.FLOAT;
    if (a === au) return o.HALF_FLOAT;
    if (a === p2) return o.ALPHA;
    if (a === m2) return o.RGB;
    if (a === xo) return o.RGBA;
    if (a === v2) return o.LUMINANCE;
    if (a === g2) return o.LUMINANCE_ALPHA;
    if (a === WS) return o.DEPTH_COMPONENT;
    if (a === g1) return o.DEPTH_STENCIL;
    if (a === lE) return o.RED;
    if (a === sE) return o.RED_INTEGER;
    if (a === y2) return o.RG;
    if (a === ux) return o.RG_INTEGER;
    if (a === cx) return o.RGBA_INTEGER;
    if (a === NA || a === zA || a === HA || a === LA)
      if (p === Nl)
        if (d = e.get("WEBGL_compressed_texture_s3tc_srgb"), d !== null) {
          if (a === NA) return d.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (a === zA) return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (a === HA) return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (a === LA) return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (d = e.get("WEBGL_compressed_texture_s3tc"), d !== null) {
        if (a === NA) return d.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (a === zA) return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (a === HA) return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (a === LA) return d.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (a === _M || a === AM || a === EM || a === bM)
      if (d = e.get("WEBGL_compressed_texture_pvrtc"), d !== null) {
        if (a === _M) return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (a === AM) return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (a === EM) return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (a === bM) return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (a === MM || a === xM || a === TM)
      if (d = e.get("WEBGL_compressed_texture_etc"), d !== null) {
        if (a === MM || a === xM) return p === Nl ? d.COMPRESSED_SRGB8_ETC2 : d.COMPRESSED_RGB8_ETC2;
        if (a === TM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : d.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (a === CM || a === RM || a === DM || a === BM || a === UM || a === OM || a === wM || a === NM || a === zM || a === HM || a === LM || a === GM || a === IM || a === VM)
      if (d = e.get("WEBGL_compressed_texture_astc"), d !== null) {
        if (a === CM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : d.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (a === RM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : d.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (a === DM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : d.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (a === BM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : d.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (a === UM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : d.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (a === OM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : d.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (a === wM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : d.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (a === NM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : d.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (a === zM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : d.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (a === HM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : d.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (a === LM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : d.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (a === GM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : d.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (a === IM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : d.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (a === VM) return p === Nl ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : d.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (a === GA || a === FM || a === PM)
      if (d = e.get("EXT_texture_compression_bptc"), d !== null) {
        if (a === GA) return p === Nl ? d.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : d.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (a === FM) return d.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (a === PM) return d.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (a === S2 || a === XM || a === YM || a === qM)
      if (d = e.get("EXT_texture_compression_rgtc"), d !== null) {
        if (a === GA) return d.COMPRESSED_RED_RGTC1_EXT;
        if (a === XM) return d.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (a === YM) return d.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (a === qM) return d.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return a === v1 ? o.UNSIGNED_INT_24_8 : o[a] !== void 0 ? o[a] : null;
  }
  return { convert: t };
}
const OG = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, wG = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class NG {
  /**
   * Constructs a new depth sensing module.
   */
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  /**
   * Inits the depth sensing module
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {XRWebGLDepthInformation} depthData - The XR depth data.
   * @param {XRRenderState} renderState - The XR render state.
   */
  init(e, t, a) {
    if (this.texture === null) {
      const r = new Ml(), d = e.properties.get(r);
      d.__webglTexture = t.texture, (t.depthNear !== a.depthNear || t.depthFar !== a.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = r;
    }
  }
  /**
   * Returns a plane mesh that visualizes the depth texture.
   *
   * @param {ArrayCamera} cameraXR - The XR camera.
   * @return {?Mesh} The plane mesh.
   */
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport, a = new iu({
        vertexShader: OG,
        fragmentShader: wG,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: t.z },
          depthHeight: { value: t.w }
        }
      });
      this.mesh = new es(new Ky(20, 20), a);
    }
    return this.mesh;
  }
  /**
   * Resets the module
   */
  reset() {
    this.texture = null, this.mesh = null;
  }
  /**
   * Returns a texture representing the depth of the user's environment.
   *
   * @return {?Texture} The depth texture.
   */
  getDepthTexture() {
    return this.texture;
  }
}
class zG extends Jg {
  /**
   * Constructs a new WebGL renderer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGL2RenderingContext} gl - The rendering context.
   */
  constructor(e, t) {
    super();
    const a = this;
    let r = null, d = 1, p = null, y = "local-floor", _ = 1, E = null, T = null, C = null, D = null, B = null, z = null;
    const V = new NG(), G = t.getContextAttributes();
    let N = null, F = null;
    const q = [], Y = [], ie = new Ot();
    let k = null;
    const le = new Ls();
    le.viewport = new Bi();
    const ne = new Ls();
    ne.viewport = new Bi();
    const Q = [le, ne], j = new iw();
    let re = null, _e = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(Me) {
      let Ze = q[Me];
      return Ze === void 0 && (Ze = new sM(), q[Me] = Ze), Ze.getTargetRaySpace();
    }, this.getControllerGrip = function(Me) {
      let Ze = q[Me];
      return Ze === void 0 && (Ze = new sM(), q[Me] = Ze), Ze.getGripSpace();
    }, this.getHand = function(Me) {
      let Ze = q[Me];
      return Ze === void 0 && (Ze = new sM(), q[Me] = Ze), Ze.getHandSpace();
    };
    function me(Me) {
      const Ze = Y.indexOf(Me.inputSource);
      if (Ze === -1)
        return;
      const ct = q[Ze];
      ct !== void 0 && (ct.update(Me.inputSource, Me.frame, E || p), ct.dispatchEvent({ type: Me.type, data: Me.inputSource }));
    }
    function Ae() {
      r.removeEventListener("select", me), r.removeEventListener("selectstart", me), r.removeEventListener("selectend", me), r.removeEventListener("squeeze", me), r.removeEventListener("squeezestart", me), r.removeEventListener("squeezeend", me), r.removeEventListener("end", Ae), r.removeEventListener("inputsourceschange", He);
      for (let Me = 0; Me < q.length; Me++) {
        const Ze = Y[Me];
        Ze !== null && (Y[Me] = null, q[Me].disconnect(Ze));
      }
      re = null, _e = null, V.reset(), e.setRenderTarget(N), B = null, D = null, C = null, r = null, F = null, We.stop(), a.isPresenting = !1, e.setPixelRatio(k), e.setSize(ie.width, ie.height, !1), a.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(Me) {
      d = Me, a.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(Me) {
      y = Me, a.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return E || p;
    }, this.setReferenceSpace = function(Me) {
      E = Me;
    }, this.getBaseLayer = function() {
      return D !== null ? D : B;
    }, this.getBinding = function() {
      return C;
    }, this.getFrame = function() {
      return z;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(Me) {
      if (r = Me, r !== null) {
        if (N = e.getRenderTarget(), r.addEventListener("select", me), r.addEventListener("selectstart", me), r.addEventListener("selectend", me), r.addEventListener("squeeze", me), r.addEventListener("squeezestart", me), r.addEventListener("squeezeend", me), r.addEventListener("end", Ae), r.addEventListener("inputsourceschange", He), G.xrCompatible !== !0 && await t.makeXRCompatible(), k = e.getPixelRatio(), e.getSize(ie), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
          let ct = null, Vt = null, Zt = null;
          G.depth && (Zt = G.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, ct = G.stencil ? g1 : WS, Vt = G.stencil ? v1 : jg);
          const Bn = {
            colorFormat: t.RGBA8,
            depthFormat: Zt,
            scaleFactor: d
          };
          C = new XRWebGLBinding(r, t), D = C.createProjectionLayer(Bn), r.updateRenderState({ layers: [D] }), e.setPixelRatio(1), e.setSize(D.textureWidth, D.textureHeight, !1), F = new uf(
            D.textureWidth,
            D.textureHeight,
            {
              format: xo,
              type: qh,
              depthTexture: new _x(D.textureWidth, D.textureHeight, Vt, void 0, void 0, void 0, void 0, void 0, void 0, ct),
              stencilBuffer: G.stencil,
              colorSpace: e.outputColorSpace,
              samples: G.antialias ? 4 : 0,
              resolveDepthBuffer: D.ignoreDepthValues === !1,
              resolveStencilBuffer: D.ignoreDepthValues === !1
            }
          );
        } else {
          const ct = {
            antialias: G.antialias,
            alpha: !0,
            depth: G.depth,
            stencil: G.stencil,
            framebufferScaleFactor: d
          };
          B = new XRWebGLLayer(r, t, ct), r.updateRenderState({ baseLayer: B }), e.setPixelRatio(1), e.setSize(B.framebufferWidth, B.framebufferHeight, !1), F = new uf(
            B.framebufferWidth,
            B.framebufferHeight,
            {
              format: xo,
              type: qh,
              colorSpace: e.outputColorSpace,
              stencilBuffer: G.stencil,
              resolveDepthBuffer: B.ignoreDepthValues === !1,
              resolveStencilBuffer: B.ignoreDepthValues === !1
            }
          );
        }
        F.isXRRenderTarget = !0, this.setFoveation(_), E = null, p = await r.requestReferenceSpace(y), We.setContext(r), We.start(), a.isPresenting = !0, a.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null)
        return r.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return V.getDepthTexture();
    };
    function He(Me) {
      for (let Ze = 0; Ze < Me.removed.length; Ze++) {
        const ct = Me.removed[Ze], Vt = Y.indexOf(ct);
        Vt >= 0 && (Y[Vt] = null, q[Vt].disconnect(ct));
      }
      for (let Ze = 0; Ze < Me.added.length; Ze++) {
        const ct = Me.added[Ze];
        let Vt = Y.indexOf(ct);
        if (Vt === -1) {
          for (let Bn = 0; Bn < q.length; Bn++)
            if (Bn >= Y.length) {
              Y.push(ct), Vt = Bn;
              break;
            } else if (Y[Bn] === null) {
              Y[Bn] = ct, Vt = Bn;
              break;
            }
          if (Vt === -1) break;
        }
        const Zt = q[Vt];
        Zt && Zt.connect(ct);
      }
    }
    const P = new ve(), te = new ve();
    function ae(Me, Ze, ct) {
      P.setFromMatrixPosition(Ze.matrixWorld), te.setFromMatrixPosition(ct.matrixWorld);
      const Vt = P.distanceTo(te), Zt = Ze.projectionMatrix.elements, Bn = ct.projectionMatrix.elements, rn = Zt[14] / (Zt[10] - 1), dn = Zt[14] / (Zt[10] + 1), Zn = (Zt[9] + 1) / Zt[5], Rn = (Zt[9] - 1) / Zt[5], Te = (Zt[8] - 1) / Zt[0], Ha = (Bn[8] + 1) / Bn[0], Tt = rn * Te, St = rn * Ha, Mt = Vt / (-Te + Ha), kt = Mt * -Te;
      if (Ze.matrixWorld.decompose(Me.position, Me.quaternion, Me.scale), Me.translateX(kt), Me.translateZ(Mt), Me.matrixWorld.compose(Me.position, Me.quaternion, Me.scale), Me.matrixWorldInverse.copy(Me.matrixWorld).invert(), Zt[10] === -1)
        Me.projectionMatrix.copy(Ze.projectionMatrix), Me.projectionMatrixInverse.copy(Ze.projectionMatrixInverse);
      else {
        const At = rn + Mt, ce = dn + Mt, se = Tt - kt, Xe = St + (Vt - kt), dt = Zn * dn / ce * At, Et = Rn * dn / ce * At;
        Me.projectionMatrix.makePerspective(se, Xe, dt, Et, At, ce), Me.projectionMatrixInverse.copy(Me.projectionMatrix).invert();
      }
    }
    function Se(Me, Ze) {
      Ze === null ? Me.matrixWorld.copy(Me.matrix) : Me.matrixWorld.multiplyMatrices(Ze.matrixWorld, Me.matrix), Me.matrixWorldInverse.copy(Me.matrixWorld).invert();
    }
    this.updateCamera = function(Me) {
      if (r === null) return;
      let Ze = Me.near, ct = Me.far;
      V.texture !== null && (V.depthNear > 0 && (Ze = V.depthNear), V.depthFar > 0 && (ct = V.depthFar)), j.near = ne.near = le.near = Ze, j.far = ne.far = le.far = ct, (re !== j.near || _e !== j.far) && (r.updateRenderState({
        depthNear: j.near,
        depthFar: j.far
      }), re = j.near, _e = j.far), le.layers.mask = Me.layers.mask | 2, ne.layers.mask = Me.layers.mask | 4, j.layers.mask = le.layers.mask | ne.layers.mask;
      const Vt = Me.parent, Zt = j.cameras;
      Se(j, Vt);
      for (let Bn = 0; Bn < Zt.length; Bn++)
        Se(Zt[Bn], Vt);
      Zt.length === 2 ? ae(j, le, ne) : j.projectionMatrix.copy(le.projectionMatrix), ue(Me, j, Vt);
    };
    function ue(Me, Ze, ct) {
      ct === null ? Me.matrix.copy(Ze.matrixWorld) : (Me.matrix.copy(ct.matrixWorld), Me.matrix.invert(), Me.matrix.multiply(Ze.matrixWorld)), Me.matrix.decompose(Me.position, Me.quaternion, Me.scale), Me.updateMatrixWorld(!0), Me.projectionMatrix.copy(Ze.projectionMatrix), Me.projectionMatrixInverse.copy(Ze.projectionMatrixInverse), Me.isPerspectiveCamera && (Me.fov = _1 * 2 * Math.atan(1 / Me.projectionMatrix.elements[5]), Me.zoom = 1);
    }
    this.getCamera = function() {
      return j;
    }, this.getFoveation = function() {
      if (!(D === null && B === null))
        return _;
    }, this.setFoveation = function(Me) {
      _ = Me, D !== null && (D.fixedFoveation = Me), B !== null && B.fixedFoveation !== void 0 && (B.fixedFoveation = Me);
    }, this.hasDepthSensing = function() {
      return V.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return V.getMesh(j);
    };
    let we = null;
    function De(Me, Ze) {
      if (T = Ze.getViewerPose(E || p), z = Ze, T !== null) {
        const ct = T.views;
        B !== null && (e.setRenderTargetFramebuffer(F, B.framebuffer), e.setRenderTarget(F));
        let Vt = !1;
        ct.length !== j.cameras.length && (j.cameras.length = 0, Vt = !0);
        for (let rn = 0; rn < ct.length; rn++) {
          const dn = ct[rn];
          let Zn = null;
          if (B !== null)
            Zn = B.getViewport(dn);
          else {
            const Te = C.getViewSubImage(D, dn);
            Zn = Te.viewport, rn === 0 && (e.setRenderTargetTextures(
              F,
              Te.colorTexture,
              Te.depthStencilTexture
            ), e.setRenderTarget(F));
          }
          let Rn = Q[rn];
          Rn === void 0 && (Rn = new Ls(), Rn.layers.enable(rn), Rn.viewport = new Bi(), Q[rn] = Rn), Rn.matrix.fromArray(dn.transform.matrix), Rn.matrix.decompose(Rn.position, Rn.quaternion, Rn.scale), Rn.projectionMatrix.fromArray(dn.projectionMatrix), Rn.projectionMatrixInverse.copy(Rn.projectionMatrix).invert(), Rn.viewport.set(Zn.x, Zn.y, Zn.width, Zn.height), rn === 0 && (j.matrix.copy(Rn.matrix), j.matrix.decompose(j.position, j.quaternion, j.scale)), Vt === !0 && j.cameras.push(Rn);
        }
        const Zt = r.enabledFeatures;
        if (Zt && Zt.includes("depth-sensing") && r.depthUsage == "gpu-optimized" && C) {
          const rn = C.getDepthInformation(ct[0]);
          rn && rn.isValid && rn.texture && V.init(e, rn, r.renderState);
        }
      }
      for (let ct = 0; ct < q.length; ct++) {
        const Vt = Y[ct], Zt = q[ct];
        Vt !== null && Zt !== void 0 && Zt.update(Vt, Ze, E || p);
      }
      we && we(Me, Ze), Ze.detectedPlanes && a.dispatchEvent({ type: "planesdetected", data: Ze }), z = null;
    }
    const We = new uw();
    We.setAnimationLoop(De), this.setAnimationLoop = function(Me) {
      we = Me;
    }, this.dispose = function() {
    };
  }
}
const wS = /* @__PURE__ */ new Ip(), HG = /* @__PURE__ */ new ia();
function LG(o, e) {
  function t(G, N) {
    G.matrixAutoUpdate === !0 && G.updateMatrix(), N.value.copy(G.matrix);
  }
  function a(G, N) {
    N.color.getRGB(G.fogColor.value, gO(o)), N.isFog ? (G.fogNear.value = N.near, G.fogFar.value = N.far) : N.isFogExp2 && (G.fogDensity.value = N.density);
  }
  function r(G, N, F, q, Y) {
    N.isMeshBasicMaterial || N.isMeshLambertMaterial ? d(G, N) : N.isMeshToonMaterial ? (d(G, N), C(G, N)) : N.isMeshPhongMaterial ? (d(G, N), T(G, N)) : N.isMeshStandardMaterial ? (d(G, N), D(G, N), N.isMeshPhysicalMaterial && B(G, N, Y)) : N.isMeshMatcapMaterial ? (d(G, N), z(G, N)) : N.isMeshDepthMaterial ? d(G, N) : N.isMeshDistanceMaterial ? (d(G, N), V(G, N)) : N.isMeshNormalMaterial ? d(G, N) : N.isLineBasicMaterial ? (p(G, N), N.isLineDashedMaterial && y(G, N)) : N.isPointsMaterial ? _(G, N, F, q) : N.isSpriteMaterial ? E(G, N) : N.isShadowMaterial ? (G.color.value.copy(N.color), G.opacity.value = N.opacity) : N.isShaderMaterial && (N.uniformsNeedUpdate = !1);
  }
  function d(G, N) {
    G.opacity.value = N.opacity, N.color && G.diffuse.value.copy(N.color), N.emissive && G.emissive.value.copy(N.emissive).multiplyScalar(N.emissiveIntensity), N.map && (G.map.value = N.map, t(N.map, G.mapTransform)), N.alphaMap && (G.alphaMap.value = N.alphaMap, t(N.alphaMap, G.alphaMapTransform)), N.bumpMap && (G.bumpMap.value = N.bumpMap, t(N.bumpMap, G.bumpMapTransform), G.bumpScale.value = N.bumpScale, N.side === ed && (G.bumpScale.value *= -1)), N.normalMap && (G.normalMap.value = N.normalMap, t(N.normalMap, G.normalMapTransform), G.normalScale.value.copy(N.normalScale), N.side === ed && G.normalScale.value.negate()), N.displacementMap && (G.displacementMap.value = N.displacementMap, t(N.displacementMap, G.displacementMapTransform), G.displacementScale.value = N.displacementScale, G.displacementBias.value = N.displacementBias), N.emissiveMap && (G.emissiveMap.value = N.emissiveMap, t(N.emissiveMap, G.emissiveMapTransform)), N.specularMap && (G.specularMap.value = N.specularMap, t(N.specularMap, G.specularMapTransform)), N.alphaTest > 0 && (G.alphaTest.value = N.alphaTest);
    const F = e.get(N), q = F.envMap, Y = F.envMapRotation;
    q && (G.envMap.value = q, wS.copy(Y), wS.x *= -1, wS.y *= -1, wS.z *= -1, q.isCubeTexture && q.isRenderTargetTexture === !1 && (wS.y *= -1, wS.z *= -1), G.envMapRotation.value.setFromMatrix4(HG.makeRotationFromEuler(wS)), G.flipEnvMap.value = q.isCubeTexture && q.isRenderTargetTexture === !1 ? -1 : 1, G.reflectivity.value = N.reflectivity, G.ior.value = N.ior, G.refractionRatio.value = N.refractionRatio), N.lightMap && (G.lightMap.value = N.lightMap, G.lightMapIntensity.value = N.lightMapIntensity, t(N.lightMap, G.lightMapTransform)), N.aoMap && (G.aoMap.value = N.aoMap, G.aoMapIntensity.value = N.aoMapIntensity, t(N.aoMap, G.aoMapTransform));
  }
  function p(G, N) {
    G.diffuse.value.copy(N.color), G.opacity.value = N.opacity, N.map && (G.map.value = N.map, t(N.map, G.mapTransform));
  }
  function y(G, N) {
    G.dashSize.value = N.dashSize, G.totalSize.value = N.dashSize + N.gapSize, G.scale.value = N.scale;
  }
  function _(G, N, F, q) {
    G.diffuse.value.copy(N.color), G.opacity.value = N.opacity, G.size.value = N.size * F, G.scale.value = q * 0.5, N.map && (G.map.value = N.map, t(N.map, G.uvTransform)), N.alphaMap && (G.alphaMap.value = N.alphaMap, t(N.alphaMap, G.alphaMapTransform)), N.alphaTest > 0 && (G.alphaTest.value = N.alphaTest);
  }
  function E(G, N) {
    G.diffuse.value.copy(N.color), G.opacity.value = N.opacity, G.rotation.value = N.rotation, N.map && (G.map.value = N.map, t(N.map, G.mapTransform)), N.alphaMap && (G.alphaMap.value = N.alphaMap, t(N.alphaMap, G.alphaMapTransform)), N.alphaTest > 0 && (G.alphaTest.value = N.alphaTest);
  }
  function T(G, N) {
    G.specular.value.copy(N.specular), G.shininess.value = Math.max(N.shininess, 1e-4);
  }
  function C(G, N) {
    N.gradientMap && (G.gradientMap.value = N.gradientMap);
  }
  function D(G, N) {
    G.metalness.value = N.metalness, N.metalnessMap && (G.metalnessMap.value = N.metalnessMap, t(N.metalnessMap, G.metalnessMapTransform)), G.roughness.value = N.roughness, N.roughnessMap && (G.roughnessMap.value = N.roughnessMap, t(N.roughnessMap, G.roughnessMapTransform)), N.envMap && (G.envMapIntensity.value = N.envMapIntensity);
  }
  function B(G, N, F) {
    G.ior.value = N.ior, N.sheen > 0 && (G.sheenColor.value.copy(N.sheenColor).multiplyScalar(N.sheen), G.sheenRoughness.value = N.sheenRoughness, N.sheenColorMap && (G.sheenColorMap.value = N.sheenColorMap, t(N.sheenColorMap, G.sheenColorMapTransform)), N.sheenRoughnessMap && (G.sheenRoughnessMap.value = N.sheenRoughnessMap, t(N.sheenRoughnessMap, G.sheenRoughnessMapTransform))), N.clearcoat > 0 && (G.clearcoat.value = N.clearcoat, G.clearcoatRoughness.value = N.clearcoatRoughness, N.clearcoatMap && (G.clearcoatMap.value = N.clearcoatMap, t(N.clearcoatMap, G.clearcoatMapTransform)), N.clearcoatRoughnessMap && (G.clearcoatRoughnessMap.value = N.clearcoatRoughnessMap, t(N.clearcoatRoughnessMap, G.clearcoatRoughnessMapTransform)), N.clearcoatNormalMap && (G.clearcoatNormalMap.value = N.clearcoatNormalMap, t(N.clearcoatNormalMap, G.clearcoatNormalMapTransform), G.clearcoatNormalScale.value.copy(N.clearcoatNormalScale), N.side === ed && G.clearcoatNormalScale.value.negate())), N.dispersion > 0 && (G.dispersion.value = N.dispersion), N.iridescence > 0 && (G.iridescence.value = N.iridescence, G.iridescenceIOR.value = N.iridescenceIOR, G.iridescenceThicknessMinimum.value = N.iridescenceThicknessRange[0], G.iridescenceThicknessMaximum.value = N.iridescenceThicknessRange[1], N.iridescenceMap && (G.iridescenceMap.value = N.iridescenceMap, t(N.iridescenceMap, G.iridescenceMapTransform)), N.iridescenceThicknessMap && (G.iridescenceThicknessMap.value = N.iridescenceThicknessMap, t(N.iridescenceThicknessMap, G.iridescenceThicknessMapTransform))), N.transmission > 0 && (G.transmission.value = N.transmission, G.transmissionSamplerMap.value = F.texture, G.transmissionSamplerSize.value.set(F.width, F.height), N.transmissionMap && (G.transmissionMap.value = N.transmissionMap, t(N.transmissionMap, G.transmissionMapTransform)), G.thickness.value = N.thickness, N.thicknessMap && (G.thicknessMap.value = N.thicknessMap, t(N.thicknessMap, G.thicknessMapTransform)), G.attenuationDistance.value = N.attenuationDistance, G.attenuationColor.value.copy(N.attenuationColor)), N.anisotropy > 0 && (G.anisotropyVector.value.set(N.anisotropy * Math.cos(N.anisotropyRotation), N.anisotropy * Math.sin(N.anisotropyRotation)), N.anisotropyMap && (G.anisotropyMap.value = N.anisotropyMap, t(N.anisotropyMap, G.anisotropyMapTransform))), G.specularIntensity.value = N.specularIntensity, G.specularColor.value.copy(N.specularColor), N.specularColorMap && (G.specularColorMap.value = N.specularColorMap, t(N.specularColorMap, G.specularColorMapTransform)), N.specularIntensityMap && (G.specularIntensityMap.value = N.specularIntensityMap, t(N.specularIntensityMap, G.specularIntensityMapTransform));
  }
  function z(G, N) {
    N.matcap && (G.matcap.value = N.matcap);
  }
  function V(G, N) {
    const F = e.get(N).light;
    G.referencePosition.value.setFromMatrixPosition(F.matrixWorld), G.nearDistance.value = F.shadow.camera.near, G.farDistance.value = F.shadow.camera.far;
  }
  return {
    refreshFogUniforms: a,
    refreshMaterialUniforms: r
  };
}
function GG(o, e, t, a) {
  let r = {}, d = {}, p = [];
  const y = o.getParameter(o.MAX_UNIFORM_BUFFER_BINDINGS);
  function _(F, q) {
    const Y = q.program;
    a.uniformBlockBinding(F, Y);
  }
  function E(F, q) {
    let Y = r[F.id];
    Y === void 0 && (z(F), Y = T(F), r[F.id] = Y, F.addEventListener("dispose", G));
    const ie = q.program;
    a.updateUBOMapping(F, ie);
    const k = e.render.frame;
    d[F.id] !== k && (D(F), d[F.id] = k);
  }
  function T(F) {
    const q = C();
    F.__bindingPointIndex = q;
    const Y = o.createBuffer(), ie = F.__size, k = F.usage;
    return o.bindBuffer(o.UNIFORM_BUFFER, Y), o.bufferData(o.UNIFORM_BUFFER, ie, k), o.bindBuffer(o.UNIFORM_BUFFER, null), o.bindBufferBase(o.UNIFORM_BUFFER, q, Y), Y;
  }
  function C() {
    for (let F = 0; F < y; F++)
      if (p.indexOf(F) === -1)
        return p.push(F), F;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function D(F) {
    const q = r[F.id], Y = F.uniforms, ie = F.__cache;
    o.bindBuffer(o.UNIFORM_BUFFER, q);
    for (let k = 0, le = Y.length; k < le; k++) {
      const ne = Array.isArray(Y[k]) ? Y[k] : [Y[k]];
      for (let Q = 0, j = ne.length; Q < j; Q++) {
        const re = ne[Q];
        if (B(re, k, Q, ie) === !0) {
          const _e = re.__offset, me = Array.isArray(re.value) ? re.value : [re.value];
          let Ae = 0;
          for (let He = 0; He < me.length; He++) {
            const P = me[He], te = V(P);
            typeof P == "number" || typeof P == "boolean" ? (re.__data[0] = P, o.bufferSubData(o.UNIFORM_BUFFER, _e + Ae, re.__data)) : P.isMatrix3 ? (re.__data[0] = P.elements[0], re.__data[1] = P.elements[1], re.__data[2] = P.elements[2], re.__data[3] = 0, re.__data[4] = P.elements[3], re.__data[5] = P.elements[4], re.__data[6] = P.elements[5], re.__data[7] = 0, re.__data[8] = P.elements[6], re.__data[9] = P.elements[7], re.__data[10] = P.elements[8], re.__data[11] = 0) : (P.toArray(re.__data, Ae), Ae += te.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          o.bufferSubData(o.UNIFORM_BUFFER, _e, re.__data);
        }
      }
    }
    o.bindBuffer(o.UNIFORM_BUFFER, null);
  }
  function B(F, q, Y, ie) {
    const k = F.value, le = q + "_" + Y;
    if (ie[le] === void 0)
      return typeof k == "number" || typeof k == "boolean" ? ie[le] = k : ie[le] = k.clone(), !0;
    {
      const ne = ie[le];
      if (typeof k == "number" || typeof k == "boolean") {
        if (ne !== k)
          return ie[le] = k, !0;
      } else if (ne.equals(k) === !1)
        return ne.copy(k), !0;
    }
    return !1;
  }
  function z(F) {
    const q = F.uniforms;
    let Y = 0;
    const ie = 16;
    for (let le = 0, ne = q.length; le < ne; le++) {
      const Q = Array.isArray(q[le]) ? q[le] : [q[le]];
      for (let j = 0, re = Q.length; j < re; j++) {
        const _e = Q[j], me = Array.isArray(_e.value) ? _e.value : [_e.value];
        for (let Ae = 0, He = me.length; Ae < He; Ae++) {
          const P = me[Ae], te = V(P), ae = Y % ie, Se = ae % te.boundary, ue = ae + Se;
          Y += Se, ue !== 0 && ie - ue < te.storage && (Y += ie - ue), _e.__data = new Float32Array(te.storage / Float32Array.BYTES_PER_ELEMENT), _e.__offset = Y, Y += te.storage;
        }
      }
    }
    const k = Y % ie;
    return k > 0 && (Y += ie - k), F.__size = Y, F.__cache = {}, this;
  }
  function V(F) {
    const q = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof F == "number" || typeof F == "boolean" ? (q.boundary = 4, q.storage = 4) : F.isVector2 ? (q.boundary = 8, q.storage = 8) : F.isVector3 || F.isColor ? (q.boundary = 16, q.storage = 12) : F.isVector4 ? (q.boundary = 16, q.storage = 16) : F.isMatrix3 ? (q.boundary = 48, q.storage = 48) : F.isMatrix4 ? (q.boundary = 64, q.storage = 64) : F.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", F), q;
  }
  function G(F) {
    const q = F.target;
    q.removeEventListener("dispose", G);
    const Y = p.indexOf(q.__bindingPointIndex);
    p.splice(Y, 1), o.deleteBuffer(r[q.id]), delete r[q.id], delete d[q.id];
  }
  function N() {
    for (const F in r)
      o.deleteBuffer(r[F]);
    p = [], r = {}, d = {};
  }
  return {
    bind: _,
    update: E,
    dispose: N
  };
}
class tR {
  /**
   * Constructs a new WebGL renderer.
   *
   * @param {WebGLRenderer~Options} [parameters] - The configuration parameter.
   */
  constructor(e = {}) {
    const {
      canvas: t = pO(),
      context: a = null,
      depth: r = !0,
      stencil: d = !1,
      alpha: p = !1,
      antialias: y = !1,
      premultipliedAlpha: _ = !0,
      preserveDrawingBuffer: E = !1,
      powerPreference: T = "default",
      failIfMajorPerformanceCaveat: C = !1,
      reverseDepthBuffer: D = !1
    } = e;
    this.isWebGLRenderer = !0;
    let B;
    if (a !== null) {
      if (typeof WebGLRenderingContext < "u" && a instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      B = a.getContextAttributes().alpha;
    } else
      B = p;
    const z = new Uint32Array(4), V = new Int32Array(4);
    let G = null, N = null;
    const F = [], q = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled.
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = Yg, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
    const Y = this;
    let ie = !1;
    this._outputColorSpace = lf;
    let k = 0, le = 0, ne = null, Q = -1, j = null;
    const re = new Bi(), _e = new Bi();
    let me = null;
    const Ae = new hn(0);
    let He = 0, P = t.width, te = t.height, ae = 1, Se = null, ue = null;
    const we = new Bi(0, 0, P, te), De = new Bi(0, 0, P, te);
    let We = !1;
    const Me = new dE();
    let Ze = !1, ct = !1;
    const Vt = new ia(), Zt = new ia(), Bn = new ve(), rn = new Bi(), dn = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let Zn = !1;
    function Rn() {
      return ne === null ? ae : 1;
    }
    let Te = a;
    function Ha(ee, ye) {
      return t.getContext(ee, ye);
    }
    try {
      const ee = {
        alpha: !0,
        depth: r,
        stencil: d,
        antialias: y,
        premultipliedAlpha: _,
        preserveDrawingBuffer: E,
        powerPreference: T,
        failIfMajorPerformanceCaveat: C
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${T1}`), t.addEventListener("webglcontextlost", Ct, !1), t.addEventListener("webglcontextrestored", $t, !1), t.addEventListener("webglcontextcreationerror", tn, !1), Te === null) {
        const ye = "webgl2";
        if (Te = Ha(ye, ee), Te === null)
          throw Ha(ye) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (ee) {
      throw console.error("THREE.WebGLRenderer: " + ee.message), ee;
    }
    let Tt, St, Mt, kt, At, ce, se, Xe, dt, Et, yt, Jt, Xt, Wt, Vn, Pt, pn, gn, nn, jt, Ue, ot, Ht, xe;
    function Je() {
      Tt = new K8(Te), Tt.init(), ot = new pw(Te, Tt), St = new X8(Te, Tt, e, ot), Mt = new BG(Te, Tt), St.reverseDepthBuffer && D && Mt.buffers.depth.setReversed(!0), kt = new $8(Te), At = new gG(), ce = new UG(Te, Tt, Mt, At, St, ot, kt), se = new q8(Y), Xe = new J8(Y), dt = new lL(Te), Ht = new F8(Te, dt), Et = new k8(Te, dt, kt, Ht), yt = new t5(Te, Et, dt, kt), nn = new e5(Te, St, ce), Pt = new Y8(At), Jt = new vG(Y, se, Xe, Tt, St, Ht, Pt), Xt = new LG(Y, At), Wt = new SG(), Vn = new xG(Tt), gn = new V8(Y, se, Xe, Mt, yt, B, _), pn = new RG(Y, yt, St), xe = new GG(Te, kt, St, Mt), jt = new P8(Te, Tt, kt), Ue = new W8(Te, Tt, kt), kt.programs = Jt.programs, Y.capabilities = St, Y.extensions = Tt, Y.properties = At, Y.renderLists = Wt, Y.shadowMap = pn, Y.state = Mt, Y.info = kt;
    }
    Je();
    const tt = new zG(Y, Te);
    this.xr = tt, this.getContext = function() {
      return Te;
    }, this.getContextAttributes = function() {
      return Te.getContextAttributes();
    }, this.forceContextLoss = function() {
      const ee = Tt.get("WEBGL_lose_context");
      ee && ee.loseContext();
    }, this.forceContextRestore = function() {
      const ee = Tt.get("WEBGL_lose_context");
      ee && ee.restoreContext();
    }, this.getPixelRatio = function() {
      return ae;
    }, this.setPixelRatio = function(ee) {
      ee !== void 0 && (ae = ee, this.setSize(P, te, !1));
    }, this.getSize = function(ee) {
      return ee.set(P, te);
    }, this.setSize = function(ee, ye, Ee = !0) {
      if (tt.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      P = ee, te = ye, t.width = Math.floor(ee * ae), t.height = Math.floor(ye * ae), Ee === !0 && (t.style.width = ee + "px", t.style.height = ye + "px"), this.setViewport(0, 0, ee, ye);
    }, this.getDrawingBufferSize = function(ee) {
      return ee.set(P * ae, te * ae).floor();
    }, this.setDrawingBufferSize = function(ee, ye, Ee) {
      P = ee, te = ye, ae = Ee, t.width = Math.floor(ee * Ee), t.height = Math.floor(ye * Ee), this.setViewport(0, 0, ee, ye);
    }, this.getCurrentViewport = function(ee) {
      return ee.copy(re);
    }, this.getViewport = function(ee) {
      return ee.copy(we);
    }, this.setViewport = function(ee, ye, Ee, Re) {
      ee.isVector4 ? we.set(ee.x, ee.y, ee.z, ee.w) : we.set(ee, ye, Ee, Re), Mt.viewport(re.copy(we).multiplyScalar(ae).round());
    }, this.getScissor = function(ee) {
      return ee.copy(De);
    }, this.setScissor = function(ee, ye, Ee, Re) {
      ee.isVector4 ? De.set(ee.x, ee.y, ee.z, ee.w) : De.set(ee, ye, Ee, Re), Mt.scissor(_e.copy(De).multiplyScalar(ae).round());
    }, this.getScissorTest = function() {
      return We;
    }, this.setScissorTest = function(ee) {
      Mt.setScissorTest(We = ee);
    }, this.setOpaqueSort = function(ee) {
      Se = ee;
    }, this.setTransparentSort = function(ee) {
      ue = ee;
    }, this.getClearColor = function(ee) {
      return ee.copy(gn.getClearColor());
    }, this.setClearColor = function() {
      gn.setClearColor(...arguments);
    }, this.getClearAlpha = function() {
      return gn.getClearAlpha();
    }, this.setClearAlpha = function() {
      gn.setClearAlpha(...arguments);
    }, this.clear = function(ee = !0, ye = !0, Ee = !0) {
      let Re = 0;
      if (ee) {
        let Ie = !1;
        if (ne !== null) {
          const je = ne.texture.format;
          Ie = je === cx || je === ux || je === sE;
        }
        if (Ie) {
          const je = ne.texture.type, _t = je === qh || je === jg || je === kS || je === v1 || je === rx || je === ox, Ut = gn.getClearColor(), It = gn.getClearAlpha(), on = Ut.r, sn = Ut.g, Qt = Ut.b;
          _t ? (z[0] = on, z[1] = sn, z[2] = Qt, z[3] = It, Te.clearBufferuiv(Te.COLOR, 0, z)) : (V[0] = on, V[1] = sn, V[2] = Qt, V[3] = It, Te.clearBufferiv(Te.COLOR, 0, V));
        } else
          Re |= Te.COLOR_BUFFER_BIT;
      }
      ye && (Re |= Te.DEPTH_BUFFER_BIT), Ee && (Re |= Te.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Te.clear(Re);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Ct, !1), t.removeEventListener("webglcontextrestored", $t, !1), t.removeEventListener("webglcontextcreationerror", tn, !1), gn.dispose(), Wt.dispose(), Vn.dispose(), At.dispose(), se.dispose(), Xe.dispose(), yt.dispose(), Ht.dispose(), xe.dispose(), Jt.dispose(), tt.dispose(), tt.removeEventListener("sessionstart", Ui), tt.removeEventListener("sessionend", cl), Xl.stop();
    };
    function Ct(ee) {
      ee.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), ie = !0;
    }
    function $t() {
      console.log("THREE.WebGLRenderer: Context Restored."), ie = !1;
      const ee = kt.autoReset, ye = pn.enabled, Ee = pn.autoUpdate, Re = pn.needsUpdate, Ie = pn.type;
      Je(), kt.autoReset = ee, pn.enabled = ye, pn.autoUpdate = Ee, pn.needsUpdate = Re, pn.type = Ie;
    }
    function tn(ee) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", ee.statusMessage);
    }
    function Mn(ee) {
      const ye = ee.target;
      ye.removeEventListener("dispose", Mn), Wn(ye);
    }
    function Wn(ee) {
      Xa(ee), At.remove(ee);
    }
    function Xa(ee) {
      const ye = At.get(ee).programs;
      ye !== void 0 && (ye.forEach(function(Ee) {
        Jt.releaseProgram(Ee);
      }), ee.isShaderMaterial && Jt.releaseShaderCache(ee));
    }
    this.renderBufferDirect = function(ee, ye, Ee, Re, Ie, je) {
      ye === null && (ye = dn);
      const _t = Ie.isMesh && Ie.matrixWorld.determinant() < 0, Ut = Ne(ee, ye, Ee, Re, Ie);
      Mt.setMaterial(Re, _t);
      let It = Ee.index, on = 1;
      if (Re.wireframe === !0) {
        if (It = Et.getWireframeAttribute(Ee), It === void 0) return;
        on = 2;
      }
      const sn = Ee.drawRange, Qt = Ee.attributes.position;
      let bn = sn.start * on, En = (sn.start + sn.count) * on;
      je !== null && (bn = Math.max(bn, je.start * on), En = Math.min(En, (je.start + je.count) * on)), It !== null ? (bn = Math.max(bn, 0), En = Math.min(En, It.count)) : Qt != null && (bn = Math.max(bn, 0), En = Math.min(En, Qt.count));
      const ca = En - bn;
      if (ca < 0 || ca === 1 / 0) return;
      Ht.setup(Ie, Re, Ut, Ee, It);
      let yn, zn = jt;
      if (It !== null && (yn = dt.get(It), zn = Ue, zn.setIndex(yn)), Ie.isMesh)
        Re.wireframe === !0 ? (Mt.setLineWidth(Re.wireframeLinewidth * Rn()), zn.setMode(Te.LINES)) : zn.setMode(Te.TRIANGLES);
      else if (Ie.isLine) {
        let xn = Re.linewidth;
        xn === void 0 && (xn = 1), Mt.setLineWidth(xn * Rn()), Ie.isLineSegments ? zn.setMode(Te.LINES) : Ie.isLineLoop ? zn.setMode(Te.LINE_LOOP) : zn.setMode(Te.LINE_STRIP);
      } else Ie.isPoints ? zn.setMode(Te.POINTS) : Ie.isSprite && zn.setMode(Te.TRIANGLES);
      if (Ie.isBatchedMesh)
        if (Ie._multiDrawInstances !== null)
          lM("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), zn.renderMultiDrawInstances(Ie._multiDrawStarts, Ie._multiDrawCounts, Ie._multiDrawCount, Ie._multiDrawInstances);
        else if (Tt.get("WEBGL_multi_draw"))
          zn.renderMultiDraw(Ie._multiDrawStarts, Ie._multiDrawCounts, Ie._multiDrawCount);
        else {
          const xn = Ie._multiDrawStarts, si = Ie._multiDrawCounts, jn = Ie._multiDrawCount, ta = It ? dt.get(It).bytesPerElement : 1, Li = At.get(Re).currentProgram.getUniforms();
          for (let Qn = 0; Qn < jn; Qn++)
            Li.setValue(Te, "_gl_DrawID", Qn), zn.render(xn[Qn] / ta, si[Qn]);
        }
      else if (Ie.isInstancedMesh)
        zn.renderInstances(bn, ca, Ie.count);
      else if (Ee.isInstancedBufferGeometry) {
        const xn = Ee._maxInstanceCount !== void 0 ? Ee._maxInstanceCount : 1 / 0, si = Math.min(Ee.instanceCount, xn);
        zn.renderInstances(bn, ca, si);
      } else
        zn.render(bn, ca);
    };
    function sa(ee, ye, Ee) {
      ee.transparent === !0 && ee.side === Lp && ee.forceSinglePass === !1 ? (ee.side = ed, ee.needsUpdate = !0, li(ee, ye, Ee), ee.side = Zg, ee.needsUpdate = !0, li(ee, ye, Ee), ee.side = Lp) : li(ee, ye, Ee);
    }
    this.compile = function(ee, ye, Ee = null) {
      Ee === null && (Ee = ee), N = Vn.get(Ee), N.init(ye), q.push(N), Ee.traverseVisible(function(Ie) {
        Ie.isLight && Ie.layers.test(ye.layers) && (N.pushLight(Ie), Ie.castShadow && N.pushShadow(Ie));
      }), ee !== Ee && ee.traverseVisible(function(Ie) {
        Ie.isLight && Ie.layers.test(ye.layers) && (N.pushLight(Ie), Ie.castShadow && N.pushShadow(Ie));
      }), N.setupLights();
      const Re = /* @__PURE__ */ new Set();
      return ee.traverse(function(Ie) {
        if (!(Ie.isMesh || Ie.isPoints || Ie.isLine || Ie.isSprite))
          return;
        const je = Ie.material;
        if (je)
          if (Array.isArray(je))
            for (let _t = 0; _t < je.length; _t++) {
              const Ut = je[_t];
              sa(Ut, Ee, Ie), Re.add(Ut);
            }
          else
            sa(je, Ee, Ie), Re.add(je);
      }), N = q.pop(), Re;
    }, this.compileAsync = function(ee, ye, Ee = null) {
      const Re = this.compile(ee, ye, Ee);
      return new Promise((Ie) => {
        function je() {
          if (Re.forEach(function(_t) {
            At.get(_t).currentProgram.isReady() && Re.delete(_t);
          }), Re.size === 0) {
            Ie(ee);
            return;
          }
          setTimeout(je, 10);
        }
        Tt.get("KHR_parallel_shader_compile") !== null ? je() : setTimeout(je, 10);
      });
    };
    let ul = null;
    function xa(ee) {
      ul && ul(ee);
    }
    function Ui() {
      Xl.stop();
    }
    function cl() {
      Xl.start();
    }
    const Xl = new uw();
    Xl.setAnimationLoop(xa), typeof self < "u" && Xl.setContext(self), this.setAnimationLoop = function(ee) {
      ul = ee, tt.setAnimationLoop(ee), ee === null ? Xl.stop() : Xl.start();
    }, tt.addEventListener("sessionstart", Ui), tt.addEventListener("sessionend", cl), this.render = function(ee, ye) {
      if (ye !== void 0 && ye.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (ie === !0) return;
      if (ee.matrixWorldAutoUpdate === !0 && ee.updateMatrixWorld(), ye.parent === null && ye.matrixWorldAutoUpdate === !0 && ye.updateMatrixWorld(), tt.enabled === !0 && tt.isPresenting === !0 && (tt.cameraAutoUpdate === !0 && tt.updateCamera(ye), ye = tt.getCamera()), ee.isScene === !0 && ee.onBeforeRender(Y, ee, ye, ne), N = Vn.get(ee, q.length), N.init(ye), q.push(N), Zt.multiplyMatrices(ye.projectionMatrix, ye.matrixWorldInverse), Me.setFromProjectionMatrix(Zt), ct = this.localClippingEnabled, Ze = Pt.init(this.clippingPlanes, ct), G = Wt.get(ee, F.length), G.init(), F.push(G), tt.enabled === !0 && tt.isPresenting === !0) {
        const je = Y.xr.getDepthSensingMesh();
        je !== null && Ws(je, ye, -1 / 0, Y.sortObjects);
      }
      Ws(ee, ye, 0, Y.sortObjects), G.finish(), Y.sortObjects === !0 && G.sort(Se, ue), Zn = tt.enabled === !1 || tt.isPresenting === !1 || tt.hasDepthSensing() === !1, Zn && gn.addToRenderList(G, ee), this.info.render.frame++, Ze === !0 && Pt.beginShadows();
      const Ee = N.state.shadowsArray;
      pn.render(Ee, ee, ye), Ze === !0 && Pt.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const Re = G.opaque, Ie = G.transmissive;
      if (N.setupLights(), ye.isArrayCamera) {
        const je = ye.cameras;
        if (Ie.length > 0)
          for (let _t = 0, Ut = je.length; _t < Ut; _t++) {
            const It = je[_t];
            zl(Re, Ie, ee, It);
          }
        Zn && gn.render(ee);
        for (let _t = 0, Ut = je.length; _t < Ut; _t++) {
          const It = je[_t];
          lu(G, ee, It, It.viewport);
        }
      } else
        Ie.length > 0 && zl(Re, Ie, ee, ye), Zn && gn.render(ee), lu(G, ee, ye);
      ne !== null && le === 0 && (ce.updateMultisampleRenderTarget(ne), ce.updateRenderTargetMipmap(ne)), ee.isScene === !0 && ee.onAfterRender(Y, ee, ye), Ht.resetDefaultState(), Q = -1, j = null, q.pop(), q.length > 0 ? (N = q[q.length - 1], Ze === !0 && Pt.setGlobalState(Y.clippingPlanes, N.state.camera)) : N = null, F.pop(), F.length > 0 ? G = F[F.length - 1] : G = null;
    };
    function Ws(ee, ye, Ee, Re) {
      if (ee.visible === !1) return;
      if (ee.layers.test(ye.layers)) {
        if (ee.isGroup)
          Ee = ee.renderOrder;
        else if (ee.isLOD)
          ee.autoUpdate === !0 && ee.update(ye);
        else if (ee.isLight)
          N.pushLight(ee), ee.castShadow && N.pushShadow(ee);
        else if (ee.isSprite) {
          if (!ee.frustumCulled || Me.intersectsSprite(ee)) {
            Re && rn.setFromMatrixPosition(ee.matrixWorld).applyMatrix4(Zt);
            const _t = yt.update(ee), Ut = ee.material;
            Ut.visible && G.push(ee, _t, Ut, Ee, rn.z, null);
          }
        } else if ((ee.isMesh || ee.isLine || ee.isPoints) && (!ee.frustumCulled || Me.intersectsObject(ee))) {
          const _t = yt.update(ee), Ut = ee.material;
          if (Re && (ee.boundingSphere !== void 0 ? (ee.boundingSphere === null && ee.computeBoundingSphere(), rn.copy(ee.boundingSphere.center)) : (_t.boundingSphere === null && _t.computeBoundingSphere(), rn.copy(_t.boundingSphere.center)), rn.applyMatrix4(ee.matrixWorld).applyMatrix4(Zt)), Array.isArray(Ut)) {
            const It = _t.groups;
            for (let on = 0, sn = It.length; on < sn; on++) {
              const Qt = It[on], bn = Ut[Qt.materialIndex];
              bn && bn.visible && G.push(ee, _t, bn, Ee, rn.z, Qt);
            }
          } else Ut.visible && G.push(ee, _t, Ut, Ee, rn.z, null);
        }
      }
      const je = ee.children;
      for (let _t = 0, Ut = je.length; _t < Ut; _t++)
        Ws(je[_t], ye, Ee, Re);
    }
    function lu(ee, ye, Ee, Re) {
      const Ie = ee.opaque, je = ee.transmissive, _t = ee.transparent;
      N.setupLightsView(Ee), Ze === !0 && Pt.setGlobalState(Y.clippingPlanes, Ee), Re && Mt.viewport(re.copy(Re)), Ie.length > 0 && Jn(Ie, ye, Ee), je.length > 0 && Jn(je, ye, Ee), _t.length > 0 && Jn(_t, ye, Ee), Mt.buffers.depth.setTest(!0), Mt.buffers.depth.setMask(!0), Mt.buffers.color.setMask(!0), Mt.setPolygonOffset(!1);
    }
    function zl(ee, ye, Ee, Re) {
      if ((Ee.isScene === !0 ? Ee.overrideMaterial : null) !== null)
        return;
      N.state.transmissionRenderTarget[Re.id] === void 0 && (N.state.transmissionRenderTarget[Re.id] = new uf(1, 1, {
        generateMipmaps: !0,
        type: Tt.has("EXT_color_buffer_half_float") || Tt.has("EXT_color_buffer_float") ? au : qh,
        minFilter: qm,
        samples: 4,
        stencilBuffer: d,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: wi.workingColorSpace
      }));
      const je = N.state.transmissionRenderTarget[Re.id], _t = Re.viewport || re;
      je.setSize(_t.z * Y.transmissionResolutionScale, _t.w * Y.transmissionResolutionScale);
      const Ut = Y.getRenderTarget();
      Y.setRenderTarget(je), Y.getClearColor(Ae), He = Y.getClearAlpha(), He < 1 && Y.setClearColor(16777215, 0.5), Y.clear(), Zn && gn.render(Ee);
      const It = Y.toneMapping;
      Y.toneMapping = Yg;
      const on = Re.viewport;
      if (Re.viewport !== void 0 && (Re.viewport = void 0), N.setupLightsView(Re), Ze === !0 && Pt.setGlobalState(Y.clippingPlanes, Re), Jn(ee, Ee, Re), ce.updateMultisampleRenderTarget(je), ce.updateRenderTargetMipmap(je), Tt.has("WEBGL_multisampled_render_to_texture") === !1) {
        let sn = !1;
        for (let Qt = 0, bn = ye.length; Qt < bn; Qt++) {
          const En = ye[Qt], ca = En.object, yn = En.geometry, zn = En.material, xn = En.group;
          if (zn.side === Lp && ca.layers.test(Re.layers)) {
            const si = zn.side;
            zn.side = ed, zn.needsUpdate = !0, un(ca, Ee, Re, yn, zn, xn), zn.side = si, zn.needsUpdate = !0, sn = !0;
          }
        }
        sn === !0 && (ce.updateMultisampleRenderTarget(je), ce.updateRenderTargetMipmap(je));
      }
      Y.setRenderTarget(Ut), Y.setClearColor(Ae, He), on !== void 0 && (Re.viewport = on), Y.toneMapping = It;
    }
    function Jn(ee, ye, Ee) {
      const Re = ye.isScene === !0 ? ye.overrideMaterial : null;
      for (let Ie = 0, je = ee.length; Ie < je; Ie++) {
        const _t = ee[Ie], Ut = _t.object, It = _t.geometry, on = _t.group;
        let sn = _t.material;
        sn.allowOverride === !0 && Re !== null && (sn = Re), Ut.layers.test(Ee.layers) && un(Ut, ye, Ee, It, sn, on);
      }
    }
    function un(ee, ye, Ee, Re, Ie, je) {
      ee.onBeforeRender(Y, ye, Ee, Re, Ie, je), ee.modelViewMatrix.multiplyMatrices(Ee.matrixWorldInverse, ee.matrixWorld), ee.normalMatrix.getNormalMatrix(ee.modelViewMatrix), Ie.onBeforeRender(Y, ye, Ee, Re, ee, je), Ie.transparent === !0 && Ie.side === Lp && Ie.forceSinglePass === !1 ? (Ie.side = ed, Ie.needsUpdate = !0, Y.renderBufferDirect(Ee, ye, Re, Ie, ee, je), Ie.side = Zg, Ie.needsUpdate = !0, Y.renderBufferDirect(Ee, ye, Re, Ie, ee, je), Ie.side = Lp) : Y.renderBufferDirect(Ee, ye, Re, Ie, ee, je), ee.onAfterRender(Y, ye, Ee, Re, Ie, je);
    }
    function li(ee, ye, Ee) {
      ye.isScene !== !0 && (ye = dn);
      const Re = At.get(ee), Ie = N.state.lights, je = N.state.shadowsArray, _t = Ie.state.version, Ut = Jt.getParameters(ee, Ie.state, je, ye, Ee), It = Jt.getProgramCacheKey(Ut);
      let on = Re.programs;
      Re.environment = ee.isMeshStandardMaterial ? ye.environment : null, Re.fog = ye.fog, Re.envMap = (ee.isMeshStandardMaterial ? Xe : se).get(ee.envMap || Re.environment), Re.envMapRotation = Re.environment !== null && ee.envMap === null ? ye.environmentRotation : ee.envMapRotation, on === void 0 && (ee.addEventListener("dispose", Mn), on = /* @__PURE__ */ new Map(), Re.programs = on);
      let sn = on.get(It);
      if (sn !== void 0) {
        if (Re.currentProgram === sn && Re.lightsStateVersion === _t)
          return pe(ee, Ut), sn;
      } else
        Ut.uniforms = Jt.getUniforms(ee), ee.onBeforeCompile(Ut, Y), sn = Jt.acquireProgram(Ut, It), on.set(It, sn), Re.uniforms = Ut.uniforms;
      const Qt = Re.uniforms;
      return (!ee.isShaderMaterial && !ee.isRawShaderMaterial || ee.clipping === !0) && (Qt.clippingPlanes = Pt.uniform), pe(ee, Ut), Re.needsLights = nt(ee), Re.lightsStateVersion = _t, Re.needsLights && (Qt.ambientLightColor.value = Ie.state.ambient, Qt.lightProbe.value = Ie.state.probe, Qt.directionalLights.value = Ie.state.directional, Qt.directionalLightShadows.value = Ie.state.directionalShadow, Qt.spotLights.value = Ie.state.spot, Qt.spotLightShadows.value = Ie.state.spotShadow, Qt.rectAreaLights.value = Ie.state.rectArea, Qt.ltc_1.value = Ie.state.rectAreaLTC1, Qt.ltc_2.value = Ie.state.rectAreaLTC2, Qt.pointLights.value = Ie.state.point, Qt.pointLightShadows.value = Ie.state.pointShadow, Qt.hemisphereLights.value = Ie.state.hemi, Qt.directionalShadowMap.value = Ie.state.directionalShadowMap, Qt.directionalShadowMatrix.value = Ie.state.directionalShadowMatrix, Qt.spotShadowMap.value = Ie.state.spotShadowMap, Qt.spotLightMatrix.value = Ie.state.spotLightMatrix, Qt.spotLightMap.value = Ie.state.spotLightMap, Qt.pointShadowMap.value = Ie.state.pointShadowMap, Qt.pointShadowMatrix.value = Ie.state.pointShadowMatrix), Re.currentProgram = sn, Re.uniformsList = null, sn;
    }
    function $(ee) {
      if (ee.uniformsList === null) {
        const ye = ee.currentProgram.getUniforms();
        ee.uniformsList = rM.seqWithValue(ye.seq, ee.uniforms);
      }
      return ee.uniformsList;
    }
    function pe(ee, ye) {
      const Ee = At.get(ee);
      Ee.outputColorSpace = ye.outputColorSpace, Ee.batching = ye.batching, Ee.batchingColor = ye.batchingColor, Ee.instancing = ye.instancing, Ee.instancingColor = ye.instancingColor, Ee.instancingMorph = ye.instancingMorph, Ee.skinning = ye.skinning, Ee.morphTargets = ye.morphTargets, Ee.morphNormals = ye.morphNormals, Ee.morphColors = ye.morphColors, Ee.morphTargetsCount = ye.morphTargetsCount, Ee.numClippingPlanes = ye.numClippingPlanes, Ee.numIntersection = ye.numClipIntersection, Ee.vertexAlphas = ye.vertexAlphas, Ee.vertexTangents = ye.vertexTangents, Ee.toneMapping = ye.toneMapping;
    }
    function Ne(ee, ye, Ee, Re, Ie) {
      ye.isScene !== !0 && (ye = dn), ce.resetTextureUnits();
      const je = ye.fog, _t = Re.isMeshStandardMaterial ? ye.environment : null, Ut = ne === null ? Y.outputColorSpace : ne.isXRRenderTarget === !0 ? ne.texture.colorSpace : Kv, It = (Re.isMeshStandardMaterial ? Xe : se).get(Re.envMap || _t), on = Re.vertexColors === !0 && !!Ee.attributes.color && Ee.attributes.color.itemSize === 4, sn = !!Ee.attributes.tangent && (!!Re.normalMap || Re.anisotropy > 0), Qt = !!Ee.morphAttributes.position, bn = !!Ee.morphAttributes.normal, En = !!Ee.morphAttributes.color;
      let ca = Yg;
      Re.toneMapped && (ne === null || ne.isXRRenderTarget === !0) && (ca = Y.toneMapping);
      const yn = Ee.morphAttributes.position || Ee.morphAttributes.normal || Ee.morphAttributes.color, zn = yn !== void 0 ? yn.length : 0, xn = At.get(Re), si = N.state.lights;
      if (Ze === !0 && (ct === !0 || ee !== j)) {
        const Ei = ee === j && Re.id === Q;
        Pt.setState(Re, ee, Ei);
      }
      let jn = !1;
      Re.version === xn.__version ? (xn.needsLights && xn.lightsStateVersion !== si.state.version || xn.outputColorSpace !== Ut || Ie.isBatchedMesh && xn.batching === !1 || !Ie.isBatchedMesh && xn.batching === !0 || Ie.isBatchedMesh && xn.batchingColor === !0 && Ie.colorTexture === null || Ie.isBatchedMesh && xn.batchingColor === !1 && Ie.colorTexture !== null || Ie.isInstancedMesh && xn.instancing === !1 || !Ie.isInstancedMesh && xn.instancing === !0 || Ie.isSkinnedMesh && xn.skinning === !1 || !Ie.isSkinnedMesh && xn.skinning === !0 || Ie.isInstancedMesh && xn.instancingColor === !0 && Ie.instanceColor === null || Ie.isInstancedMesh && xn.instancingColor === !1 && Ie.instanceColor !== null || Ie.isInstancedMesh && xn.instancingMorph === !0 && Ie.morphTexture === null || Ie.isInstancedMesh && xn.instancingMorph === !1 && Ie.morphTexture !== null || xn.envMap !== It || Re.fog === !0 && xn.fog !== je || xn.numClippingPlanes !== void 0 && (xn.numClippingPlanes !== Pt.numPlanes || xn.numIntersection !== Pt.numIntersection) || xn.vertexAlphas !== on || xn.vertexTangents !== sn || xn.morphTargets !== Qt || xn.morphNormals !== bn || xn.morphColors !== En || xn.toneMapping !== ca || xn.morphTargetsCount !== zn) && (jn = !0) : (jn = !0, xn.__version = Re.version);
      let ta = xn.currentProgram;
      jn === !0 && (ta = li(Re, ye, Ie));
      let Li = !1, Qn = !1, Ta = !1;
      const da = ta.getUniforms(), qi = xn.uniforms;
      if (Mt.useProgram(ta.program) && (Li = !0, Qn = !0, Ta = !0), Re.id !== Q && (Q = Re.id, Qn = !0), Li || j !== ee) {
        Mt.buffers.depth.getReversed() ? (Vt.copy(ee.projectionMatrix), Oz(Vt), wz(Vt), da.setValue(Te, "projectionMatrix", Vt)) : da.setValue(Te, "projectionMatrix", ee.projectionMatrix), da.setValue(Te, "viewMatrix", ee.matrixWorldInverse);
        const Wi = da.map.cameraPosition;
        Wi !== void 0 && Wi.setValue(Te, Bn.setFromMatrixPosition(ee.matrixWorld)), St.logarithmicDepthBuffer && da.setValue(
          Te,
          "logDepthBufFC",
          2 / (Math.log(ee.far + 1) / Math.LN2)
        ), (Re.isMeshPhongMaterial || Re.isMeshToonMaterial || Re.isMeshLambertMaterial || Re.isMeshBasicMaterial || Re.isMeshStandardMaterial || Re.isShaderMaterial) && da.setValue(Te, "isOrthographic", ee.isOrthographicCamera === !0), j !== ee && (j = ee, Qn = !0, Ta = !0);
      }
      if (Ie.isSkinnedMesh) {
        da.setOptional(Te, Ie, "bindMatrix"), da.setOptional(Te, Ie, "bindMatrixInverse");
        const Ei = Ie.skeleton;
        Ei && (Ei.boneTexture === null && Ei.computeBoneTexture(), da.setValue(Te, "boneTexture", Ei.boneTexture, ce));
      }
      Ie.isBatchedMesh && (da.setOptional(Te, Ie, "batchingTexture"), da.setValue(Te, "batchingTexture", Ie._matricesTexture, ce), da.setOptional(Te, Ie, "batchingIdTexture"), da.setValue(Te, "batchingIdTexture", Ie._indirectTexture, ce), da.setOptional(Te, Ie, "batchingColorTexture"), Ie._colorsTexture !== null && da.setValue(Te, "batchingColorTexture", Ie._colorsTexture, ce));
      const Ya = Ee.morphAttributes;
      if ((Ya.position !== void 0 || Ya.normal !== void 0 || Ya.color !== void 0) && nn.update(Ie, Ee, ta), (Qn || xn.receiveShadow !== Ie.receiveShadow) && (xn.receiveShadow = Ie.receiveShadow, da.setValue(Te, "receiveShadow", Ie.receiveShadow)), Re.isMeshGouraudMaterial && Re.envMap !== null && (qi.envMap.value = It, qi.flipEnvMap.value = It.isCubeTexture && It.isRenderTargetTexture === !1 ? -1 : 1), Re.isMeshStandardMaterial && Re.envMap === null && ye.environment !== null && (qi.envMapIntensity.value = ye.environmentIntensity), Qn && (da.setValue(Te, "toneMappingExposure", Y.toneMappingExposure), xn.needsLights && $e(qi, Ta), je && Re.fog === !0 && Xt.refreshFogUniforms(qi, je), Xt.refreshMaterialUniforms(qi, Re, ae, te, N.state.transmissionRenderTarget[ee.id]), rM.upload(Te, $(xn), qi, ce)), Re.isShaderMaterial && Re.uniformsNeedUpdate === !0 && (rM.upload(Te, $(xn), qi, ce), Re.uniformsNeedUpdate = !1), Re.isSpriteMaterial && da.setValue(Te, "center", Ie.center), da.setValue(Te, "modelViewMatrix", Ie.modelViewMatrix), da.setValue(Te, "normalMatrix", Ie.normalMatrix), da.setValue(Te, "modelMatrix", Ie.matrixWorld), Re.isShaderMaterial || Re.isRawShaderMaterial) {
        const Ei = Re.uniformsGroups;
        for (let Wi = 0, Hl = Ei.length; Wi < Hl; Wi++) {
          const Pr = Ei[Wi];
          xe.update(Pr, ta), xe.bind(Pr, ta);
        }
      }
      return ta;
    }
    function $e(ee, ye) {
      ee.ambientLightColor.needsUpdate = ye, ee.lightProbe.needsUpdate = ye, ee.directionalLights.needsUpdate = ye, ee.directionalLightShadows.needsUpdate = ye, ee.pointLights.needsUpdate = ye, ee.pointLightShadows.needsUpdate = ye, ee.spotLights.needsUpdate = ye, ee.spotLightShadows.needsUpdate = ye, ee.rectAreaLights.needsUpdate = ye, ee.hemisphereLights.needsUpdate = ye;
    }
    function nt(ee) {
      return ee.isMeshLambertMaterial || ee.isMeshToonMaterial || ee.isMeshPhongMaterial || ee.isMeshStandardMaterial || ee.isShadowMaterial || ee.isShaderMaterial && ee.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return k;
    }, this.getActiveMipmapLevel = function() {
      return le;
    }, this.getRenderTarget = function() {
      return ne;
    }, this.setRenderTargetTextures = function(ee, ye, Ee) {
      const Re = At.get(ee);
      Re.__autoAllocateDepthBuffer = ee.resolveDepthBuffer === !1, Re.__autoAllocateDepthBuffer === !1 && (Re.__useRenderToTexture = !1), At.get(ee.texture).__webglTexture = ye, At.get(ee.depthTexture).__webglTexture = Re.__autoAllocateDepthBuffer ? void 0 : Ee, Re.__hasExternalTextures = !0;
    }, this.setRenderTargetFramebuffer = function(ee, ye) {
      const Ee = At.get(ee);
      Ee.__webglFramebuffer = ye, Ee.__useDefaultFramebuffer = ye === void 0;
    };
    const pt = Te.createFramebuffer();
    this.setRenderTarget = function(ee, ye = 0, Ee = 0) {
      ne = ee, k = ye, le = Ee;
      let Re = !0, Ie = null, je = !1, _t = !1;
      if (ee) {
        const It = At.get(ee);
        if (It.__useDefaultFramebuffer !== void 0)
          Mt.bindFramebuffer(Te.FRAMEBUFFER, null), Re = !1;
        else if (It.__webglFramebuffer === void 0)
          ce.setupRenderTarget(ee);
        else if (It.__hasExternalTextures)
          ce.rebindTextures(ee, At.get(ee.texture).__webglTexture, At.get(ee.depthTexture).__webglTexture);
        else if (ee.depthBuffer) {
          const Qt = ee.depthTexture;
          if (It.__boundDepthTexture !== Qt) {
            if (Qt !== null && At.has(Qt) && (ee.width !== Qt.image.width || ee.height !== Qt.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            ce.setupDepthRenderbuffer(ee);
          }
        }
        const on = ee.texture;
        (on.isData3DTexture || on.isDataArrayTexture || on.isCompressedArrayTexture) && (_t = !0);
        const sn = At.get(ee).__webglFramebuffer;
        ee.isWebGLCubeRenderTarget ? (Array.isArray(sn[ye]) ? Ie = sn[ye][Ee] : Ie = sn[ye], je = !0) : ee.samples > 0 && ce.useMultisampledRTT(ee) === !1 ? Ie = At.get(ee).__webglMultisampledFramebuffer : Array.isArray(sn) ? Ie = sn[Ee] : Ie = sn, re.copy(ee.viewport), _e.copy(ee.scissor), me = ee.scissorTest;
      } else
        re.copy(we).multiplyScalar(ae).floor(), _e.copy(De).multiplyScalar(ae).floor(), me = We;
      if (Ee !== 0 && (Ie = pt), Mt.bindFramebuffer(Te.FRAMEBUFFER, Ie) && Re && Mt.drawBuffers(ee, Ie), Mt.viewport(re), Mt.scissor(_e), Mt.setScissorTest(me), je) {
        const It = At.get(ee.texture);
        Te.framebufferTexture2D(Te.FRAMEBUFFER, Te.COLOR_ATTACHMENT0, Te.TEXTURE_CUBE_MAP_POSITIVE_X + ye, It.__webglTexture, Ee);
      } else if (_t) {
        const It = At.get(ee.texture), on = ye;
        Te.framebufferTextureLayer(Te.FRAMEBUFFER, Te.COLOR_ATTACHMENT0, It.__webglTexture, Ee, on);
      } else if (ee !== null && Ee !== 0) {
        const It = At.get(ee.texture);
        Te.framebufferTexture2D(Te.FRAMEBUFFER, Te.COLOR_ATTACHMENT0, Te.TEXTURE_2D, It.__webglTexture, Ee);
      }
      Q = -1;
    }, this.readRenderTargetPixels = function(ee, ye, Ee, Re, Ie, je, _t) {
      if (!(ee && ee.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Ut = At.get(ee).__webglFramebuffer;
      if (ee.isWebGLCubeRenderTarget && _t !== void 0 && (Ut = Ut[_t]), Ut) {
        Mt.bindFramebuffer(Te.FRAMEBUFFER, Ut);
        try {
          const It = ee.texture, on = It.format, sn = It.type;
          if (!St.textureFormatReadable(on)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!St.textureTypeReadable(sn)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          ye >= 0 && ye <= ee.width - Re && Ee >= 0 && Ee <= ee.height - Ie && Te.readPixels(ye, Ee, Re, Ie, ot.convert(on), ot.convert(sn), je);
        } finally {
          const It = ne !== null ? At.get(ne).__webglFramebuffer : null;
          Mt.bindFramebuffer(Te.FRAMEBUFFER, It);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(ee, ye, Ee, Re, Ie, je, _t) {
      if (!(ee && ee.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Ut = At.get(ee).__webglFramebuffer;
      if (ee.isWebGLCubeRenderTarget && _t !== void 0 && (Ut = Ut[_t]), Ut)
        if (ye >= 0 && ye <= ee.width - Re && Ee >= 0 && Ee <= ee.height - Ie) {
          Mt.bindFramebuffer(Te.FRAMEBUFFER, Ut);
          const It = ee.texture, on = It.format, sn = It.type;
          if (!St.textureFormatReadable(on))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
          if (!St.textureTypeReadable(sn))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
          const Qt = Te.createBuffer();
          Te.bindBuffer(Te.PIXEL_PACK_BUFFER, Qt), Te.bufferData(Te.PIXEL_PACK_BUFFER, je.byteLength, Te.STREAM_READ), Te.readPixels(ye, Ee, Re, Ie, ot.convert(on), ot.convert(sn), 0);
          const bn = ne !== null ? At.get(ne).__webglFramebuffer : null;
          Mt.bindFramebuffer(Te.FRAMEBUFFER, bn);
          const En = Te.fenceSync(Te.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return Te.flush(), await Uz(Te, En, 4), Te.bindBuffer(Te.PIXEL_PACK_BUFFER, Qt), Te.getBufferSubData(Te.PIXEL_PACK_BUFFER, 0, je), Te.deleteBuffer(Qt), Te.deleteSync(En), je;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
    }, this.copyFramebufferToTexture = function(ee, ye = null, Ee = 0) {
      const Re = Math.pow(2, -Ee), Ie = Math.floor(ee.image.width * Re), je = Math.floor(ee.image.height * Re), _t = ye !== null ? ye.x : 0, Ut = ye !== null ? ye.y : 0;
      ce.setTexture2D(ee, 0), Te.copyTexSubImage2D(Te.TEXTURE_2D, Ee, 0, 0, _t, Ut, Ie, je), Mt.unbindTexture();
    };
    const Ft = Te.createFramebuffer(), Gt = Te.createFramebuffer();
    this.copyTextureToTexture = function(ee, ye, Ee = null, Re = null, Ie = 0, je = null) {
      je === null && (Ie !== 0 ? (lM("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), je = Ie, Ie = 0) : je = 0);
      let _t, Ut, It, on, sn, Qt, bn, En, ca;
      const yn = ee.isCompressedTexture ? ee.mipmaps[je] : ee.image;
      if (Ee !== null)
        _t = Ee.max.x - Ee.min.x, Ut = Ee.max.y - Ee.min.y, It = Ee.isBox3 ? Ee.max.z - Ee.min.z : 1, on = Ee.min.x, sn = Ee.min.y, Qt = Ee.isBox3 ? Ee.min.z : 0;
      else {
        const Ya = Math.pow(2, -Ie);
        _t = Math.floor(yn.width * Ya), Ut = Math.floor(yn.height * Ya), ee.isDataArrayTexture ? It = yn.depth : ee.isData3DTexture ? It = Math.floor(yn.depth * Ya) : It = 1, on = 0, sn = 0, Qt = 0;
      }
      Re !== null ? (bn = Re.x, En = Re.y, ca = Re.z) : (bn = 0, En = 0, ca = 0);
      const zn = ot.convert(ye.format), xn = ot.convert(ye.type);
      let si;
      ye.isData3DTexture ? (ce.setTexture3D(ye, 0), si = Te.TEXTURE_3D) : ye.isDataArrayTexture || ye.isCompressedArrayTexture ? (ce.setTexture2DArray(ye, 0), si = Te.TEXTURE_2D_ARRAY) : (ce.setTexture2D(ye, 0), si = Te.TEXTURE_2D), Te.pixelStorei(Te.UNPACK_FLIP_Y_WEBGL, ye.flipY), Te.pixelStorei(Te.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ye.premultiplyAlpha), Te.pixelStorei(Te.UNPACK_ALIGNMENT, ye.unpackAlignment);
      const jn = Te.getParameter(Te.UNPACK_ROW_LENGTH), ta = Te.getParameter(Te.UNPACK_IMAGE_HEIGHT), Li = Te.getParameter(Te.UNPACK_SKIP_PIXELS), Qn = Te.getParameter(Te.UNPACK_SKIP_ROWS), Ta = Te.getParameter(Te.UNPACK_SKIP_IMAGES);
      Te.pixelStorei(Te.UNPACK_ROW_LENGTH, yn.width), Te.pixelStorei(Te.UNPACK_IMAGE_HEIGHT, yn.height), Te.pixelStorei(Te.UNPACK_SKIP_PIXELS, on), Te.pixelStorei(Te.UNPACK_SKIP_ROWS, sn), Te.pixelStorei(Te.UNPACK_SKIP_IMAGES, Qt);
      const da = ee.isDataArrayTexture || ee.isData3DTexture, qi = ye.isDataArrayTexture || ye.isData3DTexture;
      if (ee.isDepthTexture) {
        const Ya = At.get(ee), Ei = At.get(ye), Wi = At.get(Ya.__renderTarget), Hl = At.get(Ei.__renderTarget);
        Mt.bindFramebuffer(Te.READ_FRAMEBUFFER, Wi.__webglFramebuffer), Mt.bindFramebuffer(Te.DRAW_FRAMEBUFFER, Hl.__webglFramebuffer);
        for (let Pr = 0; Pr < It; Pr++)
          da && (Te.framebufferTextureLayer(Te.READ_FRAMEBUFFER, Te.COLOR_ATTACHMENT0, At.get(ee).__webglTexture, Ie, Qt + Pr), Te.framebufferTextureLayer(Te.DRAW_FRAMEBUFFER, Te.COLOR_ATTACHMENT0, At.get(ye).__webglTexture, je, ca + Pr)), Te.blitFramebuffer(on, sn, _t, Ut, bn, En, _t, Ut, Te.DEPTH_BUFFER_BIT, Te.NEAREST);
        Mt.bindFramebuffer(Te.READ_FRAMEBUFFER, null), Mt.bindFramebuffer(Te.DRAW_FRAMEBUFFER, null);
      } else if (Ie !== 0 || ee.isRenderTargetTexture || At.has(ee)) {
        const Ya = At.get(ee), Ei = At.get(ye);
        Mt.bindFramebuffer(Te.READ_FRAMEBUFFER, Ft), Mt.bindFramebuffer(Te.DRAW_FRAMEBUFFER, Gt);
        for (let Wi = 0; Wi < It; Wi++)
          da ? Te.framebufferTextureLayer(Te.READ_FRAMEBUFFER, Te.COLOR_ATTACHMENT0, Ya.__webglTexture, Ie, Qt + Wi) : Te.framebufferTexture2D(Te.READ_FRAMEBUFFER, Te.COLOR_ATTACHMENT0, Te.TEXTURE_2D, Ya.__webglTexture, Ie), qi ? Te.framebufferTextureLayer(Te.DRAW_FRAMEBUFFER, Te.COLOR_ATTACHMENT0, Ei.__webglTexture, je, ca + Wi) : Te.framebufferTexture2D(Te.DRAW_FRAMEBUFFER, Te.COLOR_ATTACHMENT0, Te.TEXTURE_2D, Ei.__webglTexture, je), Ie !== 0 ? Te.blitFramebuffer(on, sn, _t, Ut, bn, En, _t, Ut, Te.COLOR_BUFFER_BIT, Te.NEAREST) : qi ? Te.copyTexSubImage3D(si, je, bn, En, ca + Wi, on, sn, _t, Ut) : Te.copyTexSubImage2D(si, je, bn, En, on, sn, _t, Ut);
        Mt.bindFramebuffer(Te.READ_FRAMEBUFFER, null), Mt.bindFramebuffer(Te.DRAW_FRAMEBUFFER, null);
      } else
        qi ? ee.isDataTexture || ee.isData3DTexture ? Te.texSubImage3D(si, je, bn, En, ca, _t, Ut, It, zn, xn, yn.data) : ye.isCompressedArrayTexture ? Te.compressedTexSubImage3D(si, je, bn, En, ca, _t, Ut, It, zn, yn.data) : Te.texSubImage3D(si, je, bn, En, ca, _t, Ut, It, zn, xn, yn) : ee.isDataTexture ? Te.texSubImage2D(Te.TEXTURE_2D, je, bn, En, _t, Ut, zn, xn, yn.data) : ee.isCompressedTexture ? Te.compressedTexSubImage2D(Te.TEXTURE_2D, je, bn, En, yn.width, yn.height, zn, yn.data) : Te.texSubImage2D(Te.TEXTURE_2D, je, bn, En, _t, Ut, zn, xn, yn);
      Te.pixelStorei(Te.UNPACK_ROW_LENGTH, jn), Te.pixelStorei(Te.UNPACK_IMAGE_HEIGHT, ta), Te.pixelStorei(Te.UNPACK_SKIP_PIXELS, Li), Te.pixelStorei(Te.UNPACK_SKIP_ROWS, Qn), Te.pixelStorei(Te.UNPACK_SKIP_IMAGES, Ta), je === 0 && ye.generateMipmaps && Te.generateMipmap(si), Mt.unbindTexture();
    }, this.copyTextureToTexture3D = function(ee, ye, Ee = null, Re = null, Ie = 0) {
      return lM('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(ee, ye, Ee, Re, Ie);
    }, this.initRenderTarget = function(ee) {
      At.get(ee).__webglFramebuffer === void 0 && ce.setupRenderTarget(ee);
    }, this.initTexture = function(ee) {
      ee.isCubeTexture ? ce.setTextureCube(ee, 0) : ee.isData3DTexture ? ce.setTexture3D(ee, 0) : ee.isDataArrayTexture || ee.isCompressedArrayTexture ? ce.setTexture2DArray(ee, 0) : ce.setTexture2D(ee, 0), Mt.unbindTexture();
    }, this.resetState = function() {
      k = 0, le = 0, ne = null, Mt.reset(), Ht.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  /**
   * Defines the coordinate system of the renderer.
   *
   * In `WebGLRenderer`, the value is always `WebGLCoordinateSystem`.
   *
   * @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}
   * @default WebGLCoordinateSystem
   * @readonly
   */
  get coordinateSystem() {
    return Qv;
  }
  /**
   * Defines the output color space of the renderer.
   *
   * @type {SRGBColorSpace|LinearSRGBColorSpace}
   * @default SRGBColorSpace
   */
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = wi._getDrawingBufferColorSpace(e), t.unpackColorSpace = wi._getUnpackColorSpace();
  }
}
const IG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: d2,
  AddEquation: I0,
  AddOperation: qU,
  AdditiveAnimationBlendMode: _2,
  AdditiveBlending: cM,
  AgXToneMapping: KU,
  AlphaFormat: p2,
  AlwaysCompare: dO,
  AlwaysDepth: pM,
  AlwaysStencilFunc: ZC,
  AmbientLight: kO,
  AnimationAction: rw,
  AnimationClip: M1,
  AnimationLoader: a4,
  AnimationMixer: R4,
  AnimationObjectGroup: T4,
  AnimationUtils: $H,
  ArcCurve: MO,
  ArrayCamera: iw,
  ArrowHelper: K4,
  AttachedBindMode: YC,
  Audio: lw,
  AudioAnalyser: v4,
  AudioContext: j2,
  AudioListener: h4,
  AudioLoader: c4,
  AxesHelper: k4,
  BackSide: ed,
  BasicDepthPacking: aO,
  BasicShadowMap: xU,
  BatchedMesh: EO,
  Bone: gx,
  BooleanKeyframeTrack: s_,
  Box2: H4,
  Box3: td,
  Box3Helper: j4,
  BoxGeometry: j0,
  BoxHelper: Q4,
  BufferAttribute: Hi,
  BufferGeometry: Pa,
  BufferGeometryLoader: nw,
  ByteType: lx,
  Cache: Yy,
  Camera: oE,
  CameraHelper: Z4,
  CanvasTexture: EH,
  CapsuleGeometry: Ex,
  CatmullRomCurve3: xO,
  CineonToneMapping: jU,
  CircleGeometry: bx,
  ClampToEdgeWrapping: Mo,
  Clock: J2,
  Color: hn,
  ColorKeyframeTrack: P2,
  ColorManagement: wi,
  CompressedArrayTexture: _H,
  CompressedCubeTexture: AH,
  CompressedTexture: Sx,
  CompressedTextureLoader: i4,
  ConeGeometry: Mx,
  ConstantAlphaFactor: PU,
  ConstantColorFactor: VU,
  Controls: $4,
  CubeCamera: yO,
  CubeReflectionMapping: Qg,
  CubeRefractionMapping: Y0,
  CubeTexture: uE,
  CubeTextureLoader: jO,
  CubeUVReflectionMapping: C1,
  CubicBezierCurve: N2,
  CubicBezierCurve3: TO,
  CubicInterpolant: qO,
  CullFaceBack: FC,
  CullFaceFront: MU,
  CullFaceFrontBack: LN,
  CullFaceNone: bU,
  Curve: Wv,
  CurvePath: RO,
  CustomBlending: TU,
  CustomToneMapping: JU,
  CylinderGeometry: D1,
  Cylindrical: z4,
  Data3DTexture: px,
  DataArrayTexture: rE,
  DataTexture: Jv,
  DataTextureLoader: X2,
  DataUtils: XS,
  DecrementStencilOp: QN,
  DecrementWrapStencilOp: JN,
  DefaultLoadingManager: o1,
  DepthFormat: WS,
  DepthStencilFormat: g1,
  DepthTexture: _x,
  DetachedBindMode: WU,
  DirectionalLight: Q2,
  DirectionalLightHelper: q4,
  DiscreteInterpolant: ZO,
  DodecahedronGeometry: xx,
  DoubleSide: Lp,
  DstAlphaFactor: zU,
  DstColorFactor: LU,
  DynamicCopyUsage: cz,
  DynamicDrawUsage: iz,
  DynamicReadUsage: rz,
  EdgesGeometry: DO,
  EllipseCurve: Ax,
  EqualCompare: oO,
  EqualDepth: vM,
  EqualStencilFunc: $N,
  EquirectangularReflectionMapping: p1,
  EquirectangularRefractionMapping: YA,
  Euler: Ip,
  EventDispatcher: Jg,
  ExtrudeGeometry: Tx,
  FileLoader: of,
  Float16BufferAttribute: eH,
  Float32BufferAttribute: qn,
  FloatType: pr,
  Fog: vx,
  FogExp2: mx,
  FramebufferTexture: SH,
  FrontSide: Zg,
  Frustum: dE,
  GLBufferAttribute: N4,
  GLSL1: dz,
  GLSL3: QC,
  GreaterCompare: uO,
  GreaterDepth: yM,
  GreaterEqualCompare: fO,
  GreaterEqualDepth: gM,
  GreaterEqualStencilFunc: az,
  GreaterStencilFunc: tz,
  GridHelper: X4,
  Group: Xy,
  HalfFloatType: au,
  HemisphereLight: KO,
  HemisphereLightHelper: P4,
  IcosahedronGeometry: pE,
  ImageBitmapLoader: aw,
  ImageLoader: eE,
  ImageUtils: mO,
  IncrementStencilOp: ZN,
  IncrementWrapStencilOp: jN,
  InstancedBufferAttribute: $S,
  InstancedBufferGeometry: tw,
  InstancedInterleavedBuffer: w4,
  InstancedMesh: B2,
  Int16BufferAttribute: Wz,
  Int32BufferAttribute: $z,
  Int8BufferAttribute: Jz,
  IntType: iE,
  InterleavedBuffer: cE,
  InterleavedBufferAttribute: Z0,
  Interpolant: U1,
  InterpolateDiscrete: y1,
  InterpolateLinear: S1,
  InterpolateSmooth: iM,
  InvertStencilOp: KN,
  KeepStencilOp: LS,
  KeyframeTrack: Jm,
  LOD: AO,
  LatheGeometry: hE,
  Layers: A1,
  LessCompare: rO,
  LessDepth: mM,
  LessEqualCompare: E2,
  LessEqualDepth: KS,
  LessEqualStencilFunc: ez,
  LessStencilFunc: WN,
  Light: K0,
  LightProbe: ew,
  Line: Qy,
  Line3: L4,
  LineBasicMaterial: nd,
  LineCurve: z2,
  LineCurve3: CO,
  LineDashedMaterial: PO,
  LineLoop: U2,
  LineSegments: kv,
  LinearFilter: Ni,
  LinearInterpolant: F2,
  LinearMipMapLinearFilter: qC,
  LinearMipMapNearestFilter: VN,
  LinearMipmapLinearFilter: qm,
  LinearMipmapNearestFilter: c1,
  LinearSRGBColorSpace: Kv,
  LinearToneMapping: ZU,
  LinearTransfer: ZA,
  Loader: cf,
  LoaderUtils: P0,
  LoadingManager: Nx,
  LoopOnce: $U,
  LoopPingPong: tO,
  LoopRepeat: eO,
  LuminanceAlphaFormat: g2,
  LuminanceFormat: v2,
  MOUSE: zS,
  Material: Vu,
  MaterialLoader: zx,
  MathUtils: dx,
  Matrix2: $2,
  Matrix3: ja,
  Matrix4: ia,
  MaxEquation: BU,
  Mesh: es,
  MeshBasicMaterial: Yh,
  MeshDepthMaterial: wx,
  MeshDistanceMaterial: I2,
  MeshLambertMaterial: VO,
  MeshMatcapMaterial: FO,
  MeshNormalMaterial: IO,
  MeshPhongMaterial: LO,
  MeshPhysicalMaterial: jm,
  MeshStandardMaterial: B1,
  MeshToonMaterial: GO,
  MinEquation: DU,
  MirroredRepeatWrapping: m1,
  MixOperation: YU,
  MultiplyBlending: XC,
  MultiplyOperation: aE,
  NearestFilter: _c,
  NearestMipMapLinearFilter: IN,
  NearestMipMapNearestFilter: GN,
  NearestMipmapLinearFilter: VS,
  NearestMipmapNearestFilter: ix,
  NeutralToneMapping: kU,
  NeverCompare: sO,
  NeverDepth: hM,
  NeverStencilFunc: kN,
  NoBlending: jv,
  NoColorSpace: Fy,
  NoToneMapping: Yg,
  NormalAnimationBlendMode: fx,
  NormalBlending: QS,
  NotEqualCompare: cO,
  NotEqualDepth: SM,
  NotEqualStencilFunc: nz,
  NumberKeyframeTrack: t_,
  Object3D: zi,
  ObjectLoader: o4,
  ObjectSpaceNormalMap: lO,
  OctahedronGeometry: mE,
  OneFactor: OU,
  OneMinusConstantAlphaFactor: XU,
  OneMinusConstantColorFactor: FU,
  OneMinusDstAlphaFactor: HU,
  OneMinusDstColorFactor: GU,
  OneMinusSrcAlphaFactor: dM,
  OneMinusSrcColorFactor: NU,
  OrthographicCamera: Zm,
  PCFShadowMap: ax,
  PCFSoftShadowMap: wA,
  PMREMGenerator: e2,
  Path: KA,
  PerspectiveCamera: Ls,
  Plane: Pg,
  PlaneGeometry: Ky,
  PlaneHelper: J4,
  PointLight: Z2,
  PointLightHelper: V4,
  Points: O2,
  PointsMaterial: yx,
  PolarGridHelper: Y4,
  PolyhedronGeometry: J0,
  PositionalAudio: m4,
  PropertyBinding: Yi,
  PropertyMixer: sw,
  QuadraticBezierCurve: H2,
  QuadraticBezierCurve3: L2,
  Quaternion: Ac,
  QuaternionKeyframeTrack: n_,
  QuaternionLinearInterpolant: QO,
  RED_GREEN_RGTC2_Format: YM,
  RED_RGTC1_Format: S2,
  REVISION: T1,
  RGBADepthPacking: iO,
  RGBAFormat: xo,
  RGBAIntegerFormat: cx,
  RGBA_ASTC_10x10_Format: GM,
  RGBA_ASTC_10x5_Format: zM,
  RGBA_ASTC_10x6_Format: HM,
  RGBA_ASTC_10x8_Format: LM,
  RGBA_ASTC_12x10_Format: IM,
  RGBA_ASTC_12x12_Format: VM,
  RGBA_ASTC_4x4_Format: CM,
  RGBA_ASTC_5x4_Format: RM,
  RGBA_ASTC_5x5_Format: DM,
  RGBA_ASTC_6x5_Format: BM,
  RGBA_ASTC_6x6_Format: UM,
  RGBA_ASTC_8x5_Format: OM,
  RGBA_ASTC_8x6_Format: wM,
  RGBA_ASTC_8x8_Format: NM,
  RGBA_BPTC_Format: GA,
  RGBA_ETC2_EAC_Format: TM,
  RGBA_PVRTC_2BPPV1_Format: bM,
  RGBA_PVRTC_4BPPV1_Format: EM,
  RGBA_S3TC_DXT1_Format: zA,
  RGBA_S3TC_DXT3_Format: HA,
  RGBA_S3TC_DXT5_Format: LA,
  RGBDepthPacking: PN,
  RGBFormat: m2,
  RGBIntegerFormat: FN,
  RGB_BPTC_SIGNED_Format: FM,
  RGB_BPTC_UNSIGNED_Format: PM,
  RGB_ETC1_Format: MM,
  RGB_ETC2_Format: xM,
  RGB_PVRTC_2BPPV1_Format: AM,
  RGB_PVRTC_4BPPV1_Format: _M,
  RGB_S3TC_DXT1_Format: NA,
  RGDepthPacking: XN,
  RGFormat: y2,
  RGIntegerFormat: ux,
  RawShaderMaterial: HO,
  Ray: l_,
  Raycaster: W2,
  RectAreaLight: WO,
  RedFormat: lE,
  RedIntegerFormat: sE,
  ReinhardToneMapping: QU,
  RenderTarget: hx,
  RenderTarget3D: D4,
  RenderTargetArray: B4,
  RepeatWrapping: q0,
  ReplaceStencilOp: qN,
  ReverseSubtractEquation: RU,
  RingGeometry: Cx,
  SIGNED_RED_GREEN_RGTC2_Format: qM,
  SIGNED_RED_RGTC1_Format: XM,
  SRGBColorSpace: lf,
  SRGBTransfer: Nl,
  Scene: R1,
  ShaderChunk: ii,
  ShaderLib: Zv,
  ShaderMaterial: iu,
  ShadowMaterial: zO,
  Shape: JS,
  ShapeGeometry: Rx,
  ShapePath: W4,
  ShapeUtils: qg,
  ShortType: sx,
  Skeleton: fE,
  SkeletonHelper: I4,
  SkinnedMesh: D2,
  Source: V0,
  Sphere: rf,
  SphereGeometry: vE,
  Spherical: KM,
  SphericalHarmonics3: $O,
  SplineCurve: G2,
  SpotLight: q2,
  SpotLightHelper: G4,
  Sprite: _O,
  SpriteMaterial: R2,
  SrcAlphaFactor: fM,
  SrcAlphaSaturateFactor: IU,
  SrcColorFactor: wU,
  StaticCopyUsage: uz,
  StaticDrawUsage: QA,
  StaticReadUsage: sz,
  StereoCamera: f4,
  StreamCopyUsage: fz,
  StreamDrawUsage: lz,
  StreamReadUsage: oz,
  StringKeyframeTrack: r_,
  SubtractEquation: CU,
  SubtractiveBlending: PC,
  TOUCH: HS,
  TangentSpaceNormalMap: Q0,
  TetrahedronGeometry: Dx,
  Texture: Ml,
  TextureLoader: JO,
  TextureUtils: iL,
  TimestampQuery: hz,
  TorusGeometry: Bx,
  TorusKnotGeometry: Ux,
  Triangle: Xh,
  TriangleFanDrawMode: ZM,
  TriangleStripDrawMode: A2,
  TrianglesDrawMode: nO,
  TubeGeometry: Ox,
  UVMapping: X0,
  Uint16BufferAttribute: M2,
  Uint32BufferAttribute: x2,
  Uint8BufferAttribute: Kz,
  Uint8ClampedBufferAttribute: kz,
  Uniform: $f,
  UniformsGroup: O4,
  UniformsLib: An,
  UniformsUtils: T2,
  UnsignedByteType: qh,
  UnsignedInt248Type: v1,
  UnsignedInt5999Type: h2,
  UnsignedIntType: jg,
  UnsignedShort4444Type: rx,
  UnsignedShort5551Type: ox,
  UnsignedShortType: kS,
  VSMShadowMap: qv,
  Vector2: Ot,
  Vector3: ve,
  Vector4: Bi,
  VectorKeyframeTrack: a_,
  VideoFrameTexture: yH,
  VideoTexture: bO,
  WebGL3DRenderTarget: Gz,
  WebGLArrayRenderTarget: Lz,
  WebGLCoordinateSystem: Qv,
  WebGLCubeRenderTarget: C2,
  WebGLRenderTarget: uf,
  WebGLRenderer: tR,
  WebGLUtils: pw,
  WebGPUCoordinateSystem: jA,
  WebXRController: sM,
  WireframeGeometry: NO,
  WrapAroundEnding: qA,
  ZeroCurvatureEnding: FS,
  ZeroFactor: UU,
  ZeroSlopeEnding: PS,
  ZeroStencilOp: YN,
  createCanvasElement: pO
}, Symbol.toStringTag, { value: "Module" }));
function mw(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
var Pb = { exports: {} }, Gy = {};
/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var x3;
function VG() {
  return x3 || (x3 = 1, Gy.ConcurrentRoot = 1, Gy.ContinuousEventPriority = 8, Gy.DefaultEventPriority = 32, Gy.DiscreteEventPriority = 2, Gy.IdleEventPriority = 268435456, Gy.LegacyRoot = 0, Gy.NoEventPriority = 0), Gy;
}
var Iy = {};
/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var T3;
function FG() {
  return T3 || (T3 = 1, process.env.NODE_ENV !== "production" && (Iy.ConcurrentRoot = 1, Iy.ContinuousEventPriority = 8, Iy.DefaultEventPriority = 32, Iy.DiscreteEventPriority = 2, Iy.IdleEventPriority = 268435456, Iy.LegacyRoot = 0, Iy.NoEventPriority = 0)), Iy;
}
var C3;
function PG() {
  return C3 || (C3 = 1, process.env.NODE_ENV === "production" ? Pb.exports = VG() : Pb.exports = FG()), Pb.exports;
}
var oM = PG(), Xb = { exports: {} }, mC = {}, Yb = { exports: {} }, vC = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var R3;
function XG() {
  if (R3) return vC;
  R3 = 1;
  var o = Qm;
  function e(C, D) {
    return C === D && (C !== 0 || 1 / C === 1 / D) || C !== C && D !== D;
  }
  var t = typeof Object.is == "function" ? Object.is : e, a = o.useState, r = o.useEffect, d = o.useLayoutEffect, p = o.useDebugValue;
  function y(C, D) {
    var B = D(), z = a({ inst: { value: B, getSnapshot: D } }), V = z[0].inst, G = z[1];
    return d(
      function() {
        V.value = B, V.getSnapshot = D, _(V) && G({ inst: V });
      },
      [C, B, D]
    ), r(
      function() {
        return _(V) && G({ inst: V }), C(function() {
          _(V) && G({ inst: V });
        });
      },
      [C]
    ), p(B), B;
  }
  function _(C) {
    var D = C.getSnapshot;
    C = C.value;
    try {
      var B = D();
      return !t(C, B);
    } catch {
      return !0;
    }
  }
  function E(C, D) {
    return D();
  }
  var T = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? E : y;
  return vC.useSyncExternalStore = o.useSyncExternalStore !== void 0 ? o.useSyncExternalStore : T, vC;
}
var gC = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var D3;
function YG() {
  return D3 || (D3 = 1, process.env.NODE_ENV !== "production" && function() {
    function o(B, z) {
      return B === z && (B !== 0 || 1 / B === 1 / z) || B !== B && z !== z;
    }
    function e(B, z) {
      T || r.startTransition === void 0 || (T = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var V = z();
      if (!C) {
        var G = z();
        d(V, G) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), C = !0);
      }
      G = p({
        inst: { value: V, getSnapshot: z }
      });
      var N = G[0].inst, F = G[1];
      return _(
        function() {
          N.value = V, N.getSnapshot = z, t(N) && F({ inst: N });
        },
        [B, V, z]
      ), y(
        function() {
          return t(N) && F({ inst: N }), B(function() {
            t(N) && F({ inst: N });
          });
        },
        [B]
      ), E(V), V;
    }
    function t(B) {
      var z = B.getSnapshot;
      B = B.value;
      try {
        var V = z();
        return !d(B, V);
      } catch {
        return !0;
      }
    }
    function a(B, z) {
      return z();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var r = Qm, d = typeof Object.is == "function" ? Object.is : o, p = r.useState, y = r.useEffect, _ = r.useLayoutEffect, E = r.useDebugValue, T = !1, C = !1, D = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? a : e;
    gC.useSyncExternalStore = r.useSyncExternalStore !== void 0 ? r.useSyncExternalStore : D, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), gC;
}
var B3;
function vw() {
  return B3 || (B3 = 1, process.env.NODE_ENV === "production" ? Yb.exports = XG() : Yb.exports = YG()), Yb.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var U3;
function qG() {
  if (U3) return mC;
  U3 = 1;
  var o = Qm, e = vw();
  function t(E, T) {
    return E === T && (E !== 0 || 1 / E === 1 / T) || E !== E && T !== T;
  }
  var a = typeof Object.is == "function" ? Object.is : t, r = e.useSyncExternalStore, d = o.useRef, p = o.useEffect, y = o.useMemo, _ = o.useDebugValue;
  return mC.useSyncExternalStoreWithSelector = function(E, T, C, D, B) {
    var z = d(null);
    if (z.current === null) {
      var V = { hasValue: !1, value: null };
      z.current = V;
    } else V = z.current;
    z = y(
      function() {
        function N(k) {
          if (!F) {
            if (F = !0, q = k, k = D(k), B !== void 0 && V.hasValue) {
              var le = V.value;
              if (B(le, k))
                return Y = le;
            }
            return Y = k;
          }
          if (le = Y, a(q, k)) return le;
          var ne = D(k);
          return B !== void 0 && B(le, ne) ? (q = k, le) : (q = k, Y = ne);
        }
        var F = !1, q, Y, ie = C === void 0 ? null : C;
        return [
          function() {
            return N(T());
          },
          ie === null ? void 0 : function() {
            return N(ie());
          }
        ];
      },
      [T, C, D, B]
    );
    var G = r(E, z[0], z[1]);
    return p(
      function() {
        V.hasValue = !0, V.value = G;
      },
      [G]
    ), _(G), G;
  }, mC;
}
var yC = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var O3;
function ZG() {
  return O3 || (O3 = 1, process.env.NODE_ENV !== "production" && function() {
    function o(E, T) {
      return E === T && (E !== 0 || 1 / E === 1 / T) || E !== E && T !== T;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var e = Qm, t = vw(), a = typeof Object.is == "function" ? Object.is : o, r = t.useSyncExternalStore, d = e.useRef, p = e.useEffect, y = e.useMemo, _ = e.useDebugValue;
    yC.useSyncExternalStoreWithSelector = function(E, T, C, D, B) {
      var z = d(null);
      if (z.current === null) {
        var V = { hasValue: !1, value: null };
        z.current = V;
      } else V = z.current;
      z = y(
        function() {
          function N(k) {
            if (!F) {
              if (F = !0, q = k, k = D(k), B !== void 0 && V.hasValue) {
                var le = V.value;
                if (B(le, k))
                  return Y = le;
              }
              return Y = k;
            }
            if (le = Y, a(q, k))
              return le;
            var ne = D(k);
            return B !== void 0 && B(le, ne) ? (q = k, le) : (q = k, Y = ne);
          }
          var F = !1, q, Y, ie = C === void 0 ? null : C;
          return [
            function() {
              return N(T());
            },
            ie === null ? void 0 : function() {
              return N(ie());
            }
          ];
        },
        [T, C, D, B]
      );
      var G = r(E, z[0], z[1]);
      return p(
        function() {
          V.hasValue = !0, V.value = G;
        },
        [G]
      ), _(G), G;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), yC;
}
var w3;
function QG() {
  return w3 || (w3 = 1, process.env.NODE_ENV === "production" ? Xb.exports = qG() : Xb.exports = ZG()), Xb.exports;
}
var jG = QG();
const JG = /* @__PURE__ */ mw(jG), N3 = (o) => {
  let e;
  const t = /* @__PURE__ */ new Set(), a = (E, T) => {
    const C = typeof E == "function" ? E(e) : E;
    if (!Object.is(C, e)) {
      const D = e;
      e = T ?? (typeof C != "object" || C === null) ? C : Object.assign({}, e, C), t.forEach((B) => B(e, D));
    }
  }, r = () => e, y = { setState: a, getState: r, getInitialState: () => _, subscribe: (E) => (t.add(E), () => t.delete(E)) }, _ = e = o(a, r, y);
  return y;
}, gw = (o) => o ? N3(o) : N3, { useSyncExternalStoreWithSelector: KG } = JG, kG = (o) => o;
function WG(o, e = kG, t) {
  const a = KG(
    o.subscribe,
    o.getState,
    o.getInitialState,
    e,
    t
  );
  return Qm.useDebugValue(a), a;
}
const z3 = (o, e) => {
  const t = gw(o), a = (r, d = e) => WG(t, r, d);
  return Object.assign(a, t), a;
}, yw = (o, e) => o ? z3(o, e) : z3;
var qb = { exports: {} }, SC = { exports: {} }, Zb = { exports: {} }, _C = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var H3;
function $G() {
  return H3 || (H3 = 1, function(o) {
    function e(P, te) {
      var ae = P.length;
      P.push(te);
      e: for (; 0 < ae; ) {
        var Se = ae - 1 >>> 1, ue = P[Se];
        if (0 < r(ue, te))
          P[Se] = te, P[ae] = ue, ae = Se;
        else break e;
      }
    }
    function t(P) {
      return P.length === 0 ? null : P[0];
    }
    function a(P) {
      if (P.length === 0) return null;
      var te = P[0], ae = P.pop();
      if (ae !== te) {
        P[0] = ae;
        e: for (var Se = 0, ue = P.length, we = ue >>> 1; Se < we; ) {
          var De = 2 * (Se + 1) - 1, We = P[De], Me = De + 1, Ze = P[Me];
          if (0 > r(We, ae))
            Me < ue && 0 > r(Ze, We) ? (P[Se] = Ze, P[Me] = ae, Se = Me) : (P[Se] = We, P[De] = ae, Se = De);
          else if (Me < ue && 0 > r(Ze, ae))
            P[Se] = Ze, P[Me] = ae, Se = Me;
          else break e;
        }
      }
      return te;
    }
    function r(P, te) {
      var ae = P.sortIndex - te.sortIndex;
      return ae !== 0 ? ae : P.id - te.id;
    }
    if (o.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var d = performance;
      o.unstable_now = function() {
        return d.now();
      };
    } else {
      var p = Date, y = p.now();
      o.unstable_now = function() {
        return p.now() - y;
      };
    }
    var _ = [], E = [], T = 1, C = null, D = 3, B = !1, z = !1, V = !1, G = typeof setTimeout == "function" ? setTimeout : null, N = typeof clearTimeout == "function" ? clearTimeout : null, F = typeof setImmediate < "u" ? setImmediate : null;
    function q(P) {
      for (var te = t(E); te !== null; ) {
        if (te.callback === null) a(E);
        else if (te.startTime <= P)
          a(E), te.sortIndex = te.expirationTime, e(_, te);
        else break;
        te = t(E);
      }
    }
    function Y(P) {
      if (V = !1, q(P), !z)
        if (t(_) !== null)
          z = !0, Ae();
        else {
          var te = t(E);
          te !== null && He(Y, te.startTime - P);
        }
    }
    var ie = !1, k = -1, le = 5, ne = -1;
    function Q() {
      return !(o.unstable_now() - ne < le);
    }
    function j() {
      if (ie) {
        var P = o.unstable_now();
        ne = P;
        var te = !0;
        try {
          e: {
            z = !1, V && (V = !1, N(k), k = -1), B = !0;
            var ae = D;
            try {
              t: {
                for (q(P), C = t(_); C !== null && !(C.expirationTime > P && Q()); ) {
                  var Se = C.callback;
                  if (typeof Se == "function") {
                    C.callback = null, D = C.priorityLevel;
                    var ue = Se(
                      C.expirationTime <= P
                    );
                    if (P = o.unstable_now(), typeof ue == "function") {
                      C.callback = ue, q(P), te = !0;
                      break t;
                    }
                    C === t(_) && a(_), q(P);
                  } else a(_);
                  C = t(_);
                }
                if (C !== null) te = !0;
                else {
                  var we = t(E);
                  we !== null && He(
                    Y,
                    we.startTime - P
                  ), te = !1;
                }
              }
              break e;
            } finally {
              C = null, D = ae, B = !1;
            }
            te = void 0;
          }
        } finally {
          te ? re() : ie = !1;
        }
      }
    }
    var re;
    if (typeof F == "function")
      re = function() {
        F(j);
      };
    else if (typeof MessageChannel < "u") {
      var _e = new MessageChannel(), me = _e.port2;
      _e.port1.onmessage = j, re = function() {
        me.postMessage(null);
      };
    } else
      re = function() {
        G(j, 0);
      };
    function Ae() {
      ie || (ie = !0, re());
    }
    function He(P, te) {
      k = G(function() {
        P(o.unstable_now());
      }, te);
    }
    o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(P) {
      P.callback = null;
    }, o.unstable_continueExecution = function() {
      z || B || (z = !0, Ae());
    }, o.unstable_forceFrameRate = function(P) {
      0 > P || 125 < P ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : le = 0 < P ? Math.floor(1e3 / P) : 5;
    }, o.unstable_getCurrentPriorityLevel = function() {
      return D;
    }, o.unstable_getFirstCallbackNode = function() {
      return t(_);
    }, o.unstable_next = function(P) {
      switch (D) {
        case 1:
        case 2:
        case 3:
          var te = 3;
          break;
        default:
          te = D;
      }
      var ae = D;
      D = te;
      try {
        return P();
      } finally {
        D = ae;
      }
    }, o.unstable_pauseExecution = function() {
    }, o.unstable_requestPaint = function() {
    }, o.unstable_runWithPriority = function(P, te) {
      switch (P) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          P = 3;
      }
      var ae = D;
      D = P;
      try {
        return te();
      } finally {
        D = ae;
      }
    }, o.unstable_scheduleCallback = function(P, te, ae) {
      var Se = o.unstable_now();
      switch (typeof ae == "object" && ae !== null ? (ae = ae.delay, ae = typeof ae == "number" && 0 < ae ? Se + ae : Se) : ae = Se, P) {
        case 1:
          var ue = -1;
          break;
        case 2:
          ue = 250;
          break;
        case 5:
          ue = 1073741823;
          break;
        case 4:
          ue = 1e4;
          break;
        default:
          ue = 5e3;
      }
      return ue = ae + ue, P = {
        id: T++,
        callback: te,
        priorityLevel: P,
        startTime: ae,
        expirationTime: ue,
        sortIndex: -1
      }, ae > Se ? (P.sortIndex = ae, e(E, P), t(_) === null && P === t(E) && (V ? (N(k), k = -1) : V = !0, He(Y, ae - Se))) : (P.sortIndex = ue, e(_, P), z || B || (z = !0, Ae())), P;
    }, o.unstable_shouldYield = Q, o.unstable_wrapCallback = function(P) {
      var te = D;
      return function() {
        var ae = D;
        D = te;
        try {
          return P.apply(this, arguments);
        } finally {
          D = ae;
        }
      };
    };
  }(_C)), _C;
}
var AC = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var L3;
function e9() {
  return L3 || (L3 = 1, function(o) {
    process.env.NODE_ENV !== "production" && function() {
      function e() {
        if (Q) {
          var P = o.unstable_now();
          _e = P;
          var te = !0;
          try {
            e: {
              Y = !1, ie && (ie = !1, le(j), j = -1), q = !0;
              var ae = F;
              try {
                t: {
                  for (p(P), N = a(z); N !== null && !(N.expirationTime > P && _()); ) {
                    var Se = N.callback;
                    if (typeof Se == "function") {
                      N.callback = null, F = N.priorityLevel;
                      var ue = Se(
                        N.expirationTime <= P
                      );
                      if (P = o.unstable_now(), typeof ue == "function") {
                        N.callback = ue, p(P), te = !0;
                        break t;
                      }
                      N === a(z) && r(z), p(P);
                    } else r(z);
                    N = a(z);
                  }
                  if (N !== null) te = !0;
                  else {
                    var we = a(V);
                    we !== null && T(
                      y,
                      we.startTime - P
                    ), te = !1;
                  }
                }
                break e;
              } finally {
                N = null, F = ae, q = !1;
              }
              te = void 0;
            }
          } finally {
            te ? me() : Q = !1;
          }
        }
      }
      function t(P, te) {
        var ae = P.length;
        P.push(te);
        e: for (; 0 < ae; ) {
          var Se = ae - 1 >>> 1, ue = P[Se];
          if (0 < d(ue, te))
            P[Se] = te, P[ae] = ue, ae = Se;
          else break e;
        }
      }
      function a(P) {
        return P.length === 0 ? null : P[0];
      }
      function r(P) {
        if (P.length === 0) return null;
        var te = P[0], ae = P.pop();
        if (ae !== te) {
          P[0] = ae;
          e: for (var Se = 0, ue = P.length, we = ue >>> 1; Se < we; ) {
            var De = 2 * (Se + 1) - 1, We = P[De], Me = De + 1, Ze = P[Me];
            if (0 > d(We, ae))
              Me < ue && 0 > d(Ze, We) ? (P[Se] = Ze, P[Me] = ae, Se = Me) : (P[Se] = We, P[De] = ae, Se = De);
            else if (Me < ue && 0 > d(Ze, ae))
              P[Se] = Ze, P[Me] = ae, Se = Me;
            else break e;
          }
        }
        return te;
      }
      function d(P, te) {
        var ae = P.sortIndex - te.sortIndex;
        return ae !== 0 ? ae : P.id - te.id;
      }
      function p(P) {
        for (var te = a(V); te !== null; ) {
          if (te.callback === null) r(V);
          else if (te.startTime <= P)
            r(V), te.sortIndex = te.expirationTime, t(z, te);
          else break;
          te = a(V);
        }
      }
      function y(P) {
        if (ie = !1, p(P), !Y)
          if (a(z) !== null)
            Y = !0, E();
          else {
            var te = a(V);
            te !== null && T(
              y,
              te.startTime - P
            );
          }
      }
      function _() {
        return !(o.unstable_now() - _e < re);
      }
      function E() {
        Q || (Q = !0, me());
      }
      function T(P, te) {
        j = k(function() {
          P(o.unstable_now());
        }, te);
      }
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error()), o.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var C = performance;
        o.unstable_now = function() {
          return C.now();
        };
      } else {
        var D = Date, B = D.now();
        o.unstable_now = function() {
          return D.now() - B;
        };
      }
      var z = [], V = [], G = 1, N = null, F = 3, q = !1, Y = !1, ie = !1, k = typeof setTimeout == "function" ? setTimeout : null, le = typeof clearTimeout == "function" ? clearTimeout : null, ne = typeof setImmediate < "u" ? setImmediate : null, Q = !1, j = -1, re = 5, _e = -1;
      if (typeof ne == "function")
        var me = function() {
          ne(e);
        };
      else if (typeof MessageChannel < "u") {
        var Ae = new MessageChannel(), He = Ae.port2;
        Ae.port1.onmessage = e, me = function() {
          He.postMessage(null);
        };
      } else
        me = function() {
          k(e, 0);
        };
      o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(P) {
        P.callback = null;
      }, o.unstable_continueExecution = function() {
        Y || q || (Y = !0, E());
      }, o.unstable_forceFrameRate = function(P) {
        0 > P || 125 < P ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : re = 0 < P ? Math.floor(1e3 / P) : 5;
      }, o.unstable_getCurrentPriorityLevel = function() {
        return F;
      }, o.unstable_getFirstCallbackNode = function() {
        return a(z);
      }, o.unstable_next = function(P) {
        switch (F) {
          case 1:
          case 2:
          case 3:
            var te = 3;
            break;
          default:
            te = F;
        }
        var ae = F;
        F = te;
        try {
          return P();
        } finally {
          F = ae;
        }
      }, o.unstable_pauseExecution = function() {
      }, o.unstable_requestPaint = function() {
      }, o.unstable_runWithPriority = function(P, te) {
        switch (P) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            P = 3;
        }
        var ae = F;
        F = P;
        try {
          return te();
        } finally {
          F = ae;
        }
      }, o.unstable_scheduleCallback = function(P, te, ae) {
        var Se = o.unstable_now();
        switch (typeof ae == "object" && ae !== null ? (ae = ae.delay, ae = typeof ae == "number" && 0 < ae ? Se + ae : Se) : ae = Se, P) {
          case 1:
            var ue = -1;
            break;
          case 2:
            ue = 250;
            break;
          case 5:
            ue = 1073741823;
            break;
          case 4:
            ue = 1e4;
            break;
          default:
            ue = 5e3;
        }
        return ue = ae + ue, P = {
          id: G++,
          callback: te,
          priorityLevel: P,
          startTime: ae,
          expirationTime: ue,
          sortIndex: -1
        }, ae > Se ? (P.sortIndex = ae, t(V, P), a(z) === null && P === a(V) && (ie ? (le(j), j = -1) : ie = !0, T(y, ae - Se))) : (P.sortIndex = ue, t(z, P), Y || q || (Y = !0, E())), P;
      }, o.unstable_shouldYield = _, o.unstable_wrapCallback = function(P) {
        var te = F;
        return function() {
          var ae = F;
          F = te;
          try {
            return P.apply(this, arguments);
          } finally {
            F = ae;
          }
        };
      }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }(AC)), AC;
}
var G3;
function Sw() {
  return G3 || (G3 = 1, process.env.NODE_ENV === "production" ? Zb.exports = $G() : Zb.exports = e9()), Zb.exports;
}
/**
 * @license React
 * react-reconciler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var I3;
function t9() {
  return I3 || (I3 = 1, function(o) {
    o.exports = function(e) {
      function t(h, m, M, w) {
        return new av(h, m, M, w);
      }
      function a() {
      }
      function r(h) {
        var m = "https://react.dev/errors/" + h;
        if (1 < arguments.length) {
          m += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var M = 2; M < arguments.length; M++)
            m += "&args[]=" + encodeURIComponent(arguments[M]);
        }
        return "Minified React error #" + h + "; visit " + m + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function d(h) {
        return h === null || typeof h != "object" ? null : (h = $u && h[$u] || h["@@iterator"], typeof h == "function" ? h : null);
      }
      function p(h) {
        if (h == null) return null;
        if (typeof h == "function")
          return h.$$typeof === ig ? null : h.displayName || h.name || null;
        if (typeof h == "string") return h;
        switch (h) {
          case wc:
            return "Fragment";
          case kr:
            return "Portal";
          case np:
            return "Profiler";
          case yd:
            return "StrictMode";
          case ip:
            return "Suspense";
          case lp:
            return "SuspenseList";
        }
        if (typeof h == "object")
          switch (h.$$typeof) {
            case Wr:
              return (h.displayName || "Context") + ".Provider";
            case ap:
              return (h._context.displayName || "Context") + ".Consumer";
            case em:
              var m = h.render;
              return h = h.displayName, h || (h = m.displayName || m.name || "", h = h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef"), h;
            case tm:
              return m = h.displayName || null, m !== null ? m : p(h.type) || "Memo";
            case $r:
              m = h._payload, h = h._init;
              try {
                return p(h(m));
              } catch {
              }
          }
        return null;
      }
      function y(h) {
        if (xr === void 0)
          try {
            throw Error();
          } catch (M) {
            var m = M.stack.trim().match(/\n( *(at )?)/);
            xr = m && m[1] || "", ml = -1 < M.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < M.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return `
` + xr + h + ml;
      }
      function _(h, m) {
        if (!h || Tf) return "";
        Tf = !0;
        var M = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var w = {
            DetermineComponentFrameRoot: function() {
              try {
                if (m) {
                  var mn = function() {
                    throw Error();
                  };
                  if (Object.defineProperty(mn.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                      Reflect.construct(mn, []);
                    } catch (Un) {
                      var cn = Un;
                    }
                    Reflect.construct(h, [], mn);
                  } else {
                    try {
                      mn.call();
                    } catch (Un) {
                      cn = Un;
                    }
                    h.call(mn.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (Un) {
                    cn = Un;
                  }
                  (mn = h()) && typeof mn.catch == "function" && mn.catch(function() {
                  });
                }
              } catch (Un) {
                if (Un && cn && typeof Un.stack == "string")
                  return [Un.stack, cn.stack];
              }
              return [null, null];
            }
          };
          w.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var I = Object.getOwnPropertyDescriptor(
            w.DetermineComponentFrameRoot,
            "name"
          );
          I && I.configurable && Object.defineProperty(
            w.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var Z = w.DetermineComponentFrameRoot(), fe = Z[0], Be = Z[1];
          if (fe && Be) {
            var qe = fe.split(`
`), wt = Be.split(`
`);
            for (I = w = 0; w < qe.length && !qe[w].includes("DetermineComponentFrameRoot"); )
              w++;
            for (; I < wt.length && !wt[I].includes(
              "DetermineComponentFrameRoot"
            ); )
              I++;
            if (w === qe.length || I === wt.length)
              for (w = qe.length - 1, I = wt.length - 1; 1 <= w && 0 <= I && qe[w] !== wt[I]; )
                I--;
            for (; 1 <= w && 0 <= I; w--, I--)
              if (qe[w] !== wt[I]) {
                if (w !== 1 || I !== 1)
                  do
                    if (w--, I--, 0 > I || qe[w] !== wt[I]) {
                      var en = `
` + qe[w].replace(" at new ", " at ");
                      return h.displayName && en.includes("<anonymous>") && (en = en.replace("<anonymous>", h.displayName)), en;
                    }
                  while (1 <= w && 0 <= I);
                break;
              }
          }
        } finally {
          Tf = !1, Error.prepareStackTrace = M;
        }
        return (M = h ? h.displayName || h.name : "") ? y(M) : "";
      }
      function E(h) {
        switch (h.tag) {
          case 26:
          case 27:
          case 5:
            return y(h.type);
          case 16:
            return y("Lazy");
          case 13:
            return y("Suspense");
          case 19:
            return y("SuspenseList");
          case 0:
          case 15:
            return h = _(h.type, !1), h;
          case 11:
            return h = _(h.type.render, !1), h;
          case 1:
            return h = _(h.type, !0), h;
          default:
            return "";
        }
      }
      function T(h) {
        try {
          var m = "";
          do
            m += E(h), h = h.return;
          while (h);
          return m;
        } catch (M) {
          return `
Error generating stack: ` + M.message + `
` + M.stack;
        }
      }
      function C(h) {
        var m = h, M = h;
        if (h.alternate) for (; m.return; ) m = m.return;
        else {
          h = m;
          do
            m = h, (m.flags & 4098) !== 0 && (M = m.return), h = m.return;
          while (h);
        }
        return m.tag === 3 ? M : null;
      }
      function D(h) {
        if (C(h) !== h)
          throw Error(r(188));
      }
      function B(h) {
        var m = h.alternate;
        if (!m) {
          if (m = C(h), m === null) throw Error(r(188));
          return m !== h ? null : h;
        }
        for (var M = h, w = m; ; ) {
          var I = M.return;
          if (I === null) break;
          var Z = I.alternate;
          if (Z === null) {
            if (w = I.return, w !== null) {
              M = w;
              continue;
            }
            break;
          }
          if (I.child === Z.child) {
            for (Z = I.child; Z; ) {
              if (Z === M) return D(I), h;
              if (Z === w) return D(I), m;
              Z = Z.sibling;
            }
            throw Error(r(188));
          }
          if (M.return !== w.return) M = I, w = Z;
          else {
            for (var fe = !1, Be = I.child; Be; ) {
              if (Be === M) {
                fe = !0, M = I, w = Z;
                break;
              }
              if (Be === w) {
                fe = !0, w = I, M = Z;
                break;
              }
              Be = Be.sibling;
            }
            if (!fe) {
              for (Be = Z.child; Be; ) {
                if (Be === M) {
                  fe = !0, M = Z, w = I;
                  break;
                }
                if (Be === w) {
                  fe = !0, w = Z, M = I;
                  break;
                }
                Be = Be.sibling;
              }
              if (!fe) throw Error(r(189));
            }
          }
          if (M.alternate !== w) throw Error(r(190));
        }
        if (M.tag !== 3) throw Error(r(188));
        return M.stateNode.current === M ? h : m;
      }
      function z(h) {
        var m = h.tag;
        if (m === 5 || m === 26 || m === 27 || m === 6) return h;
        for (h = h.child; h !== null; ) {
          if (m = z(h), m !== null) return m;
          h = h.sibling;
        }
        return null;
      }
      function V(h) {
        var m = h.tag;
        if (m === 5 || m === 26 || m === 27 || m === 6) return h;
        for (h = h.child; h !== null; ) {
          if (h.tag !== 4 && (m = V(h), m !== null))
            return m;
          h = h.sibling;
        }
        return null;
      }
      function G(h) {
        return { current: h };
      }
      function N(h) {
        0 > Vo || (h.current = La[Vo], La[Vo] = null, Vo--);
      }
      function F(h, m) {
        Vo++, La[Vo] = h.current, h.current = m;
      }
      function q(h) {
        return h >>>= 0, h === 0 ? 32 : 31 - (xd(h) / bs | 0) | 0;
      }
      function Y(h) {
        var m = h & 42;
        if (m !== 0) return m;
        switch (h & -h) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return h & 4194176;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return h & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return h;
        }
      }
      function ie(h, m) {
        var M = h.pendingLanes;
        if (M === 0) return 0;
        var w = 0, I = h.suspendedLanes, Z = h.pingedLanes, fe = h.warmLanes;
        h = h.finishedLanes !== 0;
        var Be = M & 134217727;
        return Be !== 0 ? (M = Be & ~I, M !== 0 ? w = Y(M) : (Z &= Be, Z !== 0 ? w = Y(Z) : h || (fe = Be & ~fe, fe !== 0 && (w = Y(fe))))) : (Be = M & ~I, Be !== 0 ? w = Y(Be) : Z !== 0 ? w = Y(Z) : h || (fe = M & ~fe, fe !== 0 && (w = Y(fe)))), w === 0 ? 0 : m !== 0 && m !== w && (m & I) === 0 && (I = w & -w, fe = m & -m, I >= fe || I === 32 && (fe & 4194176) !== 0) ? m : w;
      }
      function k(h, m) {
        return (h.pendingLanes & ~(h.suspendedLanes & ~h.pingedLanes) & m) === 0;
      }
      function le(h, m) {
        switch (h) {
          case 1:
          case 2:
          case 4:
          case 8:
            return m + 250;
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return m + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function ne() {
        var h = lc;
        return lc <<= 1, (lc & 4194176) === 0 && (lc = 128), h;
      }
      function Q() {
        var h = Mh;
        return Mh <<= 1, (Mh & 62914560) === 0 && (Mh = 4194304), h;
      }
      function j(h) {
        for (var m = [], M = 0; 31 > M; M++) m.push(h);
        return m;
      }
      function re(h, m) {
        h.pendingLanes |= m, m !== 268435456 && (h.suspendedLanes = 0, h.pingedLanes = 0, h.warmLanes = 0);
      }
      function _e(h, m, M, w, I, Z) {
        var fe = h.pendingLanes;
        h.pendingLanes = M, h.suspendedLanes = 0, h.pingedLanes = 0, h.warmLanes = 0, h.expiredLanes &= M, h.entangledLanes &= M, h.errorRecoveryDisabledLanes &= M, h.shellSuspendCounter = 0;
        var Be = h.entanglements, qe = h.expirationTimes, wt = h.hiddenUpdates;
        for (M = fe & ~M; 0 < M; ) {
          var en = 31 - Qs(M), mn = 1 << en;
          Be[en] = 0, qe[en] = -1;
          var cn = wt[en];
          if (cn !== null)
            for (wt[en] = null, en = 0; en < cn.length; en++) {
              var Un = cn[en];
              Un !== null && (Un.lane &= -536870913);
            }
          M &= ~mn;
        }
        w !== 0 && me(h, w, 0), Z !== 0 && I === 0 && h.tag !== 0 && (h.suspendedLanes |= Z & ~(fe & ~m));
      }
      function me(h, m, M) {
        h.pendingLanes |= m, h.suspendedLanes &= ~m;
        var w = 31 - Qs(m);
        h.entangledLanes |= m, h.entanglements[w] = h.entanglements[w] | 1073741824 | M & 4194218;
      }
      function Ae(h, m) {
        var M = h.entangledLanes |= m;
        for (h = h.entanglements; M; ) {
          var w = 31 - Qs(M), I = 1 << w;
          I & m | h[w] & m && (h[w] |= m), M &= ~I;
        }
      }
      function He(h) {
        return h &= -h, 2 < h ? 8 < h ? (h & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
      }
      function P(h) {
        if (io && typeof io.onCommitFiberRoot == "function")
          try {
            io.onCommitFiberRoot(
              gl,
              h,
              void 0,
              (h.current.flags & 128) === 128
            );
          } catch {
          }
      }
      function te(h) {
        if (typeof Cl == "function" && ss(h), io && typeof io.setStrictMode == "function")
          try {
            io.setStrictMode(gl, h);
          } catch {
          }
      }
      function ae(h, m) {
        return h === m && (h !== 0 || 1 / h === 1 / m) || h !== h && m !== m;
      }
      function Se(h, m) {
        if (typeof h == "object" && h !== null) {
          var M = wf.get(h);
          return M !== void 0 ? M : (m = {
            value: h,
            source: m,
            stack: T(m)
          }, wf.set(h, m), m);
        }
        return {
          value: h,
          source: m,
          stack: T(m)
        };
      }
      function ue(h, m) {
        rs[Dl++] = up, rs[Dl++] = Il, Il = h, up = m;
      }
      function we(h, m, M) {
        Po[Ur++] = sc, Po[Ur++] = Ic, Po[Ur++] = lo, lo = h;
        var w = sc;
        h = Ic;
        var I = 32 - Qs(w) - 1;
        w &= ~(1 << I), M += 1;
        var Z = 32 - Qs(m) + I;
        if (30 < Z) {
          var fe = I - I % 5;
          Z = (w & (1 << fe) - 1).toString(32), w >>= fe, I -= fe, sc = 1 << 32 - Qs(m) + I | M << I | w, Ic = Z + h;
        } else
          sc = 1 << Z | M << I | w, Ic = h;
      }
      function De(h) {
        h.return !== null && (ue(h, 1), we(h, 1, 0));
      }
      function We(h) {
        for (; h === Il; )
          Il = rs[--Dl], rs[Dl] = null, up = rs[--Dl], rs[Dl] = null;
        for (; h === lo; )
          lo = Po[--Ur], Po[Ur] = null, Ic = Po[--Ur], Po[Ur] = null, sc = Po[--Ur], Po[Ur] = null;
      }
      function Me(h, m) {
        F(Vc, m), F(cp, h), F(Ms, null), h = Cf(m), N(Ms), F(Ms, h);
      }
      function Ze() {
        N(Ms), N(cp), N(Vc);
      }
      function ct(h) {
        h.memoizedState !== null && F(Cd, h);
        var m = Ms.current, M = vh(m, h.type);
        m !== M && (F(cp, h), F(Ms, M));
      }
      function Vt(h) {
        cp.current === h && (N(Ms), N(cp)), Cd.current === h && (N(Cd), ar ? _u._currentValue = zc : _u._currentValue2 = zc);
      }
      function Zt(h) {
        var m = Error(r(418, ""));
        throw Rn(Se(m, h)), xh;
      }
      function Bn(h, m) {
        if (!Tl) throw Error(r(175));
        Ah(
          h.stateNode,
          h.type,
          h.memoizedProps,
          m,
          h
        ) || Zt(h);
      }
      function rn(h) {
        for (Bl = h.return; Bl; )
          switch (Bl.tag) {
            case 3:
            case 27:
              xs = !0;
              return;
            case 5:
            case 13:
              xs = !1;
              return;
            default:
              Bl = Bl.return;
          }
      }
      function dn(h) {
        if (!Tl || h !== Bl) return !1;
        if (!Ja) return rn(h), Ja = !0, !1;
        var m = !1;
        if (oi ? h.tag !== 3 && h.tag !== 27 && (h.tag !== 5 || Eh(h.type) && !ea(h.type, h.memoizedProps)) && (m = !0) : h.tag !== 3 && (h.tag !== 5 || Eh(h.type) && !ea(h.type, h.memoizedProps)) && (m = !0), m && Ul && Zt(h), rn(h), h.tag === 13) {
          if (!Tl) throw Error(r(316));
          if (h = h.memoizedState, h = h !== null ? h.dehydrated : null, !h) throw Error(r(317));
          Ul = gg(h);
        } else
          Ul = Bl ? mg(h.stateNode) : null;
        return !0;
      }
      function Zn() {
        Tl && (Ul = Bl = null, Ja = !1);
      }
      function Rn(h) {
        Xo === null ? Xo = [h] : Xo.push(h);
      }
      function Te() {
        for (var h = Vl, m = Ts = Vl = 0; m < h; ) {
          var M = jl[m];
          jl[m++] = null;
          var w = jl[m];
          jl[m++] = null;
          var I = jl[m];
          jl[m++] = null;
          var Z = jl[m];
          if (jl[m++] = null, w !== null && I !== null) {
            var fe = w.pending;
            fe === null ? I.next = I : (I.next = fe.next, fe.next = I), w.pending = I;
          }
          Z !== 0 && Mt(M, I, Z);
        }
      }
      function Ha(h, m, M, w) {
        jl[Vl++] = h, jl[Vl++] = m, jl[Vl++] = M, jl[Vl++] = w, Ts |= w, h.lanes |= w, h = h.alternate, h !== null && (h.lanes |= w);
      }
      function Tt(h, m, M, w) {
        return Ha(h, m, M, w), kt(h);
      }
      function St(h, m) {
        return Ha(h, null, null, m), kt(h);
      }
      function Mt(h, m, M) {
        h.lanes |= M;
        var w = h.alternate;
        w !== null && (w.lanes |= M);
        for (var I = !1, Z = h.return; Z !== null; )
          Z.childLanes |= M, w = Z.alternate, w !== null && (w.childLanes |= M), Z.tag === 22 && (h = Z.stateNode, h === null || h._visibility & 1 || (I = !0)), h = Z, Z = Z.return;
        I && m !== null && h.tag === 3 && (Z = h.stateNode, I = 31 - Qs(M), Z = Z.hiddenUpdates, h = Z[I], h === null ? Z[I] = [m] : h.push(m), m.lane = M | 536870912);
      }
      function kt(h) {
        if (50 < Am)
          throw Am = 0, cc = null, Error(r(185));
        for (var m = h.return; m !== null; )
          h = m, m = h.return;
        return h.tag === 3 ? h.stateNode : null;
      }
      function At(h) {
        h !== Fc && h.next === null && (Fc === null ? os = Fc = h : Fc = Fc.next = h), Tn = !0, Th || (Th = !0, yt(se));
      }
      function ce(h, m) {
        if (!Pc && Tn) {
          Pc = !0;
          do
            for (var M = !1, w = os; w !== null; ) {
              if (h !== 0) {
                var I = w.pendingLanes;
                if (I === 0) var Z = 0;
                else {
                  var fe = w.suspendedLanes, Be = w.pingedLanes;
                  Z = (1 << 31 - Qs(42 | h) + 1) - 1, Z &= I & ~(fe & ~Be), Z = Z & 201326677 ? Z & 201326677 | 1 : Z ? Z | 2 : 0;
                }
                Z !== 0 && (M = !0, Et(w, Z));
              } else
                Z = qa, Z = ie(
                  w,
                  w === Si ? Z : 0
                ), (Z & 3) === 0 || k(w, Z) || (M = !0, Et(w, Z));
              w = w.next;
            }
          while (M);
          Pc = !1;
        }
      }
      function se() {
        Tn = Th = !1;
        var h = 0;
        pm !== 0 && (sg() && (h = pm), pm = 0);
        for (var m = Fo(), M = null, w = os; w !== null; ) {
          var I = w.next, Z = Xe(w, m);
          Z === 0 ? (w.next = null, M === null ? os = I : M.next = I, I === null && (Fc = M)) : (M = w, (h !== 0 || (Z & 3) !== 0) && (Tn = !0)), w = I;
        }
        ce(h);
      }
      function Xe(h, m) {
        for (var M = h.suspendedLanes, w = h.pingedLanes, I = h.expirationTimes, Z = h.pendingLanes & -62914561; 0 < Z; ) {
          var fe = 31 - Qs(Z), Be = 1 << fe, qe = I[fe];
          qe === -1 ? ((Be & M) === 0 || (Be & w) !== 0) && (I[fe] = le(Be, m)) : qe <= m && (h.expiredLanes |= Be), Z &= ~Be;
        }
        if (m = Si, M = qa, M = ie(
          h,
          h === m ? M : 0
        ), w = h.callbackNode, M === 0 || h === m && Ri === 2 || h.cancelPendingCommit !== null)
          return w !== null && w !== null && mv(w), h.callbackNode = null, h.callbackPriority = 0;
        if ((M & 3) === 0 || k(h, M)) {
          if (m = M & -M, m === h.callbackPriority) return m;
          switch (w !== null && mv(w), He(M)) {
            case 2:
            case 8:
              M = Sg;
              break;
            case 32:
              M = ir;
              break;
            case 268435456:
              M = ty;
              break;
            default:
              M = ir;
          }
          return w = dt.bind(null, h), M = Of(M, w), h.callbackPriority = m, h.callbackNode = M, m;
        }
        return w !== null && w !== null && mv(w), h.callbackPriority = 2, h.callbackNode = null, 2;
      }
      function dt(h, m) {
        var M = h.callbackNode;
        if (Kr() && h.callbackNode !== M)
          return null;
        var w = qa;
        return w = ie(
          h,
          h === Si ? w : 0
        ), w === 0 ? null : (Qr(h, w, m), Xe(h, Fo()), h.callbackNode != null && h.callbackNode === M ? dt.bind(null, h) : null);
      }
      function Et(h, m) {
        if (Kr()) return null;
        Qr(h, m, !0);
      }
      function yt(h) {
        og ? Zs(function() {
          (hi & 6) !== 0 ? Of(vv, h) : h();
        }) : Of(vv, h);
      }
      function Jt() {
        return pm === 0 && (pm = ne()), pm;
      }
      function Xt(h, m) {
        if (fp === null) {
          var M = fp = [];
          dp = 0, Au = Jt(), Nf = {
            status: "pending",
            value: void 0,
            then: function(w) {
              M.push(w);
            }
          };
        }
        return dp++, m.then(Wt, Wt), m;
      }
      function Wt() {
        if (--dp === 0 && fp !== null) {
          Nf !== null && (Nf.status = "fulfilled");
          var h = fp;
          fp = null, Au = 0, Nf = null;
          for (var m = 0; m < h.length; m++) (0, h[m])();
        }
      }
      function Vn(h, m) {
        var M = [], w = {
          status: "pending",
          value: null,
          reason: null,
          then: function(I) {
            M.push(I);
          }
        };
        return h.then(
          function() {
            w.status = "fulfilled", w.value = m;
            for (var I = 0; I < M.length; I++) (0, M[I])(m);
          },
          function(I) {
            for (w.status = "rejected", w.reason = I, I = 0; I < M.length; I++)
              (0, M[I])(void 0);
          }
        ), w;
      }
      function Pt(h) {
        h.updateQueue = {
          baseState: h.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function pn(h, m) {
        h = h.updateQueue, m.updateQueue === h && (m.updateQueue = {
          baseState: h.baseState,
          firstBaseUpdate: h.firstBaseUpdate,
          lastBaseUpdate: h.lastBaseUpdate,
          shared: h.shared,
          callbacks: null
        });
      }
      function gn(h) {
        return { lane: h, tag: 0, payload: null, callback: null, next: null };
      }
      function nn(h, m, M) {
        var w = h.updateQueue;
        if (w === null) return null;
        if (w = w.shared, (hi & 2) !== 0) {
          var I = w.pending;
          return I === null ? m.next = m : (m.next = I.next, I.next = m), w.pending = m, m = kt(h), Mt(h, null, M), m;
        }
        return Ha(h, w, m, M), kt(h);
      }
      function jt(h, m, M) {
        if (m = m.updateQueue, m !== null && (m = m.shared, (M & 4194176) !== 0)) {
          var w = m.lanes;
          w &= h.pendingLanes, M |= w, m.lanes = M, Ae(h, M);
        }
      }
      function Ue(h, m) {
        var M = h.updateQueue, w = h.alternate;
        if (w !== null && (w = w.updateQueue, M === w)) {
          var I = null, Z = null;
          if (M = M.firstBaseUpdate, M !== null) {
            do {
              var fe = {
                lane: M.lane,
                tag: M.tag,
                payload: M.payload,
                callback: null,
                next: null
              };
              Z === null ? I = Z = fe : Z = Z.next = fe, M = M.next;
            } while (M !== null);
            Z === null ? I = Z = m : Z = Z.next = m;
          } else I = Z = m;
          M = {
            baseState: w.baseState,
            firstBaseUpdate: I,
            lastBaseUpdate: Z,
            shared: w.shared,
            callbacks: w.callbacks
          }, h.updateQueue = M;
          return;
        }
        h = M.lastBaseUpdate, h === null ? M.firstBaseUpdate = m : h.next = m, M.lastBaseUpdate = m;
      }
      function ot() {
        if (Rd) {
          var h = Nf;
          if (h !== null) throw h;
        }
      }
      function Ht(h, m, M, w) {
        Rd = !1;
        var I = h.updateQueue;
        zf = !1;
        var Z = I.firstBaseUpdate, fe = I.lastBaseUpdate, Be = I.shared.pending;
        if (Be !== null) {
          I.shared.pending = null;
          var qe = Be, wt = qe.next;
          qe.next = null, fe === null ? Z = wt : fe.next = wt, fe = qe;
          var en = h.alternate;
          en !== null && (en = en.updateQueue, Be = en.lastBaseUpdate, Be !== fe && (Be === null ? en.firstBaseUpdate = wt : Be.next = wt, en.lastBaseUpdate = qe));
        }
        if (Z !== null) {
          var mn = I.baseState;
          fe = 0, en = wt = qe = null, Be = Z;
          do {
            var cn = Be.lane & -536870913, Un = cn !== Be.lane;
            if (Un ? (qa & cn) === cn : (w & cn) === cn) {
              cn !== 0 && cn === Au && (Rd = !0), en !== null && (en = en.next = {
                lane: 0,
                tag: Be.tag,
                payload: Be.payload,
                callback: null,
                next: null
              });
              e: {
                var an = h, ur = Be;
                cn = m;
                var Us = M;
                switch (ur.tag) {
                  case 1:
                    if (an = ur.payload, typeof an == "function") {
                      mn = an.call(
                        Us,
                        mn,
                        cn
                      );
                      break e;
                    }
                    mn = an;
                    break e;
                  case 3:
                    an.flags = an.flags & -65537 | 128;
                  case 0:
                    if (an = ur.payload, cn = typeof an == "function" ? an.call(Us, mn, cn) : an, cn == null) break e;
                    mn = Wu({}, mn, cn);
                    break e;
                  case 2:
                    zf = !0;
                }
              }
              cn = Be.callback, cn !== null && (h.flags |= 64, Un && (h.flags |= 8192), Un = I.callbacks, Un === null ? I.callbacks = [cn] : Un.push(cn));
            } else
              Un = {
                lane: cn,
                tag: Be.tag,
                payload: Be.payload,
                callback: Be.callback,
                next: null
              }, en === null ? (wt = en = Un, qe = mn) : en = en.next = Un, fe |= cn;
            if (Be = Be.next, Be === null) {
              if (Be = I.shared.pending, Be === null)
                break;
              Un = Be, Be = Un.next, Un.next = null, I.lastBaseUpdate = Un, I.shared.pending = null;
            }
          } while (!0);
          en === null && (qe = mn), I.baseState = qe, I.firstBaseUpdate = wt, I.lastBaseUpdate = en, Z === null && (I.shared.lanes = 0), Al |= fe, h.lanes = fe, h.memoizedState = mn;
        }
      }
      function xe(h, m) {
        if (typeof h != "function")
          throw Error(r(191, h));
        h.call(m);
      }
      function Je(h, m) {
        var M = h.callbacks;
        if (M !== null)
          for (h.callbacks = null, h = 0; h < M.length; h++)
            xe(M[h], m);
      }
      function tt(h, m) {
        if (Rl(h, m)) return !0;
        if (typeof h != "object" || h === null || typeof m != "object" || m === null)
          return !1;
        var M = Object.keys(h), w = Object.keys(m);
        if (M.length !== w.length) return !1;
        for (w = 0; w < M.length; w++) {
          var I = M[w];
          if (!Xc.call(m, I) || !Rl(h[I], m[I]))
            return !1;
        }
        return !0;
      }
      function Ct(h) {
        return h = h.status, h === "fulfilled" || h === "rejected";
      }
      function $t() {
      }
      function tn(h, m, M) {
        switch (M = h[M], M === void 0 ? h.push(m) : M !== m && (m.then($t, $t), m = M), m.status) {
          case "fulfilled":
            return m.value;
          case "rejected":
            throw h = m.reason, h === so ? Error(r(483)) : h;
          default:
            if (typeof m.status == "string") m.then($t, $t);
            else {
              if (h = Si, h !== null && 100 < h.shellSuspendCounter)
                throw Error(r(482));
              h = m, h.status = "pending", h.then(
                function(w) {
                  if (m.status === "pending") {
                    var I = m;
                    I.status = "fulfilled", I.value = w;
                  }
                },
                function(w) {
                  if (m.status === "pending") {
                    var I = m;
                    I.status = "rejected", I.reason = w;
                  }
                }
              );
            }
            switch (m.status) {
              case "fulfilled":
                return m.value;
              case "rejected":
                throw h = m.reason, h === so ? Error(r(483)) : h;
            }
            throw lr = m, so;
        }
      }
      function Mn() {
        if (lr === null) throw Error(r(459));
        var h = lr;
        return lr = null, h;
      }
      function Wn(h) {
        var m = Ch;
        return Ch += 1, rc === null && (rc = []), tn(rc, h, m);
      }
      function Xa(h, m) {
        m = m.props.ref, h.ref = m !== void 0 ? m : null;
      }
      function sa(h, m) {
        throw m.$$typeof === zo ? Error(r(525)) : (h = Object.prototype.toString.call(m), Error(
          r(
            31,
            h === "[object Object]" ? "object with keys {" + Object.keys(m).join(", ") + "}" : h
          )
        ));
      }
      function ul(h) {
        var m = h._init;
        return m(h._payload);
      }
      function xa(h) {
        function m(Ke, Ge) {
          if (h) {
            var rt = Ke.deletions;
            rt === null ? (Ke.deletions = [Ge], Ke.flags |= 16) : rt.push(Ge);
          }
        }
        function M(Ke, Ge) {
          if (!h) return null;
          for (; Ge !== null; )
            m(Ke, Ge), Ge = Ge.sibling;
          return null;
        }
        function w(Ke) {
          for (var Ge = /* @__PURE__ */ new Map(); Ke !== null; )
            Ke.key !== null ? Ge.set(Ke.key, Ke) : Ge.set(Ke.index, Ke), Ke = Ke.sibling;
          return Ge;
        }
        function I(Ke, Ge) {
          return Ke = nr(Ke, Ge), Ke.index = 0, Ke.sibling = null, Ke;
        }
        function Z(Ke, Ge, rt) {
          return Ke.index = rt, h ? (rt = Ke.alternate, rt !== null ? (rt = rt.index, rt < Ge ? (Ke.flags |= 33554434, Ge) : rt) : (Ke.flags |= 33554434, Ge)) : (Ke.flags |= 1048576, Ge);
        }
        function fe(Ke) {
          return h && Ke.alternate === null && (Ke.flags |= 33554434), Ke;
        }
        function Be(Ke, Ge, rt, qt) {
          return Ge === null || Ge.tag !== 6 ? (Ge = No(rt, Ke.mode, qt), Ge.return = Ke, Ge) : (Ge = I(Ge, rt), Ge.return = Ke, Ge);
        }
        function qe(Ke, Ge, rt, qt) {
          var On = rt.type;
          return On === wc ? en(
            Ke,
            Ge,
            rt.props.children,
            qt,
            rt.key
          ) : Ge !== null && (Ge.elementType === On || typeof On == "object" && On !== null && On.$$typeof === $r && ul(On) === Ge.type) ? (Ge = I(Ge, rt.props), Xa(Ge, rt), Ge.return = Ke, Ge) : (Ge = Oc(
            rt.type,
            rt.key,
            rt.props,
            null,
            Ke.mode,
            qt
          ), Xa(Ge, rt), Ge.return = Ke, Ge);
        }
        function wt(Ke, Ge, rt, qt) {
          return Ge === null || Ge.tag !== 4 || Ge.stateNode.containerInfo !== rt.containerInfo || Ge.stateNode.implementation !== rt.implementation ? (Ge = gd(rt, Ke.mode, qt), Ge.return = Ke, Ge) : (Ge = I(Ge, rt.children || []), Ge.return = Ke, Ge);
        }
        function en(Ke, Ge, rt, qt, On) {
          return Ge === null || Ge.tag !== 7 ? (Ge = pl(
            rt,
            Ke.mode,
            qt,
            On
          ), Ge.return = Ke, Ge) : (Ge = I(Ge, rt), Ge.return = Ke, Ge);
        }
        function mn(Ke, Ge, rt) {
          if (typeof Ge == "string" && Ge !== "" || typeof Ge == "number" || typeof Ge == "bigint")
            return Ge = No(
              "" + Ge,
              Ke.mode,
              rt
            ), Ge.return = Ke, Ge;
          if (typeof Ge == "object" && Ge !== null) {
            switch (Ge.$$typeof) {
              case mh:
                return rt = Oc(
                  Ge.type,
                  Ge.key,
                  Ge.props,
                  null,
                  Ke.mode,
                  rt
                ), Xa(rt, Ge), rt.return = Ke, rt;
              case kr:
                return Ge = gd(
                  Ge,
                  Ke.mode,
                  rt
                ), Ge.return = Ke, Ge;
              case $r:
                var qt = Ge._init;
                return Ge = qt(Ge._payload), mn(Ke, Ge, rt);
            }
            if (Ys(Ge) || d(Ge))
              return Ge = pl(
                Ge,
                Ke.mode,
                rt,
                null
              ), Ge.return = Ke, Ge;
            if (typeof Ge.then == "function")
              return mn(Ke, Wn(Ge), rt);
            if (Ge.$$typeof === Wr)
              return mn(
                Ke,
                od(Ke, Ge),
                rt
              );
            sa(Ke, Ge);
          }
          return null;
        }
        function cn(Ke, Ge, rt, qt) {
          var On = Ge !== null ? Ge.key : null;
          if (typeof rt == "string" && rt !== "" || typeof rt == "number" || typeof rt == "bigint")
            return On !== null ? null : Be(Ke, Ge, "" + rt, qt);
          if (typeof rt == "object" && rt !== null) {
            switch (rt.$$typeof) {
              case mh:
                return rt.key === On ? qe(Ke, Ge, rt, qt) : null;
              case kr:
                return rt.key === On ? wt(Ke, Ge, rt, qt) : null;
              case $r:
                return On = rt._init, rt = On(rt._payload), cn(Ke, Ge, rt, qt);
            }
            if (Ys(rt) || d(rt))
              return On !== null ? null : en(Ke, Ge, rt, qt, null);
            if (typeof rt.then == "function")
              return cn(
                Ke,
                Ge,
                Wn(rt),
                qt
              );
            if (rt.$$typeof === Wr)
              return cn(
                Ke,
                Ge,
                od(Ke, rt),
                qt
              );
            sa(Ke, rt);
          }
          return null;
        }
        function Un(Ke, Ge, rt, qt, On) {
          if (typeof qt == "string" && qt !== "" || typeof qt == "number" || typeof qt == "bigint")
            return Ke = Ke.get(rt) || null, Be(Ge, Ke, "" + qt, On);
          if (typeof qt == "object" && qt !== null) {
            switch (qt.$$typeof) {
              case mh:
                return Ke = Ke.get(
                  qt.key === null ? rt : qt.key
                ) || null, qe(Ge, Ke, qt, On);
              case kr:
                return Ke = Ke.get(
                  qt.key === null ? rt : qt.key
                ) || null, wt(Ge, Ke, qt, On);
              case $r:
                var Fi = qt._init;
                return qt = Fi(qt._payload), Un(
                  Ke,
                  Ge,
                  rt,
                  qt,
                  On
                );
            }
            if (Ys(qt) || d(qt))
              return Ke = Ke.get(rt) || null, en(Ge, Ke, qt, On, null);
            if (typeof qt.then == "function")
              return Un(
                Ke,
                Ge,
                rt,
                Wn(qt),
                On
              );
            if (qt.$$typeof === Wr)
              return Un(
                Ke,
                Ge,
                rt,
                od(Ge, qt),
                On
              );
            sa(Ge, qt);
          }
          return null;
        }
        function an(Ke, Ge, rt, qt) {
          for (var On = null, Fi = null, Hn = Ge, ya = Ge = 0, Ki = null; Hn !== null && ya < rt.length; ya++) {
            Hn.index > ya ? (Ki = Hn, Hn = null) : Ki = Hn.sibling;
            var la = cn(
              Ke,
              Hn,
              rt[ya],
              qt
            );
            if (la === null) {
              Hn === null && (Hn = Ki);
              break;
            }
            h && Hn && la.alternate === null && m(Ke, Hn), Ge = Z(la, Ge, ya), Fi === null ? On = la : Fi.sibling = la, Fi = la, Hn = Ki;
          }
          if (ya === rt.length)
            return M(Ke, Hn), Ja && ue(Ke, ya), On;
          if (Hn === null) {
            for (; ya < rt.length; ya++)
              Hn = mn(Ke, rt[ya], qt), Hn !== null && (Ge = Z(
                Hn,
                Ge,
                ya
              ), Fi === null ? On = Hn : Fi.sibling = Hn, Fi = Hn);
            return Ja && ue(Ke, ya), On;
          }
          for (Hn = w(Hn); ya < rt.length; ya++)
            Ki = Un(
              Hn,
              Ke,
              ya,
              rt[ya],
              qt
            ), Ki !== null && (h && Ki.alternate !== null && Hn.delete(
              Ki.key === null ? ya : Ki.key
            ), Ge = Z(
              Ki,
              Ge,
              ya
            ), Fi === null ? On = Ki : Fi.sibling = Ki, Fi = Ki);
          return h && Hn.forEach(function(cs) {
            return m(Ke, cs);
          }), Ja && ue(Ke, ya), On;
        }
        function ur(Ke, Ge, rt, qt) {
          if (rt == null) throw Error(r(151));
          for (var On = null, Fi = null, Hn = Ge, ya = Ge = 0, Ki = null, la = rt.next(); Hn !== null && !la.done; ya++, la = rt.next()) {
            Hn.index > ya ? (Ki = Hn, Hn = null) : Ki = Hn.sibling;
            var cs = cn(Ke, Hn, la.value, qt);
            if (cs === null) {
              Hn === null && (Hn = Ki);
              break;
            }
            h && Hn && cs.alternate === null && m(Ke, Hn), Ge = Z(cs, Ge, ya), Fi === null ? On = cs : Fi.sibling = cs, Fi = cs, Hn = Ki;
          }
          if (la.done)
            return M(Ke, Hn), Ja && ue(Ke, ya), On;
          if (Hn === null) {
            for (; !la.done; ya++, la = rt.next())
              la = mn(Ke, la.value, qt), la !== null && (Ge = Z(
                la,
                Ge,
                ya
              ), Fi === null ? On = la : Fi.sibling = la, Fi = la);
            return Ja && ue(Ke, ya), On;
          }
          for (Hn = w(Hn); !la.done; ya++, la = rt.next())
            la = Un(
              Hn,
              Ke,
              ya,
              la.value,
              qt
            ), la !== null && (h && la.alternate !== null && Hn.delete(la.key === null ? ya : la.key), Ge = Z(la, Ge, ya), Fi === null ? On = la : Fi.sibling = la, Fi = la);
          return h && Hn.forEach(function(Tu) {
            return m(Ke, Tu);
          }), Ja && ue(Ke, ya), On;
        }
        function Us(Ke, Ge, rt, qt) {
          if (typeof rt == "object" && rt !== null && rt.type === wc && rt.key === null && (rt = rt.props.children), typeof rt == "object" && rt !== null) {
            switch (rt.$$typeof) {
              case mh:
                e: {
                  for (var On = rt.key; Ge !== null; ) {
                    if (Ge.key === On) {
                      if (On = rt.type, On === wc) {
                        if (Ge.tag === 7) {
                          M(
                            Ke,
                            Ge.sibling
                          ), qt = I(
                            Ge,
                            rt.props.children
                          ), qt.return = Ke, Ke = qt;
                          break e;
                        }
                      } else if (Ge.elementType === On || typeof On == "object" && On !== null && On.$$typeof === $r && ul(On) === Ge.type) {
                        M(
                          Ke,
                          Ge.sibling
                        ), qt = I(Ge, rt.props), Xa(qt, rt), qt.return = Ke, Ke = qt;
                        break e;
                      }
                      M(Ke, Ge);
                      break;
                    } else m(Ke, Ge);
                    Ge = Ge.sibling;
                  }
                  rt.type === wc ? (qt = pl(
                    rt.props.children,
                    Ke.mode,
                    qt,
                    rt.key
                  ), qt.return = Ke, Ke = qt) : (qt = Oc(
                    rt.type,
                    rt.key,
                    rt.props,
                    null,
                    Ke.mode,
                    qt
                  ), Xa(qt, rt), qt.return = Ke, Ke = qt);
                }
                return fe(Ke);
              case kr:
                e: {
                  for (On = rt.key; Ge !== null; ) {
                    if (Ge.key === On)
                      if (Ge.tag === 4 && Ge.stateNode.containerInfo === rt.containerInfo && Ge.stateNode.implementation === rt.implementation) {
                        M(
                          Ke,
                          Ge.sibling
                        ), qt = I(
                          Ge,
                          rt.children || []
                        ), qt.return = Ke, Ke = qt;
                        break e;
                      } else {
                        M(Ke, Ge);
                        break;
                      }
                    else m(Ke, Ge);
                    Ge = Ge.sibling;
                  }
                  qt = gd(rt, Ke.mode, qt), qt.return = Ke, Ke = qt;
                }
                return fe(Ke);
              case $r:
                return On = rt._init, rt = On(rt._payload), Us(
                  Ke,
                  Ge,
                  rt,
                  qt
                );
            }
            if (Ys(rt))
              return an(
                Ke,
                Ge,
                rt,
                qt
              );
            if (d(rt)) {
              if (On = d(rt), typeof On != "function")
                throw Error(r(150));
              return rt = On.call(rt), ur(
                Ke,
                Ge,
                rt,
                qt
              );
            }
            if (typeof rt.then == "function")
              return Us(
                Ke,
                Ge,
                Wn(rt),
                qt
              );
            if (rt.$$typeof === Wr)
              return Us(
                Ke,
                Ge,
                od(Ke, rt),
                qt
              );
            sa(Ke, rt);
          }
          return typeof rt == "string" && rt !== "" || typeof rt == "number" || typeof rt == "bigint" ? (rt = "" + rt, Ge !== null && Ge.tag === 6 ? (M(Ke, Ge.sibling), qt = I(Ge, rt), qt.return = Ke, Ke = qt) : (M(Ke, Ge), qt = No(rt, Ke.mode, qt), qt.return = Ke, Ke = qt), fe(Ke)) : M(Ke, Ge);
        }
        return function(Ke, Ge, rt, qt) {
          try {
            Ch = 0;
            var On = Us(
              Ke,
              Ge,
              rt,
              qt
            );
            return rc = null, On;
          } catch (Hn) {
            if (Hn === so) throw Hn;
            var Fi = t(29, Hn, null, Ke.mode);
            return Fi.lanes = qt, Fi.return = Ke, Fi;
          } finally {
          }
        };
      }
      function Ui(h, m) {
        h = Ds, F(hp, h), F(ji, m), Ds = h | m.baseLanes;
      }
      function cl() {
        F(hp, Ds), F(ji, ji.current);
      }
      function Xl() {
        Ds = hp.current, N(ji), N(hp);
      }
      function Ws(h) {
        var m = h.alternate;
        F(Jl, Jl.current & 1), F(Cs, h), Gi === null && (m === null || ji.current !== null || m.memoizedState !== null) && (Gi = h);
      }
      function lu(h) {
        if (h.tag === 22) {
          if (F(Jl, Jl.current), F(Cs, h), Gi === null) {
            var m = h.alternate;
            m !== null && m.memoizedState !== null && (Gi = h);
          }
        } else zl();
      }
      function zl() {
        F(Jl, Jl.current), F(Cs, Cs.current);
      }
      function Jn(h) {
        N(Cs), Gi === h && (Gi = null), N(Jl);
      }
      function un(h) {
        for (var m = h; m !== null; ) {
          if (m.tag === 13) {
            var M = m.memoizedState;
            if (M !== null && (M = M.dehydrated, M === null || sp(M) || Go(M)))
              return m;
          } else if (m.tag === 19 && m.memoizedProps.revealOrder !== void 0) {
            if ((m.flags & 128) !== 0) return m;
          } else if (m.child !== null) {
            m.child.return = m, m = m.child;
            continue;
          }
          if (m === h) break;
          for (; m.sibling === null; ) {
            if (m.return === null || m.return === h) return null;
            m = m.return;
          }
          m.sibling.return = m.return, m = m.sibling;
        }
        return null;
      }
      function li() {
        throw Error(r(321));
      }
      function $(h, m) {
        if (m === null) return !1;
        for (var M = 0; M < m.length && M < h.length; M++)
          if (!Rl(h[M], m[M])) return !1;
        return !0;
      }
      function pe(h, m, M, w, I, Z) {
        return Hf = Z, Ra = m, m.memoizedState = null, m.updateQueue = null, m.lanes = 0, $n.H = h === null || h.memoizedState === null ? Dd : sr, Lf = !1, Z = M(w, I), Lf = !1, ga && (Z = $e(
          m,
          M,
          w,
          I
        )), Ne(h), Z;
      }
      function Ne(h) {
        $n.H = Ji;
        var m = kn !== null && kn.next !== null;
        if (Hf = 0, Ka = kn = Ra = null, Eu = !1, Rh = 0, us = null, m) throw Error(r(300));
        h === null || ui || (h = h.dependencies, h !== null && cu(h) && (ui = !0));
      }
      function $e(h, m, M, w) {
        Ra = h;
        var I = 0;
        do {
          if (ga && (us = null), Rh = 0, ga = !1, 25 <= I) throw Error(r(301));
          if (I += 1, Ka = kn = null, h.updateQueue != null) {
            var Z = h.updateQueue;
            Z.lastEffect = null, Z.events = null, Z.stores = null, Z.memoCache != null && (Z.memoCache.index = 0);
          }
          $n.H = Ci, Z = m(M, w);
        } while (ga);
        return Z;
      }
      function nt() {
        var h = $n.H, m = h.useState()[0];
        return m = typeof m.then == "function" ? Ee(m) : m, h = h.useState()[0], (kn !== null ? kn.memoizedState : null) !== h && (Ra.flags |= 1024), m;
      }
      function pt() {
        var h = mm !== 0;
        return mm = 0, h;
      }
      function Ft(h, m, M) {
        m.updateQueue = h.updateQueue, m.flags &= -2053, h.lanes &= ~M;
      }
      function Gt(h) {
        if (Eu) {
          for (h = h.memoizedState; h !== null; ) {
            var m = h.queue;
            m !== null && (m.pending = null), h = h.next;
          }
          Eu = !1;
        }
        Hf = 0, Ka = kn = Ra = null, ga = !1, Rh = mm = 0, us = null;
      }
      function ee() {
        var h = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        return Ka === null ? Ra.memoizedState = Ka = h : Ka = Ka.next = h, Ka;
      }
      function ye() {
        if (kn === null) {
          var h = Ra.alternate;
          h = h !== null ? h.memoizedState : null;
        } else h = kn.next;
        var m = Ka === null ? Ra.memoizedState : Ka.next;
        if (m !== null)
          Ka = m, kn = h;
        else {
          if (h === null)
            throw Ra.alternate === null ? Error(r(467)) : Error(r(310));
          kn = h, h = {
            memoizedState: kn.memoizedState,
            baseState: kn.baseState,
            baseQueue: kn.baseQueue,
            queue: kn.queue,
            next: null
          }, Ka === null ? Ra.memoizedState = Ka = h : Ka = Ka.next = h;
        }
        return Ka;
      }
      function Ee(h) {
        var m = Rh;
        return Rh += 1, us === null && (us = []), h = tn(us, h, m), m = Ra, (Ka === null ? m.memoizedState : Ka.next) === null && (m = m.alternate, $n.H = m === null || m.memoizedState === null ? Dd : sr), h;
      }
      function Re(h) {
        if (h !== null && typeof h == "object") {
          if (typeof h.then == "function") return Ee(h);
          if (h.$$typeof === Wr) return ts(h);
        }
        throw Error(r(438, String(h)));
      }
      function Ie(h) {
        var m = null, M = Ra.updateQueue;
        if (M !== null && (m = M.memoCache), m == null) {
          var w = Ra.alternate;
          w !== null && (w = w.updateQueue, w !== null && (w = w.memoCache, w != null && (m = {
            data: w.data.map(function(I) {
              return I.slice();
            }),
            index: 0
          })));
        }
        if (m == null && (m = { data: [], index: 0 }), M === null && (M = pp(), Ra.updateQueue = M), M.memoCache = m, M = m.data[m.index], M === void 0)
          for (M = m.data[m.index] = Array(h), w = 0; w < h; w++)
            M[w] = iv;
        return m.index++, M;
      }
      function je(h, m) {
        return typeof m == "function" ? m(h) : m;
      }
      function _t(h) {
        var m = ye();
        return Ut(m, kn, h);
      }
      function Ut(h, m, M) {
        var w = h.queue;
        if (w === null) throw Error(r(311));
        w.lastRenderedReducer = M;
        var I = h.baseQueue, Z = w.pending;
        if (Z !== null) {
          if (I !== null) {
            var fe = I.next;
            I.next = Z.next, Z.next = fe;
          }
          m.baseQueue = I = Z, w.pending = null;
        }
        if (Z = h.baseState, I === null) h.memoizedState = Z;
        else {
          m = I.next;
          var Be = fe = null, qe = null, wt = m, en = !1;
          do {
            var mn = wt.lane & -536870913;
            if (mn !== wt.lane ? (qa & mn) === mn : (Hf & mn) === mn) {
              var cn = wt.revertLane;
              if (cn === 0)
                qe !== null && (qe = qe.next = {
                  lane: 0,
                  revertLane: 0,
                  action: wt.action,
                  hasEagerState: wt.hasEagerState,
                  eagerState: wt.eagerState,
                  next: null
                }), mn === Au && (en = !0);
              else if ((Hf & cn) === cn) {
                wt = wt.next, cn === Au && (en = !0);
                continue;
              } else
                mn = {
                  lane: 0,
                  revertLane: wt.revertLane,
                  action: wt.action,
                  hasEagerState: wt.hasEagerState,
                  eagerState: wt.eagerState,
                  next: null
                }, qe === null ? (Be = qe = mn, fe = Z) : qe = qe.next = mn, Ra.lanes |= cn, Al |= cn;
              mn = wt.action, Lf && M(Z, mn), Z = wt.hasEagerState ? wt.eagerState : M(Z, mn);
            } else
              cn = {
                lane: mn,
                revertLane: wt.revertLane,
                action: wt.action,
                hasEagerState: wt.hasEagerState,
                eagerState: wt.eagerState,
                next: null
              }, qe === null ? (Be = qe = cn, fe = Z) : qe = qe.next = cn, Ra.lanes |= mn, Al |= mn;
            wt = wt.next;
          } while (wt !== null && wt !== m);
          if (qe === null ? fe = Z : qe.next = Be, !Rl(Z, h.memoizedState) && (ui = !0, en && (M = Nf, M !== null)))
            throw M;
          h.memoizedState = Z, h.baseState = fe, h.baseQueue = qe, w.lastRenderedState = Z;
        }
        return I === null && (w.lanes = 0), [h.memoizedState, w.dispatch];
      }
      function It(h) {
        var m = ye(), M = m.queue;
        if (M === null) throw Error(r(311));
        M.lastRenderedReducer = h;
        var w = M.dispatch, I = M.pending, Z = m.memoizedState;
        if (I !== null) {
          M.pending = null;
          var fe = I = I.next;
          do
            Z = h(Z, fe.action), fe = fe.next;
          while (fe !== I);
          Rl(Z, m.memoizedState) || (ui = !0), m.memoizedState = Z, m.baseQueue === null && (m.baseState = Z), M.lastRenderedState = Z;
        }
        return [Z, w];
      }
      function on(h, m, M) {
        var w = Ra, I = ye(), Z = Ja;
        if (Z) {
          if (M === void 0)
            throw Error(r(407));
          M = M();
        } else M = m();
        var fe = !Rl(
          (kn || I).memoizedState,
          M
        );
        if (fe && (I.memoizedState = M, ui = !0), I = I.queue, $v(bn.bind(null, w, I, h), [
          h
        ]), I.getSnapshot !== m || fe || Ka !== null && Ka.memoizedState.tag & 1) {
          if (w.flags |= 2048, Hl(
            9,
            Qt.bind(
              null,
              w,
              I,
              M,
              m
            ),
            { destroy: void 0 },
            null
          ), Si === null) throw Error(r(349));
          Z || (Hf & 60) !== 0 || sn(w, m, M);
        }
        return M;
      }
      function sn(h, m, M) {
        h.flags |= 16384, h = { getSnapshot: m, value: M }, m = Ra.updateQueue, m === null ? (m = pp(), Ra.updateQueue = m, m.stores = [h]) : (M = m.stores, M === null ? m.stores = [h] : M.push(h));
      }
      function Qt(h, m, M, w) {
        m.value = M, m.getSnapshot = w, En(m) && ca(h);
      }
      function bn(h, m, M) {
        return M(function() {
          En(m) && ca(h);
        });
      }
      function En(h) {
        var m = h.getSnapshot;
        h = h.value;
        try {
          var M = m();
          return !Rl(h, M);
        } catch {
          return !0;
        }
      }
      function ca(h) {
        var m = St(h, 2);
        m !== null && Lt(m, h, 2);
      }
      function yn(h) {
        var m = ee();
        if (typeof h == "function") {
          var M = h;
          if (h = M(), Lf) {
            te(!0);
            try {
              M();
            } finally {
              te(!1);
            }
          }
        }
        return m.memoizedState = m.baseState = h, m.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: je,
          lastRenderedState: h
        }, m;
      }
      function zn(h, m, M, w) {
        return h.baseState = M, Ut(
          h,
          kn,
          typeof w == "function" ? w : je
        );
      }
      function xn(h, m, M, w, I) {
        if (sd(h)) throw Error(r(485));
        if (h = m.action, h !== null) {
          var Z = {
            payload: I,
            action: h,
            next: null,
            isTransition: !0,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(fe) {
              Z.listeners.push(fe);
            }
          };
          $n.T !== null ? M(!0) : Z.isTransition = !1, w(Z), M = m.pending, M === null ? (Z.next = m.pending = Z, si(m, Z)) : (Z.next = M.next, m.pending = M.next = Z);
        }
      }
      function si(h, m) {
        var M = m.action, w = m.payload, I = h.state;
        if (m.isTransition) {
          var Z = $n.T, fe = {};
          $n.T = fe;
          try {
            var Be = M(I, w), qe = $n.S;
            qe !== null && qe(fe, Be), jn(h, m, Be);
          } catch (wt) {
            Li(h, m, wt);
          } finally {
            $n.T = Z;
          }
        } else
          try {
            Z = M(I, w), jn(h, m, Z);
          } catch (wt) {
            Li(h, m, wt);
          }
      }
      function jn(h, m, M) {
        M !== null && typeof M == "object" && typeof M.then == "function" ? M.then(
          function(w) {
            ta(h, m, w);
          },
          function(w) {
            return Li(h, m, w);
          }
        ) : ta(h, m, M);
      }
      function ta(h, m, M) {
        m.status = "fulfilled", m.value = M, Qn(m), h.state = M, m = h.pending, m !== null && (M = m.next, M === m ? h.pending = null : (M = M.next, m.next = M, si(h, M)));
      }
      function Li(h, m, M) {
        var w = h.pending;
        if (h.pending = null, w !== null) {
          w = w.next;
          do
            m.status = "rejected", m.reason = M, Qn(m), m = m.next;
          while (m !== w);
        }
        h.action = null;
      }
      function Qn(h) {
        h = h.listeners;
        for (var m = 0; m < h.length; m++) (0, h[m])();
      }
      function Ta(h, m) {
        return m;
      }
      function da(h, m) {
        if (Ja) {
          var M = Si.formState;
          if (M !== null) {
            e: {
              var w = Ra;
              if (Ja) {
                if (Ul) {
                  var I = Lc(
                    Ul,
                    xs
                  );
                  if (I) {
                    Ul = mg(I), w = rp(I);
                    break e;
                  }
                }
                Zt(w);
              }
              w = !1;
            }
            w && (m = M[0]);
          }
        }
        M = ee(), M.memoizedState = M.baseState = m, w = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Ta,
          lastRenderedState: m
        }, M.queue = w, M = Km.bind(
          null,
          Ra,
          w
        ), w.dispatch = M, w = yn(!1);
        var Z = kd.bind(
          null,
          Ra,
          !1,
          w.queue
        );
        return w = ee(), I = {
          state: m,
          dispatch: null,
          action: h,
          pending: null
        }, w.queue = I, M = xn.bind(
          null,
          Ra,
          I,
          Z,
          M
        ), I.dispatch = M, w.memoizedState = h, [m, M, !1];
      }
      function qi(h) {
        var m = ye();
        return Ya(m, kn, h);
      }
      function Ya(h, m, M) {
        m = Ut(
          h,
          m,
          Ta
        )[0], h = _t(je)[0], m = typeof m == "object" && m !== null && typeof m.then == "function" ? Ee(m) : m;
        var w = ye(), I = w.queue, Z = I.dispatch;
        return M !== w.memoizedState && (Ra.flags |= 2048, Hl(
          9,
          Ei.bind(null, I, M),
          { destroy: void 0 },
          null
        )), [m, Z, h];
      }
      function Ei(h, m) {
        h.action = m;
      }
      function Wi(h) {
        var m = ye(), M = kn;
        if (M !== null)
          return Ya(m, M, h);
        ye(), m = m.memoizedState, M = ye();
        var w = M.queue.dispatch;
        return M.memoizedState = h, [m, w, !1];
      }
      function Hl(h, m, M, w) {
        return h = { tag: h, create: m, inst: M, deps: w, next: null }, m = Ra.updateQueue, m === null && (m = pp(), Ra.updateQueue = m), M = m.lastEffect, M === null ? m.lastEffect = h.next = h : (w = M.next, M.next = h, h.next = w, m.lastEffect = h), h;
      }
      function Pr() {
        return ye().memoizedState;
      }
      function ff(h, m, M, w) {
        var I = ee();
        Ra.flags |= h, I.memoizedState = Hl(
          1 | m,
          M,
          { destroy: void 0 },
          w === void 0 ? null : w
        );
      }
      function Xu(h, m, M, w) {
        var I = ye();
        w = w === void 0 ? null : w;
        var Z = I.memoizedState.inst;
        kn !== null && w !== null && $(w, kn.memoizedState.deps) ? I.memoizedState = Hl(m, M, Z, w) : (Ra.flags |= h, I.memoizedState = Hl(1 | m, M, Z, w));
      }
      function Yu(h, m) {
        ff(8390656, 8, h, m);
      }
      function $v(h, m) {
        Xu(2048, 8, h, m);
      }
      function Kg(h, m) {
        return Xu(4, 2, h, m);
      }
      function Zh(h, m) {
        return Xu(4, 4, h, m);
      }
      function Ec(h, m) {
        if (typeof m == "function") {
          h = h();
          var M = m(h);
          return function() {
            typeof M == "function" ? M() : m(null);
          };
        }
        if (m != null)
          return h = h(), m.current = h, function() {
            m.current = null;
          };
      }
      function Vp(h, m, M) {
        M = M != null ? M.concat([h]) : null, Xu(
          4,
          4,
          Ec.bind(null, m, h),
          M
        );
      }
      function ad() {
      }
      function df(h, m) {
        var M = ye();
        m = m === void 0 ? null : m;
        var w = M.memoizedState;
        return m !== null && $(m, w[1]) ? w[0] : (M.memoizedState = [h, m], h);
      }
      function eg(h, m) {
        var M = ye();
        m = m === void 0 ? null : m;
        var w = M.memoizedState;
        if (m !== null && $(m, w[1]))
          return w[0];
        if (w = h(), Lf) {
          te(!0);
          try {
            h();
          } finally {
            te(!1);
          }
        }
        return M.memoizedState = [w, m], w;
      }
      function Fp(h, m, M) {
        return M === void 0 || (Hf & 1073741824) !== 0 ? h.memoizedState = m : (h.memoizedState = M, h = Ca(), Ra.lanes |= h, Al |= h, M);
      }
      function Kd(h, m, M, w) {
        return Rl(M, m) ? M : ji.current !== null ? (h = Fp(h, M, w), Rl(h, m) || (ui = !0), h) : (Hf & 42) === 0 ? (ui = !0, h.memoizedState = M) : (h = Ca(), Ra.lanes |= h, Al |= h, m);
      }
      function fl(h, m, M, w, I) {
        var Z = ec();
        As(
          Z !== 0 && 8 > Z ? Z : 8
        );
        var fe = $n.T, Be = {};
        $n.T = Be, kd(h, !1, m, M);
        try {
          var qe = I(), wt = $n.S;
          if (wt !== null && wt(Be, qe), qe !== null && typeof qe == "object" && typeof qe.then == "function") {
            var en = Vn(
              qe,
              w
            );
            Ll(
              h,
              m,
              en,
              tl(h)
            );
          } else
            Ll(
              h,
              m,
              w,
              tl(h)
            );
        } catch (mn) {
          Ll(
            h,
            m,
            { then: function() {
            }, status: "rejected", reason: mn },
            tl()
          );
        } finally {
          As(Z), $n.T = fe;
        }
      }
      function To(h) {
        var m = h.memoizedState;
        if (m !== null) return m;
        m = {
          memoizedState: zc,
          baseState: zc,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: je,
            lastRenderedState: zc
          },
          next: null
        };
        var M = {};
        return m.next = {
          memoizedState: M,
          baseState: M,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: je,
            lastRenderedState: M
          },
          next: null
        }, h.memoizedState = m, h = h.alternate, h !== null && (h.memoizedState = m), m;
      }
      function id() {
        return ts(_u);
      }
      function Co() {
        return ye().memoizedState;
      }
      function su() {
        return ye().memoizedState;
      }
      function ld(h) {
        for (var m = h.return; m !== null; ) {
          switch (m.tag) {
            case 24:
            case 3:
              var M = tl();
              h = gn(M);
              var w = nn(m, h, M);
              w !== null && (Lt(w, m, M), jt(w, m, M)), m = { cache: Cc() }, h.payload = m;
              return;
          }
          m = m.return;
        }
      }
      function hf(h, m, M) {
        var w = tl();
        M = {
          lane: w,
          revertLane: 0,
          action: M,
          hasEagerState: !1,
          eagerState: null,
          next: null
        }, sd(h) ? xl(m, M) : (M = Tt(h, m, M, w), M !== null && (Lt(M, h, w), pf(M, m, w)));
      }
      function Km(h, m, M) {
        var w = tl();
        Ll(h, m, M, w);
      }
      function Ll(h, m, M, w) {
        var I = {
          lane: w,
          revertLane: 0,
          action: M,
          hasEagerState: !1,
          eagerState: null,
          next: null
        };
        if (sd(h)) xl(m, I);
        else {
          var Z = h.alternate;
          if (h.lanes === 0 && (Z === null || Z.lanes === 0) && (Z = m.lastRenderedReducer, Z !== null))
            try {
              var fe = m.lastRenderedState, Be = Z(fe, M);
              if (I.hasEagerState = !0, I.eagerState = Be, Rl(Be, fe))
                return Ha(h, m, I, 0), Si === null && Te(), !1;
            } catch {
            } finally {
            }
          if (M = Tt(h, m, I, w), M !== null)
            return Lt(M, h, w), pf(M, m, w), !0;
        }
        return !1;
      }
      function kd(h, m, M, w) {
        if (w = {
          lane: 2,
          revertLane: Jt(),
          action: w,
          hasEagerState: !1,
          eagerState: null,
          next: null
        }, sd(h)) {
          if (m) throw Error(r(479));
        } else
          m = Tt(
            h,
            M,
            w,
            2
          ), m !== null && Lt(m, h, 2);
      }
      function sd(h) {
        var m = h.alternate;
        return h === Ra || m !== null && m === Ra;
      }
      function xl(h, m) {
        ga = Eu = !0;
        var M = h.pending;
        M === null ? m.next = m : (m.next = M.next, M.next = m), h.pending = m;
      }
      function pf(h, m, M) {
        if ((M & 4194176) !== 0) {
          var w = m.lanes;
          w &= h.pendingLanes, M |= w, m.lanes = M, Ae(h, M);
        }
      }
      function ru(h, m, M, w) {
        m = h.memoizedState, M = M(w, m), M = M == null ? m : Wu({}, m, M), h.memoizedState = M, h.lanes === 0 && (h.updateQueue.baseState = M);
      }
      function Ro(h, m, M, w, I, Z, fe) {
        return h = h.stateNode, typeof h.shouldComponentUpdate == "function" ? h.shouldComponentUpdate(w, Z, fe) : m.prototype && m.prototype.isPureReactComponent ? !tt(M, w) || !tt(I, Z) : !0;
      }
      function Pp(h, m, M, w) {
        h = m.state, typeof m.componentWillReceiveProps == "function" && m.componentWillReceiveProps(M, w), typeof m.UNSAFE_componentWillReceiveProps == "function" && m.UNSAFE_componentWillReceiveProps(M, w), m.state !== h && Gf.enqueueReplaceState(m, m.state, null);
      }
      function ra(h, m) {
        var M = m;
        if ("ref" in m) {
          M = {};
          for (var w in m)
            w !== "ref" && (M[w] = m[w]);
        }
        if (h = h.defaultProps) {
          M === m && (M = Wu({}, M));
          for (var I in h)
            M[I] === void 0 && (M[I] = h[I]);
        }
        return M;
      }
      function Yt(h, m) {
        try {
          var M = h.onUncaughtError;
          M(m.value, { componentStack: m.stack });
        } catch (w) {
          setTimeout(function() {
            throw w;
          });
        }
      }
      function bc(h, m, M) {
        try {
          var w = h.onCaughtError;
          w(M.value, {
            componentStack: M.stack,
            errorBoundary: m.tag === 1 ? m.stateNode : null
          });
        } catch (I) {
          setTimeout(function() {
            throw I;
          });
        }
      }
      function qu(h, m, M) {
        return M = gn(M), M.tag = 3, M.payload = { element: null }, M.callback = function() {
          Yt(h, m);
        }, M;
      }
      function dl(h) {
        return h = gn(h), h.tag = 3, h;
      }
      function km(h, m, M, w) {
        var I = M.type.getDerivedStateFromError;
        if (typeof I == "function") {
          var Z = w.value;
          h.payload = function() {
            return I(Z);
          }, h.callback = function() {
            bc(m, M, w);
          };
        }
        var fe = M.stateNode;
        fe !== null && typeof fe.componentDidCatch == "function" && (h.callback = function() {
          bc(m, M, w), typeof I != "function" && (jc === null ? jc = /* @__PURE__ */ new Set([this]) : jc.add(this));
          var Be = w.stack;
          this.componentDidCatch(w.value, {
            componentStack: Be !== null ? Be : ""
          });
        });
      }
      function tg(h, m, M, w, I) {
        if (M.flags |= 32768, w !== null && typeof w == "object" && typeof w.then == "function") {
          if (m = M.alternate, m !== null && ah(
            m,
            M,
            I,
            !0
          ), M = Cs.current, M !== null) {
            switch (M.tag) {
              case 13:
                return Gi === null ? fa() : M.alternate === null && Vi === 0 && (Vi = 3), M.flags &= -257, M.flags |= 65536, M.lanes = I, w === gv ? M.flags |= 16384 : (m = M.updateQueue, m === null ? M.updateQueue = /* @__PURE__ */ new Set([w]) : m.add(w), vd(h, w, I)), !1;
              case 22:
                return M.flags |= 65536, w === gv ? M.flags |= 16384 : (m = M.updateQueue, m === null ? (m = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([w])
                }, M.updateQueue = m) : (M = m.retryQueue, M === null ? m.retryQueue = /* @__PURE__ */ new Set([w]) : M.add(w)), vd(h, w, I)), !1;
            }
            throw Error(r(435, M.tag));
          }
          return vd(h, w, I), fa(), !1;
        }
        if (Ja)
          return m = Cs.current, m !== null ? ((m.flags & 65536) === 0 && (m.flags |= 256), m.flags |= 65536, m.lanes = I, w !== xh && (h = Error(r(422), { cause: w }), Rn(
            Se(h, M)
          ))) : (w !== xh && (m = Error(r(423), {
            cause: w
          }), Rn(
            Se(m, M)
          )), h = h.current.alternate, h.flags |= 65536, I &= -I, h.lanes |= I, w = Se(w, M), I = qu(
            h.stateNode,
            w,
            I
          ), Ue(h, I), Vi !== 4 && (Vi = 2)), !1;
        var Z = Error(r(520), { cause: w });
        if (Z = Se(Z, M), Fl === null ? Fl = [Z] : Fl.push(Z), Vi !== 4 && (Vi = 2), m === null) return !0;
        w = Se(w, M), M = m;
        do {
          switch (M.tag) {
            case 3:
              return M.flags |= 65536, h = I & -I, M.lanes |= h, h = qu(M.stateNode, w, h), Ue(M, h), !1;
            case 1:
              if (m = M.type, Z = M.stateNode, (M.flags & 128) === 0 && (typeof m.getDerivedStateFromError == "function" || Z !== null && typeof Z.componentDidCatch == "function" && (jc === null || !jc.has(
                Z
              ))))
                return M.flags |= 65536, I &= -I, M.lanes |= I, I = dl(I), km(
                  I,
                  h,
                  M,
                  w
                ), Ue(M, I), !1;
          }
          M = M.return;
        } while (M !== null);
        return !1;
      }
      function Is(h, m, M, w) {
        m.child = h === null ? qc(m, null, M, w) : ro(
          m,
          h.child,
          M,
          w
        );
      }
      function Xp(h, m, M, w, I) {
        M = M.render;
        var Z = m.ref;
        if ("ref" in w) {
          var fe = {};
          for (var Be in w)
            Be !== "ref" && (fe[Be] = w[Be]);
        } else fe = w;
        return gf(m), w = pe(
          h,
          m,
          M,
          fe,
          Z,
          I
        ), Be = pt(), h !== null && !ui ? (Ft(h, m, I), Mc(h, m, I)) : (Ja && Be && De(m), m.flags |= 1, Is(h, m, w, I), m.child);
      }
      function ky(h, m, M, w, I) {
        if (h === null) {
          var Z = M.type;
          return typeof Z == "function" && !hh(Z) && Z.defaultProps === void 0 && M.compare === null ? (m.tag = 15, m.type = Z, ng(
            h,
            m,
            Z,
            w,
            I
          )) : (h = Oc(
            M.type,
            null,
            w,
            m,
            m.mode,
            I
          ), h.ref = m.ref, h.return = m, m.child = h);
        }
        if (Z = h.child, !jh(h, I)) {
          var fe = Z.memoizedProps;
          if (M = M.compare, M = M !== null ? M : tt, M(fe, w) && h.ref === m.ref)
            return Mc(
              h,
              m,
              I
            );
        }
        return m.flags |= 1, h = nr(Z, w), h.ref = m.ref, h.return = m, m.child = h;
      }
      function ng(h, m, M, w, I) {
        if (h !== null) {
          var Z = h.memoizedProps;
          if (tt(Z, w) && h.ref === m.ref)
            if (ui = !1, m.pendingProps = w = Z, jh(h, I))
              (h.flags & 131072) !== 0 && (ui = !0);
            else
              return m.lanes = h.lanes, Mc(h, m, I);
        }
        return fi(
          h,
          m,
          M,
          w,
          I
        );
      }
      function ag(h, m, M) {
        var w = m.pendingProps, I = w.children, Z = (m.stateNode._pendingVisibility & 2) !== 0, fe = h !== null ? h.memoizedState : null;
        if (ms(h, m), w.mode === "hidden" || Z) {
          if ((m.flags & 128) !== 0) {
            if (w = fe !== null ? fe.baseLanes | M : M, h !== null) {
              for (I = m.child = h.child, Z = 0; I !== null; )
                Z = Z | I.lanes | I.childLanes, I = I.sibling;
              m.childLanes = Z & ~w;
            } else m.childLanes = 0, m.child = null;
            return Wd(
              h,
              m,
              w,
              M
            );
          }
          if ((M & 536870912) !== 0)
            m.memoizedState = { baseLanes: 0, cachePool: null }, h !== null && lh(
              m,
              fe !== null ? fe.cachePool : null
            ), fe !== null ? Ui(m, fe) : cl(), lu(m);
          else
            return m.lanes = m.childLanes = 536870912, Wd(
              h,
              m,
              fe !== null ? fe.baseLanes | M : M,
              M
            );
        } else
          fe !== null ? (lh(m, fe.cachePool), Ui(m, fe), zl(), m.memoizedState = null) : (h !== null && lh(m, null), cl(), zl());
        return Is(h, m, I, M), m.child;
      }
      function Wd(h, m, M, w) {
        var I = Bo();
        return I = I === null ? null : {
          parent: ar ? Ii._currentValue : Ii._currentValue2,
          pool: I
        }, m.memoizedState = {
          baseLanes: M,
          cachePool: I
        }, h !== null && lh(m, null), cl(), lu(m), h !== null && ah(h, m, w, !0), null;
      }
      function ms(h, m) {
        var M = m.ref;
        if (M === null)
          h !== null && h.ref !== null && (m.flags |= 2097664);
        else {
          if (typeof M != "function" && typeof M != "object")
            throw Error(r(284));
          (h === null || h.ref !== M) && (m.flags |= 2097664);
        }
      }
      function fi(h, m, M, w, I) {
        return gf(m), M = pe(
          h,
          m,
          M,
          w,
          void 0,
          I
        ), w = pt(), h !== null && !ui ? (Ft(h, m, I), Mc(h, m, I)) : (Ja && w && De(m), m.flags |= 1, Is(h, m, M, I), m.child);
      }
      function Qh(h, m, M, w, I, Z) {
        return gf(m), m.updateQueue = null, M = $e(
          m,
          w,
          M,
          I
        ), Ne(h), w = pt(), h !== null && !ui ? (Ft(h, m, Z), Mc(h, m, Z)) : (Ja && w && De(m), m.flags |= 1, Is(h, m, M, Z), m.child);
      }
      function mf(h, m, M, w, I) {
        if (gf(m), m.stateNode === null) {
          var Z = ao, fe = M.contextType;
          typeof fe == "object" && fe !== null && (Z = ts(fe)), Z = new M(w, Z), m.memoizedState = Z.state !== null && Z.state !== void 0 ? Z.state : null, Z.updater = Gf, m.stateNode = Z, Z._reactInternals = m, Z = m.stateNode, Z.props = w, Z.state = m.memoizedState, Z.refs = {}, Pt(m), fe = M.contextType, Z.context = typeof fe == "object" && fe !== null ? ts(fe) : ao, Z.state = m.memoizedState, fe = M.getDerivedStateFromProps, typeof fe == "function" && (ru(
            m,
            M,
            fe,
            w
          ), Z.state = m.memoizedState), typeof M.getDerivedStateFromProps == "function" || typeof Z.getSnapshotBeforeUpdate == "function" || typeof Z.UNSAFE_componentWillMount != "function" && typeof Z.componentWillMount != "function" || (fe = Z.state, typeof Z.componentWillMount == "function" && Z.componentWillMount(), typeof Z.UNSAFE_componentWillMount == "function" && Z.UNSAFE_componentWillMount(), fe !== Z.state && Gf.enqueueReplaceState(
            Z,
            Z.state,
            null
          ), Ht(m, w, Z, I), ot(), Z.state = m.memoizedState), typeof Z.componentDidMount == "function" && (m.flags |= 4194308), w = !0;
        } else if (h === null) {
          Z = m.stateNode;
          var Be = m.memoizedProps, qe = ra(M, Be);
          Z.props = qe;
          var wt = Z.context, en = M.contextType;
          fe = ao, typeof en == "object" && en !== null && (fe = ts(en));
          var mn = M.getDerivedStateFromProps;
          en = typeof mn == "function" || typeof Z.getSnapshotBeforeUpdate == "function", Be = m.pendingProps !== Be, en || typeof Z.UNSAFE_componentWillReceiveProps != "function" && typeof Z.componentWillReceiveProps != "function" || (Be || wt !== fe) && Pp(
            m,
            Z,
            w,
            fe
          ), zf = !1;
          var cn = m.memoizedState;
          Z.state = cn, Ht(m, w, Z, I), ot(), wt = m.memoizedState, Be || cn !== wt || zf ? (typeof mn == "function" && (ru(
            m,
            M,
            mn,
            w
          ), wt = m.memoizedState), (qe = zf || Ro(
            m,
            M,
            qe,
            w,
            cn,
            wt,
            fe
          )) ? (en || typeof Z.UNSAFE_componentWillMount != "function" && typeof Z.componentWillMount != "function" || (typeof Z.componentWillMount == "function" && Z.componentWillMount(), typeof Z.UNSAFE_componentWillMount == "function" && Z.UNSAFE_componentWillMount()), typeof Z.componentDidMount == "function" && (m.flags |= 4194308)) : (typeof Z.componentDidMount == "function" && (m.flags |= 4194308), m.memoizedProps = w, m.memoizedState = wt), Z.props = w, Z.state = wt, Z.context = fe, w = qe) : (typeof Z.componentDidMount == "function" && (m.flags |= 4194308), w = !1);
        } else {
          Z = m.stateNode, pn(h, m), fe = m.memoizedProps, en = ra(M, fe), Z.props = en, mn = m.pendingProps, cn = Z.context, wt = M.contextType, qe = ao, typeof wt == "object" && wt !== null && (qe = ts(wt)), Be = M.getDerivedStateFromProps, (wt = typeof Be == "function" || typeof Z.getSnapshotBeforeUpdate == "function") || typeof Z.UNSAFE_componentWillReceiveProps != "function" && typeof Z.componentWillReceiveProps != "function" || (fe !== mn || cn !== qe) && Pp(
            m,
            Z,
            w,
            qe
          ), zf = !1, cn = m.memoizedState, Z.state = cn, Ht(m, w, Z, I), ot();
          var Un = m.memoizedState;
          fe !== mn || cn !== Un || zf || h !== null && h.dependencies !== null && cu(h.dependencies) ? (typeof Be == "function" && (ru(
            m,
            M,
            Be,
            w
          ), Un = m.memoizedState), (en = zf || Ro(
            m,
            M,
            en,
            w,
            cn,
            Un,
            qe
          ) || h !== null && h.dependencies !== null && cu(h.dependencies)) ? (wt || typeof Z.UNSAFE_componentWillUpdate != "function" && typeof Z.componentWillUpdate != "function" || (typeof Z.componentWillUpdate == "function" && Z.componentWillUpdate(w, Un, qe), typeof Z.UNSAFE_componentWillUpdate == "function" && Z.UNSAFE_componentWillUpdate(
            w,
            Un,
            qe
          )), typeof Z.componentDidUpdate == "function" && (m.flags |= 4), typeof Z.getSnapshotBeforeUpdate == "function" && (m.flags |= 1024)) : (typeof Z.componentDidUpdate != "function" || fe === h.memoizedProps && cn === h.memoizedState || (m.flags |= 4), typeof Z.getSnapshotBeforeUpdate != "function" || fe === h.memoizedProps && cn === h.memoizedState || (m.flags |= 1024), m.memoizedProps = w, m.memoizedState = Un), Z.props = w, Z.state = Un, Z.context = qe, w = en) : (typeof Z.componentDidUpdate != "function" || fe === h.memoizedProps && cn === h.memoizedState || (m.flags |= 4), typeof Z.getSnapshotBeforeUpdate != "function" || fe === h.memoizedProps && cn === h.memoizedState || (m.flags |= 1024), w = !1);
        }
        return Z = w, ms(h, m), w = (m.flags & 128) !== 0, Z || w ? (Z = m.stateNode, M = w && typeof M.getDerivedStateFromError != "function" ? null : Z.render(), m.flags |= 1, h !== null && w ? (m.child = ro(
          m,
          h.child,
          null,
          I
        ), m.child = ro(
          m,
          null,
          M,
          I
        )) : Is(h, m, M, I), m.memoizedState = Z.state, h = m.child) : h = Mc(
          h,
          m,
          I
        ), h;
      }
      function vf(h, m, M, w) {
        return Zn(), m.flags |= 256, Is(h, m, M, w), m.child;
      }
      function Do(h) {
        return { baseLanes: h, cachePool: Zp() };
      }
      function ou(h, m, M) {
        return h = h !== null ? h.childLanes & ~M : 0, m && (h |= co), h;
      }
      function uu(h, m, M) {
        var w = m.pendingProps, I = !1, Z = (m.flags & 128) !== 0, fe;
        if ((fe = Z) || (fe = h !== null && h.memoizedState === null ? !1 : (Jl.current & 2) !== 0), fe && (I = !0, m.flags &= -129), fe = (m.flags & 32) !== 0, m.flags &= -33, h === null) {
          if (Ja) {
            if (I ? Ws(m) : zl(), Ja) {
              var Be = Ul, qe;
              (qe = Be) && (Be = t0(
                Be,
                xs
              ), Be !== null ? (m.memoizedState = {
                dehydrated: Be,
                treeContext: lo !== null ? { id: sc, overflow: Ic } : null,
                retryLane: 536870912
              }, qe = t(18, null, null, 0), qe.stateNode = Be, qe.return = m, m.child = qe, Bl = m, Ul = null, qe = !0) : qe = !1), qe || Zt(m);
            }
            if (Be = m.memoizedState, Be !== null && (Be = Be.dehydrated, Be !== null))
              return Go(Be) ? m.lanes = 16 : m.lanes = 536870912, null;
            Jn(m);
          }
          return Be = w.children, w = w.fallback, I ? (zl(), I = m.mode, Be = vs(
            { mode: "hidden", children: Be },
            I
          ), w = pl(
            w,
            I,
            M,
            null
          ), Be.return = m, w.return = m, Be.sibling = w, m.child = Be, I = m.child, I.memoizedState = Do(M), I.childLanes = ou(
            h,
            fe,
            M
          ), m.memoizedState = gm, w) : (Ws(m), Xr(m, Be));
        }
        if (qe = h.memoizedState, qe !== null && (Be = qe.dehydrated, Be !== null)) {
          if (Z)
            m.flags & 256 ? (Ws(m), m.flags &= -257, m = rd(
              h,
              m,
              M
            )) : m.memoizedState !== null ? (zl(), m.child = h.child, m.flags |= 128, m = null) : (zl(), I = w.fallback, Be = m.mode, w = vs(
              { mode: "visible", children: w.children },
              Be
            ), I = pl(
              I,
              Be,
              M,
              null
            ), I.flags |= 2, w.return = m, I.return = m, w.sibling = I, m.child = w, ro(
              m,
              h.child,
              null,
              M
            ), w = m.child, w.memoizedState = Do(M), w.childLanes = ou(
              h,
              fe,
              M
            ), m.memoizedState = gm, m = I);
          else if (Ws(m), Go(Be))
            fe = pg(Be).digest, w = Error(r(419)), w.stack = "", w.digest = fe, Rn({ value: w, source: null, stack: null }), m = rd(
              h,
              m,
              M
            );
          else if (ui || ah(
            h,
            m,
            M,
            !1
          ), fe = (M & h.childLanes) !== 0, ui || fe) {
            if (fe = Si, fe !== null) {
              if (w = M & -M, (w & 42) !== 0) w = 1;
              else
                switch (w) {
                  case 2:
                    w = 1;
                    break;
                  case 8:
                    w = 4;
                    break;
                  case 32:
                    w = 16;
                    break;
                  case 128:
                  case 256:
                  case 512:
                  case 1024:
                  case 2048:
                  case 4096:
                  case 8192:
                  case 16384:
                  case 32768:
                  case 65536:
                  case 131072:
                  case 262144:
                  case 524288:
                  case 1048576:
                  case 2097152:
                  case 4194304:
                  case 8388608:
                  case 16777216:
                  case 33554432:
                    w = 64;
                    break;
                  case 268435456:
                    w = 134217728;
                    break;
                  default:
                    w = 0;
                }
              if (w = (w & (fe.suspendedLanes | M)) !== 0 ? 0 : w, w !== 0 && w !== qe.retryLane)
                throw qe.retryLane = w, St(h, w), Lt(fe, h, w), vm;
            }
            sp(Be) || fa(), m = rd(
              h,
              m,
              M
            );
          } else
            sp(Be) ? (m.flags |= 128, m.child = h.child, m = Ku.bind(
              null,
              h
            ), cv(Be, m), m = null) : (h = qe.treeContext, Tl && (Ul = $g(Be), Bl = m, Ja = !0, Xo = null, xs = !1, h !== null && (Po[Ur++] = sc, Po[Ur++] = Ic, Po[Ur++] = lo, sc = h.id, Ic = h.overflow, lo = m)), m = Xr(
              m,
              w.children
            ), m.flags |= 4096);
          return m;
        }
        return I ? (zl(), I = w.fallback, Be = m.mode, qe = h.child, Z = qe.sibling, w = nr(qe, {
          mode: "hidden",
          children: w.children
        }), w.subtreeFlags = qe.subtreeFlags & 31457280, Z !== null ? I = nr(Z, I) : (I = pl(
          I,
          Be,
          M,
          null
        ), I.flags |= 2), I.return = m, w.return = m, w.sibling = I, m.child = w, w = I, I = m.child, Be = h.child.memoizedState, Be === null ? Be = Do(M) : (qe = Be.cachePool, qe !== null ? (Z = ar ? Ii._currentValue : Ii._currentValue2, qe = qe.parent !== Z ? { parent: Z, pool: Z } : qe) : qe = Zp(), Be = {
          baseLanes: Be.baseLanes | M,
          cachePool: qe
        }), I.memoizedState = Be, I.childLanes = ou(
          h,
          fe,
          M
        ), m.memoizedState = gm, w) : (Ws(m), M = h.child, h = M.sibling, M = nr(M, {
          mode: "visible",
          children: w.children
        }), M.return = m, M.sibling = null, h !== null && (fe = m.deletions, fe === null ? (m.deletions = [h], m.flags |= 16) : fe.push(h)), m.child = M, m.memoizedState = null, M);
      }
      function Xr(h, m) {
        return m = vs(
          { mode: "visible", children: m },
          h.mode
        ), m.return = h, h.child = m;
      }
      function vs(h, m) {
        return $h(h, m, 0, null);
      }
      function rd(h, m, M) {
        return ro(m, h.child, null, M), h = Xr(
          m,
          m.pendingProps.children
        ), h.flags |= 2, m.memoizedState = null, h;
      }
      function $d(h, m, M) {
        h.lanes |= m;
        var w = h.alternate;
        w !== null && (w.lanes |= m), th(h.return, m, M);
      }
      function Yp(h, m, M, w, I) {
        var Z = h.memoizedState;
        Z === null ? h.memoizedState = {
          isBackwards: m,
          rendering: null,
          renderingStartTime: 0,
          last: w,
          tail: M,
          tailMode: I
        } : (Z.isBackwards = m, Z.rendering = null, Z.renderingStartTime = 0, Z.last = w, Z.tail = M, Z.tailMode = I);
      }
      function mr(h, m, M) {
        var w = m.pendingProps, I = w.revealOrder, Z = w.tail;
        if (Is(h, m, w.children, M), w = Jl.current, (w & 2) !== 0)
          w = w & 1 | 2, m.flags |= 128;
        else {
          if (h !== null && (h.flags & 128) !== 0)
            e: for (h = m.child; h !== null; ) {
              if (h.tag === 13)
                h.memoizedState !== null && $d(h, M, m);
              else if (h.tag === 19)
                $d(h, M, m);
              else if (h.child !== null) {
                h.child.return = h, h = h.child;
                continue;
              }
              if (h === m) break e;
              for (; h.sibling === null; ) {
                if (h.return === null || h.return === m)
                  break e;
                h = h.return;
              }
              h.sibling.return = h.return, h = h.sibling;
            }
          w &= 1;
        }
        switch (F(Jl, w), I) {
          case "forwards":
            for (M = m.child, I = null; M !== null; )
              h = M.alternate, h !== null && un(h) === null && (I = M), M = M.sibling;
            M = I, M === null ? (I = m.child, m.child = null) : (I = M.sibling, M.sibling = null), Yp(
              m,
              !1,
              I,
              M,
              Z
            );
            break;
          case "backwards":
            for (M = null, I = m.child, m.child = null; I !== null; ) {
              if (h = I.alternate, h !== null && un(h) === null) {
                m.child = I;
                break;
              }
              h = I.sibling, I.sibling = M, M = I, I = h;
            }
            Yp(
              m,
              !0,
              M,
              null,
              Z
            );
            break;
          case "together":
            Yp(m, !1, null, null, void 0);
            break;
          default:
            m.memoizedState = null;
        }
        return m.child;
      }
      function Mc(h, m, M) {
        if (h !== null && (m.dependencies = h.dependencies), Al |= m.lanes, (M & m.childLanes) === 0)
          if (h !== null) {
            if (ah(
              h,
              m,
              M,
              !1
            ), (M & m.childLanes) === 0)
              return null;
          } else return null;
        if (h !== null && m.child !== h.child)
          throw Error(r(153));
        if (m.child !== null) {
          for (h = m.child, M = nr(h, h.pendingProps), m.child = M, M.return = m; h.sibling !== null; )
            h = h.sibling, M = M.sibling = nr(h, h.pendingProps), M.return = m;
          M.sibling = null;
        }
        return m.child;
      }
      function jh(h, m) {
        return (h.lanes & m) !== 0 ? !0 : (h = h.dependencies, !!(h !== null && cu(h)));
      }
      function eh(h, m, M) {
        switch (m.tag) {
          case 3:
            Me(
              m,
              m.stateNode.containerInfo
            ), xc(m, Ii, h.memoizedState.cache), Zn();
            break;
          case 27:
          case 5:
            ct(m);
            break;
          case 4:
            Me(
              m,
              m.stateNode.containerInfo
            );
            break;
          case 10:
            xc(
              m,
              m.type,
              m.memoizedProps.value
            );
            break;
          case 13:
            var w = m.memoizedState;
            if (w !== null)
              return w.dehydrated !== null ? (Ws(m), m.flags |= 128, null) : (M & m.child.childLanes) !== 0 ? uu(
                h,
                m,
                M
              ) : (Ws(m), h = Mc(
                h,
                m,
                M
              ), h !== null ? h.sibling : null);
            Ws(m);
            break;
          case 19:
            var I = (h.flags & 128) !== 0;
            if (w = (M & m.childLanes) !== 0, w || (ah(
              h,
              m,
              M,
              !1
            ), w = (M & m.childLanes) !== 0), I) {
              if (w)
                return mr(
                  h,
                  m,
                  M
                );
              m.flags |= 128;
            }
            if (I = m.memoizedState, I !== null && (I.rendering = null, I.tail = null, I.lastEffect = null), F(Jl, Jl.current), w) break;
            return null;
          case 22:
          case 23:
            return m.lanes = 0, ag(h, m, M);
          case 24:
            xc(m, Ii, h.memoizedState.cache);
        }
        return Mc(h, m, M);
      }
      function qp(h, m, M) {
        if (h !== null)
          if (h.memoizedProps !== m.pendingProps)
            ui = !0;
          else {
            if (!jh(h, M) && (m.flags & 128) === 0)
              return ui = !1, eh(
                h,
                m,
                M
              );
            ui = (h.flags & 131072) !== 0;
          }
        else
          ui = !1, Ja && (m.flags & 1048576) !== 0 && we(m, up, m.index);
        switch (m.lanes = 0, m.tag) {
          case 16:
            e: {
              h = m.pendingProps;
              var w = m.elementType, I = w._init;
              if (w = I(w._payload), m.type = w, typeof w == "function")
                hh(w) ? (h = ra(w, h), m.tag = 1, m = mf(
                  null,
                  m,
                  w,
                  h,
                  M
                )) : (m.tag = 0, m = fi(
                  null,
                  m,
                  w,
                  h,
                  M
                ));
              else {
                if (w != null) {
                  if (I = w.$$typeof, I === em) {
                    m.tag = 11, m = Xp(
                      null,
                      m,
                      w,
                      h,
                      M
                    );
                    break e;
                  } else if (I === tm) {
                    m.tag = 14, m = ky(
                      null,
                      m,
                      w,
                      h,
                      M
                    );
                    break e;
                  }
                }
                throw m = p(w) || w, Error(r(306, m, ""));
              }
            }
            return m;
          case 0:
            return fi(
              h,
              m,
              m.type,
              m.pendingProps,
              M
            );
          case 1:
            return w = m.type, I = ra(
              w,
              m.pendingProps
            ), mf(
              h,
              m,
              w,
              I,
              M
            );
          case 3:
            e: {
              if (Me(
                m,
                m.stateNode.containerInfo
              ), h === null) throw Error(r(387));
              var Z = m.pendingProps;
              I = m.memoizedState, w = I.element, pn(h, m), Ht(m, Z, null, M);
              var fe = m.memoizedState;
              if (Z = fe.cache, xc(m, Ii, Z), Z !== I.cache && nh(
                m,
                [Ii],
                M,
                !0
              ), ot(), Z = fe.element, Tl && I.isDehydrated)
                if (I = {
                  element: Z,
                  isDehydrated: !1,
                  cache: fe.cache
                }, m.updateQueue.baseState = I, m.memoizedState = I, m.flags & 256) {
                  m = vf(
                    h,
                    m,
                    Z,
                    M
                  );
                  break e;
                } else if (Z !== w) {
                  w = Se(
                    Error(r(424)),
                    m
                  ), Rn(w), m = vf(
                    h,
                    m,
                    Z,
                    M
                  );
                  break e;
                } else
                  for (Tl && (Ul = fv(
                    m.stateNode.containerInfo
                  ), Bl = m, Ja = !0, Xo = null, xs = !0), M = qc(
                    m,
                    null,
                    Z,
                    M
                  ), m.child = M; M; )
                    M.flags = M.flags & -3 | 4096, M = M.sibling;
              else {
                if (Zn(), Z === w) {
                  m = Mc(
                    h,
                    m,
                    M
                  );
                  break e;
                }
                Is(h, m, Z, M);
              }
              m = m.child;
            }
            return m;
          case 26:
            if (no)
              return ms(h, m), h === null ? (M = hv(
                m.type,
                null,
                m.pendingProps,
                null
              )) ? m.memoizedState = M : Ja || (m.stateNode = Rr(
                m.type,
                m.pendingProps,
                Vc.current,
                m
              )) : m.memoizedState = hv(
                m.type,
                h.memoizedProps,
                m.pendingProps,
                h.memoizedState
              ), null;
          case 27:
            if (oi)
              return ct(m), h === null && oi && Ja && (w = m.stateNode = Gl(
                m.type,
                m.pendingProps,
                Vc.current,
                Ms.current,
                !1
              ), Bl = m, xs = !0, Ul = nc(w)), w = m.pendingProps.children, h !== null || Ja ? Is(
                h,
                m,
                w,
                M
              ) : m.child = ro(
                m,
                null,
                w,
                M
              ), ms(h, m), m.child;
          case 5:
            return h === null && Ja && (op(
              m.type,
              m.pendingProps,
              Ms.current
            ), (I = w = Ul) && (w = e0(
              w,
              m.type,
              m.pendingProps,
              xs
            ), w !== null ? (m.stateNode = w, Bl = m, Ul = nc(w), xs = !1, I = !0) : I = !1), I || Zt(m)), ct(m), I = m.type, Z = m.pendingProps, fe = h !== null ? h.memoizedProps : null, w = Z.children, ea(I, Z) ? w = null : fe !== null && ea(I, fe) && (m.flags |= 32), m.memoizedState !== null && (I = pe(
              h,
              m,
              nt,
              null,
              null,
              M
            ), ar ? _u._currentValue = I : _u._currentValue2 = I), ms(h, m), Is(h, m, w, M), m.child;
          case 6:
            return h === null && Ja && (ey(
              m.pendingProps,
              Ms.current
            ), (h = M = Ul) && (M = cm(
              M,
              m.pendingProps,
              xs
            ), M !== null ? (m.stateNode = M, Bl = m, Ul = null, h = !0) : h = !1), h || Zt(m)), null;
          case 13:
            return uu(h, m, M);
          case 4:
            return Me(
              m,
              m.stateNode.containerInfo
            ), w = m.pendingProps, h === null ? m.child = ro(
              m,
              null,
              w,
              M
            ) : Is(
              h,
              m,
              w,
              M
            ), m.child;
          case 11:
            return Xp(
              h,
              m,
              m.type,
              m.pendingProps,
              M
            );
          case 7:
            return Is(
              h,
              m,
              m.pendingProps,
              M
            ), m.child;
          case 8:
            return Is(
              h,
              m,
              m.pendingProps.children,
              M
            ), m.child;
          case 12:
            return Is(
              h,
              m,
              m.pendingProps.children,
              M
            ), m.child;
          case 10:
            return w = m.pendingProps, xc(
              m,
              m.type,
              w.value
            ), Is(
              h,
              m,
              w.children,
              M
            ), m.child;
          case 9:
            return I = m.type._context, w = m.pendingProps.children, gf(m), I = ts(I), w = w(I), m.flags |= 1, Is(
              h,
              m,
              w,
              M
            ), m.child;
          case 14:
            return ky(
              h,
              m,
              m.type,
              m.pendingProps,
              M
            );
          case 15:
            return ng(
              h,
              m,
              m.type,
              m.pendingProps,
              M
            );
          case 19:
            return mr(
              h,
              m,
              M
            );
          case 22:
            return ag(h, m, M);
          case 24:
            return gf(m), w = ts(Ii), h === null ? (I = Bo(), I === null && (I = Si, Z = Cc(), I.pooledCache = Z, Z.refCount++, Z !== null && (I.pooledCacheLanes |= M), I = Z), m.memoizedState = {
              parent: w,
              cache: I
            }, Pt(m), xc(m, Ii, I)) : ((h.lanes & M) !== 0 && (pn(h, m), Ht(m, null, null, M), ot()), I = h.memoizedState, Z = m.memoizedState, I.parent !== w ? (I = { parent: w, cache: w }, m.memoizedState = I, m.lanes === 0 && (m.memoizedState = m.updateQueue.baseState = I), xc(m, Ii, w)) : (w = Z.cache, xc(m, Ii, w), w !== I.cache && nh(
              m,
              [Ii],
              M,
              !0
            ))), Is(
              h,
              m,
              m.pendingProps.children,
              M
            ), m.child;
          case 29:
            throw m.pendingProps;
        }
        throw Error(r(156, m.tag));
      }
      function xc(h, m, M) {
        ar ? (F(bu, m._currentValue), m._currentValue = M) : (F(bu, m._currentValue2), m._currentValue2 = M);
      }
      function Zu(h) {
        var m = bu.current;
        ar ? h._currentValue = m : h._currentValue2 = m, N(bu);
      }
      function th(h, m, M) {
        for (; h !== null; ) {
          var w = h.alternate;
          if ((h.childLanes & m) !== m ? (h.childLanes |= m, w !== null && (w.childLanes |= m)) : w !== null && (w.childLanes & m) !== m && (w.childLanes |= m), h === M) break;
          h = h.return;
        }
      }
      function nh(h, m, M, w) {
        var I = h.child;
        for (I !== null && (I.return = h); I !== null; ) {
          var Z = I.dependencies;
          if (Z !== null) {
            var fe = I.child;
            Z = Z.firstContext;
            e: for (; Z !== null; ) {
              var Be = Z;
              Z = I;
              for (var qe = 0; qe < m.length; qe++)
                if (Be.context === m[qe]) {
                  Z.lanes |= M, Be = Z.alternate, Be !== null && (Be.lanes |= M), th(
                    Z.return,
                    M,
                    h
                  ), w || (fe = null);
                  break e;
                }
              Z = Be.next;
            }
          } else if (I.tag === 18) {
            if (fe = I.return, fe === null) throw Error(r(341));
            fe.lanes |= M, Z = fe.alternate, Z !== null && (Z.lanes |= M), th(fe, M, h), fe = null;
          } else fe = I.child;
          if (fe !== null) fe.return = I;
          else
            for (fe = I; fe !== null; ) {
              if (fe === h) {
                fe = null;
                break;
              }
              if (I = fe.sibling, I !== null) {
                I.return = fe.return, fe = I;
                break;
              }
              fe = fe.return;
            }
          I = fe;
        }
      }
      function ah(h, m, M, w) {
        h = null;
        for (var I = m, Z = !1; I !== null; ) {
          if (!Z) {
            if ((I.flags & 524288) !== 0) Z = !0;
            else if ((I.flags & 262144) !== 0) break;
          }
          if (I.tag === 10) {
            var fe = I.alternate;
            if (fe === null) throw Error(r(387));
            if (fe = fe.memoizedProps, fe !== null) {
              var Be = I.type;
              Rl(I.pendingProps.value, fe.value) || (h !== null ? h.push(Be) : h = [Be]);
            }
          } else if (I === Cd.current) {
            if (fe = I.alternate, fe === null) throw Error(r(387));
            fe.memoizedState.memoizedState !== I.memoizedState.memoizedState && (h !== null ? h.push(_u) : h = [_u]);
          }
          I = I.return;
        }
        h !== null && nh(
          m,
          h,
          M,
          w
        ), m.flags |= 262144;
      }
      function cu(h) {
        for (h = h.firstContext; h !== null; ) {
          var m = h.context;
          if (!Rl(
            ar ? m._currentValue : m._currentValue2,
            h.memoizedValue
          ))
            return !0;
          h = h.next;
        }
        return !1;
      }
      function gf(h) {
        Oa = h, rr = null, h = h.dependencies, h !== null && (h.firstContext = null);
      }
      function ts(h) {
        return Tc(Oa, h);
      }
      function od(h, m) {
        return Oa === null && gf(h), Tc(h, m);
      }
      function Tc(h, m) {
        var M = ar ? m._currentValue : m._currentValue2;
        if (m = { context: m, memoizedValue: M, next: null }, rr === null) {
          if (h === null) throw Error(r(308));
          rr = m, h.dependencies = { lanes: 0, firstContext: m }, h.flags |= 524288;
        } else rr = rr.next = m;
        return M;
      }
      function Cc() {
        return {
          controller: new yl(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function ih(h) {
        h.refCount--, h.refCount === 0 && n0(ny, function() {
          h.controller.abort();
        });
      }
      function Bo() {
        var h = Ol.current;
        return h !== null ? h : Si.pooledCache;
      }
      function lh(h, m) {
        m === null ? F(Ol, Ol.current) : F(Ol, m.pool);
      }
      function Zp() {
        var h = Bo();
        return h === null ? null : {
          parent: ar ? Ii._currentValue : Ii._currentValue2,
          pool: h
        };
      }
      function vr(h) {
        h.flags |= 4;
      }
      function Yr(h, m) {
        if (h !== null && h.child === m.child) return !1;
        if ((m.flags & 16) !== 0) return !0;
        for (h = m.child; h !== null; ) {
          if ((h.flags & 13878) !== 0 || (h.subtreeFlags & 13878) !== 0)
            return !0;
          h = h.sibling;
        }
        return !1;
      }
      function Vs(h, m, M, w) {
        if (Mi)
          for (M = m.child; M !== null; ) {
            if (M.tag === 5 || M.tag === 6)
              eo(h, M.stateNode);
            else if (!(M.tag === 4 || oi && M.tag === 27) && M.child !== null) {
              M.child.return = M, M = M.child;
              continue;
            }
            if (M === m) break;
            for (; M.sibling === null; ) {
              if (M.return === null || M.return === m)
                return;
              M = M.return;
            }
            M.sibling.return = M.return, M = M.sibling;
          }
        else if (Zl)
          for (var I = m.child; I !== null; ) {
            if (I.tag === 5) {
              var Z = I.stateNode;
              M && w && (Z = kg(
                Z,
                I.type,
                I.memoizedProps
              )), eo(h, Z);
            } else if (I.tag === 6)
              Z = I.stateNode, M && w && (Z = Wg(
                Z,
                I.memoizedProps
              )), eo(h, Z);
            else if (I.tag !== 4) {
              if (I.tag === 22 && I.memoizedState !== null)
                Z = I.child, Z !== null && (Z.return = I), Vs(h, I, !0, !0);
              else if (I.child !== null) {
                I.child.return = I, I = I.child;
                continue;
              }
            }
            if (I === m) break;
            for (; I.sibling === null; ) {
              if (I.return === null || I.return === m)
                return;
              I = I.return;
            }
            I.sibling.return = I.return, I = I.sibling;
          }
      }
      function Qp(h, m, M, w) {
        if (Zl)
          for (var I = m.child; I !== null; ) {
            if (I.tag === 5) {
              var Z = I.stateNode;
              M && w && (Z = kg(
                Z,
                I.type,
                I.memoizedProps
              )), Sh(h, Z);
            } else if (I.tag === 6)
              Z = I.stateNode, M && w && (Z = Wg(
                Z,
                I.memoizedProps
              )), Sh(h, Z);
            else if (I.tag !== 4) {
              if (I.tag === 22 && I.memoizedState !== null)
                Z = I.child, Z !== null && (Z.return = I), Qp(
                  h,
                  I,
                  !(I.memoizedProps !== null && I.memoizedProps.mode === "manual"),
                  !0
                );
              else if (I.child !== null) {
                I.child.return = I, I = I.child;
                continue;
              }
            }
            if (I === m) break;
            for (; I.sibling === null; ) {
              if (I.return === null || I.return === m) return;
              I = I.return;
            }
            I.sibling.return = I.return, I = I.sibling;
          }
      }
      function $s(h, m) {
        if (Zl && Yr(h, m)) {
          h = m.stateNode;
          var M = h.containerInfo, w = $a();
          Qp(w, m, !1, !1), h.pendingChildren = w, vr(m), _h(M, w);
        }
      }
      function Fs(h, m, M, w) {
        if (Mi)
          h.memoizedProps !== w && vr(m);
        else if (Zl) {
          var I = h.stateNode, Z = h.memoizedProps;
          if ((h = Yr(h, m)) || Z !== w) {
            var fe = Ms.current;
            Z = to(
              I,
              M,
              Z,
              w,
              !h,
              null
            ), Z === I ? m.stateNode = I : (Lo(
              Z,
              M,
              w,
              fe
            ) && vr(m), m.stateNode = Z, h ? Vs(Z, m, !1, !1) : vr(m));
          } else m.stateNode = I;
        }
      }
      function sh(h, m, M) {
        if (rg(m, M)) {
          if (h.flags |= 16777216, !yh(m, M))
            if (Ju()) h.flags |= 8192;
            else
              throw lr = gv, Yc;
        } else h.flags &= -16777217;
      }
      function yf(h, m) {
        if (Ti(m)) {
          if (h.flags |= 16777216, !bh(m))
            if (Ju()) h.flags |= 8192;
            else
              throw lr = gv, Yc;
        } else h.flags &= -16777217;
      }
      function Rc(h, m) {
        m !== null && (h.flags |= 4), h.flags & 16384 && (m = h.tag !== 22 ? Q() : 536870912, h.lanes |= m, Qc |= m);
      }
      function ud(h, m) {
        if (!Ja)
          switch (h.tailMode) {
            case "hidden":
              m = h.tail;
              for (var M = null; m !== null; )
                m.alternate !== null && (M = m), m = m.sibling;
              M === null ? h.tail = null : M.sibling = null;
              break;
            case "collapsed":
              M = h.tail;
              for (var w = null; M !== null; )
                M.alternate !== null && (w = M), M = M.sibling;
              w === null ? m || h.tail === null ? h.tail = null : h.tail.sibling = null : w.sibling = null;
          }
      }
      function yi(h) {
        var m = h.alternate !== null && h.alternate.child === h.child, M = 0, w = 0;
        if (m)
          for (var I = h.child; I !== null; )
            M |= I.lanes | I.childLanes, w |= I.subtreeFlags & 31457280, w |= I.flags & 31457280, I.return = h, I = I.sibling;
        else
          for (I = h.child; I !== null; )
            M |= I.lanes | I.childLanes, w |= I.subtreeFlags, w |= I.flags, I.return = h, I = I.sibling;
        return h.subtreeFlags |= w, h.childLanes = M, m;
      }
      function Wm(h, m, M) {
        var w = m.pendingProps;
        switch (We(m), m.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return yi(m), null;
          case 1:
            return yi(m), null;
          case 3:
            return M = m.stateNode, w = null, h !== null && (w = h.memoizedState.cache), m.memoizedState.cache !== w && (m.flags |= 2048), Zu(Ii), Ze(), M.pendingContext && (M.context = M.pendingContext, M.pendingContext = null), (h === null || h.child === null) && (dn(m) ? vr(m) : h === null || h.memoizedState.isDehydrated && (m.flags & 256) === 0 || (m.flags |= 1024, Xo !== null && (Ef(Xo), Xo = null))), $s(h, m), yi(m), null;
          case 26:
            if (no) {
              M = m.type;
              var I = m.memoizedState;
              return h === null ? (vr(m), I !== null ? (yi(m), yf(
                m,
                I
              )) : (yi(m), sh(
                m,
                M,
                w
              ))) : I ? I !== h.memoizedState ? (vr(m), yi(m), yf(
                m,
                I
              )) : (yi(m), m.flags &= -16777217) : (Mi ? h.memoizedProps !== w && vr(m) : Fs(
                h,
                m,
                M,
                w
              ), yi(m), sh(
                m,
                M,
                w
              )), null;
            }
          case 27:
            if (oi) {
              if (Vt(m), M = Vc.current, I = m.type, h !== null && m.stateNode != null)
                Mi ? h.memoizedProps !== w && vr(m) : Fs(
                  h,
                  m,
                  I,
                  w
                );
              else {
                if (!w) {
                  if (m.stateNode === null)
                    throw Error(r(166));
                  return yi(m), null;
                }
                h = Ms.current, dn(m) ? Bn(m, h) : (h = Gl(
                  I,
                  w,
                  M,
                  h,
                  !0
                ), m.stateNode = h, vr(m));
              }
              return yi(m), null;
            }
          case 5:
            if (Vt(m), M = m.type, h !== null && m.stateNode != null)
              Fs(h, m, M, w);
            else {
              if (!w) {
                if (m.stateNode === null)
                  throw Error(r(166));
                return yi(m), null;
              }
              h = Ms.current, dn(m) ? Bn(m, h) : (I = gh(
                M,
                w,
                Vc.current,
                h,
                m
              ), Vs(I, m, !1, !1), m.stateNode = I, Lo(
                I,
                M,
                w,
                h
              ) && vr(m));
            }
            return yi(m), sh(
              m,
              m.type,
              m.pendingProps
            ), null;
          case 6:
            if (h && m.stateNode != null)
              M = h.memoizedProps, Mi ? M !== w && vr(m) : Zl && (M !== w ? (m.stateNode = di(
                w,
                Vc.current,
                Ms.current,
                m
              ), vr(m)) : m.stateNode = h.stateNode);
            else {
              if (typeof w != "string" && m.stateNode === null)
                throw Error(r(166));
              if (h = Vc.current, M = Ms.current, dn(m)) {
                if (!Tl) throw Error(r(176));
                if (h = m.stateNode, M = m.memoizedProps, w = null, I = Bl, I !== null)
                  switch (I.tag) {
                    case 27:
                    case 5:
                      w = I.memoizedProps;
                  }
                Es(
                  h,
                  M,
                  m,
                  w
                ) || Zt(m);
              } else
                m.stateNode = di(
                  w,
                  h,
                  M,
                  m
                );
            }
            return yi(m), null;
          case 13:
            if (w = m.memoizedState, h === null || h.memoizedState !== null && h.memoizedState.dehydrated !== null) {
              if (I = dn(m), w !== null && w.dehydrated !== null) {
                if (h === null) {
                  if (!I) throw Error(r(318));
                  if (!Tl) throw Error(r(344));
                  if (I = m.memoizedState, I = I !== null ? I.dehydrated : null, !I) throw Error(r(317));
                  vg(I, m);
                } else
                  Zn(), (m.flags & 128) === 0 && (m.memoizedState = null), m.flags |= 4;
                yi(m), I = !1;
              } else
                Xo !== null && (Ef(Xo), Xo = null), I = !0;
              if (!I)
                return m.flags & 256 ? (Jn(m), m) : (Jn(m), null);
            }
            if (Jn(m), (m.flags & 128) !== 0)
              return m.lanes = M, m;
            if (M = w !== null, h = h !== null && h.memoizedState !== null, M) {
              w = m.child, I = null, w.alternate !== null && w.alternate.memoizedState !== null && w.alternate.memoizedState.cachePool !== null && (I = w.alternate.memoizedState.cachePool.pool);
              var Z = null;
              w.memoizedState !== null && w.memoizedState.cachePool !== null && (Z = w.memoizedState.cachePool.pool), Z !== I && (w.flags |= 2048);
            }
            return M !== h && M && (m.child.flags |= 8192), Rc(m, m.updateQueue), yi(m), null;
          case 4:
            return Ze(), $s(h, m), h === null && vl(m.stateNode.containerInfo), yi(m), null;
          case 10:
            return Zu(m.type), yi(m), null;
          case 19:
            if (N(Jl), I = m.memoizedState, I === null)
              return yi(m), null;
            if (w = (m.flags & 128) !== 0, Z = I.rendering, Z === null)
              if (w) ud(I, !1);
              else {
                if (Vi !== 0 || h !== null && (h.flags & 128) !== 0)
                  for (h = m.child; h !== null; ) {
                    if (Z = un(h), Z !== null) {
                      for (m.flags |= 128, ud(I, !1), h = Z.updateQueue, m.updateQueue = h, Rc(m, h), m.subtreeFlags = 0, h = M, M = m.child; M !== null; )
                        Oi(M, h), M = M.sibling;
                      return F(
                        Jl,
                        Jl.current & 1 | 2
                      ), m.child;
                    }
                    h = h.sibling;
                  }
                I.tail !== null && Fo() > Vf && (m.flags |= 128, w = !0, ud(I, !1), m.lanes = 4194304);
              }
            else {
              if (!w)
                if (h = un(Z), h !== null) {
                  if (m.flags |= 128, w = !0, h = h.updateQueue, m.updateQueue = h, Rc(m, h), ud(I, !0), I.tail === null && I.tailMode === "hidden" && !Z.alternate && !Ja)
                    return yi(m), null;
                } else
                  2 * Fo() - I.renderingStartTime > Vf && M !== 536870912 && (m.flags |= 128, w = !0, ud(I, !1), m.lanes = 4194304);
              I.isBackwards ? (Z.sibling = m.child, m.child = Z) : (h = I.last, h !== null ? h.sibling = Z : m.child = Z, I.last = Z);
            }
            return I.tail !== null ? (m = I.tail, I.rendering = m, I.tail = m.sibling, I.renderingStartTime = Fo(), m.sibling = null, h = Jl.current, F(
              Jl,
              w ? h & 1 | 2 : h & 1
            ), m) : (yi(m), null);
          case 22:
          case 23:
            return Jn(m), Xl(), w = m.memoizedState !== null, h !== null ? h.memoizedState !== null !== w && (m.flags |= 8192) : w && (m.flags |= 8192), w ? (M & 536870912) !== 0 && (m.flags & 128) === 0 && (yi(m), m.subtreeFlags & 6 && (m.flags |= 8192)) : yi(m), M = m.updateQueue, M !== null && Rc(m, M.retryQueue), M = null, h !== null && h.memoizedState !== null && h.memoizedState.cachePool !== null && (M = h.memoizedState.cachePool.pool), w = null, m.memoizedState !== null && m.memoizedState.cachePool !== null && (w = m.memoizedState.cachePool.pool), w !== M && (m.flags |= 2048), h !== null && N(Ol), null;
          case 24:
            return M = null, h !== null && (M = h.memoizedState.cache), m.memoizedState.cache !== M && (m.flags |= 2048), Zu(Ii), yi(m), null;
          case 25:
            return null;
        }
        throw Error(r(156, m.tag));
      }
      function Jh(h, m) {
        switch (We(m), m.tag) {
          case 1:
            return h = m.flags, h & 65536 ? (m.flags = h & -65537 | 128, m) : null;
          case 3:
            return Zu(Ii), Ze(), h = m.flags, (h & 65536) !== 0 && (h & 128) === 0 ? (m.flags = h & -65537 | 128, m) : null;
          case 26:
          case 27:
          case 5:
            return Vt(m), null;
          case 13:
            if (Jn(m), h = m.memoizedState, h !== null && h.dehydrated !== null) {
              if (m.alternate === null)
                throw Error(r(340));
              Zn();
            }
            return h = m.flags, h & 65536 ? (m.flags = h & -65537 | 128, m) : null;
          case 19:
            return N(Jl), null;
          case 4:
            return Ze(), null;
          case 10:
            return Zu(m.type), null;
          case 22:
          case 23:
            return Jn(m), Xl(), h !== null && N(Ol), h = m.flags, h & 65536 ? (m.flags = h & -65537 | 128, m) : null;
          case 24:
            return Zu(Ii), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function Dc(h, m) {
        switch (We(m), m.tag) {
          case 3:
            Zu(Ii), Ze();
            break;
          case 26:
          case 27:
          case 5:
            Vt(m);
            break;
          case 4:
            Ze();
            break;
          case 13:
            Jn(m);
            break;
          case 19:
            N(Jl);
            break;
          case 10:
            Zu(m.type);
            break;
          case 22:
          case 23:
            Jn(m), Xl(), h !== null && N(Ol);
            break;
          case 24:
            Zu(Ii);
        }
      }
      function gr(h, m) {
        try {
          var M = m.updateQueue, w = M !== null ? M.lastEffect : null;
          if (w !== null) {
            var I = w.next;
            M = I;
            do {
              if ((M.tag & h) === h) {
                w = void 0;
                var Z = M.create, fe = M.inst;
                w = Z(), fe.destroy = w;
              }
              M = M.next;
            } while (M !== I);
          }
        } catch (Be) {
          va(m, m.return, Be);
        }
      }
      function Qu(h, m, M) {
        try {
          var w = m.updateQueue, I = w !== null ? w.lastEffect : null;
          if (I !== null) {
            var Z = I.next;
            w = Z;
            do {
              if ((w.tag & h) === h) {
                var fe = w.inst, Be = fe.destroy;
                if (Be !== void 0) {
                  fe.destroy = void 0, I = m;
                  var qe = M;
                  try {
                    Be();
                  } catch (wt) {
                    va(
                      I,
                      qe,
                      wt
                    );
                  }
                }
              }
              w = w.next;
            } while (w !== Z);
          }
        } catch (wt) {
          va(m, m.return, wt);
        }
      }
      function $m(h) {
        var m = h.updateQueue;
        if (m !== null) {
          var M = h.stateNode;
          try {
            Je(m, M);
          } catch (w) {
            va(h, h.return, w);
          }
        }
      }
      function gs(h, m, M) {
        M.props = ra(
          h.type,
          h.memoizedProps
        ), M.state = h.memoizedState;
        try {
          M.componentWillUnmount();
        } catch (w) {
          va(h, m, w);
        }
      }
      function yr(h, m) {
        try {
          var M = h.ref;
          if (M !== null) {
            var w = h.stateNode;
            switch (h.tag) {
              case 26:
              case 27:
              case 5:
                var I = Sd(w);
                break;
              default:
                I = w;
            }
            typeof M == "function" ? h.refCleanup = M(I) : M.current = I;
          }
        } catch (Z) {
          va(h, m, Z);
        }
      }
      function Yl(h, m) {
        var M = h.ref, w = h.refCleanup;
        if (M !== null)
          if (typeof w == "function")
            try {
              w();
            } catch (I) {
              va(h, m, I);
            } finally {
              h.refCleanup = null, h = h.alternate, h != null && (h.refCleanup = null);
            }
          else if (typeof M == "function")
            try {
              M(null);
            } catch (I) {
              va(h, m, I);
            }
          else M.current = null;
      }
      function Zi(h) {
        var m = h.type, M = h.memoizedProps, w = h.stateNode;
        try {
          Wy(w, m, M, h);
        } catch (I) {
          va(h, h.return, I);
        }
      }
      function Kh(h, m, M) {
        try {
          ov(
            h.stateNode,
            h.type,
            M,
            m,
            h
          );
        } catch (w) {
          va(h, h.return, w);
        }
      }
      function jp(h) {
        return h.tag === 5 || h.tag === 3 || (no ? h.tag === 26 : !1) || (oi ? h.tag === 27 : !1) || h.tag === 4;
      }
      function rh(h) {
        e: for (; ; ) {
          for (; h.sibling === null; ) {
            if (h.return === null || jp(h.return)) return null;
            h = h.return;
          }
          for (h.sibling.return = h.return, h = h.sibling; h.tag !== 5 && h.tag !== 6 && (!oi || h.tag !== 27) && h.tag !== 18; ) {
            if (h.flags & 2 || h.child === null || h.tag === 4) continue e;
            h.child.return = h, h = h.child;
          }
          if (!(h.flags & 2)) return h.stateNode;
        }
      }
      function Sf(h, m, M) {
        var w = h.tag;
        if (w === 5 || w === 6)
          h = h.stateNode, m ? dg(M, h, m) : sm(M, h);
        else if (!(w === 4 || oi && w === 27) && (h = h.child, h !== null))
          for (Sf(h, m, M), h = h.sibling; h !== null; )
            Sf(h, m, M), h = h.sibling;
      }
      function ys(h, m, M) {
        var w = h.tag;
        if (w === 5 || w === 6)
          h = h.stateNode, m ? rm(M, h, m) : lm(M, h);
        else if (!(w === 4 || oi && w === 27) && (h = h.child, h !== null))
          for (ys(h, m, M), h = h.sibling; h !== null; )
            ys(h, m, M), h = h.sibling;
      }
      function Uo(h, m, M) {
        h = h.containerInfo;
        try {
          xi(h, M);
        } catch (w) {
          va(m, m.return, w);
        }
      }
      function _f(h, m) {
        for (Su(h.containerInfo), ma = m; ma !== null; )
          if (h = ma, m = h.child, (h.subtreeFlags & 1028) !== 0 && m !== null)
            m.return = h, ma = m;
          else
            for (; ma !== null; ) {
              h = ma;
              var M = h.alternate;
              switch (m = h.flags, h.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if ((m & 1024) !== 0 && M !== null) {
                    m = void 0;
                    var w = h, I = M.memoizedProps;
                    M = M.memoizedState;
                    var Z = w.stateNode;
                    try {
                      var fe = ra(
                        w.type,
                        I,
                        w.elementType === w.type
                      );
                      m = Z.getSnapshotBeforeUpdate(
                        fe,
                        M
                      ), Z.__reactInternalSnapshotBeforeUpdate = m;
                    } catch (Be) {
                      va(
                        w,
                        w.return,
                        Be
                      );
                    }
                  }
                  break;
                case 3:
                  (m & 1024) !== 0 && Mi && Hc(h.stateNode.containerInfo);
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if ((m & 1024) !== 0)
                    throw Error(r(163));
              }
              if (m = h.sibling, m !== null) {
                m.return = h.return, ma = m;
                break;
              }
              ma = h.return;
            }
        return fe = Ga, Ga = !1, fe;
      }
      function oh(h, m, M) {
        var w = M.flags;
        switch (M.tag) {
          case 0:
          case 11:
          case 15:
            hu(h, M), w & 4 && gr(5, M);
            break;
          case 1:
            if (hu(h, M), w & 4)
              if (h = M.stateNode, m === null)
                try {
                  h.componentDidMount();
                } catch (Be) {
                  va(M, M.return, Be);
                }
              else {
                var I = ra(
                  M.type,
                  m.memoizedProps
                );
                m = m.memoizedState;
                try {
                  h.componentDidUpdate(
                    I,
                    m,
                    h.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (Be) {
                  va(
                    M,
                    M.return,
                    Be
                  );
                }
              }
            w & 64 && $m(M), w & 512 && yr(M, M.return);
            break;
          case 3:
            if (hu(h, M), w & 64 && (w = M.updateQueue, w !== null)) {
              if (h = null, M.child !== null)
                switch (M.child.tag) {
                  case 27:
                  case 5:
                    h = Sd(M.child.stateNode);
                    break;
                  case 1:
                    h = M.child.stateNode;
                }
              try {
                Je(w, h);
              } catch (Be) {
                va(M, M.return, Be);
              }
            }
            break;
          case 26:
            if (no) {
              hu(h, M), w & 512 && yr(M, M.return);
              break;
            }
          case 27:
          case 5:
            hu(h, M), m === null && w & 4 && Zi(M), w & 512 && yr(M, M.return);
            break;
          case 12:
            hu(h, M);
            break;
          case 13:
            hu(h, M), w & 4 && qr(h, M);
            break;
          case 22:
            if (I = M.memoizedState !== null || oc, !I) {
              m = m !== null && m.memoizedState !== null || Sl;
              var Z = oc, fe = Sl;
              oc = I, (Sl = m) && !fe ? mu(
                h,
                M,
                (M.subtreeFlags & 8772) !== 0
              ) : hu(h, M), oc = Z, Sl = fe;
            }
            w & 512 && (M.memoizedProps.mode === "manual" ? yr(M, M.return) : Yl(M, M.return));
            break;
          default:
            hu(h, M);
        }
      }
      function ev(h) {
        var m = h.alternate;
        m !== null && (h.alternate = null, ev(m)), h.child = null, h.deletions = null, h.sibling = null, h.tag === 5 && (m = h.stateNode, m !== null && sv(m)), h.stateNode = null, h.return = null, h.dependencies = null, h.memoizedProps = null, h.memoizedState = null, h.pendingProps = null, h.stateNode = null, h.updateQueue = null;
      }
      function ns(h, m, M) {
        for (M = M.child; M !== null; )
          fu(
            h,
            m,
            M
          ), M = M.sibling;
      }
      function fu(h, m, M) {
        if (io && typeof io.onCommitFiberUnmount == "function")
          try {
            io.onCommitFiberUnmount(gl, M);
          } catch {
          }
        switch (M.tag) {
          case 26:
            if (no) {
              Sl || Yl(M, m), ns(
                h,
                m,
                M
              ), M.memoizedState ? Bf(M.memoizedState) : M.stateNode && pa(M.stateNode);
              break;
            }
          case 27:
            if (oi) {
              Sl || Yl(M, m);
              var w = Fn, I = ba;
              Fn = M.stateNode, ns(
                h,
                m,
                M
              ), Uf(M.stateNode), Fn = w, ba = I;
              break;
            }
          case 5:
            Sl || Yl(M, m);
          case 6:
            if (Mi) {
              if (w = Fn, I = ba, Fn = null, ns(
                h,
                m,
                M
              ), Fn = w, ba = I, Fn !== null)
                if (ba)
                  try {
                    om(Fn, M.stateNode);
                  } catch (Z) {
                    va(
                      M,
                      m,
                      Z
                    );
                  }
                else
                  try {
                    Ed(Fn, M.stateNode);
                  } catch (Z) {
                    va(
                      M,
                      m,
                      Z
                    );
                  }
            } else
              ns(
                h,
                m,
                M
              );
            break;
          case 18:
            Mi && Fn !== null && (ba ? Md(
              Fn,
              M.stateNode
            ) : yg(Fn, M.stateNode));
            break;
          case 4:
            Mi ? (w = Fn, I = ba, Fn = M.stateNode.containerInfo, ba = !0, ns(
              h,
              m,
              M
            ), Fn = w, ba = I) : (Zl && Uo(
              M.stateNode,
              M,
              $a()
            ), ns(
              h,
              m,
              M
            ));
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            Sl || Qu(2, M, m), Sl || Qu(4, M, m), ns(
              h,
              m,
              M
            );
            break;
          case 1:
            Sl || (Yl(M, m), w = M.stateNode, typeof w.componentWillUnmount == "function" && gs(
              M,
              m,
              w
            )), ns(
              h,
              m,
              M
            );
            break;
          case 21:
            ns(
              h,
              m,
              M
            );
            break;
          case 22:
            Sl || Yl(M, m), Sl = (w = Sl) || M.memoizedState !== null, ns(
              h,
              m,
              M
            ), Sl = w;
            break;
          default:
            ns(
              h,
              m,
              M
            );
        }
      }
      function qr(h, m) {
        if (Tl && m.memoizedState === null && (h = m.alternate, h !== null && (h = h.memoizedState, h !== null && (h = h.dehydrated, h !== null))))
          try {
            bd(h);
          } catch (M) {
            va(m, m.return, M);
          }
      }
      function Oo(h) {
        switch (h.tag) {
          case 13:
          case 19:
            var m = h.stateNode;
            return m === null && (m = h.stateNode = new mi()), m;
          case 22:
            return h = h.stateNode, m = h._retryCache, m === null && (m = h._retryCache = new mi()), m;
          default:
            throw Error(r(435, h.tag));
        }
      }
      function du(h, m) {
        var M = Oo(h);
        m.forEach(function(w) {
          var I = Uc.bind(null, h, w);
          M.has(w) || (M.add(w), w.then(I, I));
        });
      }
      function Sr(h, m) {
        var M = m.deletions;
        if (M !== null)
          for (var w = 0; w < M.length; w++) {
            var I = M[w], Z = h, fe = m;
            if (Mi) {
              var Be = fe;
              e: for (; Be !== null; ) {
                switch (Be.tag) {
                  case 27:
                  case 5:
                    Fn = Be.stateNode, ba = !1;
                    break e;
                  case 3:
                    Fn = Be.stateNode.containerInfo, ba = !0;
                    break e;
                  case 4:
                    Fn = Be.stateNode.containerInfo, ba = !0;
                    break e;
                }
                Be = Be.return;
              }
              if (Fn === null) throw Error(r(160));
              fu(Z, fe, I), Fn = null, ba = !1;
            } else fu(Z, fe, I);
            Z = I.alternate, Z !== null && (Z.return = null), I.return = null;
          }
        if (m.subtreeFlags & 13878)
          for (m = m.child; m !== null; )
            Jp(m, h), m = m.sibling;
      }
      function Jp(h, m) {
        var M = h.alternate, w = h.flags;
        switch (h.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Sr(m, h), _r(h), w & 4 && (Qu(3, h, h.return), gr(3, h), Qu(5, h, h.return));
            break;
          case 1:
            Sr(m, h), _r(h), w & 512 && (Sl || M === null || Yl(M, M.return)), w & 64 && oc && (h = h.updateQueue, h !== null && (w = h.callbacks, w !== null && (M = h.shared.hiddenCallbacks, h.shared.hiddenCallbacks = M === null ? w : M.concat(w))));
            break;
          case 26:
            if (no) {
              var I = _l;
              Sr(m, h), _r(h), w & 512 && (Sl || M === null || Yl(M, M.return)), w & 4 && (w = M !== null ? M.memoizedState : null, m = h.memoizedState, M === null ? m === null ? h.stateNode === null ? h.stateNode = hm(
                I,
                h.type,
                h.memoizedProps,
                h
              ) : pv(
                I,
                h.type,
                h.stateNode
              ) : h.stateNode = Gc(
                I,
                m,
                h.memoizedProps
              ) : w !== m ? (w === null ? M.stateNode !== null && pa(M.stateNode) : Bf(w), m === null ? pv(
                I,
                h.type,
                h.stateNode
              ) : Gc(
                I,
                m,
                h.memoizedProps
              )) : m === null && h.stateNode !== null && Kh(
                h,
                h.memoizedProps,
                M.memoizedProps
              ));
              break;
            }
          case 27:
            if (oi && w & 4 && h.alternate === null) {
              I = h.stateNode;
              var Z = h.memoizedProps;
              try {
                ac(I), ic(
                  h.type,
                  Z,
                  I,
                  h
                );
              } catch (en) {
                va(h, h.return, en);
              }
            }
          case 5:
            if (Sr(m, h), _r(h), w & 512 && (Sl || M === null || Yl(M, M.return)), Mi) {
              if (h.flags & 32) {
                m = h.stateNode;
                try {
                  um(m);
                } catch (en) {
                  va(h, h.return, en);
                }
              }
              w & 4 && h.stateNode != null && (m = h.memoizedProps, Kh(
                h,
                m,
                M !== null ? M.memoizedProps : m
              )), w & 1024 && (Ag = !0);
            }
            break;
          case 6:
            if (Sr(m, h), _r(h), w & 4 && Mi) {
              if (h.stateNode === null)
                throw Error(r(162));
              w = h.memoizedProps, M = M !== null ? M.memoizedProps : w, m = h.stateNode;
              try {
                fg(m, M, w);
              } catch (en) {
                va(h, h.return, en);
              }
            }
            break;
          case 3:
            if (no ? (Dr(), I = _l, _l = dm(m.containerInfo), Sr(m, h), _l = I) : Sr(m, h), _r(h), w & 4) {
              if (Mi && Tl && M !== null && M.memoizedState.isDehydrated)
                try {
                  dv(m.containerInfo);
                } catch (en) {
                  va(h, h.return, en);
                }
              if (Zl) {
                w = m.containerInfo, M = m.pendingChildren;
                try {
                  xi(w, M);
                } catch (en) {
                  va(h, h.return, en);
                }
              }
            }
            Ag && (Ag = !1, tv(h));
            break;
          case 4:
            no ? (M = _l, _l = dm(
              h.stateNode.containerInfo
            ), Sr(m, h), _r(h), _l = M) : (Sr(m, h), _r(h)), w & 4 && Zl && Uo(
              h.stateNode,
              h,
              h.stateNode.pendingChildren
            );
            break;
          case 12:
            Sr(m, h), _r(h);
            break;
          case 13:
            Sr(m, h), _r(h), h.child.flags & 8192 && h.memoizedState !== null != (M !== null && M.memoizedState !== null) && (fo = Fo()), w & 4 && (w = h.updateQueue, w !== null && (h.updateQueue = null, du(h, w)));
            break;
          case 22:
            w & 512 && (Sl || M === null || Yl(M, M.return)), I = h.memoizedState !== null;
            var fe = M !== null && M.memoizedState !== null, Be = oc, qe = Sl;
            if (oc = Be || I, Sl = qe || fe, Sr(m, h), Sl = qe, oc = Be, _r(h), m = h.stateNode, m._current = h, m._visibility &= -3, m._visibility |= m._pendingVisibility & 2, w & 8192 && (m._visibility = I ? m._visibility & -2 : m._visibility | 1, I && (m = oc || Sl, M === null || fe || m || pu(h)), Mi && (h.memoizedProps === null || h.memoizedProps.mode !== "manual"))) {
              e: if (M = null, Mi)
                for (m = h; ; ) {
                  if (m.tag === 5 || no && m.tag === 26 || oi && m.tag === 27) {
                    if (M === null) {
                      fe = M = m;
                      try {
                        Z = fe.stateNode, I ? uv(Z) : hg(
                          fe.stateNode,
                          fe.memoizedProps
                        );
                      } catch (en) {
                        va(fe, fe.return, en);
                      }
                    }
                  } else if (m.tag === 6) {
                    if (M === null) {
                      fe = m;
                      try {
                        var wt = fe.stateNode;
                        I ? Df(wt) : $y(wt, fe.memoizedProps);
                      } catch (en) {
                        va(fe, fe.return, en);
                      }
                    }
                  } else if ((m.tag !== 22 && m.tag !== 23 || m.memoizedState === null || m === h) && m.child !== null) {
                    m.child.return = m, m = m.child;
                    continue;
                  }
                  if (m === h) break e;
                  for (; m.sibling === null; ) {
                    if (m.return === null || m.return === h)
                      break e;
                    M === m && (M = null), m = m.return;
                  }
                  M === m && (M = null), m.sibling.return = m.return, m = m.sibling;
                }
            }
            w & 4 && (w = h.updateQueue, w !== null && (M = w.retryQueue, M !== null && (w.retryQueue = null, du(h, M))));
            break;
          case 19:
            Sr(m, h), _r(h), w & 4 && (w = h.updateQueue, w !== null && (h.updateQueue = null, du(h, w)));
            break;
          case 21:
            break;
          default:
            Sr(m, h), _r(h);
        }
      }
      function _r(h) {
        var m = h.flags;
        if (m & 2) {
          try {
            if (Mi && (!oi || h.tag !== 27)) {
              e: {
                for (var M = h.return; M !== null; ) {
                  if (jp(M)) {
                    var w = M;
                    break e;
                  }
                  M = M.return;
                }
                throw Error(r(160));
              }
              switch (w.tag) {
                case 27:
                  if (oi) {
                    var I = w.stateNode, Z = rh(h);
                    ys(
                      h,
                      Z,
                      I
                    );
                    break;
                  }
                case 5:
                  var fe = w.stateNode;
                  w.flags & 32 && (um(fe), w.flags &= -33);
                  var Be = rh(h);
                  ys(h, Be, fe);
                  break;
                case 3:
                case 4:
                  var qe = w.stateNode.containerInfo, wt = rh(h);
                  Sf(
                    h,
                    wt,
                    qe
                  );
                  break;
                default:
                  throw Error(r(161));
              }
            }
          } catch (en) {
            va(h, h.return, en);
          }
          h.flags &= -3;
        }
        m & 4096 && (h.flags &= -4097);
      }
      function tv(h) {
        if (h.subtreeFlags & 1024)
          for (h = h.child; h !== null; ) {
            var m = h;
            tv(m), m.tag === 5 && m.flags & 1024 && Ql(m.stateNode), h = h.sibling;
          }
      }
      function hu(h, m) {
        if (m.subtreeFlags & 8772)
          for (m = m.child; m !== null; )
            oh(h, m.alternate, m), m = m.sibling;
      }
      function pu(h) {
        for (h = h.child; h !== null; ) {
          var m = h;
          switch (m.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              Qu(4, m, m.return), pu(m);
              break;
            case 1:
              Yl(m, m.return);
              var M = m.stateNode;
              typeof M.componentWillUnmount == "function" && gs(
                m,
                m.return,
                M
              ), pu(m);
              break;
            case 26:
            case 27:
            case 5:
              Yl(m, m.return), pu(m);
              break;
            case 22:
              Yl(m, m.return), m.memoizedState === null && pu(m);
              break;
            default:
              pu(m);
          }
          h = h.sibling;
        }
      }
      function mu(h, m, M) {
        for (M = M && (m.subtreeFlags & 8772) !== 0, m = m.child; m !== null; ) {
          var w = m.alternate, I = h, Z = m, fe = Z.flags;
          switch (Z.tag) {
            case 0:
            case 11:
            case 15:
              mu(
                I,
                Z,
                M
              ), gr(4, Z);
              break;
            case 1:
              if (mu(
                I,
                Z,
                M
              ), w = Z, I = w.stateNode, typeof I.componentDidMount == "function")
                try {
                  I.componentDidMount();
                } catch (wt) {
                  va(w, w.return, wt);
                }
              if (w = Z, I = w.updateQueue, I !== null) {
                var Be = w.stateNode;
                try {
                  var qe = I.shared.hiddenCallbacks;
                  if (qe !== null)
                    for (I.shared.hiddenCallbacks = null, I = 0; I < qe.length; I++)
                      xe(qe[I], Be);
                } catch (wt) {
                  va(w, w.return, wt);
                }
              }
              M && fe & 64 && $m(Z), yr(Z, Z.return);
              break;
            case 26:
            case 27:
            case 5:
              mu(
                I,
                Z,
                M
              ), M && w === null && fe & 4 && Zi(Z), yr(Z, Z.return);
              break;
            case 12:
              mu(
                I,
                Z,
                M
              );
              break;
            case 13:
              mu(
                I,
                Z,
                M
              ), M && fe & 4 && qr(I, Z);
              break;
            case 22:
              Z.memoizedState === null && mu(
                I,
                Z,
                M
              ), yr(Z, Z.return);
              break;
            default:
              mu(
                I,
                Z,
                M
              );
          }
          m = m.sibling;
        }
      }
      function Kp(h, m) {
        var M = null;
        h !== null && h.memoizedState !== null && h.memoizedState.cachePool !== null && (M = h.memoizedState.cachePool.pool), h = null, m.memoizedState !== null && m.memoizedState.cachePool !== null && (h = m.memoizedState.cachePool.pool), h !== M && (h != null && h.refCount++, M != null && ih(M));
      }
      function Af(h, m) {
        h = null, m.alternate !== null && (h = m.alternate.memoizedState.cache), m = m.memoizedState.cache, m !== h && (m.refCount++, h != null && ih(h));
      }
      function ql(h, m, M, w) {
        if (m.subtreeFlags & 10256)
          for (m = m.child; m !== null; )
            kp(
              h,
              m,
              M,
              w
            ), m = m.sibling;
      }
      function kp(h, m, M, w) {
        var I = m.flags;
        switch (m.tag) {
          case 0:
          case 11:
          case 15:
            ql(
              h,
              m,
              M,
              w
            ), I & 2048 && gr(9, m);
            break;
          case 3:
            ql(
              h,
              m,
              M,
              w
            ), I & 2048 && (h = null, m.alternate !== null && (h = m.alternate.memoizedState.cache), m = m.memoizedState.cache, m !== h && (m.refCount++, h != null && ih(h)));
            break;
          case 12:
            if (I & 2048) {
              ql(
                h,
                m,
                M,
                w
              ), h = m.stateNode;
              try {
                var Z = m.memoizedProps, fe = Z.id, Be = Z.onPostCommit;
                typeof Be == "function" && Be(
                  fe,
                  m.alternate === null ? "mount" : "update",
                  h.passiveEffectDuration,
                  -0
                );
              } catch (qe) {
                va(m, m.return, qe);
              }
            } else
              ql(
                h,
                m,
                M,
                w
              );
            break;
          case 23:
            break;
          case 22:
            Z = m.stateNode, m.memoizedState !== null ? Z._visibility & 4 ? ql(
              h,
              m,
              M,
              w
            ) : ri(
              h,
              m
            ) : Z._visibility & 4 ? ql(
              h,
              m,
              M,
              w
            ) : (Z._visibility |= 4, Ps(
              h,
              m,
              M,
              w,
              (m.subtreeFlags & 10256) !== 0
            )), I & 2048 && Kp(
              m.alternate,
              m
            );
            break;
          case 24:
            ql(
              h,
              m,
              M,
              w
            ), I & 2048 && Af(m.alternate, m);
            break;
          default:
            ql(
              h,
              m,
              M,
              w
            );
        }
      }
      function Ps(h, m, M, w, I) {
        for (I = I && (m.subtreeFlags & 10256) !== 0, m = m.child; m !== null; ) {
          var Z = h, fe = m, Be = M, qe = w, wt = fe.flags;
          switch (fe.tag) {
            case 0:
            case 11:
            case 15:
              Ps(
                Z,
                fe,
                Be,
                qe,
                I
              ), gr(8, fe);
              break;
            case 23:
              break;
            case 22:
              var en = fe.stateNode;
              fe.memoizedState !== null ? en._visibility & 4 ? Ps(
                Z,
                fe,
                Be,
                qe,
                I
              ) : ri(
                Z,
                fe
              ) : (en._visibility |= 4, Ps(
                Z,
                fe,
                Be,
                qe,
                I
              )), I && wt & 2048 && Kp(
                fe.alternate,
                fe
              );
              break;
            case 24:
              Ps(
                Z,
                fe,
                Be,
                qe,
                I
              ), I && wt & 2048 && Af(fe.alternate, fe);
              break;
            default:
              Ps(
                Z,
                fe,
                Be,
                qe,
                I
              );
          }
          m = m.sibling;
        }
      }
      function ri(h, m) {
        if (m.subtreeFlags & 10256)
          for (m = m.child; m !== null; ) {
            var M = h, w = m, I = w.flags;
            switch (w.tag) {
              case 22:
                ri(M, w), I & 2048 && Kp(
                  w.alternate,
                  w
                );
                break;
              case 24:
                ri(M, w), I & 2048 && Af(
                  w.alternate,
                  w
                );
                break;
              default:
                ri(M, w);
            }
            m = m.sibling;
          }
      }
      function Zr(h) {
        if (h.subtreeFlags & wr)
          for (h = h.child; h !== null; )
            ju(h), h = h.sibling;
      }
      function ju(h) {
        switch (h.tag) {
          case 26:
            Zr(h), h.flags & wr && (h.memoizedState !== null ? Br(
              _l,
              h.memoizedState,
              h.memoizedProps
            ) : qs(h.type, h.memoizedProps));
            break;
          case 5:
            Zr(h), h.flags & wr && qs(h.type, h.memoizedProps);
            break;
          case 3:
          case 4:
            if (no) {
              var m = _l;
              _l = dm(
                h.stateNode.containerInfo
              ), Zr(h), _l = m;
            } else Zr(h);
            break;
          case 22:
            h.memoizedState === null && (m = h.alternate, m !== null && m.memoizedState !== null ? (m = wr, wr = 16777216, Zr(h), wr = m) : Zr(h));
            break;
          default:
            Zr(h);
        }
      }
      function vu(h) {
        var m = h.alternate;
        if (m !== null && (h = m.child, h !== null)) {
          m.child = null;
          do
            m = h.sibling, h.sibling = null, h = m;
          while (h !== null);
        }
      }
      function gu(h) {
        var m = h.deletions;
        if ((h.flags & 16) !== 0) {
          if (m !== null)
            for (var M = 0; M < m.length; M++) {
              var w = m[M];
              ma = w, cd(
                w,
                h
              );
            }
          vu(h);
        }
        if (h.subtreeFlags & 10256)
          for (h = h.child; h !== null; )
            uh(h), h = h.sibling;
      }
      function uh(h) {
        switch (h.tag) {
          case 0:
          case 11:
          case 15:
            gu(h), h.flags & 2048 && Qu(9, h, h.return);
            break;
          case 3:
            gu(h);
            break;
          case 12:
            gu(h);
            break;
          case 22:
            var m = h.stateNode;
            h.memoizedState !== null && m._visibility & 4 && (h.return === null || h.return.tag !== 13) ? (m._visibility &= -5, er(h)) : gu(h);
            break;
          default:
            gu(h);
        }
      }
      function er(h) {
        var m = h.deletions;
        if ((h.flags & 16) !== 0) {
          if (m !== null)
            for (var M = 0; M < m.length; M++) {
              var w = m[M];
              ma = w, cd(
                w,
                h
              );
            }
          vu(h);
        }
        for (h = h.child; h !== null; ) {
          switch (m = h, m.tag) {
            case 0:
            case 11:
            case 15:
              Qu(8, m, m.return), er(m);
              break;
            case 22:
              M = m.stateNode, M._visibility & 4 && (M._visibility &= -5, er(m));
              break;
            default:
              er(m);
          }
          h = h.sibling;
        }
      }
      function cd(h, m) {
        for (; ma !== null; ) {
          var M = ma;
          switch (M.tag) {
            case 0:
            case 11:
            case 15:
              Qu(8, M, m);
              break;
            case 23:
            case 22:
              if (M.memoizedState !== null && M.memoizedState.cachePool !== null) {
                var w = M.memoizedState.cachePool.pool;
                w != null && w.refCount++;
              }
              break;
            case 24:
              ih(M.memoizedState.cache);
          }
          if (w = M.child, w !== null) w.return = M, ma = w;
          else
            e: for (M = h; ma !== null; ) {
              w = ma;
              var I = w.sibling, Z = w.return;
              if (ev(w), w === M) {
                ma = null;
                break e;
              }
              if (I !== null) {
                I.return = Z, ma = I;
                break e;
              }
              ma = Z;
            }
        }
      }
      function ch(h) {
        var m = lv(h);
        if (m != null) {
          if (typeof m.memoizedProps["data-testname"] != "string")
            throw Error(r(364));
          return m;
        }
        if (h = am(h), h === null) throw Error(r(362));
        return h.stateNode.current;
      }
      function fd(h, m) {
        var M = h.tag;
        switch (m.$$typeof) {
          case Sm:
            if (h.type === m.value) return !0;
            break;
          case uc:
            e: {
              for (m = m.value, h = [h, 0], M = 0; M < h.length; ) {
                var w = h[M++], I = w.tag, Z = h[M++], fe = m[Z];
                if (I !== 5 && I !== 26 && I !== 27 || !Ad(w)) {
                  for (; fe != null && fd(w, fe); )
                    Z++, fe = m[Z];
                  if (Z === m.length) {
                    m = !0;
                    break e;
                  } else
                    for (w = w.child; w !== null; )
                      h.push(w, Z), w = w.sibling;
                }
              }
              m = !1;
            }
            return m;
          case il:
            if ((M === 5 || M === 26 || M === 27) && ug(h.stateNode, m.value))
              return !0;
            break;
          case Zc:
            if ((M === 5 || M === 6 || M === 26 || M === 27) && (h = im(h), h !== null && 0 <= h.indexOf(m.value)))
              return !0;
            break;
          case Mu:
            if ((M === 5 || M === 26 || M === 27) && (h = h.memoizedProps["data-testname"], typeof h == "string" && h.toLowerCase() === m.value.toLowerCase()))
              return !0;
            break;
          default:
            throw Error(r(365));
        }
        return !1;
      }
      function nv(h) {
        switch (h.$$typeof) {
          case Sm:
            return "<" + (p(h.value) || "Unknown") + ">";
          case uc:
            return ":has(" + (nv(h) || "") + ")";
          case il:
            return '[role="' + h.value + '"]';
          case Zc:
            return '"' + h.value + '"';
          case Mu:
            return '[data-testname="' + h.value + '"]';
          default:
            throw Error(r(365));
        }
      }
      function tr(h, m) {
        var M = [];
        h = [h, 0];
        for (var w = 0; w < h.length; ) {
          var I = h[w++], Z = I.tag, fe = h[w++], Be = m[fe];
          if (Z !== 5 && Z !== 26 && Z !== 27 || !Ad(I)) {
            for (; Be != null && fd(I, Be); )
              fe++, Be = m[fe];
            if (fe === m.length) M.push(I);
            else
              for (I = I.child; I !== null; )
                h.push(I, fe), I = I.sibling;
          }
        }
        return M;
      }
      function dd(h, m) {
        if (!tc) throw Error(r(363));
        h = ch(h), h = tr(h, m), m = [], h = Array.from(h);
        for (var M = 0; M < h.length; ) {
          var w = h[M++], I = w.tag;
          if (I === 5 || I === 26 || I === 27)
            Ad(w) || m.push(w.stateNode);
          else
            for (w = w.child; w !== null; )
              h.push(w), w = w.sibling;
        }
        return m;
      }
      function tl() {
        if ((hi & 2) !== 0 && qa !== 0)
          return qa & -qa;
        if ($n.T !== null) {
          var h = Au;
          return h !== 0 ? h : Jt();
        }
        return Rf();
      }
      function Ca() {
        co === 0 && (co = (qa & 536870912) === 0 || Ja ? ne() : 536870912);
        var h = Cs.current;
        return h !== null && (h.flags |= 32), co;
      }
      function Lt(h, m, M) {
        (h === Si && Ri === 2 || h.cancelPendingCommit !== null) && (Ss(h, 0), Xs(
          h,
          qa,
          co,
          !1
        )), re(h, M), ((hi & 2) === 0 || h !== Si) && (h === Si && ((hi & 2) === 0 && (If |= M), Vi === 4 && Xs(
          h,
          qa,
          co,
          !1
        )), At(h));
      }
      function Qr(h, m, M) {
        if ((hi & 6) !== 0) throw Error(r(327));
        var w = !M && (m & 60) === 0 && (m & h.expiredLanes) === 0 || k(h, m), I = w ? wo(h, m) : fh(h, m, !0), Z = w;
        do {
          if (I === 0) {
            qo && !w && Xs(h, m, 0, !1);
            break;
          } else if (I === 6)
            Xs(
              h,
              m,
              0,
              !uo
            );
          else {
            if (M = h.current.alternate, Z && !hd(M)) {
              I = fh(h, m, !1), Z = !1;
              continue;
            }
            if (I === 2) {
              if (Z = m, h.errorRecoveryDisabledLanes & Z)
                var fe = 0;
              else
                fe = h.pendingLanes & -536870913, fe = fe !== 0 ? fe : fe & 536870912 ? 536870912 : 0;
              if (fe !== 0) {
                m = fe;
                e: {
                  var Be = h;
                  I = Fl;
                  var qe = Tl && Be.current.memoizedState.isDehydrated;
                  if (qe && (Ss(Be, fe).flags |= 256), fe = fh(
                    Be,
                    fe,
                    !1
                  ), fe !== 2) {
                    if (Rs && !qe) {
                      Be.errorRecoveryDisabledLanes |= Z, If |= Z, I = 4;
                      break e;
                    }
                    Z = wl, wl = I, Z !== null && Ef(Z);
                  }
                  I = fe;
                }
                if (Z = !1, I !== 2) continue;
              }
            }
            if (I === 1) {
              Ss(h, 0), Xs(h, m, 0, !0);
              break;
            }
            e: {
              switch (w = h, I) {
                case 0:
                case 1:
                  throw Error(r(345));
                case 4:
                  if ((m & 4194176) === m) {
                    Xs(
                      w,
                      m,
                      co,
                      !uo
                    );
                    break e;
                  }
                  break;
                case 2:
                  wl = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(r(329));
              }
              if (w.finishedWork = M, w.finishedLanes = m, (m & 62914560) === m && (Z = fo + 300 - Fo(), 10 < Z)) {
                if (Xs(
                  w,
                  m,
                  co,
                  !uo
                ), ie(w, 0) !== 0) break e;
                w.timeoutHandle = Qi(
                  nl.bind(
                    null,
                    w,
                    M,
                    wl,
                    Bd,
                    yv,
                    m,
                    co,
                    If,
                    Qc,
                    uo,
                    2,
                    -0,
                    0
                  ),
                  Z
                );
                break e;
              }
              nl(
                w,
                M,
                wl,
                Bd,
                yv,
                m,
                co,
                If,
                Qc,
                uo,
                0,
                -0,
                0
              );
            }
          }
          break;
        } while (!0);
        At(h);
      }
      function Ef(h) {
        wl === null ? wl = h : wl.push.apply(
          wl,
          h
        );
      }
      function nl(h, m, M, w, I, Z, fe, Be, qe, wt, en, mn, cn) {
        var Un = m.subtreeFlags;
        if ((Un & 8192 || (Un & 16785408) === 16785408) && (Cr(), ju(m), m = ha(), m !== null)) {
          h.cancelPendingCommit = m(
            br.bind(
              null,
              h,
              M,
              w,
              I,
              fe,
              Be,
              qe,
              1,
              mn,
              cn
            )
          ), Xs(h, Z, fe, !wt);
          return;
        }
        br(
          h,
          M,
          w,
          I,
          fe,
          Be,
          qe,
          en,
          mn,
          cn
        );
      }
      function hd(h) {
        for (var m = h; ; ) {
          var M = m.tag;
          if ((M === 0 || M === 11 || M === 15) && m.flags & 16384 && (M = m.updateQueue, M !== null && (M = M.stores, M !== null)))
            for (var w = 0; w < M.length; w++) {
              var I = M[w], Z = I.getSnapshot;
              I = I.value;
              try {
                if (!Rl(Z(), I)) return !1;
              } catch {
                return !1;
              }
            }
          if (M = m.child, m.subtreeFlags & 16384 && M !== null)
            M.return = m, m = M;
          else {
            if (m === h) break;
            for (; m.sibling === null; ) {
              if (m.return === null || m.return === h) return !0;
              m = m.return;
            }
            m.sibling.return = m.return, m = m.sibling;
          }
        }
        return !0;
      }
      function Xs(h, m, M, w) {
        m &= ~_m, m &= ~If, h.suspendedLanes |= m, h.pingedLanes &= ~m, w && (h.warmLanes |= m), w = h.expirationTimes;
        for (var I = m; 0 < I; ) {
          var Z = 31 - Qs(I), fe = 1 << Z;
          w[Z] = -1, I &= ~fe;
        }
        M !== 0 && me(h, M, m);
      }
      function kh() {
        return (hi & 6) === 0 ? (ce(0), !1) : !0;
      }
      function Ar() {
        if (Dn !== null) {
          if (Ri === 0)
            var h = Dn.return;
          else
            h = Dn, rr = Oa = null, Gt(h), rc = null, Ch = 0, h = Dn;
          for (; h !== null; )
            Dc(h.alternate, h), h = h.return;
          Dn = null;
        }
      }
      function Ss(h, m) {
        h.finishedWork = null, h.finishedLanes = 0;
        var M = h.timeoutHandle;
        M !== Tr && (h.timeoutHandle = Tr, Nc(M)), M = h.cancelPendingCommit, M !== null && (h.cancelPendingCommit = null, M()), Ar(), Si = h, Dn = M = nr(h.current, null), qa = m, Ri = 0, or = null, uo = !1, qo = k(h, m), Rs = !1, Qc = co = _m = If = Al = Vi = 0, wl = Fl = null, yv = !1, (m & 8) !== 0 && (m |= m & 32);
        var w = h.entangledLanes;
        if (w !== 0)
          for (h = h.entanglements, w &= m; 0 < w; ) {
            var I = 31 - Qs(w), Z = 1 << I;
            m |= h[I], w &= ~Z;
          }
        return Ds = m, Te(), M;
      }
      function jr(h, m) {
        Ra = null, $n.H = Ji, m === so ? (m = Mn(), Ri = 3) : m === Yc ? (m = Mn(), Ri = 4) : Ri = m === vm ? 8 : m !== null && typeof m == "object" && typeof m.then == "function" ? 6 : 1, or = m, Dn === null && (Vi = 1, Yt(
          h,
          Se(m, h.current)
        ));
      }
      function Ju() {
        var h = Cs.current;
        return h === null ? !0 : (qa & 4194176) === qa ? Gi === null : (qa & 62914560) === qa || (qa & 536870912) !== 0 ? h === Gi : !1;
      }
      function Jr() {
        var h = $n.H;
        return $n.H = Ji, h === null ? Ji : h;
      }
      function bi() {
        var h = $n.A;
        return $n.A = ym, h;
      }
      function fa() {
        Vi = 4, uo || (qa & 4194176) !== qa && Cs.current !== null || (qo = !0), (Al & 134217727) === 0 && (If & 134217727) === 0 || Si === null || Xs(
          Si,
          qa,
          co,
          !1
        );
      }
      function fh(h, m, M) {
        var w = hi;
        hi |= 2;
        var I = Jr(), Z = bi();
        (Si !== h || qa !== m) && (Bd = null, Ss(h, m)), m = !1;
        var fe = Vi;
        e: do
          try {
            if (Ri !== 0 && Dn !== null) {
              var Be = Dn, qe = or;
              switch (Ri) {
                case 8:
                  Ar(), fe = 6;
                  break e;
                case 3:
                case 2:
                case 6:
                  Cs.current === null && (m = !0);
                  var wt = Ri;
                  if (Ri = 0, or = null, as(h, Be, qe, wt), M && qo) {
                    fe = 0;
                    break e;
                  }
                  break;
                default:
                  wt = Ri, Ri = 0, or = null, as(h, Be, qe, wt);
              }
            }
            pd(), fe = Vi;
            break;
          } catch (en) {
            jr(h, en);
          }
        while (!0);
        return m && h.shellSuspendCounter++, rr = Oa = null, hi = w, $n.H = I, $n.A = Z, Dn === null && (Si = null, qa = 0, Te()), fe;
      }
      function pd() {
        for (; Dn !== null; ) Ua(Dn);
      }
      function wo(h, m) {
        var M = hi;
        hi |= 2;
        var w = Jr(), I = bi();
        Si !== h || qa !== m ? (Bd = null, Vf = Fo() + 500, Ss(h, m)) : qo = k(
          h,
          m
        );
        e: do
          try {
            if (Ri !== 0 && Dn !== null) {
              m = Dn;
              var Z = or;
              t: switch (Ri) {
                case 1:
                  Ri = 0, or = null, as(h, m, Z, 1);
                  break;
                case 2:
                  if (Ct(Z)) {
                    Ri = 0, or = null, Ln(m);
                    break;
                  }
                  m = function() {
                    Ri === 2 && Si === h && (Ri = 7), At(h);
                  }, Z.then(m, m);
                  break e;
                case 3:
                  Ri = 7;
                  break e;
                case 4:
                  Ri = 5;
                  break e;
                case 7:
                  Ct(Z) ? (Ri = 0, or = null, Ln(m)) : (Ri = 0, or = null, as(h, m, Z, 7));
                  break;
                case 5:
                  var fe = null;
                  switch (Dn.tag) {
                    case 26:
                      fe = Dn.memoizedState;
                    case 5:
                    case 27:
                      var Be = Dn, qe = Be.type, wt = Be.pendingProps;
                      if (fe ? bh(fe) : yh(qe, wt)) {
                        Ri = 0, or = null;
                        var en = Be.sibling;
                        if (en !== null) Dn = en;
                        else {
                          var mn = Be.return;
                          mn !== null ? (Dn = mn, Er(mn)) : Dn = null;
                        }
                        break t;
                      }
                  }
                  Ri = 0, or = null, as(h, m, Z, 5);
                  break;
                case 6:
                  Ri = 0, or = null, as(h, m, Z, 6);
                  break;
                case 8:
                  Ar(), Vi = 6;
                  break e;
                default:
                  throw Error(r(462));
              }
            }
            hl();
            break;
          } catch (cn) {
            jr(h, cn);
          }
        while (!0);
        return rr = Oa = null, $n.H = w, $n.A = I, hi = M, Dn !== null ? 0 : (Si = null, qa = 0, Te(), Vi);
      }
      function hl() {
        for (; Dn !== null && !ft(); )
          Ua(Dn);
      }
      function Ua(h) {
        var m = qp(
          h.alternate,
          h,
          Ds
        );
        h.memoizedProps = h.pendingProps, m === null ? Er(h) : Dn = m;
      }
      function Ln(h) {
        var m = h, M = m.alternate;
        switch (m.tag) {
          case 15:
          case 0:
            m = Qh(
              M,
              m,
              m.pendingProps,
              m.type,
              void 0,
              qa
            );
            break;
          case 11:
            m = Qh(
              M,
              m,
              m.pendingProps,
              m.type.render,
              m.ref,
              qa
            );
            break;
          case 5:
            Gt(m);
          default:
            Dc(M, m), m = Dn = Oi(m, Ds), m = qp(M, m, Ds);
        }
        h.memoizedProps = h.pendingProps, m === null ? Er(h) : Dn = m;
      }
      function as(h, m, M, w) {
        rr = Oa = null, Gt(m), rc = null, Ch = 0;
        var I = m.return;
        try {
          if (tg(
            h,
            I,
            m,
            M,
            qa
          )) {
            Vi = 1, Yt(
              h,
              Se(M, h.current)
            ), Dn = null;
            return;
          }
        } catch (Z) {
          if (I !== null) throw Dn = I, Z;
          Vi = 1, Yt(
            h,
            Se(M, h.current)
          ), Dn = null;
          return;
        }
        m.flags & 32768 ? (Ja || w === 1 ? h = !0 : qo || (qa & 536870912) !== 0 ? h = !1 : (uo = h = !0, (w === 2 || w === 3 || w === 6) && (w = Cs.current, w !== null && w.tag === 13 && (w.flags |= 16384))), bf(m, h)) : Er(m);
      }
      function Er(h) {
        var m = h;
        do {
          if ((m.flags & 32768) !== 0) {
            bf(
              m,
              uo
            );
            return;
          }
          h = m.return;
          var M = Wm(
            m.alternate,
            m,
            Ds
          );
          if (M !== null) {
            Dn = M;
            return;
          }
          if (m = m.sibling, m !== null) {
            Dn = m;
            return;
          }
          Dn = m = h;
        } while (m !== null);
        Vi === 0 && (Vi = 5);
      }
      function bf(h, m) {
        do {
          var M = Jh(h.alternate, h);
          if (M !== null) {
            M.flags &= 32767, Dn = M;
            return;
          }
          if (M = h.return, M !== null && (M.flags |= 32768, M.subtreeFlags = 0, M.deletions = null), !m && (h = h.sibling, h !== null)) {
            Dn = h;
            return;
          }
          Dn = h = M;
        } while (h !== null);
        Vi = 6, Dn = null;
      }
      function br(h, m, M, w, I, Z, fe, Be, qe, wt) {
        var en = $n.T, mn = ec();
        try {
          As(2), $n.T = null, md(
            h,
            m,
            M,
            w,
            mn,
            I,
            Z,
            fe,
            Be,
            qe,
            wt
          );
        } finally {
          $n.T = en, As(mn);
        }
      }
      function md(h, m, M, w, I, Z, fe, Be) {
        do
          Kr();
        while (Kl !== null);
        if ((hi & 6) !== 0) throw Error(r(327));
        var qe = h.finishedWork;
        if (w = h.finishedLanes, qe === null) return null;
        if (h.finishedWork = null, h.finishedLanes = 0, qe === h.current) throw Error(r(177));
        h.callbackNode = null, h.callbackPriority = 0, h.cancelPendingCommit = null;
        var wt = qe.lanes | qe.childLanes;
        if (wt |= Ts, _e(
          h,
          w,
          wt,
          Z,
          fe,
          Be
        ), h === Si && (Dn = Si = null, qa = 0), (qe.subtreeFlags & 10256) === 0 && (qe.flags & 10256) === 0 || Zo || (Zo = !0, $i = wt, Sv = M, ku(ir, function() {
          return Kr(), null;
        })), M = (qe.flags & 15990) !== 0, (qe.subtreeFlags & 15990) !== 0 || M ? (M = $n.T, $n.T = null, Z = ec(), As(2), fe = hi, hi |= 4, _f(h, qe), Jp(qe, h), ls(h.containerInfo), h.current = qe, oh(h, qe.alternate, qe), Td(), hi = fe, As(Z), $n.T = M) : h.current = qe, Zo ? (Zo = !1, Kl = h, Bs = w) : Wp(h, wt), wt = h.pendingLanes, wt === 0 && (jc = null), P(qe.stateNode), At(h), m !== null)
          for (I = h.onRecoverableError, qe = 0; qe < m.length; qe++)
            wt = m[qe], I(wt.value, {
              componentStack: wt.stack
            });
        return (Bs & 3) !== 0 && Kr(), wt = h.pendingLanes, (w & 4194218) !== 0 && (wt & 42) !== 0 ? h === cc ? Am++ : (Am = 0, cc = h) : Am = 0, ce(0), null;
      }
      function Wp(h, m) {
        (h.pooledCacheLanes &= m) === 0 && (m = h.pooledCache, m != null && (h.pooledCache = null, ih(m)));
      }
      function Kr() {
        if (Kl !== null) {
          var h = Kl, m = $i;
          $i = 0;
          var M = He(Bs), w = 32 > M ? 32 : M;
          M = $n.T;
          var I = ec();
          try {
            if (As(w), $n.T = null, Kl === null)
              var Z = !1;
            else {
              w = Sv, Sv = null;
              var fe = Kl, Be = Bs;
              if (Kl = null, Bs = 0, (hi & 6) !== 0)
                throw Error(r(331));
              var qe = hi;
              if (hi |= 4, uh(fe.current), kp(
                fe,
                fe.current,
                Be,
                w
              ), hi = qe, ce(0, !1), io && typeof io.onPostCommitFiberRoot == "function")
                try {
                  io.onPostCommitFiberRoot(gl, fe);
                } catch {
                }
              Z = !0;
            }
            return Z;
          } finally {
            As(I), $n.T = M, Wp(h, m);
          }
        }
        return !1;
      }
      function dh(h, m, M) {
        m = Se(M, m), m = qu(h.stateNode, m, 2), h = nn(h, m, 2), h !== null && (re(h, 2), At(h));
      }
      function va(h, m, M) {
        if (h.tag === 3)
          dh(h, h, M);
        else
          for (; m !== null; ) {
            if (m.tag === 3) {
              dh(
                m,
                h,
                M
              );
              break;
            } else if (m.tag === 1) {
              var w = m.stateNode;
              if (typeof m.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (jc === null || !jc.has(w))) {
                h = Se(M, h), M = dl(2), w = nn(m, M, 2), w !== null && (km(
                  M,
                  w,
                  m,
                  h
                ), re(w, 2), At(w));
                break;
              }
            }
            m = m.return;
          }
      }
      function vd(h, m, M) {
        var w = h.pingCache;
        if (w === null) {
          w = h.pingCache = new xu();
          var I = /* @__PURE__ */ new Set();
          w.set(m, I);
        } else
          I = w.get(m), I === void 0 && (I = /* @__PURE__ */ new Set(), w.set(m, I));
        I.has(M) || (Rs = !0, I.add(M), h = Wh.bind(null, h, m, M), m.then(h, h));
      }
      function Wh(h, m, M) {
        var w = h.pingCache;
        w !== null && w.delete(m), h.pingedLanes |= h.suspendedLanes & M, h.warmLanes &= ~M, Si === h && (qa & M) === M && (Vi === 4 || Vi === 3 && (qa & 62914560) === qa && 300 > Fo() - fo ? (hi & 2) === 0 && Ss(h, 0) : _m |= M, Qc === qa && (Qc = 0)), At(h);
      }
      function Bc(h, m) {
        m === 0 && (m = Q()), h = St(h, m), h !== null && (re(h, m), At(h));
      }
      function Ku(h) {
        var m = h.memoizedState, M = 0;
        m !== null && (M = m.retryLane), Bc(h, M);
      }
      function Uc(h, m) {
        var M = 0;
        switch (h.tag) {
          case 13:
            var w = h.stateNode, I = h.memoizedState;
            I !== null && (M = I.retryLane);
            break;
          case 19:
            w = h.stateNode;
            break;
          case 22:
            w = h.stateNode._retryCache;
            break;
          default:
            throw Error(r(314));
        }
        w !== null && w.delete(m), Bc(h, M);
      }
      function ku(h, m) {
        return Of(h, m);
      }
      function av(h, m, M, w) {
        this.tag = h, this.key = M, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = m, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = w, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
      }
      function hh(h) {
        return h = h.prototype, !(!h || !h.isReactComponent);
      }
      function nr(h, m) {
        var M = h.alternate;
        return M === null ? (M = t(
          h.tag,
          m,
          h.key,
          h.mode
        ), M.elementType = h.elementType, M.type = h.type, M.stateNode = h.stateNode, M.alternate = h, h.alternate = M) : (M.pendingProps = m, M.type = h.type, M.flags = 0, M.subtreeFlags = 0, M.deletions = null), M.flags = h.flags & 31457280, M.childLanes = h.childLanes, M.lanes = h.lanes, M.child = h.child, M.memoizedProps = h.memoizedProps, M.memoizedState = h.memoizedState, M.updateQueue = h.updateQueue, m = h.dependencies, M.dependencies = m === null ? null : {
          lanes: m.lanes,
          firstContext: m.firstContext
        }, M.sibling = h.sibling, M.index = h.index, M.ref = h.ref, M.refCleanup = h.refCleanup, M;
      }
      function Oi(h, m) {
        h.flags &= 31457282;
        var M = h.alternate;
        return M === null ? (h.childLanes = 0, h.lanes = m, h.child = null, h.subtreeFlags = 0, h.memoizedProps = null, h.memoizedState = null, h.updateQueue = null, h.dependencies = null, h.stateNode = null) : (h.childLanes = M.childLanes, h.lanes = M.lanes, h.child = M.child, h.subtreeFlags = 0, h.deletions = null, h.memoizedProps = M.memoizedProps, h.memoizedState = M.memoizedState, h.updateQueue = M.updateQueue, h.type = M.type, m = M.dependencies, h.dependencies = m === null ? null : {
          lanes: m.lanes,
          firstContext: m.firstContext
        }), h;
      }
      function Oc(h, m, M, w, I, Z) {
        var fe = 0;
        if (w = h, typeof h == "function") hh(h) && (fe = 1);
        else if (typeof h == "string")
          fe = no && oi ? fm(h, M, Ms.current) ? 26 : Io(h) ? 27 : 5 : no ? fm(
            h,
            M,
            Ms.current
          ) ? 26 : 5 : oi && Io(h) ? 27 : 5;
        else
          e: switch (h) {
            case wc:
              return pl(
                M.children,
                I,
                Z,
                m
              );
            case yd:
              fe = 8, I |= 24;
              break;
            case np:
              return h = t(12, M, m, I | 2), h.elementType = np, h.lanes = Z, h;
            case ip:
              return h = t(13, M, m, I), h.elementType = ip, h.lanes = Z, h;
            case lp:
              return h = t(19, M, m, I), h.elementType = lp, h.lanes = Z, h;
            case Ho:
              return $h(M, I, Z, m);
            default:
              if (typeof h == "object" && h !== null)
                switch (h.$$typeof) {
                  case xf:
                  case Wr:
                    fe = 10;
                    break e;
                  case ap:
                    fe = 9;
                    break e;
                  case em:
                    fe = 11;
                    break e;
                  case tm:
                    fe = 14;
                    break e;
                  case $r:
                    fe = 16, w = null;
                    break e;
                }
              fe = 29, M = Error(
                r(
                  130,
                  h === null ? "null" : typeof h,
                  ""
                )
              ), w = null;
          }
        return m = t(fe, M, m, I), m.elementType = h, m.type = w, m.lanes = Z, m;
      }
      function pl(h, m, M, w) {
        return h = t(7, h, w, m), h.lanes = M, h;
      }
      function $h(h, m, M, w) {
        h = t(22, h, w, m), h.elementType = Ho, h.lanes = M;
        var I = {
          _visibility: 1,
          _pendingVisibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
          _current: null,
          detach: function() {
            var Z = I._current;
            if (Z === null) throw Error(r(456));
            if ((I._pendingVisibility & 2) === 0) {
              var fe = St(Z, 2);
              fe !== null && (I._pendingVisibility |= 2, Lt(fe, Z, 2));
            }
          },
          attach: function() {
            var Z = I._current;
            if (Z === null) throw Error(r(456));
            if ((I._pendingVisibility & 2) !== 0) {
              var fe = St(Z, 2);
              fe !== null && (I._pendingVisibility &= -3, Lt(fe, Z, 2));
            }
          }
        };
        return h.stateNode = I, h;
      }
      function No(h, m, M) {
        return h = t(6, h, null, m), h.lanes = M, h;
      }
      function gd(h, m, M) {
        return m = t(
          4,
          h.children !== null ? h.children : [],
          h.key,
          m
        ), m.lanes = M, m.stateNode = {
          containerInfo: h.containerInfo,
          pendingChildren: null,
          implementation: h.implementation
        }, m;
      }
      function $p(h, m, M, w, I, Z, fe, Be) {
        this.tag = 1, this.containerInfo = h, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Tr, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = j(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = j(0), this.hiddenUpdates = j(null), this.identifierPrefix = w, this.onUncaughtError = I, this.onCaughtError = Z, this.onRecoverableError = fe, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = Be, this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function ep(h, m, M, w, I, Z, fe, Be, qe, wt, en, mn) {
        return h = new $p(
          h,
          m,
          M,
          fe,
          Be,
          qe,
          wt,
          mn
        ), m = 1, Z === !0 && (m |= 24), Z = t(3, null, null, m), h.current = Z, Z.stateNode = h, m = Cc(), m.refCount++, h.pooledCache = m, m.refCount++, Z.memoizedState = {
          element: w,
          isDehydrated: M,
          cache: m
        }, Pt(Z), h;
      }
      function al(h) {
        return h ? (h = ao, h) : ao;
      }
      function ph(h) {
        var m = h._reactInternals;
        if (m === void 0)
          throw typeof h.render == "function" ? Error(r(188)) : (h = Object.keys(h).join(","), Error(r(268, h)));
        return h = B(m), h = h !== null ? z(h) : null, h === null ? null : Sd(h.stateNode);
      }
      function yu(h, m, M, w, I, Z) {
        I = al(I), w.context === null ? w.context = I : w.pendingContext = I, w = gn(m), w.payload = { element: M }, Z = Z === void 0 ? null : Z, Z !== null && (w.callback = Z), M = nn(h, w, m), M !== null && (Lt(M, h, m), jt(M, h, m));
      }
      function Mf(h, m) {
        if (h = h.memoizedState, h !== null && h.dehydrated !== null) {
          var M = h.retryLane;
          h.retryLane = M !== 0 && M < m ? M : m;
        }
      }
      function tp(h, m) {
        Mf(h, m), (h = h.alternate) && Mf(h, m);
      }
      var na = {}, is = Qm, Mr = Sw(), Wu = Object.assign, zo = Symbol.for("react.element"), mh = Symbol.for("react.transitional.element"), kr = Symbol.for("react.portal"), wc = Symbol.for("react.fragment"), yd = Symbol.for("react.strict_mode"), np = Symbol.for("react.profiler"), xf = Symbol.for("react.provider"), ap = Symbol.for("react.consumer"), Wr = Symbol.for("react.context"), em = Symbol.for("react.forward_ref"), ip = Symbol.for("react.suspense"), lp = Symbol.for("react.suspense_list"), tm = Symbol.for("react.memo"), $r = Symbol.for("react.lazy"), Ho = Symbol.for("react.offscreen"), iv = Symbol.for("react.memo_cache_sentinel"), $u = Symbol.iterator, ig = Symbol.for("react.client.reference"), $n = is.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, xr, ml, Tf = !1, Ys = Array.isArray, lg = e.rendererVersion, nm = e.rendererPackageName, _s = e.extraDevToolsConfig, Sd = e.getPublicInstance, Cf = e.getRootHostContext, vh = e.getChildHostContext, Su = e.prepareForCommit, ls = e.resetAfterCommit, gh = e.createInstance, eo = e.appendInitialChild, Lo = e.finalizeInitialChildren, ea = e.shouldSetTextContent, di = e.createTextInstance, Qi = e.scheduleTimeout, Nc = e.cancelTimeout, Tr = e.noTimeout, ar = e.isPrimaryRenderer;
      e.warnsIfNotActing;
      var Mi = e.supportsMutation, Zl = e.supportsPersistence, Tl = e.supportsHydration, lv = e.getInstanceFromNode;
      e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
      var vl = e.preparePortalMount;
      e.prepareScopeUpdate, e.getInstanceFromScope;
      var As = e.setCurrentUpdatePriority, ec = e.getCurrentUpdatePriority, Rf = e.resolveUpdatePriority;
      e.resolveEventType, e.resolveEventTimeStamp;
      var sg = e.shouldAttemptEagerTransition, sv = e.detachDeletedInstance;
      e.requestPostPaintCallback;
      var rg = e.maySuspendCommit, yh = e.preloadInstance, Cr = e.startSuspendingCommit, qs = e.suspendInstance, ha = e.waitForCommitToBeReady, zc = e.NotPendingTransition, _u = e.HostTransitionContext, Ql = e.resetFormInstance;
      e.bindToConsole;
      var og = e.supportsMicrotasks, Zs = e.scheduleMicrotask, tc = e.supportsTestSelectors, am = e.findFiberRoot, _d = e.getBoundingRect, im = e.getTextContent, Ad = e.isHiddenSubtree, ug = e.matchAccessibilityRole, cg = e.setFocusIfFocusable, rv = e.setupIntersectionObserver, lm = e.appendChild, sm = e.appendChildToContainer, fg = e.commitTextUpdate, Wy = e.commitMount, ov = e.commitUpdate, rm = e.insertBefore, dg = e.insertInContainerBefore, Ed = e.removeChild, om = e.removeChildFromContainer, um = e.resetTextContent, uv = e.hideInstance, Df = e.hideTextInstance, hg = e.unhideInstance, $y = e.unhideTextInstance, Hc = e.clearContainer, to = e.cloneInstance, $a = e.createContainerChildSet, Sh = e.appendChildToContainerChildSet, _h = e.finalizeContainerChildren, xi = e.replaceContainerChildren, kg = e.cloneHiddenInstance, Wg = e.cloneHiddenTextInstance, sp = e.isSuspenseInstancePending, Go = e.isSuspenseInstanceFallback, pg = e.getSuspenseInstanceFallbackErrorDetails, cv = e.registerSuspenseInstanceRetry, Lc = e.canHydrateFormStateMarker, rp = e.isFormStateMarkerMatching, mg = e.getNextHydratableSibling, nc = e.getFirstHydratableChild, fv = e.getFirstHydratableChildWithinContainer, $g = e.getFirstHydratableChildWithinSuspenseInstance, e0 = e.canHydrateInstance, cm = e.canHydrateTextInstance, t0 = e.canHydrateSuspenseInstance, Ah = e.hydrateInstance, Es = e.hydrateTextInstance, vg = e.hydrateSuspenseInstance, gg = e.getNextHydratableInstanceAfterSuspenseInstance, dv = e.commitHydratedContainer, bd = e.commitHydratedSuspenseInstance, yg = e.clearSuspenseBoundary, Md = e.clearSuspenseBoundaryFromContainer, Eh = e.shouldDeleteUnhydratedTailInstances;
      e.diffHydratedPropsForDevWarnings, e.diffHydratedTextForDevWarnings, e.describeHydratableInstanceForDevWarnings;
      var op = e.validateHydratableInstance, ey = e.validateHydratableTextInstance, no = e.supportsResources, fm = e.isHostHoistableType, dm = e.getHoistableRoot, hv = e.getResource, Gc = e.acquireResource, Bf = e.releaseResource, hm = e.hydrateHoistable, pv = e.mountHoistable, pa = e.unmountHoistable, Rr = e.createHoistableInstance, Dr = e.prepareToCommitHoistables, Ti = e.mayResourceSuspendCommit, bh = e.preloadResource, Br = e.suspendResource, oi = e.supportsSingletons, Gl = e.resolveSingletonInstance, ac = e.clearSingleton, ic = e.acquireSingletonInstance, Uf = e.releaseSingletonInstance, Io = e.isHostSingletonType, La = [], Vo = -1, ao = {}, Qs = Math.clz32 ? Math.clz32 : q, xd = Math.log, bs = Math.LN2, lc = 128, Mh = 4194304, Of = Mr.unstable_scheduleCallback, mv = Mr.unstable_cancelCallback, ft = Mr.unstable_shouldYield, Td = Mr.unstable_requestPaint, Fo = Mr.unstable_now, vv = Mr.unstable_ImmediatePriority, Sg = Mr.unstable_UserBlockingPriority, ir = Mr.unstable_NormalPriority, ty = Mr.unstable_IdlePriority, Cl = Mr.log, ss = Mr.unstable_setDisableYieldValue, gl = null, io = null, Rl = typeof Object.is == "function" ? Object.is : ae, wf = /* @__PURE__ */ new WeakMap(), rs = [], Dl = 0, Il = null, up = 0, Po = [], Ur = 0, lo = null, sc = 1, Ic = "", Ms = G(null), cp = G(null), Vc = G(null), Cd = G(null), Bl = null, Ul = null, Ja = !1, Xo = null, xs = !1, xh = Error(r(519)), jl = [], Vl = 0, Ts = 0, os = null, Fc = null, Th = !1, Tn = !1, Pc = !1, pm = 0, fp = null, dp = 0, Au = 0, Nf = null, zf = !1, Rd = !1, Xc = Object.prototype.hasOwnProperty, so = Error(r(460)), Yc = Error(r(474)), gv = { then: function() {
      } }, lr = null, rc = null, Ch = 0, ro = xa(!0), qc = xa(!1), ji = G(null), hp = G(0), Cs = G(null), Gi = null, Jl = G(0), Hf = 0, Ra = null, kn = null, Ka = null, Eu = !1, ga = !1, Lf = !1, mm = 0, Rh = 0, us = null, Or = 0, pp = function() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }, Ji = {
        readContext: ts,
        use: Re,
        useCallback: li,
        useContext: li,
        useEffect: li,
        useImperativeHandle: li,
        useLayoutEffect: li,
        useInsertionEffect: li,
        useMemo: li,
        useReducer: li,
        useRef: li,
        useState: li,
        useDebugValue: li,
        useDeferredValue: li,
        useTransition: li,
        useSyncExternalStore: li,
        useId: li
      };
      Ji.useCacheRefresh = li, Ji.useMemoCache = li, Ji.useHostTransitionStatus = li, Ji.useFormState = li, Ji.useActionState = li, Ji.useOptimistic = li;
      var Dd = {
        readContext: ts,
        use: Re,
        useCallback: function(h, m) {
          return ee().memoizedState = [
            h,
            m === void 0 ? null : m
          ], h;
        },
        useContext: ts,
        useEffect: Yu,
        useImperativeHandle: function(h, m, M) {
          M = M != null ? M.concat([h]) : null, ff(
            4194308,
            4,
            Ec.bind(null, m, h),
            M
          );
        },
        useLayoutEffect: function(h, m) {
          return ff(4194308, 4, h, m);
        },
        useInsertionEffect: function(h, m) {
          ff(4, 2, h, m);
        },
        useMemo: function(h, m) {
          var M = ee();
          m = m === void 0 ? null : m;
          var w = h();
          if (Lf) {
            te(!0);
            try {
              h();
            } finally {
              te(!1);
            }
          }
          return M.memoizedState = [w, m], w;
        },
        useReducer: function(h, m, M) {
          var w = ee();
          if (M !== void 0) {
            var I = M(m);
            if (Lf) {
              te(!0);
              try {
                M(m);
              } finally {
                te(!1);
              }
            }
          } else I = m;
          return w.memoizedState = w.baseState = I, h = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: h,
            lastRenderedState: I
          }, w.queue = h, h = h.dispatch = hf.bind(
            null,
            Ra,
            h
          ), [w.memoizedState, h];
        },
        useRef: function(h) {
          var m = ee();
          return h = { current: h }, m.memoizedState = h;
        },
        useState: function(h) {
          h = yn(h);
          var m = h.queue, M = Km.bind(
            null,
            Ra,
            m
          );
          return m.dispatch = M, [h.memoizedState, M];
        },
        useDebugValue: ad,
        useDeferredValue: function(h, m) {
          var M = ee();
          return Fp(M, h, m);
        },
        useTransition: function() {
          var h = yn(!1);
          return h = fl.bind(
            null,
            Ra,
            h.queue,
            !0,
            !1
          ), ee().memoizedState = h, [!1, h];
        },
        useSyncExternalStore: function(h, m, M) {
          var w = Ra, I = ee();
          if (Ja) {
            if (M === void 0)
              throw Error(r(407));
            M = M();
          } else {
            if (M = m(), Si === null)
              throw Error(r(349));
            (qa & 60) !== 0 || sn(w, m, M);
          }
          I.memoizedState = M;
          var Z = { value: M, getSnapshot: m };
          return I.queue = Z, Yu(bn.bind(null, w, Z, h), [
            h
          ]), w.flags |= 2048, Hl(
            9,
            Qt.bind(
              null,
              w,
              Z,
              M,
              m
            ),
            { destroy: void 0 },
            null
          ), M;
        },
        useId: function() {
          var h = ee(), m = Si.identifierPrefix;
          if (Ja) {
            var M = Ic, w = sc;
            M = (w & ~(1 << 32 - Qs(w) - 1)).toString(32) + M, m = ":" + m + "R" + M, M = mm++, 0 < M && (m += "H" + M.toString(32)), m += ":";
          } else
            M = Or++, m = ":" + m + "r" + M.toString(32) + ":";
          return h.memoizedState = m;
        },
        useCacheRefresh: function() {
          return ee().memoizedState = ld.bind(
            null,
            Ra
          );
        }
      };
      Dd.useMemoCache = Ie, Dd.useHostTransitionStatus = id, Dd.useFormState = da, Dd.useActionState = da, Dd.useOptimistic = function(h) {
        var m = ee();
        m.memoizedState = m.baseState = h;
        var M = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return m.queue = M, m = kd.bind(
          null,
          Ra,
          !0,
          M
        ), M.dispatch = m, [h, m];
      };
      var sr = {
        readContext: ts,
        use: Re,
        useCallback: df,
        useContext: ts,
        useEffect: $v,
        useImperativeHandle: Vp,
        useInsertionEffect: Kg,
        useLayoutEffect: Zh,
        useMemo: eg,
        useReducer: _t,
        useRef: Pr,
        useState: function() {
          return _t(je);
        },
        useDebugValue: ad,
        useDeferredValue: function(h, m) {
          var M = ye();
          return Kd(
            M,
            kn.memoizedState,
            h,
            m
          );
        },
        useTransition: function() {
          var h = _t(je)[0], m = ye().memoizedState;
          return [
            typeof h == "boolean" ? h : Ee(h),
            m
          ];
        },
        useSyncExternalStore: on,
        useId: Co
      };
      sr.useCacheRefresh = su, sr.useMemoCache = Ie, sr.useHostTransitionStatus = id, sr.useFormState = qi, sr.useActionState = qi, sr.useOptimistic = function(h, m) {
        var M = ye();
        return zn(M, kn, h, m);
      };
      var Ci = {
        readContext: ts,
        use: Re,
        useCallback: df,
        useContext: ts,
        useEffect: $v,
        useImperativeHandle: Vp,
        useInsertionEffect: Kg,
        useLayoutEffect: Zh,
        useMemo: eg,
        useReducer: It,
        useRef: Pr,
        useState: function() {
          return It(je);
        },
        useDebugValue: ad,
        useDeferredValue: function(h, m) {
          var M = ye();
          return kn === null ? Fp(M, h, m) : Kd(
            M,
            kn.memoizedState,
            h,
            m
          );
        },
        useTransition: function() {
          var h = It(je)[0], m = ye().memoizedState;
          return [
            typeof h == "boolean" ? h : Ee(h),
            m
          ];
        },
        useSyncExternalStore: on,
        useId: Co
      };
      Ci.useCacheRefresh = su, Ci.useMemoCache = Ie, Ci.useHostTransitionStatus = id, Ci.useFormState = Wi, Ci.useActionState = Wi, Ci.useOptimistic = function(h, m) {
        var M = ye();
        return kn !== null ? zn(M, kn, h, m) : (M.baseState = h, [h, M.queue.dispatch]);
      };
      var Gf = {
        isMounted: function(h) {
          return (h = h._reactInternals) ? C(h) === h : !1;
        },
        enqueueSetState: function(h, m, M) {
          h = h._reactInternals;
          var w = tl(), I = gn(w);
          I.payload = m, M != null && (I.callback = M), m = nn(h, I, w), m !== null && (Lt(m, h, w), jt(m, h, w));
        },
        enqueueReplaceState: function(h, m, M) {
          h = h._reactInternals;
          var w = tl(), I = gn(w);
          I.tag = 1, I.payload = m, M != null && (I.callback = M), m = nn(h, I, w), m !== null && (Lt(m, h, w), jt(m, h, w));
        },
        enqueueForceUpdate: function(h, m) {
          h = h._reactInternals;
          var M = tl(), w = gn(M);
          w.tag = 2, m != null && (w.callback = m), m = nn(h, w, M), m !== null && (Lt(m, h, M), jt(m, h, M));
        }
      }, Yo = typeof reportError == "function" ? reportError : function(h) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var m = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof h == "object" && h !== null && typeof h.message == "string" ? String(h.message) : String(h),
            error: h
          });
          if (!window.dispatchEvent(m)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", h);
          return;
        }
        console.error(h);
      }, vm = Error(r(461)), ui = !1, gm = { dehydrated: null, treeContext: null, retryLane: 0 }, bu = G(null), Oa = null, rr = null, yl = typeof AbortController < "u" ? AbortController : function() {
        var h = [], m = this.signal = {
          aborted: !1,
          addEventListener: function(M, w) {
            h.push(w);
          }
        };
        this.abort = function() {
          m.aborted = !0, h.forEach(function(M) {
            return M();
          });
        };
      }, n0 = Mr.unstable_scheduleCallback, ny = Mr.unstable_NormalPriority, Ii = {
        $$typeof: Wr,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      }, _g = $n.S;
      $n.S = function(h, m) {
        typeof m == "object" && m !== null && typeof m.then == "function" && Xt(h, m), _g !== null && _g(h, m);
      };
      var Ol = G(null), oc = !1, Sl = !1, Ag = !1, mi = typeof WeakSet == "function" ? WeakSet : Set, ma = null, Ga = !1, Fn = null, ba = !1, _l = null, wr = 8192, ym = {
        getCacheForType: function(h) {
          var m = ts(Ii), M = m.data.get(h);
          return M === void 0 && (M = h(), m.data.set(h, M)), M;
        }
      }, Sm = 0, uc = 1, il = 2, Mu = 3, Zc = 4;
      if (typeof Symbol == "function" && Symbol.for) {
        var oo = Symbol.for;
        Sm = oo("selector.component"), uc = oo("selector.has_pseudo_class"), il = oo("selector.role"), Mu = oo("selector.test_id"), Zc = oo("selector.text");
      }
      var xu = typeof WeakMap == "function" ? WeakMap : Map, hi = 0, Si = null, Dn = null, qa = 0, Ri = 0, or = null, uo = !1, qo = !1, Rs = !1, Ds = 0, Vi = 0, Al = 0, If = 0, _m = 0, co = 0, Qc = 0, Fl = null, wl = null, yv = !1, fo = 0, Vf = 1 / 0, Bd = null, jc = null, Zo = !1, Kl = null, Bs = 0, $i = 0, Sv = null, Am = 0, cc = null;
      return na.attemptContinuousHydration = function(h) {
        if (h.tag === 13) {
          var m = St(h, 67108864);
          m !== null && Lt(m, h, 67108864), tp(h, 67108864);
        }
      }, na.attemptHydrationAtCurrentPriority = function(h) {
        if (h.tag === 13) {
          var m = tl(), M = St(h, m);
          M !== null && Lt(M, h, m), tp(h, m);
        }
      }, na.attemptSynchronousHydration = function(h) {
        switch (h.tag) {
          case 3:
            if (h = h.stateNode, h.current.memoizedState.isDehydrated) {
              var m = Y(h.pendingLanes);
              if (m !== 0) {
                for (h.pendingLanes |= 2, h.entangledLanes |= 2; m; ) {
                  var M = 1 << 31 - Qs(m);
                  h.entanglements[1] |= M, m &= ~M;
                }
                At(h), (hi & 6) === 0 && (Vf = Fo() + 500, ce(0));
              }
            }
            break;
          case 13:
            m = St(h, 2), m !== null && Lt(m, h, 2), kh(), tp(h, 2);
        }
      }, na.batchedUpdates = function(h, m) {
        return h(m);
      }, na.createComponentSelector = function(h) {
        return { $$typeof: Sm, value: h };
      }, na.createContainer = function(h, m, M, w, I, Z, fe, Be, qe, wt) {
        return ep(
          h,
          m,
          !1,
          null,
          M,
          w,
          Z,
          fe,
          Be,
          qe,
          wt,
          null
        );
      }, na.createHasPseudoClassSelector = function(h) {
        return { $$typeof: uc, value: h };
      }, na.createHydrationContainer = function(h, m, M, w, I, Z, fe, Be, qe, wt, en, mn, cn) {
        return h = ep(
          M,
          w,
          !0,
          h,
          I,
          Z,
          Be,
          qe,
          wt,
          en,
          mn,
          cn
        ), h.context = al(null), M = h.current, w = tl(), I = gn(w), I.callback = m ?? null, nn(M, I, w), h.current.lanes = w, re(h, w), At(h), h;
      }, na.createPortal = function(h, m, M) {
        var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
          $$typeof: kr,
          key: w == null ? null : "" + w,
          children: h,
          containerInfo: m,
          implementation: M
        };
      }, na.createRoleSelector = function(h) {
        return { $$typeof: il, value: h };
      }, na.createTestNameSelector = function(h) {
        return { $$typeof: Mu, value: h };
      }, na.createTextSelector = function(h) {
        return { $$typeof: Zc, value: h };
      }, na.defaultOnCaughtError = function(h) {
        console.error(h);
      }, na.defaultOnRecoverableError = function(h) {
        Yo(h);
      }, na.defaultOnUncaughtError = function(h) {
        Yo(h);
      }, na.deferredUpdates = function(h) {
        var m = $n.T, M = ec();
        try {
          return As(32), $n.T = null, h();
        } finally {
          As(M), $n.T = m;
        }
      }, na.discreteUpdates = function(h, m, M, w, I) {
        var Z = $n.T, fe = ec();
        try {
          return As(2), $n.T = null, h(m, M, w, I);
        } finally {
          As(fe), $n.T = Z, hi === 0 && (Vf = Fo() + 500);
        }
      }, na.findAllNodes = dd, na.findBoundingRects = function(h, m) {
        if (!tc) throw Error(r(363));
        m = dd(h, m), h = [];
        for (var M = 0; M < m.length; M++)
          h.push(_d(m[M]));
        for (m = h.length - 1; 0 < m; m--) {
          M = h[m];
          for (var w = M.x, I = w + M.width, Z = M.y, fe = Z + M.height, Be = m - 1; 0 <= Be; Be--)
            if (m !== Be) {
              var qe = h[Be], wt = qe.x, en = wt + qe.width, mn = qe.y, cn = mn + qe.height;
              if (w >= wt && Z >= mn && I <= en && fe <= cn) {
                h.splice(m, 1);
                break;
              } else if (w !== wt || M.width !== qe.width || cn < Z || mn > fe) {
                if (!(Z !== mn || M.height !== qe.height || en < w || wt > I)) {
                  wt > w && (qe.width += wt - w, qe.x = w), en < I && (qe.width = I - wt), h.splice(m, 1);
                  break;
                }
              } else {
                mn > Z && (qe.height += mn - Z, qe.y = Z), cn < fe && (qe.height = fe - mn), h.splice(m, 1);
                break;
              }
            }
        }
        return h;
      }, na.findHostInstance = ph, na.findHostInstanceWithNoPortals = function(h) {
        return h = B(h), h = h !== null ? V(h) : null, h === null ? null : Sd(h.stateNode);
      }, na.findHostInstanceWithWarning = function(h) {
        return ph(h);
      }, na.flushPassiveEffects = Kr, na.flushSyncFromReconciler = function(h) {
        var m = hi;
        hi |= 1;
        var M = $n.T, w = ec();
        try {
          if (As(2), $n.T = null, h)
            return h();
        } finally {
          As(w), $n.T = M, hi = m, (hi & 6) === 0 && ce(0);
        }
      }, na.flushSyncWork = kh, na.focusWithin = function(h, m) {
        if (!tc) throw Error(r(363));
        for (h = ch(h), m = tr(h, m), m = Array.from(m), h = 0; h < m.length; ) {
          var M = m[h++], w = M.tag;
          if (!Ad(M)) {
            if ((w === 5 || w === 26 || w === 27) && cg(M.stateNode))
              return !0;
            for (M = M.child; M !== null; )
              m.push(M), M = M.sibling;
          }
        }
        return !1;
      }, na.getFindAllNodesFailureDescription = function(h, m) {
        if (!tc) throw Error(r(363));
        var M = 0, w = [];
        h = [ch(h), 0];
        for (var I = 0; I < h.length; ) {
          var Z = h[I++], fe = Z.tag, Be = h[I++], qe = m[Be];
          if ((fe !== 5 && fe !== 26 && fe !== 27 || !Ad(Z)) && (fd(Z, qe) && (w.push(nv(qe)), Be++, Be > M && (M = Be)), Be < m.length))
            for (Z = Z.child; Z !== null; )
              h.push(Z, Be), Z = Z.sibling;
        }
        if (M < m.length) {
          for (h = []; M < m.length; M++)
            h.push(nv(m[M]));
          return `findAllNodes was able to match part of the selector:
  ` + (w.join(" > ") + `

No matching component was found for:
  `) + h.join(" > ");
        }
        return null;
      }, na.getPublicRootInstance = function(h) {
        if (h = h.current, !h.child) return null;
        switch (h.child.tag) {
          case 27:
          case 5:
            return Sd(h.child.stateNode);
          default:
            return h.child.stateNode;
        }
      }, na.injectIntoDevTools = function() {
        var h = {
          bundleType: 0,
          version: lg,
          rendererPackageName: nm,
          currentDispatcherRef: $n,
          findFiberByHostInstance: lv,
          reconcilerVersion: "19.0.0"
        };
        if (_s !== null && (h.rendererConfig = _s), typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") h = !1;
        else {
          var m = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (m.isDisabled || !m.supportsFiber) h = !0;
          else {
            try {
              gl = m.inject(h), io = m;
            } catch {
            }
            h = !!m.checkDCE;
          }
        }
        return h;
      }, na.isAlreadyRendering = function() {
        return !1;
      }, na.observeVisibleRects = function(h, m, M, w) {
        if (!tc) throw Error(r(363));
        h = dd(h, m);
        var I = rv(
          h,
          M,
          w
        ).disconnect;
        return {
          disconnect: function() {
            I();
          }
        };
      }, na.shouldError = function() {
        return null;
      }, na.shouldSuspend = function() {
        return !1;
      }, na.startHostTransition = function(h, m, M, w) {
        if (h.tag !== 5) throw Error(r(476));
        var I = To(h).queue;
        fl(
          h,
          I,
          m,
          zc,
          M === null ? a : function() {
            var Z = To(h).next.queue;
            return Ll(
              h,
              Z,
              {},
              tl()
            ), M(w);
          }
        );
      }, na.updateContainer = function(h, m, M, w) {
        var I = m.current, Z = tl();
        return yu(
          I,
          Z,
          h,
          m,
          M,
          w
        ), Z;
      }, na.updateContainerSync = function(h, m, M, w) {
        return m.tag === 0 && Kr(), yu(
          m.current,
          2,
          h,
          m,
          M,
          w
        ), 2;
      }, na;
    }, o.exports.default = o.exports, Object.defineProperty(o.exports, "__esModule", { value: !0 });
  }(SC)), SC.exports;
}
var EC = { exports: {} };
/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var V3;
function n9() {
  return V3 || (V3 = 1, function(o) {
    process.env.NODE_ENV !== "production" && (o.exports = function(e) {
      function t(l, u) {
        for (l = l.memoizedState; l !== null && 0 < u; )
          l = l.next, u--;
        return l;
      }
      function a(l, u, S, x) {
        if (S >= u.length) return x;
        var O = u[S], L = Il(l) ? l.slice() : Ti({}, l);
        return L[O] = a(l[O], u, S + 1, x), L;
      }
      function r(l, u, S) {
        if (u.length !== S.length)
          console.warn("copyWithRename() expects paths of the same length");
        else {
          for (var x = 0; x < S.length - 1; x++)
            if (u[x] !== S[x]) {
              console.warn(
                "copyWithRename() expects paths to be the same except for the deepest key"
              );
              return;
            }
          return d(l, u, S, 0);
        }
      }
      function d(l, u, S, x) {
        var O = u[x], L = Il(l) ? l.slice() : Ti({}, l);
        return x + 1 === u.length ? (L[S[x]] = L[O], Il(L) ? L.splice(O, 1) : delete L[O]) : L[O] = d(
          l[O],
          u,
          S,
          x + 1
        ), L;
      }
      function p(l, u, S) {
        var x = u[S], O = Il(l) ? l.slice() : Ti({}, l);
        return S + 1 === u.length ? (Il(O) ? O.splice(x, 1) : delete O[x], O) : (O[x] = p(l[x], u, S + 1), O);
      }
      function y() {
        return !1;
      }
      function _() {
        return null;
      }
      function E(l, u, S, x) {
        return new t0(l, u, S, x);
      }
      function T(l, u) {
        l.context === Bs && (dm(u, l, null, null), tc());
      }
      function C(l, u) {
        if (Ir !== null) {
          var S = u.staleFamilies;
          u = u.updatedFamilies, Hc(), cm(
            l.current,
            u,
            S
          ), tc();
        }
      }
      function D(l) {
        Ir = l;
      }
      function B() {
        console.error(
          "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
        );
      }
      function z() {
        console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        );
      }
      function V() {
      }
      function G() {
      }
      function N(l) {
        var u = [];
        return l.forEach(function(S) {
          u.push(S);
        }), u.sort().join(", ");
      }
      function F(l) {
        return l === null || typeof l != "object" ? null : (l = Of && l[Of] || l["@@iterator"], typeof l == "function" ? l : null);
      }
      function q(l) {
        if (l == null) return null;
        if (typeof l == "function")
          return l.$$typeof === mv ? null : l.displayName || l.name || null;
        if (typeof l == "string") return l;
        switch (l) {
          case Gl:
            return "Fragment";
          case oi:
            return "Portal";
          case ic:
            return "Profiler";
          case ac:
            return "StrictMode";
          case ao:
            return "Suspense";
          case Qs:
            return "SuspenseList";
        }
        if (typeof l == "object")
          switch (typeof l.tag == "number" && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), l.$$typeof) {
            case La:
              return (l.displayName || "Context") + ".Provider";
            case Io:
              return (l._context.displayName || "Context") + ".Consumer";
            case Vo:
              var u = l.render;
              return l = l.displayName, l || (l = u.displayName || u.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l;
            case xd:
              return u = l.displayName || null, u !== null ? u : q(l.type) || "Memo";
            case bs:
              u = l._payload, l = l._init;
              try {
                return q(l(u));
              } catch {
              }
          }
        return null;
      }
      function Y(l) {
        var u = l.type;
        switch (l.tag) {
          case 24:
            return "Cache";
          case 9:
            return (u._context.displayName || "Context") + ".Consumer";
          case 10:
            return (u.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return l = u.render, l = l.displayName || l.name || "", u.displayName || (l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 26:
          case 27:
          case 5:
            return u;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return q(u);
          case 8:
            return u === ac ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 14:
          case 15:
            if (typeof u == "function")
              return u.displayName || u.name || null;
            if (typeof u == "string") return u;
            break;
          case 29:
            if (u = l._debugInfo, u != null) {
              for (var S = u.length - 1; 0 <= S; S--)
                if (typeof u[S].name == "string") return u[S].name;
            }
            if (l.return !== null)
              return Y(l.return);
        }
        return null;
      }
      function ie() {
      }
      function k() {
        if (Td === 0) {
          Fo = console.log, vv = console.info, Sg = console.warn, ir = console.error, ty = console.group, Cl = console.groupCollapsed, ss = console.groupEnd;
          var l = {
            configurable: !0,
            enumerable: !0,
            value: ie,
            writable: !0
          };
          Object.defineProperties(console, {
            info: l,
            log: l,
            warn: l,
            error: l,
            group: l,
            groupCollapsed: l,
            groupEnd: l
          });
        }
        Td++;
      }
      function le() {
        if (Td--, Td === 0) {
          var l = { configurable: !0, enumerable: !0, writable: !0 };
          Object.defineProperties(console, {
            log: Ti({}, l, { value: Fo }),
            info: Ti({}, l, { value: vv }),
            warn: Ti({}, l, { value: Sg }),
            error: Ti({}, l, { value: ir }),
            group: Ti({}, l, { value: ty }),
            groupCollapsed: Ti({}, l, { value: Cl }),
            groupEnd: Ti({}, l, { value: ss })
          });
        }
        0 > Td && console.error(
          "disabledDepth fell below zero. This is a bug in React. Please file an issue."
        );
      }
      function ne(l) {
        if (gl === void 0)
          try {
            throw Error();
          } catch (S) {
            var u = S.stack.trim().match(/\n( *(at )?)/);
            gl = u && u[1] || "", io = -1 < S.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < S.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return `
` + gl + l + io;
      }
      function Q(l, u) {
        if (!l || Rl) return "";
        var S = wf.get(l);
        if (S !== void 0) return S;
        Rl = !0, S = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
        var x = null;
        x = ft.H, ft.H = null, k();
        try {
          var O = {
            DetermineComponentFrameRoot: function() {
              try {
                if (u) {
                  var Sn = function() {
                    throw Error();
                  };
                  if (Object.defineProperty(Sn.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                      Reflect.construct(Sn, []);
                    } catch (vi) {
                      var Na = vi;
                    }
                    Reflect.construct(l, [], Sn);
                  } else {
                    try {
                      Sn.call();
                    } catch (vi) {
                      Na = vi;
                    }
                    l.call(Sn.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (vi) {
                    Na = vi;
                  }
                  (Sn = l()) && typeof Sn.catch == "function" && Sn.catch(function() {
                  });
                }
              } catch (vi) {
                if (vi && Na && typeof vi.stack == "string")
                  return [vi.stack, Na.stack];
              }
              return [null, null];
            }
          };
          O.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var L = Object.getOwnPropertyDescriptor(
            O.DetermineComponentFrameRoot,
            "name"
          );
          L && L.configurable && Object.defineProperty(
            O.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var J = O.DetermineComponentFrameRoot(), he = J[0], Pe = J[1];
          if (he && Pe) {
            var ht = he.split(`
`), Kt = Pe.split(`
`);
            for (J = L = 0; L < ht.length && !ht[L].includes(
              "DetermineComponentFrameRoot"
            ); )
              L++;
            for (; J < Kt.length && !Kt[J].includes(
              "DetermineComponentFrameRoot"
            ); )
              J++;
            if (L === ht.length || J === Kt.length)
              for (L = ht.length - 1, J = Kt.length - 1; 1 <= L && 0 <= J && ht[L] !== Kt[J]; )
                J--;
            for (; 1 <= L && 0 <= J; L--, J--)
              if (ht[L] !== Kt[J]) {
                if (L !== 1 || J !== 1)
                  do
                    if (L--, J--, 0 > J || ht[L] !== Kt[J]) {
                      var ln = `
` + ht[L].replace(
                        " at new ",
                        " at "
                      );
                      return l.displayName && ln.includes("<anonymous>") && (ln = ln.replace("<anonymous>", l.displayName)), typeof l == "function" && wf.set(l, ln), ln;
                    }
                  while (1 <= L && 0 <= J);
                break;
              }
          }
        } finally {
          Rl = !1, ft.H = x, le(), Error.prepareStackTrace = S;
        }
        return ht = (ht = l ? l.displayName || l.name : "") ? ne(ht) : "", typeof l == "function" && wf.set(l, ht), ht;
      }
      function j(l) {
        switch (l.tag) {
          case 26:
          case 27:
          case 5:
            return ne(l.type);
          case 16:
            return ne("Lazy");
          case 13:
            return ne("Suspense");
          case 19:
            return ne("SuspenseList");
          case 0:
          case 15:
            return l = Q(l.type, !1), l;
          case 11:
            return l = Q(l.type.render, !1), l;
          case 1:
            return l = Q(l.type, !0), l;
          default:
            return "";
        }
      }
      function re(l) {
        try {
          var u = "";
          do {
            u += j(l);
            var S = l._debugInfo;
            if (S)
              for (var x = S.length - 1; 0 <= x; x--) {
                var O = S[x];
                if (typeof O.name == "string") {
                  var L = u, J = O.env, he = ne(
                    O.name + (J ? " [" + J + "]" : "")
                  );
                  u = L + he;
                }
              }
            l = l.return;
          } while (l);
          return u;
        } catch (Pe) {
          return `
Error generating stack: ` + Pe.message + `
` + Pe.stack;
        }
      }
      function _e() {
        return rs === null ? "" : re(rs);
      }
      function me(l, u, S, x, O, L, J) {
        var he = rs;
        ft.getCurrentStack = l === null ? null : _e, Dl = !1, rs = l;
        try {
          return u(S, x, O, L, J);
        } finally {
          rs = he;
        }
        throw Error(
          "runWithFiberInDEV should never be called in production. This is a bug in React."
        );
      }
      function Ae(l) {
        var u = l, S = l;
        if (l.alternate) for (; u.return; ) u = u.return;
        else {
          l = u;
          do
            u = l, (u.flags & 4098) !== 0 && (S = u.return), l = u.return;
          while (l);
        }
        return u.tag === 3 ? S : null;
      }
      function He(l) {
        if (Ae(l) !== l)
          throw Error("Unable to find node on an unmounted component.");
      }
      function P(l) {
        var u = l.alternate;
        if (!u) {
          if (u = Ae(l), u === null)
            throw Error("Unable to find node on an unmounted component.");
          return u !== l ? null : l;
        }
        for (var S = l, x = u; ; ) {
          var O = S.return;
          if (O === null) break;
          var L = O.alternate;
          if (L === null) {
            if (x = O.return, x !== null) {
              S = x;
              continue;
            }
            break;
          }
          if (O.child === L.child) {
            for (L = O.child; L; ) {
              if (L === S) return He(O), l;
              if (L === x) return He(O), u;
              L = L.sibling;
            }
            throw Error("Unable to find node on an unmounted component.");
          }
          if (S.return !== x.return) S = O, x = L;
          else {
            for (var J = !1, he = O.child; he; ) {
              if (he === S) {
                J = !0, S = O, x = L;
                break;
              }
              if (he === x) {
                J = !0, x = O, S = L;
                break;
              }
              he = he.sibling;
            }
            if (!J) {
              for (he = L.child; he; ) {
                if (he === S) {
                  J = !0, S = L, x = O;
                  break;
                }
                if (he === x) {
                  J = !0, x = L, S = O;
                  break;
                }
                he = he.sibling;
              }
              if (!J)
                throw Error(
                  "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                );
            }
          }
          if (S.alternate !== x)
            throw Error(
              "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
            );
        }
        if (S.tag !== 3)
          throw Error("Unable to find node on an unmounted component.");
        return S.stateNode.current === S ? l : u;
      }
      function te(l) {
        return l = P(l), l !== null ? ae(l) : null;
      }
      function ae(l) {
        var u = l.tag;
        if (u === 5 || u === 26 || u === 27 || u === 6) return l;
        for (l = l.child; l !== null; ) {
          if (u = ae(l), u !== null) return u;
          l = l.sibling;
        }
        return null;
      }
      function Se(l) {
        var u = l.tag;
        if (u === 5 || u === 26 || u === 27 || u === 6) return l;
        for (l = l.child; l !== null; ) {
          if (l.tag !== 4 && (u = Se(l), u !== null))
            return u;
          l = l.sibling;
        }
        return null;
      }
      function ue(l) {
        return { current: l };
      }
      function we(l, u) {
        0 > Kl ? console.error("Unexpected pop.") : (u !== Zo[Kl] && console.error("Unexpected Fiber popped."), l.current = jc[Kl], jc[Kl] = null, Zo[Kl] = null, Kl--);
      }
      function De(l, u, S) {
        Kl++, jc[Kl] = l.current, Zo[Kl] = S, l.current = u;
      }
      function We(l) {
        return l >>>= 0, l === 0 ? 32 : 31 - (Sv(l) / Am | 0) | 0;
      }
      function Me(l) {
        if (l & 1) return "SyncHydrationLane";
        if (l & 2) return "Sync";
        if (l & 4) return "InputContinuousHydration";
        if (l & 8) return "InputContinuous";
        if (l & 16) return "DefaultHydration";
        if (l & 32) return "Default";
        if (l & 64) return "TransitionHydration";
        if (l & 4194176) return "Transition";
        if (l & 62914560) return "Retry";
        if (l & 67108864) return "SelectiveHydration";
        if (l & 134217728) return "IdleHydration";
        if (l & 268435456) return "Idle";
        if (l & 536870912) return "Offscreen";
        if (l & 1073741824) return "Deferred";
      }
      function Ze(l) {
        var u = l & 42;
        if (u !== 0) return u;
        switch (l & -l) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return l & 4194176;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return l & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return console.error(
              "Should have found matching lanes. This is a bug in React."
            ), l;
        }
      }
      function ct(l, u) {
        var S = l.pendingLanes;
        if (S === 0) return 0;
        var x = 0, O = l.suspendedLanes, L = l.pingedLanes, J = l.warmLanes;
        l = l.finishedLanes !== 0;
        var he = S & 134217727;
        return he !== 0 ? (S = he & ~O, S !== 0 ? x = Ze(S) : (L &= he, L !== 0 ? x = Ze(L) : l || (J = he & ~J, J !== 0 && (x = Ze(J))))) : (he = S & ~O, he !== 0 ? x = Ze(he) : L !== 0 ? x = Ze(L) : l || (J = S & ~J, J !== 0 && (x = Ze(J)))), x === 0 ? 0 : u !== 0 && u !== x && (u & O) === 0 && (O = x & -x, J = u & -u, O >= J || O === 32 && (J & 4194176) !== 0) ? u : x;
      }
      function Vt(l, u) {
        return (l.pendingLanes & ~(l.suspendedLanes & ~l.pingedLanes) & u) === 0;
      }
      function Zt(l, u) {
        switch (l) {
          case 1:
          case 2:
          case 4:
          case 8:
            return u + 250;
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return u + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return console.error(
              "Should have found matching lanes. This is a bug in React."
            ), -1;
        }
      }
      function Bn() {
        var l = cc;
        return cc <<= 1, (cc & 4194176) === 0 && (cc = 128), l;
      }
      function rn() {
        var l = h;
        return h <<= 1, (h & 62914560) === 0 && (h = 4194304), l;
      }
      function dn(l) {
        for (var u = [], S = 0; 31 > S; S++) u.push(l);
        return u;
      }
      function Zn(l, u) {
        l.pendingLanes |= u, u !== 268435456 && (l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0);
      }
      function Rn(l, u, S, x, O, L) {
        var J = l.pendingLanes;
        l.pendingLanes = S, l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0, l.expiredLanes &= S, l.entangledLanes &= S, l.errorRecoveryDisabledLanes &= S, l.shellSuspendCounter = 0;
        var he = l.entanglements, Pe = l.expirationTimes, ht = l.hiddenUpdates;
        for (S = J & ~S; 0 < S; ) {
          var Kt = 31 - $i(S), ln = 1 << Kt;
          he[Kt] = 0, Pe[Kt] = -1;
          var Sn = ht[Kt];
          if (Sn !== null)
            for (ht[Kt] = null, Kt = 0; Kt < Sn.length; Kt++) {
              var Na = Sn[Kt];
              Na !== null && (Na.lane &= -536870913);
            }
          S &= ~ln;
        }
        x !== 0 && Te(l, x, 0), L !== 0 && O === 0 && l.tag !== 0 && (l.suspendedLanes |= L & ~(J & ~u));
      }
      function Te(l, u, S) {
        l.pendingLanes |= u, l.suspendedLanes &= ~u;
        var x = 31 - $i(u);
        l.entangledLanes |= u, l.entanglements[x] = l.entanglements[x] | 1073741824 | S & 4194218;
      }
      function Ha(l, u) {
        var S = l.entangledLanes |= u;
        for (l = l.entanglements; S; ) {
          var x = 31 - $i(S), O = 1 << x;
          O & u | l[x] & u && (l[x] |= u), S &= ~O;
        }
      }
      function Tt(l, u, S) {
        if (Us)
          for (l = l.pendingUpdatersLaneMap; 0 < S; ) {
            var x = 31 - $i(S), O = 1 << x;
            l[x].add(u), S &= ~O;
          }
      }
      function St(l, u) {
        if (Us)
          for (var S = l.pendingUpdatersLaneMap, x = l.memoizedUpdaters; 0 < u; ) {
            var O = 31 - $i(u);
            l = 1 << O, O = S[O], 0 < O.size && (O.forEach(function(L) {
              var J = L.alternate;
              J !== null && x.has(J) || x.add(L);
            }), O.clear()), u &= ~l;
          }
      }
      function Mt(l) {
        return l &= -l, 2 < l ? 8 < l ? (l & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
      }
      function kt(l) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") return !1;
        var u = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (u.isDisabled) return !0;
        if (!u.supportsFiber)
          return console.error(
            "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
          ), !0;
        try {
          cn = u.inject(l), Un = u;
        } catch (S) {
          console.error("React instrumentation encountered an error: %s.", S);
        }
        return !!u.checkDCE;
      }
      function At(l, u) {
        if (Un && typeof Un.onCommitFiberRoot == "function")
          try {
            var S = (l.current.flags & 128) === 128;
            switch (u) {
              case 2:
                var x = fe;
                break;
              case 8:
                x = Be;
                break;
              case 32:
                x = qe;
                break;
              case 268435456:
                x = wt;
                break;
              default:
                x = qe;
            }
            Un.onCommitFiberRoot(
              cn,
              l,
              x,
              S
            );
          } catch (O) {
            ur || (ur = !0, console.error(
              "React instrumentation encountered an error: %s",
              O
            ));
          }
      }
      function ce(l) {
        if (typeof en == "function" && mn(l), Un && typeof Un.setStrictMode == "function")
          try {
            Un.setStrictMode(cn, l);
          } catch (u) {
            ur || (ur = !0, console.error(
              "React instrumentation encountered an error: %s",
              u
            ));
          }
      }
      function se(l) {
        an = l;
      }
      function Xe() {
        an !== null && typeof an.markCommitStopped == "function" && an.markCommitStopped();
      }
      function dt(l) {
        an !== null && typeof an.markComponentRenderStarted == "function" && an.markComponentRenderStarted(l);
      }
      function Et() {
        an !== null && typeof an.markComponentRenderStopped == "function" && an.markComponentRenderStopped();
      }
      function yt(l) {
        an !== null && typeof an.markRenderStarted == "function" && an.markRenderStarted(l);
      }
      function Jt() {
        an !== null && typeof an.markRenderStopped == "function" && an.markRenderStopped();
      }
      function Xt(l, u) {
        an !== null && typeof an.markStateUpdateScheduled == "function" && an.markStateUpdateScheduled(l, u);
      }
      function Wt(l, u) {
        return l === u && (l !== 0 || 1 / l === 1 / u) || l !== l && u !== u;
      }
      function Vn(l, u) {
        if (typeof l == "object" && l !== null) {
          var S = Ge.get(l);
          return S !== void 0 ? S : (u = {
            value: l,
            source: u,
            stack: re(u)
          }, Ge.set(l, u), u);
        }
        return {
          value: l,
          source: u,
          stack: re(u)
        };
      }
      function Pt(l, u) {
        jt(), rt[qt++] = Fi, rt[qt++] = On, On = l, Fi = u;
      }
      function pn(l, u, S) {
        jt(), Hn[ya++] = la, Hn[ya++] = cs, Hn[ya++] = Ki, Ki = l;
        var x = la;
        l = cs;
        var O = 32 - $i(x) - 1;
        x &= ~(1 << O), S += 1;
        var L = 32 - $i(u) + O;
        if (30 < L) {
          var J = O - O % 5;
          L = (x & (1 << J) - 1).toString(32), x >>= J, O -= J, la = 1 << 32 - $i(u) + O | S << O | x, cs = L + l;
        } else
          la = 1 << L | S << O | x, cs = l;
      }
      function gn(l) {
        jt(), l.return !== null && (Pt(l, 1), pn(l, 1, 0));
      }
      function nn(l) {
        for (; l === On; )
          On = rt[--qt], rt[qt] = null, Fi = rt[--qt], rt[qt] = null;
        for (; l === Ki; )
          Ki = Hn[--ya], Hn[ya] = null, cs = Hn[--ya], Hn[ya] = null, la = Hn[--ya], Hn[ya] = null;
      }
      function jt() {
        ei || console.error(
          "Expected to be hydrating. This is a bug in React. Please file an issue."
        );
      }
      function Ue(l) {
        return l === null && console.error(
          "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
        ), l;
      }
      function ot(l, u) {
        De(Cu, u, l), De(Em, l, l), De(Tu, null, l), u = sc(u), we(Tu, l), De(Tu, u, l);
      }
      function Ht(l) {
        we(Tu, l), we(Em, l), we(Cu, l);
      }
      function xe() {
        return Ue(Tu.current);
      }
      function Je(l) {
        l.memoizedState !== null && De(ho, l, l);
        var u = Ue(Tu.current), S = Ic(u, l.type);
        u !== S && (De(Em, l, l), De(Tu, S, l));
      }
      function tt(l) {
        Em.current === l && (we(Tu, l), we(Em, l)), ho.current === l && (we(ho, l), jl ? Yc._currentValue = so : Yc._currentValue2 = so);
      }
      function Ct(l, u) {
        return l.serverProps === void 0 && l.serverTail.length === 0 && l.children.length === 1 && 3 < l.distanceFromLeaf && l.distanceFromLeaf > 15 - u ? Ct(l.children[0], u) : l;
      }
      function $t(l) {
        return "  " + "  ".repeat(l);
      }
      function tn(l) {
        return "+ " + "  ".repeat(l);
      }
      function Mn(l) {
        return "- " + "  ".repeat(l);
      }
      function Wn(l) {
        switch (l.tag) {
          case 26:
          case 27:
          case 5:
            return l.type;
          case 16:
            return "Lazy";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 0:
          case 15:
            return l = l.type, l.displayName || l.name || null;
          case 11:
            return l = l.type.render, l.displayName || l.name || null;
          case 1:
            return l = l.type, l.displayName || l.name || null;
          default:
            return null;
        }
      }
      function Xa(l, u) {
        return Eg.test(l) ? (l = JSON.stringify(l), l.length > u - 2 ? 8 > u ? '{"..."}' : "{" + l.slice(0, u - 7) + '..."}' : "{" + l + "}") : l.length > u ? 5 > u ? '{"..."}' : l.slice(0, u - 3) + "..." : l;
      }
      function sa(l, u, S) {
        var x = 120 - 2 * S;
        if (u === null)
          return tn(S) + Xa(l, x) + `
`;
        if (typeof u == "string") {
          for (var O = 0; O < u.length && O < l.length && u.charCodeAt(O) === l.charCodeAt(O); O++) ;
          return O > x - 8 && 10 < O && (l = "..." + l.slice(O - 8), u = "..." + u.slice(O - 8)), tn(S) + Xa(l, x) + `
` + Mn(S) + Xa(u, x) + `
`;
        }
        return $t(S) + Xa(l, x) + `
`;
      }
      function ul(l) {
        return Object.prototype.toString.call(l).replace(/^\[object (.*)\]$/, function(u, S) {
          return S;
        });
      }
      function xa(l, u) {
        switch (typeof l) {
          case "string":
            return l = JSON.stringify(l), l.length > u ? 5 > u ? '"..."' : l.slice(0, u - 4) + '..."' : l;
          case "object":
            if (l === null) return "null";
            if (Il(l)) return "[...]";
            if (l.$$typeof === Br)
              return (u = q(l.type)) ? "<" + u + ">" : "<...>";
            var S = ul(l);
            if (S === "Object") {
              S = "", u -= 2;
              for (var x in l)
                if (l.hasOwnProperty(x)) {
                  var O = JSON.stringify(x);
                  if (O !== '"' + x + '"' && (x = O), u -= x.length - 2, O = xa(
                    l[x],
                    15 > u ? u : 15
                  ), u -= O.length, 0 > u) {
                    S += S === "" ? "..." : ", ...";
                    break;
                  }
                  S += (S === "" ? "" : ",") + x + ":" + O;
                }
              return "{" + S + "}";
            }
            return S;
          case "function":
            return (u = l.displayName || l.name) ? "function " + u : "function";
          default:
            return String(l);
        }
      }
      function Ui(l, u) {
        return typeof l != "string" || Eg.test(l) ? "{" + xa(l, u - 2) + "}" : l.length > u - 2 ? 5 > u ? '"..."' : '"' + l.slice(0, u - 5) + '..."' : '"' + l + '"';
      }
      function cl(l, u, S) {
        var x = 120 - S.length - l.length, O = [], L;
        for (L in u)
          if (u.hasOwnProperty(L) && L !== "children") {
            var J = Ui(
              u[L],
              120 - S.length - L.length - 1
            );
            x -= L.length + J.length + 2, O.push(L + "=" + J);
          }
        return O.length === 0 ? S + "<" + l + `>
` : 0 < x ? S + "<" + l + " " + O.join(" ") + `>
` : S + "<" + l + `
` + S + "  " + O.join(`
` + S + "  ") + `
` + S + `>
`;
      }
      function Xl(l, u, S) {
        var x = "", O = Ti({}, u), L;
        for (L in l)
          if (l.hasOwnProperty(L)) {
            delete O[L];
            var J = 120 - 2 * S - L.length - 2, he = xa(l[L], J);
            u.hasOwnProperty(L) ? (J = xa(u[L], J), x += tn(S) + L + ": " + he + `
`, x += Mn(S) + L + ": " + J + `
`) : x += tn(S) + L + ": " + he + `
`;
          }
        for (var Pe in O)
          O.hasOwnProperty(Pe) && (l = xa(
            O[Pe],
            120 - 2 * S - Pe.length - 2
          ), x += Mn(S) + Pe + ": " + l + `
`);
        return x;
      }
      function Ws(l, u, S, x) {
        var O = "", L = /* @__PURE__ */ new Map();
        for (ht in S)
          S.hasOwnProperty(ht) && L.set(
            ht.toLowerCase(),
            ht
          );
        if (L.size === 1 && L.has("children"))
          O += cl(
            l,
            u,
            $t(x)
          );
        else {
          for (var J in u)
            if (u.hasOwnProperty(J) && J !== "children") {
              var he = 120 - 2 * (x + 1) - J.length - 1, Pe = L.get(J.toLowerCase());
              if (Pe !== void 0) {
                L.delete(J.toLowerCase());
                var ht = u[J];
                Pe = S[Pe];
                var Kt = Ui(
                  ht,
                  he
                );
                he = Ui(
                  Pe,
                  he
                ), typeof ht == "object" && ht !== null && typeof Pe == "object" && Pe !== null && ul(ht) === "Object" && ul(Pe) === "Object" && (2 < Object.keys(ht).length || 2 < Object.keys(Pe).length || -1 < Kt.indexOf("...") || -1 < he.indexOf("...")) ? O += $t(x + 1) + J + `={{
` + Xl(
                  ht,
                  Pe,
                  x + 2
                ) + $t(x + 1) + `}}
` : (O += tn(x + 1) + J + "=" + Kt + `
`, O += Mn(x + 1) + J + "=" + he + `
`);
              } else
                O += $t(x + 1) + J + "=" + Ui(u[J], he) + `
`;
            }
          L.forEach(function(ln) {
            if (ln !== "children") {
              var Sn = 120 - 2 * (x + 1) - ln.length - 1;
              O += Mn(x + 1) + ln + "=" + Ui(S[ln], Sn) + `
`;
            }
          }), O = O === "" ? $t(x) + "<" + l + `>
` : $t(x) + "<" + l + `
` + O + $t(x) + `>
`;
        }
        return l = S.children, u = u.children, typeof l == "string" || typeof l == "number" || typeof l == "bigint" ? (L = "", (typeof u == "string" || typeof u == "number" || typeof u == "bigint") && (L = "" + u), O += sa(L, "" + l, x + 1)) : (typeof u == "string" || typeof u == "number" || typeof u == "bigint") && (O = l == null ? O + sa("" + u, null, x + 1) : O + sa("" + u, void 0, x + 1)), O;
      }
      function lu(l, u) {
        var S = Wn(l);
        if (S === null) {
          for (S = "", l = l.child; l; )
            S += lu(l, u), l = l.sibling;
          return S;
        }
        return $t(u) + "<" + S + `>
`;
      }
      function zl(l, u) {
        var S = Ct(l, u);
        if (S !== l && (l.children.length !== 1 || l.children[0] !== S))
          return $t(u) + `...
` + zl(S, u + 1);
        S = "";
        var x = l.fiber._debugInfo;
        if (x)
          for (var O = 0; O < x.length; O++) {
            var L = x[O].name;
            typeof L == "string" && (S += $t(u) + "<" + L + `>
`, u++);
          }
        if (x = "", O = l.fiber.pendingProps, l.fiber.tag === 6)
          x = sa(O, l.serverProps, u), u++;
        else if (L = Wn(l.fiber), L !== null)
          if (l.serverProps === void 0) {
            x = u;
            var J = 120 - 2 * x - L.length - 2, he = "";
            for (ht in O)
              if (O.hasOwnProperty(ht) && ht !== "children") {
                var Pe = Ui(O[ht], 15);
                if (J -= ht.length + Pe.length + 2, 0 > J) {
                  he += " ...";
                  break;
                }
                he += " " + ht + "=" + Pe;
              }
            x = $t(x) + "<" + L + he + `>
`, u++;
          } else
            l.serverProps === null ? (x = cl(
              L,
              O,
              tn(u)
            ), u++) : typeof l.serverProps == "string" ? console.error(
              "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
            ) : (x = Ws(
              L,
              O,
              l.serverProps,
              u
            ), u++);
        var ht = "";
        for (O = l.fiber.child, L = 0; O && L < l.children.length; )
          J = l.children[L], J.fiber === O ? (ht += zl(J, u), L++) : ht += lu(O, u), O = O.sibling;
        for (O && 0 < l.children.length && (ht += $t(u) + `...
`), O = l.serverTail, l.serverProps === null && u--, l = 0; l < O.length; l++)
          L = O[l], ht = typeof L == "string" ? ht + (Mn(u) + Xa(L, 120 - 2 * u) + `
`) : ht + cl(
            L.type,
            L.props,
            Mn(u)
          );
        return S + x + ht;
      }
      function Jn(l) {
        try {
          return `

` + zl(l, 0);
        } catch {
          return "";
        }
      }
      function un(l, u) {
        if (l.return === null) {
          if (jo === null)
            jo = {
              fiber: l,
              children: [],
              serverProps: void 0,
              serverTail: [],
              distanceFromLeaf: u
            };
          else {
            if (jo.fiber !== l)
              throw Error(
                "Saw multiple hydration diff roots in a pass. This is a bug in React."
              );
            jo.distanceFromLeaf > u && (jo.distanceFromLeaf = u);
          }
          return jo;
        }
        var S = un(
          l.return,
          u + 1
        ).children;
        return 0 < S.length && S[S.length - 1].fiber === l ? (S = S[S.length - 1], S.distanceFromLeaf > u && (S.distanceFromLeaf = u), S) : (u = {
          fiber: l,
          children: [],
          serverProps: void 0,
          serverTail: [],
          distanceFromLeaf: u
        }, S.push(u), u);
      }
      function li(l, u) {
        Dh || (l = un(l, 0), l.serverProps = null, u !== null && (u = xu(u), l.serverTail.push(u)));
      }
      function $(l) {
        var u = "", S = jo;
        throw S !== null && (jo = null, u = Jn(S)), pt(
          Vn(
            Error(
              `Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + u
            ),
            l
          )
        ), bg;
      }
      function pe(l, u) {
        if (!os)
          throw Error(
            "Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
          );
        Fn(
          l.stateNode,
          l.type,
          l.memoizedProps,
          u,
          l
        ) || $(l);
      }
      function Ne(l) {
        for (Qo = l.return; Qo; )
          switch (Qo.tag) {
            case 3:
            case 27:
              Jo = !0;
              return;
            case 5:
            case 13:
              Jo = !1;
              return;
            default:
              Qo = Qo.return;
          }
      }
      function $e(l) {
        if (!os || l !== Qo) return !1;
        if (!ei)
          return Ne(l), ei = !0, !1;
        var u = !1;
        if (Fl ? l.tag !== 3 && l.tag !== 27 && (l.tag !== 5 || Mu(l.type) && !Ul(l.type, l.memoizedProps)) && (u = !0) : l.tag !== 3 && (l.tag !== 5 || Mu(l.type) && !Ul(l.type, l.memoizedProps)) && (u = !0), u && Os) {
          for (u = Os; u; ) {
            var S = un(l, 0), x = xu(u);
            S.serverTail.push(x), u = x.type === "Suspense" ? wr(u) : Ol(u);
          }
          $(l);
        }
        if (Ne(l), l.tag === 13) {
          if (!os)
            throw Error(
              "Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
            );
          if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l)
            throw Error(
              "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
            );
          Os = wr(l);
        } else
          Os = Qo ? Ol(l.stateNode) : null;
        return !0;
      }
      function nt() {
        os && (Os = Qo = null, Dh = ei = !1);
      }
      function pt(l) {
        Ff === null ? Ff = [l] : Ff.push(l);
      }
      function Ft() {
        var l = jo;
        l !== null && (jo = null, l = Jn(l), console.error(
          `A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`,
          "https://react.dev/link/hydration-mismatch",
          l
        ));
      }
      function Gt() {
        for (var l = ll, u = _v = ll = 0; u < l; ) {
          var S = Jc[u];
          Jc[u++] = null;
          var x = Jc[u];
          Jc[u++] = null;
          var O = Jc[u];
          Jc[u++] = null;
          var L = Jc[u];
          if (Jc[u++] = null, x !== null && O !== null) {
            var J = x.pending;
            J === null ? O.next = O : (O.next = J.next, J.next = O), x.pending = O;
          }
          L !== 0 && Re(S, O, L);
        }
      }
      function ee(l, u, S, x) {
        Jc[ll++] = l, Jc[ll++] = u, Jc[ll++] = S, Jc[ll++] = x, _v |= x, l.lanes |= x, l = l.alternate, l !== null && (l.lanes |= x);
      }
      function ye(l, u, S, x) {
        return ee(l, u, S, x), Ie(l);
      }
      function Ee(l, u) {
        return ee(l, null, null, u), Ie(l);
      }
      function Re(l, u, S) {
        l.lanes |= S;
        var x = l.alternate;
        x !== null && (x.lanes |= S);
        for (var O = !1, L = l.return; L !== null; )
          L.childLanes |= S, x = L.alternate, x !== null && (x.childLanes |= S), L.tag === 22 && (l = L.stateNode, l === null || l._visibility & 1 || (O = !0)), l = L, L = L.return;
        O && u !== null && l.tag === 3 && (L = l.stateNode, O = 31 - $i(S), L = L.hiddenUpdates, l = L[O], l === null ? L[O] = [u] : l.push(u), u.lane = S | 536870912);
      }
      function Ie(l) {
        if (m0 > Bp)
          throw zm = m0 = 0, Lg = g_ = null, Error(
            "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
          );
        zm > v0 && (zm = 0, Lg = null, console.error(
          "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
        )), l.alternate === null && (l.flags & 4098) !== 0 && cv(l);
        for (var u = l, S = u.return; S !== null; )
          u.alternate === null && (u.flags & 4098) !== 0 && cv(l), u = S, S = u.return;
        return u.tag === 3 ? u.stateNode : null;
      }
      function je() {
        var l = fc;
        return fc = 0, l;
      }
      function _t(l) {
        var u = fc;
        return fc = l, u;
      }
      function Ut(l) {
        var u = fc;
        return fc += l, u;
      }
      function It(l) {
        Nr = Mg(), 0 > l.actualStartTime && (l.actualStartTime = Nr);
      }
      function on(l) {
        if (0 <= Nr) {
          var u = Mg() - Nr;
          l.actualDuration += u, l.selfBaseDuration = u, Nr = -1;
        }
      }
      function sn(l) {
        if (0 <= Nr) {
          var u = Mg() - Nr;
          l.actualDuration += u, Nr = -1;
        }
      }
      function Qt() {
        if (0 <= Nr) {
          var l = Mg() - Nr;
          Nr = -1, fc += l;
        }
      }
      function bn() {
        Nr = Mg();
      }
      function En(l) {
        for (var u = l.child; u; )
          l.actualDuration += u.actualDuration, u = u.sibling;
      }
      function ca(l) {
        l !== Ud && l.next === null && (Ud === null ? mp = Ud = l : Ud = Ud.next = l), Ru = !0, ft.actQueue !== null ? xg || (xg = !0, Li(zn)) : ay || (ay = !0, Li(zn));
      }
      function yn(l, u) {
        if (!Od && Ru) {
          Od = !0;
          do
            for (var S = !1, x = mp; x !== null; ) {
              if (l !== 0) {
                var O = x.pendingLanes;
                if (O === 0) var L = 0;
                else {
                  var J = x.suspendedLanes, he = x.pingedLanes;
                  L = (1 << 31 - $i(42 | l) + 1) - 1, L &= O & ~(J & ~he), L = L & 201326677 ? L & 201326677 | 1 : L ? L | 2 : 0;
                }
                L !== 0 && (S = !0, jn(x, L));
              } else
                L = wa, L = ct(
                  x,
                  x === El ? L : 0
                ), (L & 3) === 0 || Vt(x, L) || (S = !0, jn(x, L));
              x = x.next;
            }
          while (S);
          Od = !1;
        }
      }
      function zn() {
        Ru = xg = ay = !1;
        var l = 0;
        wd !== 0 && (fp() && (l = wd), wd = 0);
        for (var u = Z(), S = null, x = mp; x !== null; ) {
          var O = x.next, L = xn(x, u);
          L === 0 ? (x.next = null, S === null ? mp = O : S.next = O, O === null && (Ud = S)) : (S = x, (l !== 0 || (L & 3) !== 0) && (Ru = !0)), x = O;
        }
        yn(l);
      }
      function xn(l, u) {
        for (var S = l.suspendedLanes, x = l.pingedLanes, O = l.expirationTimes, L = l.pendingLanes & -62914561; 0 < L; ) {
          var J = 31 - $i(L), he = 1 << J, Pe = O[J];
          Pe === -1 ? ((he & S) === 0 || (he & x) !== 0) && (O[J] = Zt(he, u)) : Pe <= u && (l.expiredLanes |= he), L &= ~he;
        }
        if (u = El, S = wa, S = ct(
          l,
          l === u ? S : 0
        ), x = l.callbackNode, S === 0 || l === u && sl === Tp || l.cancelPendingCommit !== null)
          return x !== null && ta(x), l.callbackNode = null, l.callbackPriority = 0;
        if ((S & 3) === 0 || Vt(l, S)) {
          if (u = S & -S, u !== l.callbackPriority || ft.actQueue !== null && x !== Uh)
            ta(x);
          else return u;
          switch (Mt(S)) {
            case 2:
            case 8:
              S = Be;
              break;
            case 32:
              S = qe;
              break;
            case 268435456:
              S = wt;
              break;
            default:
              S = qe;
          }
          return x = si.bind(null, l), ft.actQueue !== null ? (ft.actQueue.push(x), S = Uh) : S = m(S, x), l.callbackPriority = u, l.callbackNode = S, u;
        }
        return x !== null && ta(x), l.callbackPriority = 2, l.callbackNode = null, 2;
      }
      function si(l, u) {
        Sa = Bh = !1;
        var S = l.callbackNode;
        if (Hc() && l.callbackNode !== S)
          return null;
        var x = wa;
        return x = ct(
          l,
          l === El ? x : 0
        ), x === 0 ? null : (zc(
          l,
          x,
          u
        ), xn(l, Z()), l.callbackNode != null && l.callbackNode === S ? si.bind(null, l) : null);
      }
      function jn(l, u) {
        if (Hc()) return null;
        Bh = Sa, Sa = !1, zc(l, u, !0);
      }
      function ta(l) {
        l !== Uh && l !== null && M(l);
      }
      function Li(l) {
        ft.actQueue !== null && ft.actQueue.push(function() {
          return l(), null;
        }), rc ? Ch(function() {
          (ki & (pc | wm)) !== tf ? m(fe, l) : l();
        }) : m(fe, l);
      }
      function Qn() {
        return wd === 0 && (wd = Bn()), wd;
      }
      function Ta(l, u) {
        if (vp === null) {
          var S = vp = [];
          Du = 0, gp = Qn(), Av = {
            status: "pending",
            value: void 0,
            then: function(x) {
              S.push(x);
            }
          };
        }
        return Du++, u.then(da, da), u;
      }
      function da() {
        if (--Du === 0 && vp !== null) {
          Av !== null && (Av.status = "fulfilled");
          var l = vp;
          vp = null, gp = 0, Av = null;
          for (var u = 0; u < l.length; u++) (0, l[u])();
        }
      }
      function qi(l, u) {
        var S = [], x = {
          status: "pending",
          value: null,
          reason: null,
          then: function(O) {
            S.push(O);
          }
        };
        return l.then(
          function() {
            x.status = "fulfilled", x.value = u;
            for (var O = 0; O < S.length; O++) (0, S[O])(u);
          },
          function(O) {
            for (x.status = "rejected", x.reason = O, O = 0; O < S.length; O++)
              (0, S[O])(void 0);
          }
        ), x;
      }
      function Ya(l) {
        l.updateQueue = {
          baseState: l.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function Ei(l, u) {
        l = l.updateQueue, u.updateQueue === l && (u.updateQueue = {
          baseState: l.baseState,
          firstBaseUpdate: l.firstBaseUpdate,
          lastBaseUpdate: l.lastBaseUpdate,
          shared: l.shared,
          callbacks: null
        });
      }
      function Wi(l) {
        return {
          lane: l,
          tag: a0,
          payload: null,
          callback: null,
          next: null
        };
      }
      function Hl(l, u, S) {
        var x = l.updateQueue;
        if (x === null) return null;
        if (x = x.shared, Ev === x && !o_) {
          var O = Y(l);
          console.error(
            `An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`,
            O
          ), o_ = !0;
        }
        return (ki & pc) !== tf ? (O = x.pending, O === null ? u.next = u : (u.next = O.next, O.next = u), x.pending = u, u = Ie(l), Re(l, null, S), u) : (ee(l, x, u, S), Ie(l));
      }
      function Pr(l, u, S) {
        if (u = u.updateQueue, u !== null && (u = u.shared, (S & 4194176) !== 0)) {
          var x = u.lanes;
          x &= l.pendingLanes, S |= x, u.lanes = S, Ha(l, S);
        }
      }
      function ff(l, u) {
        var S = l.updateQueue, x = l.alternate;
        if (x !== null && (x = x.updateQueue, S === x)) {
          var O = null, L = null;
          if (S = S.firstBaseUpdate, S !== null) {
            do {
              var J = {
                lane: S.lane,
                tag: S.tag,
                payload: S.payload,
                callback: null,
                next: null
              };
              L === null ? O = L = J : L = L.next = J, S = S.next;
            } while (S !== null);
            L === null ? O = L = u : L = L.next = u;
          } else O = L = u;
          S = {
            baseState: x.baseState,
            firstBaseUpdate: O,
            lastBaseUpdate: L,
            shared: x.shared,
            callbacks: x.callbacks
          }, l.updateQueue = S;
          return;
        }
        l = S.lastBaseUpdate, l === null ? S.firstBaseUpdate = u : l.next = u, S.lastBaseUpdate = u;
      }
      function Xu() {
        if (bv) {
          var l = Av;
          if (l !== null) throw l;
        }
      }
      function Yu(l, u, S, x) {
        bv = !1;
        var O = l.updateQueue;
        Kn = !1, Ev = O.shared;
        var L = O.firstBaseUpdate, J = O.lastBaseUpdate, he = O.shared.pending;
        if (he !== null) {
          O.shared.pending = null;
          var Pe = he, ht = Pe.next;
          Pe.next = null, J === null ? L = ht : J.next = ht, J = Pe;
          var Kt = l.alternate;
          Kt !== null && (Kt = Kt.updateQueue, he = Kt.lastBaseUpdate, he !== J && (he === null ? Kt.firstBaseUpdate = ht : he.next = ht, Kt.lastBaseUpdate = Pe));
        }
        if (L !== null) {
          var ln = O.baseState;
          J = 0, Kt = ht = Pe = null, he = L;
          do {
            var Sn = he.lane & -536870913, Na = Sn !== he.lane;
            if (Na ? (wa & Sn) === Sn : (x & Sn) === Sn) {
              Sn !== 0 && Sn === gp && (bv = !0), Kt !== null && (Kt = Kt.next = {
                lane: 0,
                tag: he.tag,
                payload: he.payload,
                callback: null,
                next: null
              });
              e: {
                Sn = l;
                var vi = he, by = u, Lh = S;
                switch (vi.tag) {
                  case iy:
                    if (vi = vi.payload, typeof vi == "function") {
                      ti = !0;
                      var dr = vi.call(
                        Lh,
                        ln,
                        by
                      );
                      if (Sn.mode & 8) {
                        ce(!0);
                        try {
                          vi.call(Lh, ln, by);
                        } finally {
                          ce(!1);
                        }
                      }
                      ti = !1, ln = dr;
                      break e;
                    }
                    ln = vi;
                    break e;
                  case mt:
                    Sn.flags = Sn.flags & -65537 | 128;
                  case a0:
                    if (dr = vi.payload, typeof dr == "function") {
                      if (ti = !0, vi = dr.call(
                        Lh,
                        ln,
                        by
                      ), Sn.mode & 8) {
                        ce(!0);
                        try {
                          dr.call(Lh, ln, by);
                        } finally {
                          ce(!1);
                        }
                      }
                      ti = !1;
                    } else vi = dr;
                    if (vi == null) break e;
                    ln = Ti({}, ln, vi);
                    break e;
                  case _a:
                    Kn = !0;
                }
              }
              Sn = he.callback, Sn !== null && (l.flags |= 64, Na && (l.flags |= 8192), Na = O.callbacks, Na === null ? O.callbacks = [Sn] : Na.push(Sn));
            } else
              Na = {
                lane: Sn,
                tag: he.tag,
                payload: he.payload,
                callback: he.callback,
                next: null
              }, Kt === null ? (ht = Kt = Na, Pe = ln) : Kt = Kt.next = Na, J |= Sn;
            if (he = he.next, he === null) {
              if (he = O.shared.pending, he === null)
                break;
              Na = he, he = Na.next, Na.next = null, O.lastBaseUpdate = Na, O.shared.pending = null;
            }
          } while (!0);
          Kt === null && (Pe = ln), O.baseState = Pe, O.firstBaseUpdate = ht, O.lastBaseUpdate = Kt, L === null && (O.shared.lanes = 0), Ng |= J, l.lanes = J, l.memoizedState = ln;
        }
        Ev = null;
      }
      function $v(l, u) {
        if (typeof l != "function")
          throw Error(
            "Invalid argument passed as callback. Expected a function. Instead received: " + l
          );
        l.call(u);
      }
      function Kg(l, u) {
        var S = l.shared.hiddenCallbacks;
        if (S !== null)
          for (l.shared.hiddenCallbacks = null, l = 0; l < S.length; l++)
            $v(S[l], u);
      }
      function Zh(l, u) {
        var S = l.callbacks;
        if (S !== null)
          for (l.callbacks = null, l = 0; l < S.length; l++)
            $v(S[l], u);
      }
      function Ec(l, u) {
        if (Ke(l, u)) return !0;
        if (typeof l != "object" || l === null || typeof u != "object" || u === null)
          return !1;
        var S = Object.keys(l), x = Object.keys(u);
        if (S.length !== x.length) return !1;
        for (x = 0; x < S.length; x++) {
          var O = S[x];
          if (!Pf.call(u, O) || !Ke(l[O], u[O]))
            return !1;
        }
        return !0;
      }
      function Vp() {
        return { didWarnAboutUncachedPromise: !1, thenables: [] };
      }
      function ad(l) {
        return l = l.status, l === "fulfilled" || l === "rejected";
      }
      function df() {
      }
      function eg(l, u, S) {
        ft.actQueue !== null && (ft.didUsePromise = !0);
        var x = l.thenables;
        switch (S = x[S], S === void 0 ? x.push(u) : S !== u && (l.didWarnAboutUncachedPromise || (l.didWarnAboutUncachedPromise = !0, console.error(
          "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
        )), u.then(df, df), u = S), u.status) {
          case "fulfilled":
            return u.value;
          case "rejected":
            throw l = u.reason, Kd(l), l;
          default:
            if (typeof u.status == "string")
              u.then(df, df);
            else {
              if (l = El, l !== null && 100 < l.shellSuspendCounter)
                throw Error(
                  "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                );
              l = u, l.status = "pending", l.then(
                function(O) {
                  if (u.status === "pending") {
                    var L = u;
                    L.status = "fulfilled", L.value = O;
                  }
                },
                function(O) {
                  if (u.status === "pending") {
                    var L = u;
                    L.status = "rejected", L.reason = O;
                  }
                }
              );
            }
            switch (u.status) {
              case "fulfilled":
                return u.value;
              case "rejected":
                throw l = u.reason, Kd(l), l;
            }
            throw Hd = u, l0 = !0, zd;
        }
      }
      function Fp() {
        if (Hd === null)
          throw Error(
            "Expected a suspended thenable. This is a bug in React. Please file an issue."
          );
        var l = Hd;
        return Hd = null, l0 = !1, l;
      }
      function Kd(l) {
        if (l === zd)
          throw Error(
            "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
          );
      }
      function fl(l) {
        var u = oa;
        return l != null && (oa = u === null ? l : u.concat(l)), u;
      }
      function To(l, u, S) {
        for (var x = Object.keys(l.props), O = 0; O < x.length; O++) {
          var L = x[O];
          if (L !== "children" && L !== "key") {
            u === null && (u = dv(l, S.mode, 0), u._debugInfo = oa, u.return = S), me(
              u,
              function(J) {
                console.error(
                  "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                  J
                );
              },
              L
            );
            break;
          }
        }
      }
      function id(l) {
        var u = Hr;
        return Hr += 1, ws === null && (ws = Vp()), eg(ws, l, u);
      }
      function Co(l, u) {
        u = u.props.ref, l.ref = u !== void 0 ? u : null;
      }
      function su(l, u) {
        throw u.$$typeof === bh ? Error(
          `A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`
        ) : (l = Object.prototype.toString.call(u), Error(
          "Objects are not valid as a React child (found: " + (l === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : l) + "). If you meant to render a collection of children, use an array instead."
        ));
      }
      function ld(l, u) {
        var S = Y(l) || "Component";
        xv[S] || (xv[S] = !0, u = u.displayName || u.name || "Component", l.tag === 3 ? console.error(
          `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`,
          u,
          u,
          u
        ) : console.error(
          `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`,
          u,
          u,
          S,
          u,
          S
        ));
      }
      function hf(l, u) {
        var S = Y(l) || "Component";
        Tv[S] || (Tv[S] = !0, u = String(u), l.tag === 3 ? console.error(
          `Symbols are not valid as a React child.
  root.render(%s)`,
          u
        ) : console.error(
          `Symbols are not valid as a React child.
  <%s>%s</%s>`,
          S,
          u,
          S
        ));
      }
      function Km(l) {
        function u(Le, ze) {
          if (l) {
            var Ye = Le.deletions;
            Ye === null ? (Le.deletions = [ze], Le.flags |= 16) : Ye.push(ze);
          }
        }
        function S(Le, ze) {
          if (!l) return null;
          for (; ze !== null; )
            u(Le, ze), ze = ze.sibling;
          return null;
        }
        function x(Le) {
          for (var ze = /* @__PURE__ */ new Map(); Le !== null; )
            Le.key !== null ? ze.set(Le.key, Le) : ze.set(Le.index, Le), Le = Le.sibling;
          return ze;
        }
        function O(Le, ze) {
          return Le = Es(Le, ze), Le.index = 0, Le.sibling = null, Le;
        }
        function L(Le, ze, Ye) {
          return Le.index = Ye, l ? (Ye = Le.alternate, Ye !== null ? (Ye = Ye.index, Ye < ze ? (Le.flags |= 33554434, ze) : Ye) : (Le.flags |= 33554434, ze)) : (Le.flags |= 1048576, ze);
        }
        function J(Le) {
          return l && Le.alternate === null && (Le.flags |= 33554434), Le;
        }
        function he(Le, ze, Ye, Nt) {
          return ze === null || ze.tag !== 6 ? (ze = Md(
            Ye,
            Le.mode,
            Nt
          ), ze.return = Le, ze._debugOwner = Le, ze._debugInfo = oa, ze) : (ze = O(ze, Ye), ze.return = Le, ze._debugInfo = oa, ze);
        }
        function Pe(Le, ze, Ye, Nt) {
          var _n = Ye.type;
          return _n === Gl ? (ze = Kt(
            Le,
            ze,
            Ye.props.children,
            Nt,
            Ye.key
          ), To(Ye, ze, Le), ze) : ze !== null && (ze.elementType === _n || $g(ze, Ye) || typeof _n == "object" && _n !== null && _n.$$typeof === bs && Uu(_n) === ze.type) ? (ze = O(ze, Ye.props), Co(ze, Ye), ze.return = Le, ze._debugOwner = Ye._owner, ze._debugInfo = oa, ze) : (ze = dv(Ye, Le.mode, Nt), Co(ze, Ye), ze.return = Le, ze._debugInfo = oa, ze);
        }
        function ht(Le, ze, Ye, Nt) {
          return ze === null || ze.tag !== 4 || ze.stateNode.containerInfo !== Ye.containerInfo || ze.stateNode.implementation !== Ye.implementation ? (ze = Eh(Ye, Le.mode, Nt), ze.return = Le, ze._debugInfo = oa, ze) : (ze = O(ze, Ye.children || []), ze.return = Le, ze._debugInfo = oa, ze);
        }
        function Kt(Le, ze, Ye, Nt, _n) {
          return ze === null || ze.tag !== 7 ? (ze = bd(
            Ye,
            Le.mode,
            Nt,
            _n
          ), ze.return = Le, ze._debugOwner = Le, ze._debugInfo = oa, ze) : (ze = O(ze, Ye), ze.return = Le, ze._debugInfo = oa, ze);
        }
        function ln(Le, ze, Ye) {
          if (typeof ze == "string" && ze !== "" || typeof ze == "number" || typeof ze == "bigint")
            return ze = Md(
              "" + ze,
              Le.mode,
              Ye
            ), ze.return = Le, ze._debugOwner = Le, ze._debugInfo = oa, ze;
          if (typeof ze == "object" && ze !== null) {
            switch (ze.$$typeof) {
              case Br:
                return Ye = dv(
                  ze,
                  Le.mode,
                  Ye
                ), Co(Ye, ze), Ye.return = Le, Le = fl(ze._debugInfo), Ye._debugInfo = oa, oa = Le, Ye;
              case oi:
                return ze = Eh(
                  ze,
                  Le.mode,
                  Ye
                ), ze.return = Le, ze._debugInfo = oa, ze;
              case bs:
                var Nt = fl(ze._debugInfo);
                return ze = Uu(ze), Le = ln(Le, ze, Ye), oa = Nt, Le;
            }
            if (Il(ze) || F(ze))
              return Ye = bd(
                ze,
                Le.mode,
                Ye,
                null
              ), Ye.return = Le, Ye._debugOwner = Le, Le = fl(ze._debugInfo), Ye._debugInfo = oa, oa = Le, Ye;
            if (typeof ze.then == "function")
              return Nt = fl(ze._debugInfo), Le = ln(
                Le,
                id(ze),
                Ye
              ), oa = Nt, Le;
            if (ze.$$typeof === La)
              return ln(
                Le,
                as(Le, ze),
                Ye
              );
            su(Le, ze);
          }
          return typeof ze == "function" && ld(Le, ze), typeof ze == "symbol" && hf(Le, ze), null;
        }
        function Sn(Le, ze, Ye, Nt) {
          var _n = ze !== null ? ze.key : null;
          if (typeof Ye == "string" && Ye !== "" || typeof Ye == "number" || typeof Ye == "bigint")
            return _n !== null ? null : he(Le, ze, "" + Ye, Nt);
          if (typeof Ye == "object" && Ye !== null) {
            switch (Ye.$$typeof) {
              case Br:
                return Ye.key === _n ? (_n = fl(Ye._debugInfo), Le = Pe(
                  Le,
                  ze,
                  Ye,
                  Nt
                ), oa = _n, Le) : null;
              case oi:
                return Ye.key === _n ? ht(Le, ze, Ye, Nt) : null;
              case bs:
                return _n = fl(Ye._debugInfo), Ye = Uu(Ye), Le = Sn(
                  Le,
                  ze,
                  Ye,
                  Nt
                ), oa = _n, Le;
            }
            if (Il(Ye) || F(Ye))
              return _n !== null ? null : (_n = fl(Ye._debugInfo), Le = Kt(
                Le,
                ze,
                Ye,
                Nt,
                null
              ), oa = _n, Le);
            if (typeof Ye.then == "function")
              return _n = fl(Ye._debugInfo), Le = Sn(
                Le,
                ze,
                id(Ye),
                Nt
              ), oa = _n, Le;
            if (Ye.$$typeof === La)
              return Sn(
                Le,
                ze,
                as(Le, Ye),
                Nt
              );
            su(Le, Ye);
          }
          return typeof Ye == "function" && ld(Le, Ye), typeof Ye == "symbol" && hf(Le, Ye), null;
        }
        function Na(Le, ze, Ye, Nt, _n) {
          if (typeof Nt == "string" && Nt !== "" || typeof Nt == "number" || typeof Nt == "bigint")
            return Le = Le.get(Ye) || null, he(ze, Le, "" + Nt, _n);
          if (typeof Nt == "object" && Nt !== null) {
            switch (Nt.$$typeof) {
              case Br:
                return Ye = Le.get(
                  Nt.key === null ? Ye : Nt.key
                ) || null, Le = fl(Nt._debugInfo), ze = Pe(
                  ze,
                  Ye,
                  Nt,
                  _n
                ), oa = Le, ze;
              case oi:
                return Le = Le.get(
                  Nt.key === null ? Ye : Nt.key
                ) || null, ht(ze, Le, Nt, _n);
              case bs:
                var ni = fl(Nt._debugInfo);
                return Nt = Uu(Nt), ze = Na(
                  Le,
                  ze,
                  Ye,
                  Nt,
                  _n
                ), oa = ni, ze;
            }
            if (Il(Nt) || F(Nt))
              return Ye = Le.get(Ye) || null, Le = fl(Nt._debugInfo), ze = Kt(
                ze,
                Ye,
                Nt,
                _n,
                null
              ), oa = Le, ze;
            if (typeof Nt.then == "function")
              return ni = fl(Nt._debugInfo), ze = Na(
                Le,
                ze,
                Ye,
                id(Nt),
                _n
              ), oa = ni, ze;
            if (Nt.$$typeof === La)
              return Na(
                Le,
                ze,
                Ye,
                as(ze, Nt),
                _n
              );
            su(ze, Nt);
          }
          return typeof Nt == "function" && ld(ze, Nt), typeof Nt == "symbol" && hf(ze, Nt), null;
        }
        function vi(Le, ze, Ye, Nt) {
          if (typeof Ye != "object" || Ye === null) return Nt;
          switch (Ye.$$typeof) {
            case Br:
            case oi:
              G(Le, ze, Ye);
              var _n = Ye.key;
              if (typeof _n != "string") break;
              if (Nt === null) {
                Nt = /* @__PURE__ */ new Set(), Nt.add(_n);
                break;
              }
              if (!Nt.has(_n)) {
                Nt.add(_n);
                break;
              }
              me(ze, function() {
                console.error(
                  "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.",
                  _n
                );
              });
              break;
            case bs:
              Ye = Uu(Ye), vi(Le, ze, Ye, Nt);
          }
          return Nt;
        }
        function by(Le, ze, Ye, Nt) {
          for (var _n = null, ni = null, aa = null, Ma = ze, za = ze = 0, rl = null; Ma !== null && za < Ye.length; za++) {
            Ma.index > za ? (rl = Ma, Ma = null) : rl = Ma.sibling;
            var Ks = Sn(
              Le,
              Ma,
              Ye[za],
              Nt
            );
            if (Ks === null) {
              Ma === null && (Ma = rl);
              break;
            }
            _n = vi(
              Le,
              Ks,
              Ye[za],
              _n
            ), l && Ma && Ks.alternate === null && u(Le, Ma), ze = L(Ks, ze, za), aa === null ? ni = Ks : aa.sibling = Ks, aa = Ks, Ma = rl;
          }
          if (za === Ye.length)
            return S(Le, Ma), ei && Pt(Le, za), ni;
          if (Ma === null) {
            for (; za < Ye.length; za++)
              Ma = ln(Le, Ye[za], Nt), Ma !== null && (_n = vi(
                Le,
                Ma,
                Ye[za],
                _n
              ), ze = L(
                Ma,
                ze,
                za
              ), aa === null ? ni = Ma : aa.sibling = Ma, aa = Ma);
            return ei && Pt(Le, za), ni;
          }
          for (Ma = x(Ma); za < Ye.length; za++)
            rl = Na(
              Ma,
              Le,
              za,
              Ye[za],
              Nt
            ), rl !== null && (_n = vi(
              Le,
              rl,
              Ye[za],
              _n
            ), l && rl.alternate !== null && Ma.delete(
              rl.key === null ? za : rl.key
            ), ze = L(
              rl,
              ze,
              za
            ), aa === null ? ni = rl : aa.sibling = rl, aa = rl);
          return l && Ma.forEach(function(Gh) {
            return u(Le, Gh);
          }), ei && Pt(Le, za), ni;
        }
        function Lh(Le, ze, Ye, Nt) {
          if (Ye == null)
            throw Error("An iterable object provided no iterator.");
          for (var _n = null, ni = null, aa = ze, Ma = ze = 0, za = null, rl = null, Ks = Ye.next(); aa !== null && !Ks.done; Ma++, Ks = Ye.next()) {
            aa.index > Ma ? (za = aa, aa = null) : za = aa.sibling;
            var Gh = Sn(Le, aa, Ks.value, Nt);
            if (Gh === null) {
              aa === null && (aa = za);
              break;
            }
            rl = vi(
              Le,
              Gh,
              Ks.value,
              rl
            ), l && aa && Gh.alternate === null && u(Le, aa), ze = L(Gh, ze, Ma), ni === null ? _n = Gh : ni.sibling = Gh, ni = Gh, aa = za;
          }
          if (Ks.done)
            return S(Le, aa), ei && Pt(Le, Ma), _n;
          if (aa === null) {
            for (; !Ks.done; Ma++, Ks = Ye.next())
              aa = ln(Le, Ks.value, Nt), aa !== null && (rl = vi(
                Le,
                aa,
                Ks.value,
                rl
              ), ze = L(
                aa,
                ze,
                Ma
              ), ni === null ? _n = aa : ni.sibling = aa, ni = aa);
            return ei && Pt(Le, Ma), _n;
          }
          for (aa = x(aa); !Ks.done; Ma++, Ks = Ye.next())
            za = Na(
              aa,
              Le,
              Ma,
              Ks.value,
              Nt
            ), za !== null && (rl = vi(
              Le,
              za,
              Ks.value,
              rl
            ), l && za.alternate !== null && aa.delete(
              za.key === null ? Ma : za.key
            ), ze = L(
              za,
              ze,
              Ma
            ), ni === null ? _n = za : ni.sibling = za, ni = za);
          return l && aa.forEach(function(I1) {
            return u(Le, I1);
          }), ei && Pt(Le, Ma), _n;
        }
        function dr(Le, ze, Ye, Nt) {
          if (typeof Ye == "object" && Ye !== null && Ye.type === Gl && Ye.key === null && (To(Ye, null, Le), Ye = Ye.props.children), typeof Ye == "object" && Ye !== null) {
            switch (Ye.$$typeof) {
              case Br:
                var _n = fl(Ye._debugInfo);
                e: {
                  for (var ni = Ye.key; ze !== null; ) {
                    if (ze.key === ni) {
                      if (ni = Ye.type, ni === Gl) {
                        if (ze.tag === 7) {
                          S(
                            Le,
                            ze.sibling
                          ), Nt = O(
                            ze,
                            Ye.props.children
                          ), Nt.return = Le, Nt._debugOwner = Ye._owner, Nt._debugInfo = oa, To(Ye, Nt, Le), Le = Nt;
                          break e;
                        }
                      } else if (ze.elementType === ni || $g(
                        ze,
                        Ye
                      ) || typeof ni == "object" && ni !== null && ni.$$typeof === bs && Uu(ni) === ze.type) {
                        S(
                          Le,
                          ze.sibling
                        ), Nt = O(ze, Ye.props), Co(Nt, Ye), Nt.return = Le, Nt._debugOwner = Ye._owner, Nt._debugInfo = oa, Le = Nt;
                        break e;
                      }
                      S(Le, ze);
                      break;
                    } else u(Le, ze);
                    ze = ze.sibling;
                  }
                  Ye.type === Gl ? (Nt = bd(
                    Ye.props.children,
                    Le.mode,
                    Nt,
                    Ye.key
                  ), Nt.return = Le, Nt._debugOwner = Le, Nt._debugInfo = oa, To(Ye, Nt, Le), Le = Nt) : (Nt = dv(
                    Ye,
                    Le.mode,
                    Nt
                  ), Co(Nt, Ye), Nt.return = Le, Nt._debugInfo = oa, Le = Nt);
                }
                return Le = J(Le), oa = _n, Le;
              case oi:
                e: {
                  for (_n = Ye, Ye = _n.key; ze !== null; ) {
                    if (ze.key === Ye)
                      if (ze.tag === 4 && ze.stateNode.containerInfo === _n.containerInfo && ze.stateNode.implementation === _n.implementation) {
                        S(
                          Le,
                          ze.sibling
                        ), Nt = O(
                          ze,
                          _n.children || []
                        ), Nt.return = Le, Le = Nt;
                        break e;
                      } else {
                        S(Le, ze);
                        break;
                      }
                    else u(Le, ze);
                    ze = ze.sibling;
                  }
                  Nt = Eh(
                    _n,
                    Le.mode,
                    Nt
                  ), Nt.return = Le, Le = Nt;
                }
                return J(Le);
              case bs:
                return _n = fl(Ye._debugInfo), Ye = Uu(Ye), Le = dr(
                  Le,
                  ze,
                  Ye,
                  Nt
                ), oa = _n, Le;
            }
            if (Il(Ye))
              return _n = fl(Ye._debugInfo), Le = by(
                Le,
                ze,
                Ye,
                Nt
              ), oa = _n, Le;
            if (F(Ye)) {
              if (_n = fl(Ye._debugInfo), ni = F(Ye), typeof ni != "function")
                throw Error(
                  "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                );
              var aa = ni.call(Ye);
              return aa === Ye ? (Le.tag !== 0 || Object.prototype.toString.call(Le.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(aa) !== "[object Generator]") && ($0 || console.error(
                "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
              ), $0 = !0) : Ye.entries !== ni || uy || (console.error(
                "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
              ), uy = !0), Le = Lh(
                Le,
                ze,
                aa,
                Nt
              ), oa = _n, Le;
            }
            if (typeof Ye.then == "function")
              return _n = fl(Ye._debugInfo), Le = dr(
                Le,
                ze,
                id(Ye),
                Nt
              ), oa = _n, Le;
            if (Ye.$$typeof === La)
              return dr(
                Le,
                ze,
                as(Le, Ye),
                Nt
              );
            su(Le, Ye);
          }
          return typeof Ye == "string" && Ye !== "" || typeof Ye == "number" || typeof Ye == "bigint" ? (_n = "" + Ye, ze !== null && ze.tag === 6 ? (S(
            Le,
            ze.sibling
          ), Nt = O(ze, _n), Nt.return = Le, Le = Nt) : (S(Le, ze), Nt = Md(
            _n,
            Le.mode,
            Nt
          ), Nt.return = Le, Nt._debugOwner = Le, Nt._debugInfo = oa, Le = Nt), J(Le)) : (typeof Ye == "function" && ld(Le, Ye), typeof Ye == "symbol" && hf(Le, Ye), S(Le, ze));
        }
        return function(Le, ze, Ye, Nt) {
          var _n = oa;
          oa = null;
          try {
            Hr = 0;
            var ni = dr(
              Le,
              ze,
              Ye,
              Nt
            );
            return ws = null, ni;
          } catch (rl) {
            if (rl === zd) throw rl;
            var aa = E(29, rl, null, Le.mode);
            aa.lanes = Nt, aa.return = Le;
            var Ma = aa._debugInfo = oa;
            if (aa._debugOwner = Le._debugOwner, Ma != null) {
              for (var za = Ma.length - 1; 0 <= za; za--)
                if (typeof Ma[za].stack == "string") {
                  aa._debugOwner = Ma[za];
                  break;
                }
            }
            return aa;
          } finally {
            oa = _n;
          }
        };
      }
      function Ll(l, u) {
        var S = Dp;
        De(cy, S, l), De(qf, u, l), Dp = S | u.baseLanes;
      }
      function kd(l) {
        De(cy, Dp, l), De(
          qf,
          qf.current,
          l
        );
      }
      function sd(l) {
        Dp = cy.current, we(qf, l), we(cy, l);
      }
      function xl(l) {
        var u = l.alternate;
        De(
          Ns,
          Ns.current & _p,
          l
        ), De(Ou, l, l), Wc === null && (u === null || qf.current !== null || u.memoizedState !== null) && (Wc = l);
      }
      function pf(l) {
        if (l.tag === 22) {
          if (De(Ns, Ns.current, l), De(Ou, l, l), Wc === null) {
            var u = l.alternate;
            u !== null && u.memoizedState !== null && (Wc = l);
          }
        } else ru(l);
      }
      function ru(l) {
        De(Ns, Ns.current, l), De(
          Ou,
          Ou.current,
          l
        );
      }
      function Ro(l) {
        we(Ou, l), Wc === l && (Wc = null), we(Ns, l);
      }
      function Pp(l) {
        for (var u = l; u !== null; ) {
          if (u.tag === 13) {
            var S = u.memoizedState;
            if (S !== null && (S = S.dehydrated, S === null || rr(S) || yl(S)))
              return u;
          } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
            if ((u.flags & 128) !== 0) return u;
          } else if (u.child !== null) {
            u.child.return = u, u = u.child;
            continue;
          }
          if (u === l) break;
          for (; u.sibling === null; ) {
            if (u.return === null || u.return === l) return null;
            u = u.return;
          }
          u.sibling.return = u.return, u = u.sibling;
        }
        return null;
      }
      function ra() {
        var l = vt;
        wu === null ? wu = [l] : wu.push(l);
      }
      function Yt() {
        var l = vt;
        if (wu !== null && (Qf++, wu[Qf] !== l)) {
          var u = Y(
            Gn
          );
          if (!r0.has(u) && (r0.add(u), wu !== null)) {
            for (var S = "", x = 0; x <= Qf; x++) {
              var O = wu[x], L = x === Qf ? l : O;
              for (O = x + 1 + ". " + O; 30 > O.length; )
                O += " ";
              O += L + `
`, S += O;
            }
            console.error(
              `React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,
              u,
              S
            );
          }
        }
      }
      function bc(l) {
        l == null || Il(l) || console.error(
          "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
          vt,
          typeof l
        );
      }
      function qu() {
        var l = Y(Gn);
        Dg.has(l) || (Dg.add(l), console.error(
          "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
          l
        ));
      }
      function dl() {
        throw Error(
          `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
        );
      }
      function km(l, u) {
        if (Bv) return !1;
        if (u === null)
          return console.error(
            "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
            vt
          ), !1;
        l.length !== u.length && console.error(
          `The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,
          vt,
          "[" + u.join(", ") + "]",
          "[" + l.join(", ") + "]"
        );
        for (var S = 0; S < u.length && S < l.length; S++)
          if (!Ke(l[S], u[S])) return !1;
        return !0;
      }
      function tg(l, u, S, x, O, L) {
        Js = L, Gn = u, wu = l !== null ? l._debugHookTypes : null, Qf = -1, Bv = l !== null && l.type !== u.type, (Object.prototype.toString.call(S) === "[object AsyncFunction]" || Object.prototype.toString.call(S) === "[object AsyncGeneratorFunction]") && (L = Y(
          Gn
        ), Cm.has(L) || (Cm.add(L), console.error(
          "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
        ))), u.memoizedState = null, u.updateQueue = null, u.lanes = 0, ft.H = l !== null && l.memoizedState !== null ? Ko : wu !== null ? zu : go, Ap = L = (u.mode & 8) !== Pi;
        var J = W0(S, x, O);
        if (Ap = !1, Rm && (J = Xp(
          u,
          S,
          x,
          O
        )), L) {
          ce(!0);
          try {
            J = Xp(
              u,
              S,
              x,
              O
            );
          } finally {
            ce(!1);
          }
        }
        return Is(l, u), J;
      }
      function Is(l, u) {
        u._debugHookTypes = wu, u.dependencies === null ? ef !== null && (u.dependencies = {
          lanes: 0,
          firstContext: null,
          _debugThenableState: ef
        }) : u.dependencies._debugThenableState = ef, ft.H = Nu;
        var S = el !== null && el.next !== null;
        if (Js = 0, wu = vt = ds = el = Gn = null, Qf = -1, l !== null && (l.flags & 31457280) !== (u.flags & 31457280) && console.error(
          "Internal React error: Expected static flag was missing. Please notify the React team."
        ), Bg = !1, Dv = 0, ef = null, S)
          throw Error(
            "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
          );
        l === null || s || (l = l.dependencies, l !== null && hl(l) && (s = !0)), l0 ? (l0 = !1, l = !0) : l = !1, l && (u = Y(u) || "Unknown", Rg.has(u) || Cm.has(u) || (Rg.add(u), console.error(
          "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
        )));
      }
      function Xp(l, u, S, x) {
        Gn = l;
        var O = 0;
        do {
          if (Rm && (ef = null), Dv = 0, Rm = !1, O >= c_)
            throw Error(
              "Too many re-renders. React limits the number of renders to prevent an infinite loop."
            );
          if (O += 1, Bv = !1, ds = el = null, l.updateQueue != null) {
            var L = l.updateQueue;
            L.lastEffect = null, L.events = null, L.stores = null, L.memoCache != null && (L.memoCache.index = 0);
          }
          Qf = -1, ft.H = Ld, L = W0(u, S, x);
        } while (Rm);
        return L;
      }
      function ky() {
        var l = ft.H, u = l.useState()[0];
        return u = typeof u.then == "function" ? Qh(u) : u, l = l.useState()[0], (el !== null ? el.memoizedState : null) !== l && (Gn.flags |= 1024), u;
      }
      function ng() {
        var l = Rv !== 0;
        return Rv = 0, l;
      }
      function ag(l, u, S) {
        u.updateQueue = l.updateQueue, u.flags = (u.mode & 16) !== Pi ? u.flags & -201328645 : u.flags & -2053, l.lanes &= ~S;
      }
      function Wd(l) {
        if (Bg) {
          for (l = l.memoizedState; l !== null; ) {
            var u = l.queue;
            u !== null && (u.pending = null), l = l.next;
          }
          Bg = !1;
        }
        Js = 0, wu = ds = el = Gn = null, Qf = -1, vt = null, Rm = !1, Dv = Rv = 0, ef = null;
      }
      function ms() {
        var l = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        return ds === null ? Gn.memoizedState = ds = l : ds = ds.next = l, ds;
      }
      function fi() {
        if (el === null) {
          var l = Gn.alternate;
          l = l !== null ? l.memoizedState : null;
        } else l = el.next;
        var u = ds === null ? Gn.memoizedState : ds.next;
        if (u !== null)
          ds = u, el = l;
        else {
          if (l === null)
            throw Gn.alternate === null ? Error(
              "Update hook called on initial render. This is likely a bug in React. Please file an issue."
            ) : Error("Rendered more hooks than during the previous render.");
          el = l, l = {
            memoizedState: el.memoizedState,
            baseState: el.baseState,
            baseQueue: el.baseQueue,
            queue: el.queue,
            next: null
          }, ds === null ? Gn.memoizedState = ds = l : ds = ds.next = l;
        }
        return ds;
      }
      function Qh(l) {
        var u = Dv;
        return Dv += 1, ef === null && (ef = Vp()), l = eg(ef, l, u), u = Gn, (ds === null ? u.memoizedState : ds.next) === null && (u = u.alternate, ft.H = u !== null && u.memoizedState !== null ? Ko : go), l;
      }
      function mf(l) {
        if (l !== null && typeof l == "object") {
          if (typeof l.then == "function") return Qh(l);
          if (l.$$typeof === La) return Ln(l);
        }
        throw Error("An unsupported type was passed to use(): " + String(l));
      }
      function vf(l) {
        var u = null, S = Gn.updateQueue;
        if (S !== null && (u = S.memoCache), u == null) {
          var x = Gn.alternate;
          x !== null && (x = x.updateQueue, x !== null && (x = x.memoCache, x != null && (u = {
            data: x.data.map(function(O) {
              return O.slice();
            }),
            index: 0
          })));
        }
        if (u == null && (u = { data: [], index: 0 }), S === null && (S = fy(), Gn.updateQueue = S), S.memoCache = u, S = u.data[u.index], S === void 0 || Bv)
          for (S = u.data[u.index] = Array(l), x = 0; x < l; x++)
            S[x] = Mh;
        else
          S.length !== l && console.error(
            "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
            S.length,
            l
          );
        return u.index++, S;
      }
      function Do(l, u) {
        return typeof u == "function" ? u(l) : u;
      }
      function ou(l, u, S) {
        var x = ms();
        if (S !== void 0) {
          var O = S(u);
          if (Ap) {
            ce(!0);
            try {
              S(u);
            } finally {
              ce(!1);
            }
          }
        } else O = u;
        return x.memoizedState = x.baseState = O, l = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: l,
          lastRenderedState: O
        }, x.queue = l, l = l.dispatch = ev.bind(
          null,
          Gn,
          l
        ), [x.memoizedState, l];
      }
      function uu(l) {
        var u = fi();
        return Xr(u, el, l);
      }
      function Xr(l, u, S) {
        var x = l.queue;
        if (x === null)
          throw Error(
            "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
          );
        x.lastRenderedReducer = S;
        var O = l.baseQueue, L = x.pending;
        if (L !== null) {
          if (O !== null) {
            var J = O.next;
            O.next = L.next, L.next = J;
          }
          u.baseQueue !== O && console.error(
            "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
          ), u.baseQueue = O = L, x.pending = null;
        }
        if (L = l.baseState, O === null) l.memoizedState = L;
        else {
          u = O.next;
          var he = J = null, Pe = null, ht = u, Kt = !1;
          do {
            var ln = ht.lane & -536870913;
            if (ln !== ht.lane ? (wa & ln) === ln : (Js & ln) === ln) {
              var Sn = ht.revertLane;
              if (Sn === 0)
                Pe !== null && (Pe = Pe.next = {
                  lane: 0,
                  revertLane: 0,
                  action: ht.action,
                  hasEagerState: ht.hasEagerState,
                  eagerState: ht.eagerState,
                  next: null
                }), ln === gp && (Kt = !0);
              else if ((Js & Sn) === Sn) {
                ht = ht.next, Sn === gp && (Kt = !0);
                continue;
              } else
                ln = {
                  lane: 0,
                  revertLane: ht.revertLane,
                  action: ht.action,
                  hasEagerState: ht.hasEagerState,
                  eagerState: ht.eagerState,
                  next: null
                }, Pe === null ? (he = Pe = ln, J = L) : Pe = Pe.next = ln, Gn.lanes |= Sn, Ng |= Sn;
              ln = ht.action, Ap && S(L, ln), L = ht.hasEagerState ? ht.eagerState : S(L, ln);
            } else
              Sn = {
                lane: ln,
                revertLane: ht.revertLane,
                action: ht.action,
                hasEagerState: ht.hasEagerState,
                eagerState: ht.eagerState,
                next: null
              }, Pe === null ? (he = Pe = Sn, J = L) : Pe = Pe.next = Sn, Gn.lanes |= ln, Ng |= ln;
            ht = ht.next;
          } while (ht !== null && ht !== u);
          if (Pe === null ? J = L : Pe.next = he, !Ke(L, l.memoizedState) && (s = !0, Kt && (S = Av, S !== null)))
            throw S;
          l.memoizedState = L, l.baseState = J, l.baseQueue = Pe, x.lastRenderedState = L;
        }
        return O === null && (x.lanes = 0), [l.memoizedState, x.dispatch];
      }
      function vs(l) {
        var u = fi(), S = u.queue;
        if (S === null)
          throw Error(
            "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
          );
        S.lastRenderedReducer = l;
        var x = S.dispatch, O = S.pending, L = u.memoizedState;
        if (O !== null) {
          S.pending = null;
          var J = O = O.next;
          do
            L = l(L, J.action), J = J.next;
          while (J !== O);
          Ke(L, u.memoizedState) || (s = !0), u.memoizedState = L, u.baseQueue === null && (u.baseState = L), S.lastRenderedState = L;
        }
        return [L, x];
      }
      function rd(l, u, S) {
        var x = Gn, O = ms();
        if (ei) {
          if (S === void 0)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          var L = S();
          Cv || L === S() || (console.error(
            "The result of getServerSnapshot should be cached to avoid an infinite loop"
          ), Cv = !0);
        } else {
          if (L = u(), Cv || (S = u(), Ke(L, S) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), Cv = !0)), El === null)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          (wa & 60) !== 0 || Yp(x, u, L);
        }
        return O.memoizedState = L, S = { value: L, getSnapshot: u }, O.queue = S, sh(
          Mc.bind(null, x, S, l),
          [l]
        ), x.flags |= 2048, Vs(
          $c | js,
          mr.bind(
            null,
            x,
            S,
            L,
            u
          ),
          { destroy: void 0 },
          null
        ), L;
      }
      function $d(l, u, S) {
        var x = Gn, O = fi(), L = ei;
        if (L) {
          if (S === void 0)
            throw Error(
              "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
            );
          S = S();
        } else if (S = u(), !Cv) {
          var J = u();
          Ke(S, J) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), Cv = !0);
        }
        (J = !Ke(
          (el || O).memoizedState,
          S
        )) && (O.memoizedState = S, s = !0), O = O.queue;
        var he = Mc.bind(null, x, O, l);
        if (Fs(2048, js, he, [l]), O.getSnapshot !== u || J || ds !== null && ds.memoizedState.tag & $c) {
          if (x.flags |= 2048, Vs(
            $c | js,
            mr.bind(
              null,
              x,
              O,
              S,
              u
            ),
            { destroy: void 0 },
            null
          ), El === null)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          L || (Js & 60) !== 0 || Yp(x, u, S);
        }
        return S;
      }
      function Yp(l, u, S) {
        l.flags |= 16384, l = { getSnapshot: u, value: S }, u = Gn.updateQueue, u === null ? (u = fy(), Gn.updateQueue = u, u.stores = [l]) : (S = u.stores, S === null ? u.stores = [l] : S.push(l));
      }
      function mr(l, u, S, x) {
        u.value = S, u.getSnapshot = x, jh(u) && eh(l);
      }
      function Mc(l, u, S) {
        return S(function() {
          jh(u) && eh(l);
        });
      }
      function jh(l) {
        var u = l.getSnapshot;
        l = l.value;
        try {
          var S = u();
          return !Ke(l, S);
        } catch {
          return !0;
        }
      }
      function eh(l) {
        var u = Ee(l, 2);
        u !== null && ha(u, l, 2);
      }
      function qp(l) {
        var u = ms();
        if (typeof l == "function") {
          var S = l;
          if (l = S(), Ap) {
            ce(!0);
            try {
              S();
            } finally {
              ce(!1);
            }
          }
        }
        return u.memoizedState = u.baseState = l, u.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Do,
          lastRenderedState: l
        }, u;
      }
      function xc(l) {
        l = qp(l);
        var u = l.queue, S = ns.bind(
          null,
          Gn,
          u
        );
        return u.dispatch = S, [l.memoizedState, S];
      }
      function Zu(l) {
        var u = ms();
        u.memoizedState = u.baseState = l;
        var S = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return u.queue = S, u = qr.bind(
          null,
          Gn,
          !0,
          S
        ), S.dispatch = u, [l, u];
      }
      function th(l, u) {
        var S = fi();
        return nh(S, el, l, u);
      }
      function nh(l, u, S, x) {
        return l.baseState = S, Xr(
          l,
          el,
          typeof x == "function" ? x : Do
        );
      }
      function ah(l, u) {
        var S = fi();
        return el !== null ? nh(S, el, l, u) : (S.baseState = l, [l, S.queue.dispatch]);
      }
      function cu(l, u, S, x, O) {
        if (Oo(l))
          throw Error("Cannot update form state while rendering.");
        if (l = u.action, l !== null) {
          var L = {
            payload: O,
            action: l,
            next: null,
            isTransition: !0,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(J) {
              L.listeners.push(J);
            }
          };
          ft.T !== null ? S(!0) : L.isTransition = !1, x(L), S = u.pending, S === null ? (L.next = u.pending = L, gf(u, L)) : (L.next = S.next, u.pending = S.next = L);
        }
      }
      function gf(l, u) {
        var S = u.action, x = u.payload, O = l.state;
        if (u.isTransition) {
          var L = ft.T, J = {};
          ft.T = J, ft.T._updatedFibers = /* @__PURE__ */ new Set();
          try {
            var he = S(O, x), Pe = ft.S;
            Pe !== null && Pe(J, he), ts(l, u, he);
          } catch (ht) {
            Tc(l, u, ht);
          } finally {
            ft.T = L, L === null && J._updatedFibers && (l = J._updatedFibers.size, J._updatedFibers.clear(), 10 < l && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        } else
          try {
            J = S(O, x), ts(l, u, J);
          } catch (ht) {
            Tc(l, u, ht);
          }
      }
      function ts(l, u, S) {
        S !== null && typeof S == "object" && typeof S.then == "function" ? (S.then(
          function(x) {
            od(l, u, x);
          },
          function(x) {
            return Tc(l, u, x);
          }
        ), u.isTransition || console.error(
          "An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`"
        )) : od(l, u, S);
      }
      function od(l, u, S) {
        u.status = "fulfilled", u.value = S, Cc(u), l.state = S, u = l.pending, u !== null && (S = u.next, S === u ? l.pending = null : (S = S.next, u.next = S, gf(l, S)));
      }
      function Tc(l, u, S) {
        var x = l.pending;
        if (l.pending = null, x !== null) {
          x = x.next;
          do
            u.status = "rejected", u.reason = S, Cc(u), u = u.next;
          while (u !== x);
        }
        l.action = null;
      }
      function Cc(l) {
        l = l.listeners;
        for (var u = 0; u < l.length; u++) (0, l[u])();
      }
      function ih(l, u) {
        return u;
      }
      function Bo(l, u) {
        if (ei) {
          var S = El.formState;
          if (S !== null) {
            e: {
              var x = Gn;
              if (ei) {
                if (Os) {
                  var O = Ii(
                    Os,
                    Jo
                  );
                  if (O) {
                    Os = Ol(O), x = _g(O);
                    break e;
                  }
                }
                $(x);
              }
              x = !1;
            }
            x && (u = S[0]);
          }
        }
        S = ms(), S.memoizedState = S.baseState = u, x = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: ih,
          lastRenderedState: u
        }, S.queue = x, S = ns.bind(
          null,
          Gn,
          x
        ), x.dispatch = S, x = qp(!1);
        var L = qr.bind(
          null,
          Gn,
          !1,
          x.queue
        );
        return x = ms(), O = {
          state: u,
          dispatch: null,
          action: l,
          pending: null
        }, x.queue = O, S = cu.bind(
          null,
          Gn,
          O,
          L,
          S
        ), O.dispatch = S, x.memoizedState = l, [u, S, !1];
      }
      function lh(l) {
        var u = fi();
        return Zp(u, el, l);
      }
      function Zp(l, u, S) {
        u = Xr(
          l,
          u,
          ih
        )[0], l = uu(Do)[0], u = typeof u == "object" && u !== null && typeof u.then == "function" ? Qh(u) : u;
        var x = fi(), O = x.queue, L = O.dispatch;
        return S !== x.memoizedState && (Gn.flags |= 2048, Vs(
          $c | js,
          vr.bind(null, O, S),
          { destroy: void 0 },
          null
        )), [u, L, l];
      }
      function vr(l, u) {
        l.action = u;
      }
      function Yr(l) {
        var u = fi(), S = el;
        if (S !== null)
          return Zp(u, S, l);
        fi(), u = u.memoizedState, S = fi();
        var x = S.queue.dispatch;
        return S.memoizedState = l, [u, x, !1];
      }
      function Vs(l, u, S, x) {
        return l = { tag: l, create: u, inst: S, deps: x, next: null }, u = Gn.updateQueue, u === null && (u = fy(), Gn.updateQueue = u), S = u.lastEffect, S === null ? u.lastEffect = l.next = l : (x = S.next, S.next = l, l.next = x, u.lastEffect = l), l;
      }
      function Qp(l) {
        var u = ms();
        return l = { current: l }, u.memoizedState = l;
      }
      function $s(l, u, S, x) {
        var O = ms();
        Gn.flags |= l, O.memoizedState = Vs(
          $c | u,
          S,
          { destroy: void 0 },
          x === void 0 ? null : x
        );
      }
      function Fs(l, u, S, x) {
        var O = fi();
        x = x === void 0 ? null : x;
        var L = O.memoizedState.inst;
        el !== null && x !== null && km(x, el.memoizedState.deps) ? O.memoizedState = Vs(u, S, L, x) : (Gn.flags |= l, O.memoizedState = Vs(
          $c | u,
          S,
          L,
          x
        ));
      }
      function sh(l, u) {
        (Gn.mode & 16) !== Pi && (Gn.mode & 64) === Pi ? $s(142608384, js, l, u) : $s(8390656, js, l, u);
      }
      function yf(l, u) {
        var S = 4194308;
        return (Gn.mode & 16) !== Pi && (S |= 67108864), $s(S, fs, l, u);
      }
      function Rc(l, u) {
        if (typeof u == "function") {
          l = l();
          var S = u(l);
          return function() {
            typeof S == "function" ? S() : u(null);
          };
        }
        if (u != null)
          return u.hasOwnProperty("current") || console.error(
            "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
            "an object with keys {" + Object.keys(u).join(", ") + "}"
          ), l = l(), u.current = l, function() {
            u.current = null;
          };
      }
      function ud(l, u, S) {
        typeof u != "function" && console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          u !== null ? typeof u : "null"
        ), S = S != null ? S.concat([l]) : null;
        var x = 4194308;
        (Gn.mode & 16) !== Pi && (x |= 67108864), $s(
          x,
          fs,
          Rc.bind(null, u, l),
          S
        );
      }
      function yi(l, u, S) {
        typeof u != "function" && console.error(
          "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
          u !== null ? typeof u : "null"
        ), S = S != null ? S.concat([l]) : null, Fs(
          4,
          fs,
          Rc.bind(null, u, l),
          S
        );
      }
      function Wm(l, u) {
        return ms().memoizedState = [
          l,
          u === void 0 ? null : u
        ], l;
      }
      function Jh(l, u) {
        var S = fi();
        u = u === void 0 ? null : u;
        var x = S.memoizedState;
        return u !== null && km(u, x[1]) ? x[0] : (S.memoizedState = [l, u], l);
      }
      function Dc(l, u) {
        var S = ms();
        u = u === void 0 ? null : u;
        var x = l();
        if (Ap) {
          ce(!0);
          try {
            l();
          } finally {
            ce(!1);
          }
        }
        return S.memoizedState = [x, u], x;
      }
      function gr(l, u) {
        var S = fi();
        u = u === void 0 ? null : u;
        var x = S.memoizedState;
        if (u !== null && km(u, x[1]))
          return x[0];
        if (x = l(), Ap) {
          ce(!0);
          try {
            l();
          } finally {
            ce(!1);
          }
        }
        return S.memoizedState = [x, u], x;
      }
      function Qu(l, u) {
        var S = ms();
        return yr(S, l, u);
      }
      function $m(l, u) {
        var S = fi();
        return Yl(
          S,
          el.memoizedState,
          l,
          u
        );
      }
      function gs(l, u) {
        var S = fi();
        return el === null ? yr(S, l, u) : Yl(
          S,
          el.memoizedState,
          l,
          u
        );
      }
      function yr(l, u, S) {
        return S === void 0 || (Js & 1073741824) !== 0 ? l.memoizedState = u : (l.memoizedState = S, l = qs(), Gn.lanes |= l, Ng |= l, S);
      }
      function Yl(l, u, S, x) {
        return Ke(S, u) ? S : qf.current !== null ? (l = yr(l, S, x), Ke(l, u) || (s = !0), l) : (Js & 42) === 0 ? (s = !0, l.memoizedState = S) : (l = qs(), Gn.lanes |= l, Ng |= l, u);
      }
      function Zi(l, u, S, x, O) {
        var L = Pc();
        Tn(
          L !== 0 && 8 > L ? L : 8
        );
        var J = ft.T, he = {};
        ft.T = he, qr(l, !1, u, S), he._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var Pe = O(), ht = ft.S;
          if (ht !== null && ht(he, Pe), Pe !== null && typeof Pe == "object" && typeof Pe.then == "function") {
            var Kt = qi(
              Pe,
              x
            );
            fu(
              l,
              u,
              Kt,
              Cr(l)
            );
          } else
            fu(
              l,
              u,
              x,
              Cr(l)
            );
        } catch (ln) {
          fu(
            l,
            u,
            { then: function() {
            }, status: "rejected", reason: ln },
            Cr(l)
          );
        } finally {
          Tn(L), ft.T = J, J === null && he._updatedFibers && (l = he._updatedFibers.size, he._updatedFibers.clear(), 10 < l && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          ));
        }
      }
      function Kh(l) {
        var u = l.memoizedState;
        if (u !== null) return u;
        u = {
          memoizedState: so,
          baseState: so,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Do,
            lastRenderedState: so
          },
          next: null
        };
        var S = {};
        return u.next = {
          memoizedState: S,
          baseState: S,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Do,
            lastRenderedState: S
          },
          next: null
        }, l.memoizedState = u, l = l.alternate, l !== null && (l.memoizedState = u), u;
      }
      function jp() {
        var l = qp(!1);
        return l = Zi.bind(
          null,
          Gn,
          l.queue,
          !0,
          !1
        ), ms().memoizedState = l, [!1, l];
      }
      function rh() {
        var l = uu(Do)[0], u = fi().memoizedState;
        return [
          typeof l == "boolean" ? l : Qh(l),
          u
        ];
      }
      function Sf() {
        var l = vs(Do)[0], u = fi().memoizedState;
        return [
          typeof l == "boolean" ? l : Qh(l),
          u
        ];
      }
      function ys() {
        return Ln(Yc);
      }
      function Uo() {
        var l = ms(), u = El.identifierPrefix;
        if (ei) {
          var S = cs, x = la;
          S = (x & ~(1 << 32 - $i(x) - 1)).toString(32) + S, u = ":" + u + "R" + S, S = Rv++, 0 < S && (u += "H" + S.toString(32)), u += ":";
        } else
          S = u_++, u = ":" + u + "r" + S.toString(32) + ":";
        return l.memoizedState = u;
      }
      function _f() {
        return ms().memoizedState = oh.bind(
          null,
          Gn
        );
      }
      function oh(l, u) {
        for (var S = l.return; S !== null; ) {
          switch (S.tag) {
            case 24:
            case 3:
              var x = Cr(S);
              l = Wi(x);
              var O = Hl(S, l, x);
              O !== null && (ha(O, S, x), Pr(O, S, x)), S = bf(), u != null && O !== null && console.error(
                "The seed argument is not enabled outside experimental channels."
              ), l.payload = { cache: S };
              return;
          }
          S = S.return;
        }
      }
      function ev(l, u, S, x) {
        typeof x == "function" && console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        ), x = Cr(l), S = {
          lane: x,
          revertLane: 0,
          action: S,
          hasEagerState: !1,
          eagerState: null,
          next: null
        }, Oo(l) ? du(u, S) : (S = ye(
          l,
          u,
          S,
          x
        ), S !== null && (ha(
          S,
          l,
          x
        ), Sr(
          S,
          u,
          x
        ))), Xt(l, x);
      }
      function ns(l, u, S, x) {
        typeof x == "function" && console.error(
          "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
        ), x = Cr(l), fu(
          l,
          u,
          S,
          x
        ), Xt(l, x);
      }
      function fu(l, u, S, x) {
        var O = {
          lane: x,
          revertLane: 0,
          action: S,
          hasEagerState: !1,
          eagerState: null,
          next: null
        };
        if (Oo(l)) du(u, O);
        else {
          var L = l.alternate;
          if (l.lanes === 0 && (L === null || L.lanes === 0) && (L = u.lastRenderedReducer, L !== null)) {
            var J = ft.H;
            ft.H = hs;
            try {
              var he = u.lastRenderedState, Pe = L(he, S);
              if (O.hasEagerState = !0, O.eagerState = Pe, Ke(Pe, he))
                return ee(l, u, O, 0), El === null && Gt(), !1;
            } catch {
            } finally {
              ft.H = J;
            }
          }
          if (S = ye(l, u, O, x), S !== null)
            return ha(S, l, x), Sr(S, u, x), !0;
        }
        return !1;
      }
      function qr(l, u, S, x) {
        if (ft.T === null && gp === 0 && console.error(
          "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
        ), x = {
          lane: 2,
          revertLane: Qn(),
          action: x,
          hasEagerState: !1,
          eagerState: null,
          next: null
        }, Oo(l)) {
          if (u)
            throw Error("Cannot update optimistic state while rendering.");
          console.error("Cannot call startTransition while rendering.");
        } else
          u = ye(
            l,
            S,
            x,
            2
          ), u !== null && ha(u, l, 2);
        Xt(l, 2);
      }
      function Oo(l) {
        var u = l.alternate;
        return l === Gn || u !== null && u === Gn;
      }
      function du(l, u) {
        Rm = Bg = !0;
        var S = l.pending;
        S === null ? u.next = u : (u.next = S.next, S.next = u), l.pending = u;
      }
      function Sr(l, u, S) {
        if ((S & 4194176) !== 0) {
          var x = u.lanes;
          x &= l.pendingLanes, S |= x, u.lanes = S, Ha(l, S);
        }
      }
      function Jp(l) {
        if (l !== null && typeof l != "function") {
          var u = String(l);
          Gd.has(u) || (Gd.add(u), console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            l
          ));
        }
      }
      function _r(l, u, S, x) {
        var O = l.memoizedState, L = S(x, O);
        if (l.mode & 8) {
          ce(!0);
          try {
            L = S(x, O);
          } finally {
            ce(!1);
          }
        }
        L === void 0 && (u = q(u) || "Component", Uv.has(u) || (Uv.add(u), console.error(
          "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
          u
        ))), O = L == null ? O : Ti({}, O, L), l.memoizedState = O, l.lanes === 0 && (l.updateQueue.baseState = O);
      }
      function tv(l, u, S, x, O, L, J) {
        var he = l.stateNode;
        if (typeof he.shouldComponentUpdate == "function") {
          if (S = he.shouldComponentUpdate(
            x,
            L,
            J
          ), l.mode & 8) {
            ce(!0);
            try {
              S = he.shouldComponentUpdate(
                x,
                L,
                J
              );
            } finally {
              ce(!1);
            }
          }
          return S === void 0 && console.error(
            "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
            q(u) || "Component"
          ), S;
        }
        return u.prototype && u.prototype.isPureReactComponent ? !Ec(S, x) || !Ec(O, L) : !0;
      }
      function hu(l, u, S, x) {
        var O = u.state;
        typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(S, x), typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(S, x), u.state !== O && (l = Y(l) || "Component", Bm.has(l) || (Bm.add(l), console.error(
          "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          l
        )), hy.enqueueReplaceState(
          u,
          u.state,
          null
        ));
      }
      function pu(l, u) {
        var S = u;
        if ("ref" in u) {
          S = {};
          for (var x in u)
            x !== "ref" && (S[x] = u[x]);
        }
        if (l = l.defaultProps) {
          S === u && (S = Ti({}, S));
          for (var O in l)
            S[O] === void 0 && (S[O] = l[O]);
        }
        return S;
      }
      function mu(l, u) {
        try {
          Om = u.source ? Y(u.source) : null, yo = null;
          var S = u.value;
          if (ft.actQueue !== null)
            ft.thrownErrors.push(S);
          else {
            var x = l.onUncaughtError;
            x(S, { componentStack: u.stack });
          }
        } catch (O) {
          setTimeout(function() {
            throw O;
          });
        }
      }
      function Kp(l, u, S) {
        try {
          Om = S.source ? Y(S.source) : null, yo = Y(u);
          var x = l.onCaughtError;
          x(S.value, {
            componentStack: S.stack,
            errorBoundary: u.tag === 1 ? u.stateNode : null
          });
        } catch (O) {
          setTimeout(function() {
            throw O;
          });
        }
      }
      function Af(l, u, S) {
        return S = Wi(S), S.tag = mt, S.payload = { element: null }, S.callback = function() {
          me(u.source, mu, l, u);
        }, S;
      }
      function ql(l) {
        return l = Wi(l), l.tag = mt, l;
      }
      function kp(l, u, S, x) {
        var O = S.type.getDerivedStateFromError;
        if (typeof O == "function") {
          var L = x.value;
          l.payload = function() {
            return O(L);
          }, l.callback = function() {
            e0(S), me(
              x.source,
              Kp,
              u,
              S,
              x
            );
          };
        }
        var J = S.stateNode;
        J !== null && typeof J.componentDidCatch == "function" && (l.callback = function() {
          e0(S), me(
            x.source,
            Kp,
            u,
            S,
            x
          ), typeof O != "function" && (So === null ? So = /* @__PURE__ */ new Set([this]) : So.add(this)), s0(this, x), typeof O == "function" || (S.lanes & 2) === 0 && console.error(
            "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
            Y(S) || "Unknown"
          );
        });
      }
      function Ps(l, u, S, x, O) {
        if (S.flags |= 32768, Us && Lc(l, O), x !== null && typeof x == "object" && typeof x.then == "function") {
          if (u = S.alternate, u !== null && wo(
            u,
            S,
            O,
            !0
          ), ei && (Dh = !0), S = Ou.current, S !== null) {
            switch (S.tag) {
              case 13:
                return Wc === null ? rv() : S.alternate === null && zs === Ov && (zs = iS), S.flags &= -257, S.flags |= 65536, S.lanes = O, x === xm ? S.flags |= 16384 : (u = S.updateQueue, u === null ? S.updateQueue = /* @__PURE__ */ new Set([x]) : u.add(x), Sh(l, x, O)), !1;
              case 22:
                return S.flags |= 65536, x === xm ? S.flags |= 16384 : (u = S.updateQueue, u === null ? (u = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([x])
                }, S.updateQueue = u) : (S = u.retryQueue, S === null ? u.retryQueue = /* @__PURE__ */ new Set([x]) : S.add(x)), Sh(l, x, O)), !1;
            }
            throw Error(
              "Unexpected Suspense handler tag (" + S.tag + "). This is a bug in React."
            );
          }
          return Sh(l, x, O), rv(), !1;
        }
        if (ei)
          return Dh = !0, u = Ou.current, u !== null ? ((u.flags & 65536) === 0 && (u.flags |= 256), u.flags |= 65536, u.lanes = O, x !== bg && pt(
            Vn(
              Error(
                "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                { cause: x }
              ),
              S
            )
          )) : (x !== bg && pt(
            Vn(
              Error(
                "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                { cause: x }
              ),
              S
            )
          ), l = l.current.alternate, l.flags |= 65536, O &= -O, l.lanes |= O, x = Vn(x, S), O = Af(
            l.stateNode,
            x,
            O
          ), ff(l, O), zs !== xp && (zs = my)), !1;
        var L = Vn(
          Error(
            "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
            { cause: x }
          ),
          S
        );
        if (Sy === null ? Sy = [L] : Sy.push(L), zs !== xp && (zs = my), u === null) return !0;
        x = Vn(x, S), S = u;
        do {
          switch (S.tag) {
            case 3:
              return S.flags |= 65536, l = O & -O, S.lanes |= l, l = Af(
                S.stateNode,
                x,
                l
              ), ff(S, l), !1;
            case 1:
              if (u = S.type, L = S.stateNode, (S.flags & 128) === 0 && (typeof u.getDerivedStateFromError == "function" || L !== null && typeof L.componentDidCatch == "function" && (So === null || !So.has(L))))
                return S.flags |= 65536, O &= -O, S.lanes |= O, O = ql(O), kp(
                  O,
                  l,
                  S,
                  x
                ), ff(S, O), !1;
          }
          S = S.return;
        } while (S !== null);
        return !1;
      }
      function ri(l, u, S, x) {
        u.child = l === null ? kc(u, null, S, x) : Tm(
          u,
          l.child,
          S,
          x
        );
      }
      function Zr(l, u, S, x, O) {
        S = S.render;
        var L = u.ref;
        if ("ref" in x) {
          var J = {};
          for (var he in x)
            he !== "ref" && (J[he] = x[he]);
        } else J = x;
        return Ua(u), dt(u), x = tg(
          l,
          u,
          S,
          J,
          L,
          O
        ), he = ng(), Et(), l !== null && !s ? (ag(l, u, O), Ar(l, u, O)) : (ei && he && gn(u), u.flags |= 1, ri(l, u, x, O), u.child);
      }
      function ju(l, u, S, x, O) {
        if (l === null) {
          var L = S.type;
          return typeof L == "function" && !Ah(L) && L.defaultProps === void 0 && S.compare === null ? (S = nc(L), u.tag = 15, u.type = S, tr(u, L), vu(
            l,
            u,
            S,
            x,
            O
          )) : (l = gg(
            S.type,
            null,
            x,
            u,
            u.mode,
            O
          ), l.ref = u.ref, l.return = u, u.child = l);
        }
        if (L = l.child, !Ss(l, O)) {
          var J = L.memoizedProps;
          if (S = S.compare, S = S !== null ? S : Ec, S(J, x) && l.ref === u.ref)
            return Ar(
              l,
              u,
              O
            );
        }
        return u.flags |= 1, l = Es(L, x), l.ref = u.ref, l.return = u, u.child = l;
      }
      function vu(l, u, S, x, O) {
        if (l !== null) {
          var L = l.memoizedProps;
          if (Ec(L, x) && l.ref === u.ref && u.type === l.type)
            if (s = !1, u.pendingProps = x = L, Ss(l, O))
              (l.flags & 131072) !== 0 && (s = !0);
            else
              return u.lanes = l.lanes, Ar(l, u, O);
        }
        return cd(
          l,
          u,
          S,
          x,
          O
        );
      }
      function gu(l, u, S) {
        var x = u.pendingProps, O = x.children, L = (u.stateNode._pendingVisibility & 2) !== 0, J = l !== null ? l.memoizedState : null;
        if (er(l, u), x.mode === "hidden" || L) {
          if ((u.flags & 128) !== 0) {
            if (x = J !== null ? J.baseLanes | S : S, l !== null) {
              for (O = u.child = l.child, L = 0; O !== null; )
                L = L | O.lanes | O.childLanes, O = O.sibling;
              u.childLanes = L & ~x;
            } else u.childLanes = 0, u.child = null;
            return uh(
              l,
              u,
              x,
              S
            );
          }
          if ((S & 536870912) !== 0)
            u.memoizedState = { baseLanes: 0, cachePool: null }, l !== null && Kr(
              u,
              J !== null ? J.cachePool : null
            ), J !== null ? Ll(u, J) : kd(u), pf(u);
          else
            return u.lanes = u.childLanes = 536870912, uh(
              l,
              u,
              J !== null ? J.baseLanes | S : S,
              S
            );
        } else
          J !== null ? (Kr(u, J.cachePool), Ll(u, J), ru(u), u.memoizedState = null) : (l !== null && Kr(u, null), kd(u), ru(u));
        return ri(l, u, O, S), u.child;
      }
      function uh(l, u, S, x) {
        var O = Wp();
        return O = O === null ? null : {
          parent: jl ? gt._currentValue : gt._currentValue2,
          pool: O
        }, u.memoizedState = {
          baseLanes: S,
          cachePool: O
        }, l !== null && Kr(u, null), kd(u), pf(u), l !== null && wo(l, u, x, !0), null;
      }
      function er(l, u) {
        var S = u.ref;
        if (S === null)
          l !== null && l.ref !== null && (u.flags |= 2097664);
        else {
          if (typeof S != "function" && typeof S != "object")
            throw Error(
              "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
            );
          (l === null || l.ref !== S) && (u.flags |= 2097664);
        }
      }
      function cd(l, u, S, x, O) {
        if (S.prototype && typeof S.prototype.render == "function") {
          var L = q(S) || "Unknown";
          f[L] || (console.error(
            "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
            L,
            L
          ), f[L] = !0);
        }
        return u.mode & 8 && cr.recordLegacyContextWarning(
          u,
          null
        ), l === null && (tr(u, u.type), S.contextTypes && (L = q(S) || "Unknown", A[L] || (A[L] = !0, console.error(
          "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
          L
        )))), Ua(u), dt(u), S = tg(
          l,
          u,
          S,
          x,
          void 0,
          O
        ), x = ng(), Et(), l !== null && !s ? (ag(l, u, O), Ar(l, u, O)) : (ei && x && gn(u), u.flags |= 1, ri(l, u, S, O), u.child);
      }
      function ch(l, u, S, x, O, L) {
        return Ua(u), dt(u), Qf = -1, Bv = l !== null && l.type !== u.type, u.updateQueue = null, S = Xp(
          u,
          x,
          S,
          O
        ), Is(l, u), x = ng(), Et(), l !== null && !s ? (ag(l, u, L), Ar(l, u, L)) : (ei && x && gn(u), u.flags |= 1, ri(l, u, S, L), u.child);
      }
      function fd(l, u, S, x, O) {
        switch (_(u)) {
          case !1:
            var L = u.stateNode, J = new u.type(
              u.memoizedProps,
              L.context
            ).state;
            L.updater.enqueueSetState(L, J, null);
            break;
          case !0:
            u.flags |= 128, u.flags |= 65536, L = Error("Simulated error coming from DevTools");
            var he = O & -O;
            if (u.lanes |= he, J = El, J === null)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            he = ql(he), kp(
              he,
              J,
              u,
              Vn(L, u)
            ), ff(u, he);
        }
        if (Ua(u), u.stateNode === null) {
          if (J = Bs, L = S.contextType, "contextType" in S && L !== null && (L === void 0 || L.$$typeof !== La) && !u0.has(S) && (u0.add(S), he = L === void 0 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof L != "object" ? " However, it is set to a " + typeof L + "." : L.$$typeof === Io ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(L).join(", ") + "}.", console.error(
            "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
            q(S) || "Component",
            he
          )), typeof L == "object" && L !== null && (J = Ln(L)), L = new S(x, J), u.mode & 8) {
            ce(!0);
            try {
              L = new S(x, J);
            } finally {
              ce(!1);
            }
          }
          if (J = u.memoizedState = L.state !== null && L.state !== void 0 ? L.state : null, L.updater = hy, u.stateNode = L, L._reactInternals = u, L._reactInternalInstance = Dm, typeof S.getDerivedStateFromProps == "function" && J === null && (J = q(S) || "Component", eS.has(J) || (eS.add(J), console.error(
            "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
            J,
            L.state === null ? "null" : "undefined",
            J
          ))), typeof S.getDerivedStateFromProps == "function" || typeof L.getSnapshotBeforeUpdate == "function") {
            var Pe = he = J = null;
            if (typeof L.componentWillMount == "function" && L.componentWillMount.__suppressDeprecationWarning !== !0 ? J = "componentWillMount" : typeof L.UNSAFE_componentWillMount == "function" && (J = "UNSAFE_componentWillMount"), typeof L.componentWillReceiveProps == "function" && L.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? he = "componentWillReceiveProps" : typeof L.UNSAFE_componentWillReceiveProps == "function" && (he = "UNSAFE_componentWillReceiveProps"), typeof L.componentWillUpdate == "function" && L.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Pe = "componentWillUpdate" : typeof L.UNSAFE_componentWillUpdate == "function" && (Pe = "UNSAFE_componentWillUpdate"), J !== null || he !== null || Pe !== null) {
              L = q(S) || "Component";
              var ht = typeof S.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              Ug.has(L) || (Ug.add(L), console.error(
                `Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`,
                L,
                ht,
                J !== null ? `
  ` + J : "",
                he !== null ? `
  ` + he : "",
                Pe !== null ? `
  ` + Pe : ""
              ));
            }
          }
          L = u.stateNode, J = q(S) || "Component", L.render || (S.prototype && typeof S.prototype.render == "function" ? console.error(
            "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
            J
          ) : console.error(
            "No `render` method found on the %s instance: you may have forgotten to define `render`.",
            J
          )), !L.getInitialState || L.getInitialState.isReactClassApproved || L.state || console.error(
            "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
            J
          ), L.getDefaultProps && !L.getDefaultProps.isReactClassApproved && console.error(
            "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
            J
          ), L.contextType && console.error(
            "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
            J
          ), S.childContextTypes && !Um.has(S) && (Um.add(S), console.error(
            "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
            J
          )), S.contextTypes && !dy.has(S) && (dy.add(S), console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
            J
          )), typeof L.componentShouldUpdate == "function" && console.error(
            "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
            J
          ), S.prototype && S.prototype.isPureReactComponent && typeof L.shouldComponentUpdate < "u" && console.error(
            "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
            q(S) || "A pure component"
          ), typeof L.componentDidUnmount == "function" && console.error(
            "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
            J
          ), typeof L.componentDidReceiveProps == "function" && console.error(
            "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
            J
          ), typeof L.componentWillRecieveProps == "function" && console.error(
            "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
            J
          ), typeof L.UNSAFE_componentWillRecieveProps == "function" && console.error(
            "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
            J
          ), he = L.props !== x, L.props !== void 0 && he && console.error(
            "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
            J
          ), L.defaultProps && console.error(
            "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
            J,
            J
          ), typeof L.getSnapshotBeforeUpdate != "function" || typeof L.componentDidUpdate == "function" || o0.has(S) || (o0.add(S), console.error(
            "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
            q(S)
          )), typeof L.getDerivedStateFromProps == "function" && console.error(
            "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            J
          ), typeof L.getDerivedStateFromError == "function" && console.error(
            "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
            J
          ), typeof S.getSnapshotBeforeUpdate == "function" && console.error(
            "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
            J
          ), (he = L.state) && (typeof he != "object" || Il(he)) && console.error("%s.state: must be set to an object or null", J), typeof L.getChildContext == "function" && typeof S.childContextTypes != "object" && console.error(
            "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
            J
          ), L = u.stateNode, L.props = x, L.state = u.memoizedState, L.refs = {}, Ya(u), J = S.contextType, L.context = typeof J == "object" && J !== null ? Ln(J) : Bs, L.state === x && (J = q(S) || "Component", Og.has(J) || (Og.add(J), console.error(
            "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
            J
          ))), u.mode & 8 && cr.recordLegacyContextWarning(
            u,
            L
          ), cr.recordUnsafeLifecycleWarnings(
            u,
            L
          ), L.state = u.memoizedState, J = S.getDerivedStateFromProps, typeof J == "function" && (_r(
            u,
            S,
            J,
            x
          ), L.state = u.memoizedState), typeof S.getDerivedStateFromProps == "function" || typeof L.getSnapshotBeforeUpdate == "function" || typeof L.UNSAFE_componentWillMount != "function" && typeof L.componentWillMount != "function" || (J = L.state, typeof L.componentWillMount == "function" && L.componentWillMount(), typeof L.UNSAFE_componentWillMount == "function" && L.UNSAFE_componentWillMount(), J !== L.state && (console.error(
            "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            Y(u) || "Component"
          ), hy.enqueueReplaceState(
            L,
            L.state,
            null
          )), Yu(u, x, L, O), Xu(), L.state = u.memoizedState), typeof L.componentDidMount == "function" && (u.flags |= 4194308), (u.mode & 16) !== Pi && (u.flags |= 67108864), L = !0;
        } else if (l === null) {
          L = u.stateNode;
          var Kt = u.memoizedProps;
          he = pu(S, Kt), L.props = he;
          var ln = L.context;
          Pe = S.contextType, J = Bs, typeof Pe == "object" && Pe !== null && (J = Ln(Pe)), ht = S.getDerivedStateFromProps, Pe = typeof ht == "function" || typeof L.getSnapshotBeforeUpdate == "function", Kt = u.pendingProps !== Kt, Pe || typeof L.UNSAFE_componentWillReceiveProps != "function" && typeof L.componentWillReceiveProps != "function" || (Kt || ln !== J) && hu(
            u,
            L,
            x,
            J
          ), Kn = !1;
          var Sn = u.memoizedState;
          L.state = Sn, Yu(u, x, L, O), Xu(), ln = u.memoizedState, Kt || Sn !== ln || Kn ? (typeof ht == "function" && (_r(
            u,
            S,
            ht,
            x
          ), ln = u.memoizedState), (he = Kn || tv(
            u,
            S,
            he,
            x,
            Sn,
            ln,
            J
          )) ? (Pe || typeof L.UNSAFE_componentWillMount != "function" && typeof L.componentWillMount != "function" || (typeof L.componentWillMount == "function" && L.componentWillMount(), typeof L.UNSAFE_componentWillMount == "function" && L.UNSAFE_componentWillMount()), typeof L.componentDidMount == "function" && (u.flags |= 4194308), (u.mode & 16) !== Pi && (u.flags |= 67108864)) : (typeof L.componentDidMount == "function" && (u.flags |= 4194308), (u.mode & 16) !== Pi && (u.flags |= 67108864), u.memoizedProps = x, u.memoizedState = ln), L.props = x, L.state = ln, L.context = J, L = he) : (typeof L.componentDidMount == "function" && (u.flags |= 4194308), (u.mode & 16) !== Pi && (u.flags |= 67108864), L = !1);
        } else {
          L = u.stateNode, Ei(l, u), J = u.memoizedProps, Pe = pu(S, J), L.props = Pe, ht = u.pendingProps, Sn = L.context, ln = S.contextType, he = Bs, typeof ln == "object" && ln !== null && (he = Ln(ln)), Kt = S.getDerivedStateFromProps, (ln = typeof Kt == "function" || typeof L.getSnapshotBeforeUpdate == "function") || typeof L.UNSAFE_componentWillReceiveProps != "function" && typeof L.componentWillReceiveProps != "function" || (J !== ht || Sn !== he) && hu(
            u,
            L,
            x,
            he
          ), Kn = !1, Sn = u.memoizedState, L.state = Sn, Yu(u, x, L, O), Xu();
          var Na = u.memoizedState;
          J !== ht || Sn !== Na || Kn || l !== null && l.dependencies !== null && hl(l.dependencies) ? (typeof Kt == "function" && (_r(
            u,
            S,
            Kt,
            x
          ), Na = u.memoizedState), (Pe = Kn || tv(
            u,
            S,
            Pe,
            x,
            Sn,
            Na,
            he
          ) || l !== null && l.dependencies !== null && hl(l.dependencies)) ? (ln || typeof L.UNSAFE_componentWillUpdate != "function" && typeof L.componentWillUpdate != "function" || (typeof L.componentWillUpdate == "function" && L.componentWillUpdate(x, Na, he), typeof L.UNSAFE_componentWillUpdate == "function" && L.UNSAFE_componentWillUpdate(
            x,
            Na,
            he
          )), typeof L.componentDidUpdate == "function" && (u.flags |= 4), typeof L.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof L.componentDidUpdate != "function" || J === l.memoizedProps && Sn === l.memoizedState || (u.flags |= 4), typeof L.getSnapshotBeforeUpdate != "function" || J === l.memoizedProps && Sn === l.memoizedState || (u.flags |= 1024), u.memoizedProps = x, u.memoizedState = Na), L.props = x, L.state = Na, L.context = he, L = Pe) : (typeof L.componentDidUpdate != "function" || J === l.memoizedProps && Sn === l.memoizedState || (u.flags |= 4), typeof L.getSnapshotBeforeUpdate != "function" || J === l.memoizedProps && Sn === l.memoizedState || (u.flags |= 1024), L = !1);
        }
        if (he = L, er(l, u), J = (u.flags & 128) !== 0, he || J) {
          if (he = u.stateNode, ft.getCurrentStack = u === null ? null : _e, Dl = !1, rs = u, J && typeof S.getDerivedStateFromError != "function")
            S = null, Nr = -1;
          else {
            if (dt(u), S = yp(he), u.mode & 8) {
              ce(!0);
              try {
                yp(he);
              } finally {
                ce(!1);
              }
            }
            Et();
          }
          u.flags |= 1, l !== null && J ? (u.child = Tm(
            u,
            l.child,
            null,
            O
          ), u.child = Tm(
            u,
            null,
            S,
            O
          )) : ri(
            l,
            u,
            S,
            O
          ), u.memoizedState = he.state, l = u.child;
        } else
          l = Ar(
            l,
            u,
            O
          );
        return O = u.stateNode, L && O.props !== x && (H || console.error(
          "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
          Y(u) || "a component"
        ), H = !0), l;
      }
      function nv(l, u, S, x) {
        return nt(), u.flags |= 256, ri(l, u, S, x), u.child;
      }
      function tr(l, u) {
        u && u.childContextTypes && console.error(
          `childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`,
          u.displayName || u.name || "Component"
        ), typeof u.getDerivedStateFromProps == "function" && (l = q(u) || "Unknown", U[l] || (console.error(
          "%s: Function components do not support getDerivedStateFromProps.",
          l
        ), U[l] = !0)), typeof u.contextType == "object" && u.contextType !== null && (u = q(u) || "Unknown", v[u] || (console.error(
          "%s: Function components do not support contextType.",
          u
        ), v[u] = !0));
      }
      function dd(l) {
        return { baseLanes: l, cachePool: dh() };
      }
      function tl(l, u, S) {
        return l = l !== null ? l.childLanes & ~S : 0, u && (l |= Jf), l;
      }
      function Ca(l, u, S) {
        var x = u.pendingProps;
        y(u) && (u.flags |= 128);
        var O = !1, L = (u.flags & 128) !== 0, J;
        if ((J = L) || (J = l !== null && l.memoizedState === null ? !1 : (Ns.current & Zf) !== 0), J && (O = !0, u.flags &= -129), J = (u.flags & 32) !== 0, u.flags &= -33, l === null) {
          if (ei) {
            if (O ? xl(u) : ru(u), ei) {
              var he = Os, Pe;
              (Pe = !he) || (Pe = Ga(
                he,
                Jo
              ), Pe !== null ? (jt(), u.memoizedState = {
                dehydrated: Pe,
                treeContext: Ki !== null ? { id: la, overflow: cs } : null,
                retryLane: 536870912
              }, L = E(18, null, null, Pi), L.stateNode = Pe, L.return = u, u.child = L, Qo = u, Os = null, Pe = !0) : Pe = !1, Pe = !Pe), Pe && (li(u, he), $(u));
            }
            if (he = u.memoizedState, he !== null && (he = he.dehydrated, he !== null))
              return yl(he) ? u.lanes = 16 : u.lanes = 536870912, null;
            Ro(u);
          }
          return he = x.children, x = x.fallback, O ? (ru(u), O = u.mode, he = Qr(
            { mode: "hidden", children: he },
            O
          ), x = bd(
            x,
            O,
            S,
            null
          ), he.return = u, x.return = u, he.sibling = x, u.child = he, O = u.child, O.memoizedState = dd(S), O.childLanes = tl(
            l,
            J,
            S
          ), u.memoizedState = be, x) : (xl(u), Lt(u, he));
        }
        if (Pe = l.memoizedState, Pe !== null && (he = Pe.dehydrated, he !== null)) {
          if (L)
            u.flags & 256 ? (xl(u), u.flags &= -257, u = Ef(
              l,
              u,
              S
            )) : u.memoizedState !== null ? (ru(u), u.child = l.child, u.flags |= 128, u = null) : (ru(u), O = x.fallback, he = u.mode, x = Qr(
              { mode: "visible", children: x.children },
              he
            ), O = bd(
              O,
              he,
              S,
              null
            ), O.flags |= 2, x.return = u, O.return = u, x.sibling = O, u.child = x, Tm(
              u,
              l.child,
              null,
              S
            ), x = u.child, x.memoizedState = dd(S), x.childLanes = tl(
              l,
              J,
              S
            ), u.memoizedState = be, u = O);
          else if (xl(u), ei && console.error(
            "We should not be hydrating here. This is a bug in React. Please file a bug."
          ), yl(he))
            he = n0(he), J = he.digest, O = he.message, x = he.stack, he = he.componentStack, O = Error(O || "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."), O.stack = x || "", O.digest = J, J = he === void 0 ? null : he, x = {
              value: O,
              source: null,
              stack: J
            }, typeof J == "string" && Ge.set(O, x), pt(x), u = Ef(
              l,
              u,
              S
            );
          else if (s || wo(
            l,
            u,
            S,
            !1
          ), J = (S & l.childLanes) !== 0, s || J) {
            if (J = El, J !== null) {
              if (x = S & -S, (x & 42) !== 0) x = 1;
              else
                switch (x) {
                  case 2:
                    x = 1;
                    break;
                  case 8:
                    x = 4;
                    break;
                  case 32:
                    x = 16;
                    break;
                  case 128:
                  case 256:
                  case 512:
                  case 1024:
                  case 2048:
                  case 4096:
                  case 8192:
                  case 16384:
                  case 32768:
                  case 65536:
                  case 131072:
                  case 262144:
                  case 524288:
                  case 1048576:
                  case 2097152:
                  case 4194304:
                  case 8388608:
                  case 16777216:
                  case 33554432:
                    x = 64;
                    break;
                  case 268435456:
                    x = 134217728;
                    break;
                  default:
                    x = 0;
                }
              if (x = (x & (J.suspendedLanes | S)) !== 0 ? 0 : x, x !== 0 && x !== Pe.retryLane)
                throw Pe.retryLane = x, Ee(l, x), ha(J, l, x), wg;
            }
            rr(he) || rv(), u = Ef(
              l,
              u,
              S
            );
          } else
            rr(he) ? (u.flags |= 128, u.child = l.child, u = kg.bind(
              null,
              l
            ), ny(he, u), u = null) : (l = Pe.treeContext, os && (Os = Ag(he), Qo = u, ei = !0, Ff = null, Dh = !1, jo = null, Jo = !1, l !== null && (jt(), Hn[ya++] = la, Hn[ya++] = cs, Hn[ya++] = Ki, la = l.id, cs = l.overflow, Ki = u)), u = Lt(
              u,
              x.children
            ), u.flags |= 4096);
          return u;
        }
        return O ? (ru(u), O = x.fallback, he = u.mode, Pe = l.child, L = Pe.sibling, x = Es(Pe, {
          mode: "hidden",
          children: x.children
        }), x.subtreeFlags = Pe.subtreeFlags & 31457280, L !== null ? O = Es(L, O) : (O = bd(
          O,
          he,
          S,
          null
        ), O.flags |= 2), O.return = u, x.return = u, x.sibling = O, u.child = x, x = O, O = u.child, he = l.child.memoizedState, he === null ? he = dd(S) : (Pe = he.cachePool, Pe !== null ? (L = jl ? gt._currentValue : gt._currentValue2, Pe = Pe.parent !== L ? { parent: L, pool: L } : Pe) : Pe = dh(), he = {
          baseLanes: he.baseLanes | S,
          cachePool: Pe
        }), O.memoizedState = he, O.childLanes = tl(
          l,
          J,
          S
        ), u.memoizedState = be, x) : (xl(u), S = l.child, l = S.sibling, S = Es(S, {
          mode: "visible",
          children: x.children
        }), S.return = u, S.sibling = null, l !== null && (J = u.deletions, J === null ? (u.deletions = [l], u.flags |= 16) : J.push(l)), u.child = S, u.memoizedState = null, S);
      }
      function Lt(l, u) {
        return u = Qr(
          { mode: "visible", children: u },
          l.mode
        ), u.return = l, l.child = u;
      }
      function Qr(l, u) {
        return yg(l, u, 0, null);
      }
      function Ef(l, u, S) {
        return Tm(u, l.child, null, S), l = Lt(
          u,
          u.pendingProps.children
        ), l.flags |= 2, u.memoizedState = null, l;
      }
      function nl(l, u, S) {
        l.lanes |= u;
        var x = l.alternate;
        x !== null && (x.lanes |= u), fh(
          l.return,
          u,
          S
        );
      }
      function hd(l, u) {
        var S = Il(l);
        return l = !S && typeof F(l) == "function", S || l ? (S = S ? "array" : "iterable", console.error(
          "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
          S,
          u,
          S
        ), !1) : !0;
      }
      function Xs(l, u, S, x, O) {
        var L = l.memoizedState;
        L === null ? l.memoizedState = {
          isBackwards: u,
          rendering: null,
          renderingStartTime: 0,
          last: x,
          tail: S,
          tailMode: O
        } : (L.isBackwards = u, L.rendering = null, L.renderingStartTime = 0, L.last = x, L.tail = S, L.tailMode = O);
      }
      function kh(l, u, S) {
        var x = u.pendingProps, O = x.revealOrder, L = x.tail;
        if (x = x.children, O !== void 0 && O !== "forwards" && O !== "backwards" && O !== "together" && !W[O])
          if (W[O] = !0, typeof O == "string")
            switch (O.toLowerCase()) {
              case "together":
              case "forwards":
              case "backwards":
                console.error(
                  '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                  O,
                  O.toLowerCase()
                );
                break;
              case "forward":
              case "backward":
                console.error(
                  '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                  O,
                  O.toLowerCase()
                );
                break;
              default:
                console.error(
                  '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                  O
                );
            }
          else
            console.error(
              '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
              O
            );
        L === void 0 || oe[L] || (L !== "collapsed" && L !== "hidden" ? (oe[L] = !0, console.error(
          '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
          L
        )) : O !== "forwards" && O !== "backwards" && (oe[L] = !0, console.error(
          '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
          L
        )));
        e: if ((O === "forwards" || O === "backwards") && x !== void 0 && x !== null && x !== !1)
          if (Il(x)) {
            for (var J = 0; J < x.length; J++)
              if (!hd(x[J], J)) break e;
          } else if (J = F(x), typeof J == "function") {
            if (J = J.call(x))
              for (var he = J.next(), Pe = 0; !he.done; he = J.next()) {
                if (!hd(he.value, Pe)) break e;
                Pe++;
              }
          } else
            console.error(
              'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
              O
            );
        if (ri(l, u, x, S), x = Ns.current, (x & Zf) !== 0)
          x = x & _p | Zf, u.flags |= 128;
        else {
          if (l !== null && (l.flags & 128) !== 0)
            e: for (l = u.child; l !== null; ) {
              if (l.tag === 13)
                l.memoizedState !== null && nl(
                  l,
                  S,
                  u
                );
              else if (l.tag === 19)
                nl(l, S, u);
              else if (l.child !== null) {
                l.child.return = l, l = l.child;
                continue;
              }
              if (l === u) break e;
              for (; l.sibling === null; ) {
                if (l.return === null || l.return === u)
                  break e;
                l = l.return;
              }
              l.sibling.return = l.return, l = l.sibling;
            }
          x &= _p;
        }
        switch (De(Ns, x, u), O) {
          case "forwards":
            for (S = u.child, O = null; S !== null; )
              l = S.alternate, l !== null && Pp(l) === null && (O = S), S = S.sibling;
            S = O, S === null ? (O = u.child, u.child = null) : (O = S.sibling, S.sibling = null), Xs(
              u,
              !1,
              O,
              S,
              L
            );
            break;
          case "backwards":
            for (S = null, O = u.child, u.child = null; O !== null; ) {
              if (l = O.alternate, l !== null && Pp(l) === null) {
                u.child = O;
                break;
              }
              l = O.sibling, O.sibling = S, S = O, O = l;
            }
            Xs(
              u,
              !0,
              S,
              null,
              L
            );
            break;
          case "together":
            Xs(u, !1, null, null, void 0);
            break;
          default:
            u.memoizedState = null;
        }
        return u.child;
      }
      function Ar(l, u, S) {
        if (l !== null && (u.dependencies = l.dependencies), Nr = -1, Ng |= u.lanes, (S & u.childLanes) === 0)
          if (l !== null) {
            if (wo(
              l,
              u,
              S,
              !1
            ), (S & u.childLanes) === 0)
              return null;
          } else return null;
        if (l !== null && u.child !== l.child)
          throw Error("Resuming work not yet implemented.");
        if (u.child !== null) {
          for (l = u.child, S = Es(l, l.pendingProps), u.child = S, S.return = u; l.sibling !== null; )
            l = l.sibling, S = S.sibling = Es(l, l.pendingProps), S.return = u;
          S.sibling = null;
        }
        return u.child;
      }
      function Ss(l, u) {
        return (l.lanes & u) !== 0 ? !0 : (l = l.dependencies, !!(l !== null && hl(l)));
      }
      function jr(l, u, S) {
        switch (u.tag) {
          case 3:
            ot(
              u,
              u.stateNode.containerInfo
            ), bi(
              u,
              gt,
              l.memoizedState.cache
            ), nt();
            break;
          case 27:
          case 5:
            Je(u);
            break;
          case 4:
            ot(
              u,
              u.stateNode.containerInfo
            );
            break;
          case 10:
            bi(
              u,
              u.type,
              u.memoizedProps.value
            );
            break;
          case 12:
            (S & u.childLanes) !== 0 && (u.flags |= 4), u.flags |= 2048;
            var x = u.stateNode;
            x.effectDuration = -0, x.passiveEffectDuration = -0;
            break;
          case 13:
            if (x = u.memoizedState, x !== null)
              return x.dehydrated !== null ? (xl(u), u.flags |= 128, null) : (S & u.child.childLanes) !== 0 ? Ca(
                l,
                u,
                S
              ) : (xl(u), l = Ar(
                l,
                u,
                S
              ), l !== null ? l.sibling : null);
            xl(u);
            break;
          case 19:
            var O = (l.flags & 128) !== 0;
            if (x = (S & u.childLanes) !== 0, x || (wo(
              l,
              u,
              S,
              !1
            ), x = (S & u.childLanes) !== 0), O) {
              if (x)
                return kh(
                  l,
                  u,
                  S
                );
              u.flags |= 128;
            }
            if (O = u.memoizedState, O !== null && (O.rendering = null, O.tail = null, O.lastEffect = null), De(
              Ns,
              Ns.current,
              u
            ), x) break;
            return null;
          case 22:
          case 23:
            return u.lanes = 0, gu(l, u, S);
          case 24:
            bi(
              u,
              gt,
              l.memoizedState.cache
            );
        }
        return Ar(l, u, S);
      }
      function Ju(l, u, S) {
        if (u._debugNeedsRemount && l !== null) {
          S = gg(
            u.type,
            u.key,
            u.pendingProps,
            u._debugOwner || null,
            u.mode,
            u.lanes
          );
          var x = u.return;
          if (x === null) throw Error("Cannot swap the root fiber.");
          if (l.alternate = null, u.alternate = null, S.index = u.index, S.sibling = u.sibling, S.return = u.return, S.ref = u.ref, S._debugInfo = u._debugInfo, u === x.child)
            x.child = S;
          else {
            var O = x.child;
            if (O === null)
              throw Error("Expected parent to have a child.");
            for (; O.sibling !== u; )
              if (O = O.sibling, O === null)
                throw Error("Expected to find the previous sibling.");
            O.sibling = S;
          }
          return u = x.deletions, u === null ? (x.deletions = [l], x.flags |= 16) : u.push(l), S.flags |= 2, S;
        }
        if (l !== null)
          if (l.memoizedProps !== u.pendingProps || u.type !== l.type)
            s = !0;
          else {
            if (!Ss(l, S) && (u.flags & 128) === 0)
              return s = !1, jr(
                l,
                u,
                S
              );
            s = (l.flags & 131072) !== 0;
          }
        else
          s = !1, (x = ei) && (jt(), x = (u.flags & 1048576) !== 0), x && (x = u.index, jt(), pn(u, Fi, x));
        switch (u.lanes = 0, u.tag) {
          case 16:
            e: if (x = u.pendingProps, l = Uu(u.elementType), u.type = l, typeof l == "function")
              Ah(l) ? (x = pu(
                l,
                x
              ), u.tag = 1, u.type = l = nc(l), u = fd(
                null,
                u,
                l,
                x,
                S
              )) : (u.tag = 0, tr(u, l), u.type = l = nc(l), u = cd(
                null,
                u,
                l,
                x,
                S
              ));
            else {
              if (l != null) {
                if (O = l.$$typeof, O === Vo) {
                  u.tag = 11, u.type = l = fv(l), u = Zr(
                    null,
                    u,
                    l,
                    x,
                    S
                  );
                  break e;
                } else if (O === xd) {
                  u.tag = 14, u = ju(
                    null,
                    u,
                    l,
                    x,
                    S
                  );
                  break e;
                }
              }
              throw u = "", l !== null && typeof l == "object" && l.$$typeof === bs && (u = " Did you wrap a component in React.lazy() more than once?"), l = q(l) || l, Error(
                "Element type is invalid. Received a promise that resolves to: " + l + ". Lazy element type must resolve to a class or function." + u
              );
            }
            return u;
          case 0:
            return cd(
              l,
              u,
              u.type,
              u.pendingProps,
              S
            );
          case 1:
            return x = u.type, O = pu(
              x,
              u.pendingProps
            ), fd(
              l,
              u,
              x,
              O,
              S
            );
          case 3:
            e: {
              if (ot(
                u,
                u.stateNode.containerInfo
              ), l === null)
                throw Error(
                  "Should have a current fiber. This is a bug in React."
                );
              var L = u.pendingProps;
              O = u.memoizedState, x = O.element, Ei(l, u), Yu(u, L, null, S);
              var J = u.memoizedState;
              if (L = J.cache, bi(u, gt, L), L !== O.cache && pd(
                u,
                [gt],
                S,
                !0
              ), Xu(), L = J.element, os && O.isDehydrated)
                if (O = {
                  element: L,
                  isDehydrated: !1,
                  cache: J.cache
                }, u.updateQueue.baseState = O, u.memoizedState = O, u.flags & 256) {
                  u = nv(
                    l,
                    u,
                    L,
                    S
                  );
                  break e;
                } else if (L !== x) {
                  x = Vn(
                    Error(
                      "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                    ),
                    u
                  ), pt(x), u = nv(
                    l,
                    u,
                    L,
                    S
                  );
                  break e;
                } else
                  for (os && (Os = Sl(
                    u.stateNode.containerInfo
                  ), Qo = u, ei = !0, Ff = null, Dh = !1, jo = null, Jo = !0), l = kc(
                    u,
                    null,
                    L,
                    S
                  ), u.child = l; l; )
                    l.flags = l.flags & -3 | 4096, l = l.sibling;
              else {
                if (nt(), L === x) {
                  u = Ar(
                    l,
                    u,
                    S
                  );
                  break e;
                }
                ri(
                  l,
                  u,
                  L,
                  S
                );
              }
              u = u.child;
            }
            return u;
          case 26:
            if (Dn)
              return er(l, u), l === null ? (l = or(
                u.type,
                null,
                u.pendingProps,
                null
              )) ? u.memoizedState = l : ei || (u.stateNode = Al(
                u.type,
                u.pendingProps,
                Ue(Cu.current),
                u
              )) : u.memoizedState = or(
                u.type,
                l.memoizedProps,
                u.pendingProps,
                l.memoizedState
              ), null;
          case 27:
            if (Fl)
              return Je(u), l === null && Fl && ei && (O = Ue(
                Cu.current
              ), x = xe(), O = u.stateNode = wl(
                u.type,
                u.pendingProps,
                O,
                x,
                !1
              ), Dh || (x = Zc(
                O,
                u.type,
                u.pendingProps,
                x
              ), x !== null && (un(u, 0).serverProps = x)), Qo = u, Jo = !0, Os = oc(O)), x = u.pendingProps.children, l !== null || ei ? ri(
                l,
                u,
                x,
                S
              ) : u.child = Tm(
                u,
                null,
                x,
                S
              ), er(l, u), u.child;
          case 5:
            return l === null && ei && (L = xe(), x = hi(
              u.type,
              u.pendingProps,
              L
            ), O = Os, (J = !O) || (J = mi(
              O,
              u.type,
              u.pendingProps,
              Jo
            ), J !== null ? (u.stateNode = J, Dh || (L = Zc(
              J,
              u.type,
              u.pendingProps,
              L
            ), L !== null && (un(u, 0).serverProps = L)), Qo = u, Os = oc(J), Jo = !1, L = !0) : L = !1, J = !L), J && (x && li(u, O), $(u))), Je(u), O = u.type, L = u.pendingProps, J = l !== null ? l.memoizedProps : null, x = L.children, Ul(O, L) ? x = null : J !== null && Ul(O, J) && (u.flags |= 32), u.memoizedState !== null && (O = tg(
              l,
              u,
              ky,
              null,
              null,
              S
            ), jl ? Yc._currentValue = O : Yc._currentValue2 = O), er(l, u), ri(
              l,
              u,
              x,
              S
            ), u.child;
          case 6:
            return l === null && ei && (l = u.pendingProps, S = xe(), l = Si(l, S), S = Os, (x = !S) || (x = ma(
              S,
              u.pendingProps,
              Jo
            ), x !== null ? (u.stateNode = x, Qo = u, Os = null, x = !0) : x = !1, x = !x), x && (l && li(u, S), $(u))), null;
          case 13:
            return Ca(l, u, S);
          case 4:
            return ot(
              u,
              u.stateNode.containerInfo
            ), x = u.pendingProps, l === null ? u.child = Tm(
              u,
              null,
              x,
              S
            ) : ri(
              l,
              u,
              x,
              S
            ), u.child;
          case 11:
            return Zr(
              l,
              u,
              u.type,
              u.pendingProps,
              S
            );
          case 7:
            return ri(
              l,
              u,
              u.pendingProps,
              S
            ), u.child;
          case 8:
            return ri(
              l,
              u,
              u.pendingProps.children,
              S
            ), u.child;
          case 12:
            return u.flags |= 4, u.flags |= 2048, x = u.stateNode, x.effectDuration = -0, x.passiveEffectDuration = -0, ri(
              l,
              u,
              u.pendingProps.children,
              S
            ), u.child;
          case 10:
            return x = u.type, O = u.pendingProps, L = O.value, "value" in O || et || (et = !0, console.error(
              "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
            )), bi(u, x, L), ri(
              l,
              u,
              O.children,
              S
            ), u.child;
          case 9:
            return O = u.type._context, x = u.pendingProps.children, typeof x != "function" && console.error(
              "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
            ), Ua(u), O = Ln(O), dt(u), x = W0(
              x,
              O,
              void 0
            ), Et(), u.flags |= 1, ri(
              l,
              u,
              x,
              S
            ), u.child;
          case 14:
            return ju(
              l,
              u,
              u.type,
              u.pendingProps,
              S
            );
          case 15:
            return vu(
              l,
              u,
              u.type,
              u.pendingProps,
              S
            );
          case 19:
            return kh(
              l,
              u,
              S
            );
          case 22:
            return gu(l, u, S);
          case 24:
            return Ua(u), x = Ln(gt), l === null ? (O = Wp(), O === null && (O = El, L = bf(), O.pooledCache = L, br(L), L !== null && (O.pooledCacheLanes |= S), O = L), u.memoizedState = {
              parent: x,
              cache: O
            }, Ya(u), bi(u, gt, O)) : ((l.lanes & S) !== 0 && (Ei(l, u), Yu(u, null, null, S), Xu()), O = l.memoizedState, L = u.memoizedState, O.parent !== x ? (O = {
              parent: x,
              cache: x
            }, u.memoizedState = O, u.lanes === 0 && (u.memoizedState = u.updateQueue.baseState = O), bi(u, gt, x)) : (x = L.cache, bi(u, gt, x), x !== O.cache && pd(
              u,
              [gt],
              S,
              !0
            ))), ri(
              l,
              u,
              u.pendingProps.children,
              S
            ), u.child;
          case 29:
            throw u.pendingProps;
        }
        throw Error(
          "Unknown unit of work tag (" + u.tag + "). This error is likely caused by a bug in React. Please file an issue."
        );
      }
      function Jr() {
        In = Yn = null, ti = !1;
      }
      function bi(l, u, S) {
        jl ? (De(Rt, u._currentValue, l), u._currentValue = S, De(zt, u._currentRenderer, l), u._currentRenderer !== void 0 && u._currentRenderer !== null && u._currentRenderer !== lt && console.error(
          "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
        ), u._currentRenderer = lt) : (De(Rt, u._currentValue2, l), u._currentValue2 = S, De(at, u._currentRenderer2, l), u._currentRenderer2 !== void 0 && u._currentRenderer2 !== null && u._currentRenderer2 !== lt && console.error(
          "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
        ), u._currentRenderer2 = lt);
      }
      function fa(l, u) {
        var S = Rt.current;
        jl ? (l._currentValue = S, S = zt.current, we(zt, u), l._currentRenderer = S) : (l._currentValue2 = S, S = at.current, we(at, u), l._currentRenderer2 = S), we(Rt, u);
      }
      function fh(l, u, S) {
        for (; l !== null; ) {
          var x = l.alternate;
          if ((l.childLanes & u) !== u ? (l.childLanes |= u, x !== null && (x.childLanes |= u)) : x !== null && (x.childLanes & u) !== u && (x.childLanes |= u), l === S) break;
          l = l.return;
        }
        l !== S && console.error(
          "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
        );
      }
      function pd(l, u, S, x) {
        var O = l.child;
        for (O !== null && (O.return = l); O !== null; ) {
          var L = O.dependencies;
          if (L !== null) {
            var J = O.child;
            L = L.firstContext;
            e: for (; L !== null; ) {
              var he = L;
              L = O;
              for (var Pe = 0; Pe < u.length; Pe++)
                if (he.context === u[Pe]) {
                  L.lanes |= S, he = L.alternate, he !== null && (he.lanes |= S), fh(
                    L.return,
                    S,
                    l
                  ), x || (J = null);
                  break e;
                }
              L = he.next;
            }
          } else if (O.tag === 18) {
            if (J = O.return, J === null)
              throw Error(
                "We just came from a parent so we must have had a parent. This is a bug in React."
              );
            J.lanes |= S, L = J.alternate, L !== null && (L.lanes |= S), fh(
              J,
              S,
              l
            ), J = null;
          } else J = O.child;
          if (J !== null) J.return = O;
          else
            for (J = O; J !== null; ) {
              if (J === l) {
                J = null;
                break;
              }
              if (O = J.sibling, O !== null) {
                O.return = J.return, J = O;
                break;
              }
              J = J.return;
            }
          O = J;
        }
      }
      function wo(l, u, S, x) {
        l = null;
        for (var O = u, L = !1; O !== null; ) {
          if (!L) {
            if ((O.flags & 524288) !== 0) L = !0;
            else if ((O.flags & 262144) !== 0) break;
          }
          if (O.tag === 10) {
            var J = O.alternate;
            if (J === null)
              throw Error("Should have a current fiber. This is a bug in React.");
            if (J = J.memoizedProps, J !== null) {
              var he = O.type;
              Ke(O.pendingProps.value, J.value) || (l !== null ? l.push(he) : l = [he]);
            }
          } else if (O === ho.current) {
            if (J = O.alternate, J === null)
              throw Error("Should have a current fiber. This is a bug in React.");
            J.memoizedState.memoizedState !== O.memoizedState.memoizedState && (l !== null ? l.push(Yc) : l = [Yc]);
          }
          O = O.return;
        }
        l !== null && pd(
          u,
          l,
          S,
          x
        ), u.flags |= 262144;
      }
      function hl(l) {
        for (l = l.firstContext; l !== null; ) {
          var u = l.context;
          if (!Ke(
            jl ? u._currentValue : u._currentValue2,
            l.memoizedValue
          ))
            return !0;
          l = l.next;
        }
        return !1;
      }
      function Ua(l) {
        Yn = l, In = null, l = l.dependencies, l !== null && (l.firstContext = null);
      }
      function Ln(l) {
        return ti && console.error(
          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
        ), Er(Yn, l);
      }
      function as(l, u) {
        return Yn === null && Ua(l), Er(l, u);
      }
      function Er(l, u) {
        var S = jl ? u._currentValue : u._currentValue2;
        if (u = { context: u, memoizedValue: S, next: null }, In === null) {
          if (l === null)
            throw Error(
              "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
            );
          In = u, l.dependencies = {
            lanes: 0,
            firstContext: u,
            _debugThenableState: null
          }, l.flags |= 524288;
        } else In = In.next = u;
        return S;
      }
      function bf() {
        return {
          controller: new Qe(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function br(l) {
        l.controller.signal.aborted && console.warn(
          "A cache instance was retained after it was already freed. This likely indicates a bug in React."
        ), l.refCount++;
      }
      function md(l) {
        l.refCount--, 0 > l.refCount && console.warn(
          "A cache instance was released after it was already freed. This likely indicates a bug in React."
        ), l.refCount === 0 && Ve(ke, function() {
          l.controller.abort();
        });
      }
      function Wp() {
        var l = Aa.current;
        return l !== null ? l : El.pooledCache;
      }
      function Kr(l, u) {
        u === null ? De(Aa, Aa.current, l) : De(Aa, u.pool, l);
      }
      function dh() {
        var l = Wp();
        return l === null ? null : {
          parent: jl ? gt._currentValue : gt._currentValue2,
          pool: l
        };
      }
      function va(l) {
        l.flags |= 4;
      }
      function vd(l, u) {
        if (l !== null && l.child === u.child) return !1;
        if ((u.flags & 16) !== 0) return !0;
        for (l = u.child; l !== null; ) {
          if ((l.flags & 13878) !== 0 || (l.subtreeFlags & 13878) !== 0)
            return !0;
          l = l.sibling;
        }
        return !1;
      }
      function Wh(l, u, S, x) {
        if (Vl)
          for (S = u.child; S !== null; ) {
            if (S.tag === 5 || S.tag === 6)
              Cd(l, S.stateNode);
            else if (!(S.tag === 4 || Fl && S.tag === 27) && S.child !== null) {
              S.child.return = S, S = S.child;
              continue;
            }
            if (S === u) break;
            for (; S.sibling === null; ) {
              if (S.return === null || S.return === u)
                return;
              S = S.return;
            }
            S.sibling.return = S.return, S = S.sibling;
          }
        else if (Ts)
          for (var O = u.child; O !== null; ) {
            if (O.tag === 5) {
              var L = O.stateNode;
              S && x && (L = bu(
                L,
                O.type,
                O.memoizedProps
              )), Cd(l, L);
            } else if (O.tag === 6)
              L = O.stateNode, S && x && (L = Oa(
                L,
                O.memoizedProps
              )), Cd(l, L);
            else if (O.tag !== 4) {
              if (O.tag === 22 && O.memoizedState !== null)
                L = O.child, L !== null && (L.return = O), Wh(l, O, !0, !0);
              else if (O.child !== null) {
                O.child.return = O, O = O.child;
                continue;
              }
            }
            if (O === u) break;
            for (; O.sibling === null; ) {
              if (O.return === null || O.return === u)
                return;
              O = O.return;
            }
            O.sibling.return = O.return, O = O.sibling;
          }
      }
      function Bc(l, u, S, x) {
        if (Ts)
          for (var O = u.child; O !== null; ) {
            if (O.tag === 5) {
              var L = O.stateNode;
              S && x && (L = bu(
                L,
                O.type,
                O.memoizedProps
              )), vm(l, L);
            } else if (O.tag === 6)
              L = O.stateNode, S && x && (L = Oa(
                L,
                O.memoizedProps
              )), vm(l, L);
            else if (O.tag !== 4) {
              if (O.tag === 22 && O.memoizedState !== null)
                L = O.child, L !== null && (L.return = O), Bc(
                  l,
                  O,
                  !(O.memoizedProps !== null && O.memoizedProps.mode === "manual"),
                  !0
                );
              else if (O.child !== null) {
                O.child.return = O, O = O.child;
                continue;
              }
            }
            if (O === u) break;
            for (; O.sibling === null; ) {
              if (O.return === null || O.return === u) return;
              O = O.return;
            }
            O.sibling.return = O.return, O = O.sibling;
          }
      }
      function Ku(l, u) {
        if (Ts && vd(l, u)) {
          l = u.stateNode;
          var S = l.containerInfo, x = Yo();
          Bc(x, u, !1, !1), l.pendingChildren = x, va(u), ui(S, x);
        }
      }
      function Uc(l, u, S, x) {
        if (Vl)
          l.memoizedProps !== x && va(u);
        else if (Ts) {
          var O = l.stateNode, L = l.memoizedProps;
          if ((l = vd(l, u)) || L !== x) {
            var J = xe();
            L = Gf(
              O,
              S,
              L,
              x,
              !l,
              null
            ), L === O ? u.stateNode = O : (Bl(
              L,
              S,
              x,
              J
            ) && va(u), u.stateNode = L, l ? Wh(L, u, !1, !1) : va(u));
          } else u.stateNode = O;
        }
      }
      function ku(l, u, S) {
        if (Au(u, S)) {
          if (l.flags |= 16777216, !Nf(u, S))
            if (Ad()) l.flags |= 8192;
            else
              throw Hd = xm, Tg;
        } else l.flags &= -16777217;
      }
      function av(l, u) {
        if (_m(u)) {
          if (l.flags |= 16777216, !co(u))
            if (Ad()) l.flags |= 8192;
            else
              throw Hd = xm, Tg;
        } else l.flags &= -16777217;
      }
      function hh(l, u) {
        u !== null && (l.flags |= 4), l.flags & 16384 && (u = l.tag !== 22 ? rn() : 536870912, l.lanes |= u, Hg |= u);
      }
      function nr(l, u) {
        if (!ei)
          switch (l.tailMode) {
            case "hidden":
              u = l.tail;
              for (var S = null; u !== null; )
                u.alternate !== null && (S = u), u = u.sibling;
              S === null ? l.tail = null : S.sibling = null;
              break;
            case "collapsed":
              S = l.tail;
              for (var x = null; S !== null; )
                S.alternate !== null && (x = S), S = S.sibling;
              x === null ? u || l.tail === null ? l.tail = null : l.tail.sibling = null : x.sibling = null;
          }
      }
      function Oi(l) {
        var u = l.alternate !== null && l.alternate.child === l.child, S = 0, x = 0;
        if (u)
          if ((l.mode & 2) !== Pi) {
            for (var O = l.selfBaseDuration, L = l.child; L !== null; )
              S |= L.lanes | L.childLanes, x |= L.subtreeFlags & 31457280, x |= L.flags & 31457280, O += L.treeBaseDuration, L = L.sibling;
            l.treeBaseDuration = O;
          } else
            for (O = l.child; O !== null; )
              S |= O.lanes | O.childLanes, x |= O.subtreeFlags & 31457280, x |= O.flags & 31457280, O.return = l, O = O.sibling;
        else if ((l.mode & 2) !== Pi) {
          O = l.actualDuration, L = l.selfBaseDuration;
          for (var J = l.child; J !== null; )
            S |= J.lanes | J.childLanes, x |= J.subtreeFlags, x |= J.flags, O += J.actualDuration, L += J.treeBaseDuration, J = J.sibling;
          l.actualDuration = O, l.treeBaseDuration = L;
        } else
          for (O = l.child; O !== null; )
            S |= O.lanes | O.childLanes, x |= O.subtreeFlags, x |= O.flags, O.return = l, O = O.sibling;
        return l.subtreeFlags |= x, l.childLanes = S, u;
      }
      function Oc(l, u, S) {
        var x = u.pendingProps;
        switch (nn(u), u.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return Oi(u), null;
          case 1:
            return Oi(u), null;
          case 3:
            return S = u.stateNode, x = null, l !== null && (x = l.memoizedState.cache), u.memoizedState.cache !== x && (u.flags |= 2048), fa(gt, u), Ht(u), S.pendingContext && (S.context = S.pendingContext, S.pendingContext = null), (l === null || l.child === null) && ($e(u) ? (Ft(), va(u)) : l === null || l.memoizedState.isDehydrated && (u.flags & 256) === 0 || (u.flags |= 1024, Ff !== null && (_u(Ff), Ff = null))), Ku(l, u), Oi(u), null;
          case 26:
            if (Dn) {
              S = u.type;
              var O = u.memoizedState;
              return l === null ? (va(u), O !== null ? (Oi(u), av(
                u,
                O
              )) : (Oi(u), ku(
                u,
                S,
                x
              ))) : O ? O !== l.memoizedState ? (va(u), Oi(u), av(
                u,
                O
              )) : (Oi(u), u.flags &= -16777217) : (Vl ? l.memoizedProps !== x && va(u) : Uc(
                l,
                u,
                S,
                x
              ), Oi(u), ku(
                u,
                S,
                x
              )), null;
            }
          case 27:
            if (Fl) {
              if (tt(u), S = Ue(Cu.current), O = u.type, l !== null && u.stateNode != null)
                Vl ? l.memoizedProps !== x && va(u) : Uc(
                  l,
                  u,
                  O,
                  x
                );
              else {
                if (!x) {
                  if (u.stateNode === null)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  return Oi(u), null;
                }
                l = xe(), $e(u) ? pe(u, l) : (l = wl(
                  O,
                  x,
                  S,
                  l,
                  !0
                ), u.stateNode = l, va(u));
              }
              return Oi(u), null;
            }
          case 5:
            if (tt(u), S = u.type, l !== null && u.stateNode != null)
              Uc(l, u, S, x);
            else {
              if (!x) {
                if (u.stateNode === null)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                return Oi(u), null;
              }
              l = xe(), $e(u) ? pe(u, l) : (O = Ue(
                Cu.current
              ), O = Vc(
                S,
                x,
                O,
                l,
                u
              ), Wh(O, u, !1, !1), u.stateNode = O, Bl(
                O,
                S,
                x,
                l
              ) && va(u));
            }
            return Oi(u), ku(
              u,
              u.type,
              u.pendingProps
            ), null;
          case 6:
            if (l && u.stateNode != null)
              S = l.memoizedProps, Vl ? S !== x && va(u) : Ts && (S !== x ? (l = Ue(
                Cu.current
              ), S = xe(), u.stateNode = Ja(
                x,
                l,
                S,
                u
              ), va(u)) : u.stateNode = l.stateNode);
            else {
              if (typeof x != "string" && u.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              if (l = Ue(Cu.current), S = xe(), $e(u)) {
                if (!os)
                  throw Error(
                    "Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
                  );
                l = u.stateNode, S = u.memoizedProps, O = !Dh, x = null;
                var L = Qo;
                if (L !== null)
                  switch (L.tag) {
                    case 3:
                      O && (O = oo(
                        l,
                        S,
                        x
                      ), O !== null && (un(u, 0).serverProps = O));
                      break;
                    case 27:
                    case 5:
                      x = L.memoizedProps, O && (O = oo(
                        l,
                        S,
                        x
                      ), O !== null && (un(
                        u,
                        0
                      ).serverProps = O));
                  }
                ba(
                  l,
                  S,
                  u,
                  x
                ) || $(u);
              } else
                u.stateNode = Ja(
                  x,
                  l,
                  S,
                  u
                );
            }
            return Oi(u), null;
          case 13:
            if (x = u.memoizedState, l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
              if (O = $e(u), x !== null && x.dehydrated !== null) {
                if (l === null) {
                  if (!O)
                    throw Error(
                      "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                    );
                  if (!os)
                    throw Error(
                      "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
                    );
                  if (O = u.memoizedState, O = O !== null ? O.dehydrated : null, !O)
                    throw Error(
                      "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                    );
                  _l(O, u), Oi(u), (u.mode & 2) !== Pi && x !== null && (O = u.child, O !== null && (u.treeBaseDuration -= O.treeBaseDuration));
                } else
                  Ft(), nt(), (u.flags & 128) === 0 && (u.memoizedState = null), u.flags |= 4, Oi(u), (u.mode & 2) !== Pi && x !== null && (O = u.child, O !== null && (u.treeBaseDuration -= O.treeBaseDuration));
                O = !1;
              } else
                Ff !== null && (_u(Ff), Ff = null), O = !0;
              if (!O)
                return u.flags & 256 ? (Ro(u), u) : (Ro(u), null);
            }
            return Ro(u), (u.flags & 128) !== 0 ? (u.lanes = S, (u.mode & 2) !== Pi && En(u), u) : (S = x !== null, l = l !== null && l.memoizedState !== null, S && (x = u.child, O = null, x.alternate !== null && x.alternate.memoizedState !== null && x.alternate.memoizedState.cachePool !== null && (O = x.alternate.memoizedState.cachePool.pool), L = null, x.memoizedState !== null && x.memoizedState.cachePool !== null && (L = x.memoizedState.cachePool.pool), L !== O && (x.flags |= 2048)), S !== l && S && (u.child.flags |= 8192), hh(u, u.updateQueue), Oi(u), (u.mode & 2) !== Pi && S && (l = u.child, l !== null && (u.treeBaseDuration -= l.treeBaseDuration)), null);
          case 4:
            return Ht(u), Ku(l, u), l === null && Th(u.stateNode.containerInfo), Oi(u), null;
          case 10:
            return fa(u.type, u), Oi(u), null;
          case 19:
            if (we(Ns, u), O = u.memoizedState, O === null)
              return Oi(u), null;
            if (x = (u.flags & 128) !== 0, L = O.rendering, L === null)
              if (x) nr(O, !1);
              else {
                if (zs !== Ov || l !== null && (l.flags & 128) !== 0)
                  for (l = u.child; l !== null; ) {
                    if (L = Pp(l), L !== null) {
                      for (u.flags |= 128, nr(O, !1), l = L.updateQueue, u.updateQueue = l, hh(u, l), u.subtreeFlags = 0, l = S, S = u.child; S !== null; )
                        vg(S, l), S = S.sibling;
                      return De(
                        Ns,
                        Ns.current & _p | Zf,
                        u
                      ), u.child;
                    }
                    l = l.sibling;
                  }
                O.tail !== null && Z() > Nm && (u.flags |= 128, x = !0, nr(O, !1), u.lanes = 4194304);
              }
            else {
              if (!x)
                if (l = Pp(L), l !== null) {
                  if (u.flags |= 128, x = !0, l = l.updateQueue, u.updateQueue = l, hh(u, l), nr(O, !0), O.tail === null && O.tailMode === "hidden" && !L.alternate && !ei)
                    return Oi(u), null;
                } else
                  2 * Z() - O.renderingStartTime > Nm && S !== 536870912 && (u.flags |= 128, x = !0, nr(O, !1), u.lanes = 4194304);
              O.isBackwards ? (L.sibling = u.child, u.child = L) : (l = O.last, l !== null ? l.sibling = L : u.child = L, O.last = L);
            }
            return O.tail !== null ? (l = O.tail, O.rendering = l, O.tail = l.sibling, O.renderingStartTime = Z(), l.sibling = null, S = Ns.current, S = x ? S & _p | Zf : S & _p, De(Ns, S, u), l) : (Oi(u), null);
          case 22:
          case 23:
            return Ro(u), sd(u), x = u.memoizedState !== null, l !== null ? l.memoizedState !== null !== x && (u.flags |= 8192) : x && (u.flags |= 8192), x ? (S & 536870912) !== 0 && (u.flags & 128) === 0 && (Oi(u), u.subtreeFlags & 6 && (u.flags |= 8192)) : Oi(u), S = u.updateQueue, S !== null && hh(u, S.retryQueue), S = null, l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (S = l.memoizedState.cachePool.pool), x = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (x = u.memoizedState.cachePool.pool), x !== S && (u.flags |= 2048), l !== null && we(Aa, u), null;
          case 24:
            return S = null, l !== null && (S = l.memoizedState.cache), u.memoizedState.cache !== S && (u.flags |= 2048), fa(gt, u), Oi(u), null;
          case 25:
            return null;
        }
        throw Error(
          "Unknown unit of work tag (" + u.tag + "). This error is likely caused by a bug in React. Please file an issue."
        );
      }
      function pl(l, u) {
        switch (nn(u), u.tag) {
          case 1:
            return l = u.flags, l & 65536 ? (u.flags = l & -65537 | 128, (u.mode & 2) !== Pi && En(u), u) : null;
          case 3:
            return fa(gt, u), Ht(u), l = u.flags, (l & 65536) !== 0 && (l & 128) === 0 ? (u.flags = l & -65537 | 128, u) : null;
          case 26:
          case 27:
          case 5:
            return tt(u), null;
          case 13:
            if (Ro(u), l = u.memoizedState, l !== null && l.dehydrated !== null) {
              if (u.alternate === null)
                throw Error(
                  "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                );
              nt();
            }
            return l = u.flags, l & 65536 ? (u.flags = l & -65537 | 128, (u.mode & 2) !== Pi && En(u), u) : null;
          case 19:
            return we(Ns, u), null;
          case 4:
            return Ht(u), null;
          case 10:
            return fa(u.type, u), null;
          case 22:
          case 23:
            return Ro(u), sd(u), l !== null && we(Aa, u), l = u.flags, l & 65536 ? (u.flags = l & -65537 | 128, (u.mode & 2) !== Pi && En(u), u) : null;
          case 24:
            return fa(gt, u), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function $h(l, u) {
        switch (nn(u), u.tag) {
          case 3:
            fa(gt, u), Ht(u);
            break;
          case 26:
          case 27:
          case 5:
            tt(u);
            break;
          case 4:
            Ht(u);
            break;
          case 13:
            Ro(u);
            break;
          case 19:
            we(Ns, u);
            break;
          case 10:
            fa(u.type, u);
            break;
          case 22:
          case 23:
            Ro(u), sd(u), l !== null && we(Aa, u);
            break;
          case 24:
            fa(gt, u);
        }
      }
      function No(l) {
        return (l.mode & 2) !== Pi;
      }
      function gd(l, u) {
        No(l) ? (bn(), ep(u, l), Qt()) : ep(u, l);
      }
      function $p(l, u, S) {
        No(l) ? (bn(), al(
          S,
          l,
          u
        ), Qt()) : al(
          S,
          l,
          u
        );
      }
      function ep(l, u) {
        try {
          var S = u.updateQueue, x = S !== null ? S.lastEffect : null;
          if (x !== null) {
            var O = x.next;
            S = O;
            do {
              if ((S.tag & l) === l && ((l & js) !== hc ? an !== null && typeof an.markComponentPassiveEffectMountStarted == "function" && an.markComponentPassiveEffectMountStarted(
                u
              ) : (l & fs) !== hc && an !== null && typeof an.markComponentLayoutEffectMountStarted == "function" && an.markComponentLayoutEffectMountStarted(
                u
              ), x = void 0, (l & vo) !== hc && (Hu = !0), x = me(
                u,
                mo,
                S
              ), (l & vo) !== hc && (Hu = !1), (l & js) !== hc ? an !== null && typeof an.markComponentPassiveEffectMountStopped == "function" && an.markComponentPassiveEffectMountStopped() : (l & fs) !== hc && an !== null && typeof an.markComponentLayoutEffectMountStopped == "function" && an.markComponentLayoutEffectMountStopped(), x !== void 0 && typeof x != "function")) {
                var L = void 0;
                L = (S.tag & fs) !== 0 ? "useLayoutEffect" : (S.tag & vo) !== 0 ? "useInsertionEffect" : "useEffect";
                var J = void 0;
                J = x === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof x.then == "function" ? `

It looks like you wrote ` + L + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + L + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching` : " You returned: " + x, me(
                  u,
                  function(he, Pe) {
                    console.error(
                      "%s must not return anything besides a function, which is used for clean-up.%s",
                      he,
                      Pe
                    );
                  },
                  L,
                  J
                );
              }
              S = S.next;
            } while (S !== O);
          }
        } catch (he) {
          $a(u, u.return, he);
        }
      }
      function al(l, u, S) {
        try {
          var x = u.updateQueue, O = x !== null ? x.lastEffect : null;
          if (O !== null) {
            var L = O.next;
            x = L;
            do {
              if ((x.tag & l) === l) {
                var J = x.inst, he = J.destroy;
                he !== void 0 && (J.destroy = void 0, (l & js) !== hc ? an !== null && typeof an.markComponentPassiveEffectUnmountStarted == "function" && an.markComponentPassiveEffectUnmountStarted(
                  u
                ) : (l & fs) !== hc && an !== null && typeof an.markComponentLayoutEffectUnmountStarted == "function" && an.markComponentLayoutEffectUnmountStarted(
                  u
                ), (l & vo) !== hc && (Hu = !0), me(
                  u,
                  Sp,
                  u,
                  S,
                  he
                ), (l & vo) !== hc && (Hu = !1), (l & js) !== hc ? an !== null && typeof an.markComponentPassiveEffectUnmountStopped == "function" && an.markComponentPassiveEffectUnmountStopped() : (l & fs) !== hc && an !== null && typeof an.markComponentLayoutEffectUnmountStopped == "function" && an.markComponentLayoutEffectUnmountStopped());
              }
              x = x.next;
            } while (x !== L);
          }
        } catch (Pe) {
          $a(u, u.return, Pe);
        }
      }
      function ph(l, u) {
        No(l) ? (bn(), ep(u, l), Qt()) : ep(u, l);
      }
      function yu(l, u, S) {
        No(l) ? (bn(), al(
          S,
          l,
          u
        ), Qt()) : al(
          S,
          l,
          u
        );
      }
      function Mf(l) {
        var u = l.updateQueue;
        if (u !== null) {
          var S = l.stateNode;
          l.type.defaultProps || "ref" in l.memoizedProps || H || (S.props !== l.memoizedProps && console.error(
            "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            Y(l) || "instance"
          ), S.state !== l.memoizedState && console.error(
            "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            Y(l) || "instance"
          ));
          try {
            me(
              l,
              Zh,
              u,
              S
            );
          } catch (x) {
            $a(l, l.return, x);
          }
        }
      }
      function tp(l, u, S) {
        return l.getSnapshotBeforeUpdate(u, S);
      }
      function na(l, u) {
        var S = u.memoizedProps, x = u.memoizedState;
        u = l.stateNode, l.type.defaultProps || "ref" in l.memoizedProps || H || (u.props !== l.memoizedProps && console.error(
          "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
          Y(l) || "instance"
        ), u.state !== l.memoizedState && console.error(
          "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
          Y(l) || "instance"
        ));
        try {
          var O = pu(
            l.type,
            S,
            l.elementType === l.type
          ), L = me(
            l,
            tp,
            u,
            O,
            x
          );
          S = Pn, L !== void 0 || S.has(l.type) || (S.add(l.type), me(l, function() {
            console.error(
              "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
              Y(l)
            );
          })), u.__reactInternalSnapshotBeforeUpdate = L;
        } catch (J) {
          $a(l, l.return, J);
        }
      }
      function is(l, u, S) {
        S.props = pu(
          l.type,
          l.memoizedProps
        ), S.state = l.memoizedState, No(l) ? (bn(), me(
          l,
          sy,
          l,
          u,
          S
        ), Qt()) : me(
          l,
          sy,
          l,
          u,
          S
        );
      }
      function Mr(l) {
        var u = l.ref;
        if (u !== null) {
          var S = l.stateNode;
          switch (l.tag) {
            case 26:
            case 27:
            case 5:
              S = lo(S);
          }
          if (typeof u == "function")
            if (No(l))
              try {
                bn(), l.refCleanup = u(S);
              } finally {
                Qt();
              }
            else l.refCleanup = u(S);
          else
            typeof u == "string" ? console.error("String refs are no longer supported.") : u.hasOwnProperty("current") || console.error(
              "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
              Y(l)
            ), u.current = S;
        }
      }
      function Wu(l, u) {
        try {
          me(l, Mr, l);
        } catch (S) {
          $a(l, u, S);
        }
      }
      function zo(l, u) {
        var S = l.ref, x = l.refCleanup;
        if (S !== null)
          if (typeof x == "function")
            try {
              if (No(l))
                try {
                  bn(), me(l, x);
                } finally {
                  Qt(l);
                }
              else me(l, x);
            } catch (O) {
              $a(l, u, O);
            } finally {
              l.refCleanup = null, l = l.alternate, l != null && (l.refCleanup = null);
            }
          else if (typeof S == "function")
            try {
              if (No(l))
                try {
                  bn(), me(l, S, null);
                } finally {
                  Qt(l);
                }
              else me(l, S, null);
            } catch (O) {
              $a(l, u, O);
            }
          else S.current = null;
      }
      function mh(l, u, S, x) {
        var O = l.memoizedProps, L = O.id, J = O.onCommit;
        O = O.onRender, u = u === null ? "mount" : "update", Bh && (u = "nested-update"), typeof O == "function" && O(
          L,
          u,
          l.actualDuration,
          l.treeBaseDuration,
          l.actualStartTime,
          S
        ), typeof J == "function" && J(
          l.memoizedProps.id,
          u,
          x,
          S
        );
      }
      function kr(l, u, S, x) {
        var O = l.memoizedProps;
        l = O.id, O = O.onPostCommit, u = u === null ? "mount" : "update", Bh && (u = "nested-update"), typeof O == "function" && O(
          l,
          u,
          x,
          S
        );
      }
      function wc(l) {
        var u = l.type, S = l.memoizedProps, x = l.stateNode;
        try {
          me(
            l,
            Eu,
            x,
            u,
            S,
            l
          );
        } catch (O) {
          $a(l, l.return, O);
        }
      }
      function yd(l, u, S) {
        try {
          me(
            l,
            ga,
            l.stateNode,
            l.type,
            S,
            u,
            l
          );
        } catch (x) {
          $a(l, l.return, x);
        }
      }
      function np(l) {
        return l.tag === 5 || l.tag === 3 || (Dn ? l.tag === 26 : !1) || (Fl ? l.tag === 27 : !1) || l.tag === 4;
      }
      function xf(l) {
        e: for (; ; ) {
          for (; l.sibling === null; ) {
            if (l.return === null || np(l.return)) return null;
            l = l.return;
          }
          for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && (!Fl || l.tag !== 27) && l.tag !== 18; ) {
            if (l.flags & 2 || l.child === null || l.tag === 4) continue e;
            l.child.return = l, l = l.child;
          }
          if (!(l.flags & 2)) return l.stateNode;
        }
      }
      function ap(l, u, S) {
        var x = l.tag;
        if (x === 5 || x === 6)
          l = l.stateNode, u ? mm(S, l, u) : kn(S, l);
        else if (!(x === 4 || Fl && x === 27) && (l = l.child, l !== null))
          for (ap(l, u, S), l = l.sibling; l !== null; )
            ap(l, u, S), l = l.sibling;
      }
      function Wr(l, u, S) {
        var x = l.tag;
        if (x === 5 || x === 6)
          l = l.stateNode, u ? Lf(S, l, u) : Ra(S, l);
        else if (!(x === 4 || Fl && x === 27) && (l = l.child, l !== null))
          for (Wr(l, u, S), l = l.sibling; l !== null; )
            Wr(l, u, S), l = l.sibling;
      }
      function em(l) {
        if (Vl && (!Fl || l.tag !== 27)) {
          e: {
            for (var u = l.return; u !== null; ) {
              if (np(u)) {
                var S = u;
                break e;
              }
              u = u.return;
            }
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          }
          switch (S.tag) {
            case 27:
              if (Fl) {
                u = S.stateNode, S = xf(l), Wr(l, S, u);
                break;
              }
            case 5:
              u = S.stateNode, S.flags & 32 && (Or(u), S.flags &= -33), S = xf(l), Wr(l, S, u);
              break;
            case 3:
            case 4:
              u = S.stateNode.containerInfo, S = xf(l), ap(
                l,
                S,
                u
              );
              break;
            default:
              throw Error(
                "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
              );
          }
        }
      }
      function ip(l, u, S) {
        l = l.containerInfo;
        try {
          me(
            u,
            gm,
            l,
            S
          );
        } catch (x) {
          $a(u, u.return, x);
        }
      }
      function lp(l, u) {
        for (Ms(l.containerInfo), Gr = u; Gr !== null; )
          if (l = Gr, u = l.child, (l.subtreeFlags & 1028) !== 0 && u !== null)
            u.return = l, Gr = u;
          else
            for (; Gr !== null; ) {
              u = l = Gr;
              var S = u.alternate, x = u.flags;
              switch (u.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  (x & 1024) !== 0 && S !== null && na(u, S);
                  break;
                case 3:
                  (x & 1024) !== 0 && Vl && Ci(u.stateNode.containerInfo);
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if ((x & 1024) !== 0)
                    throw Error(
                      "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                    );
              }
              if (u = l.sibling, u !== null) {
                u.return = l.return, Gr = u;
                break;
              }
              Gr = l.return;
            }
        return l = _E, _E = !1, l;
      }
      function tm(l, u, S) {
        var x = S.flags;
        switch (S.tag) {
          case 0:
          case 11:
          case 15:
            _s(l, S), x & 4 && gd(S, fs | $c);
            break;
          case 1:
            if (_s(l, S), x & 4)
              if (l = S.stateNode, u === null)
                S.type.defaultProps || "ref" in S.memoizedProps || H || (l.props !== S.memoizedProps && console.error(
                  "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                  Y(S) || "instance"
                ), l.state !== S.memoizedState && console.error(
                  "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                  Y(S) || "instance"
                )), No(S) ? (bn(), me(
                  S,
                  vn,
                  S,
                  l
                ), Qt()) : me(
                  S,
                  vn,
                  S,
                  l
                );
              else {
                var O = pu(
                  S.type,
                  u.memoizedProps
                );
                u = u.memoizedState, S.type.defaultProps || "ref" in S.memoizedProps || H || (l.props !== S.memoizedProps && console.error(
                  "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                  Y(S) || "instance"
                ), l.state !== S.memoizedState && console.error(
                  "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                  Y(S) || "instance"
                )), No(S) ? (bn(), me(
                  S,
                  kl,
                  S,
                  l,
                  O,
                  u,
                  l.__reactInternalSnapshotBeforeUpdate
                ), Qt()) : me(
                  S,
                  kl,
                  S,
                  l,
                  O,
                  u,
                  l.__reactInternalSnapshotBeforeUpdate
                );
              }
            x & 64 && Mf(S), x & 512 && Wu(S, S.return);
            break;
          case 3:
            if (u = je(), _s(l, S), x & 64 && (x = S.updateQueue, x !== null)) {
              if (O = null, S.child !== null)
                switch (S.child.tag) {
                  case 27:
                  case 5:
                    O = lo(S.child.stateNode);
                    break;
                  case 1:
                    O = S.child.stateNode;
                }
              try {
                me(
                  S,
                  Zh,
                  x,
                  O
                );
              } catch (he) {
                $a(S, S.return, he);
              }
            }
            l.effectDuration += _t(u);
            break;
          case 26:
            if (Dn) {
              _s(l, S), x & 512 && Wu(S, S.return);
              break;
            }
          case 27:
          case 5:
            _s(l, S), u === null && x & 4 && wc(S), x & 512 && Wu(S, S.return);
            break;
          case 12:
            if (x & 4) {
              x = je(), _s(l, S), l = S.stateNode, l.effectDuration += Ut(x);
              try {
                me(
                  S,
                  mh,
                  S,
                  u,
                  Da,
                  l.effectDuration
                );
              } catch (he) {
                $a(S, S.return, he);
              }
            } else _s(l, S);
            break;
          case 13:
            _s(l, S), x & 4 && $u(l, S);
            break;
          case 22:
            if (O = S.memoizedState !== null || Xn, !O) {
              u = u !== null && u.memoizedState !== null || Za;
              var L = Xn, J = Za;
              Xn = O, (Za = u) && !J ? Su(
                l,
                S,
                (S.subtreeFlags & 8772) !== 0
              ) : _s(l, S), Xn = L, Za = J;
            }
            x & 512 && (S.memoizedProps.mode === "manual" ? Wu(S, S.return) : zo(S, S.return));
            break;
          default:
            _s(l, S);
        }
      }
      function $r(l) {
        var u = l.alternate;
        u !== null && (l.alternate = null, $r(u)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (u = l.stateNode, u !== null && dp(u)), l.stateNode = null, l._debugOwner = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
      }
      function Ho(l, u, S) {
        for (S = S.child; S !== null; )
          iv(
            l,
            u,
            S
          ), S = S.sibling;
      }
      function iv(l, u, S) {
        if (Un && typeof Un.onCommitFiberUnmount == "function")
          try {
            Un.onCommitFiberUnmount(cn, S);
          } catch (L) {
            ur || (ur = !0, console.error(
              "React instrumentation encountered an error: %s",
              L
            ));
          }
        switch (S.tag) {
          case 26:
            if (Dn) {
              Za || zo(S, u), Ho(
                l,
                u,
                S
              ), S.memoizedState ? qo(S.memoizedState) : S.stateNode && Vi(S.stateNode);
              break;
            }
          case 27:
            if (Fl) {
              Za || zo(S, u);
              var x = fr, O = Id;
              fr = S.stateNode, Ho(
                l,
                u,
                S
              ), Vf(S.stateNode), fr = x, Id = O;
              break;
            }
          case 5:
            Za || zo(S, u);
          case 6:
            if (Vl) {
              if (x = fr, O = Id, fr = null, Ho(
                l,
                u,
                S
              ), fr = x, Id = O, fr !== null)
                if (Id)
                  try {
                    me(
                      S,
                      us,
                      fr,
                      S.stateNode
                    );
                  } catch (L) {
                    $a(
                      S,
                      u,
                      L
                    );
                  }
                else
                  try {
                    me(
                      S,
                      Rh,
                      fr,
                      S.stateNode
                    );
                  } catch (L) {
                    $a(
                      S,
                      u,
                      L
                    );
                  }
            } else
              Ho(
                l,
                u,
                S
              );
            break;
          case 18:
            Vl && fr !== null && (Id ? il(
              fr,
              S.stateNode
            ) : uc(fr, S.stateNode));
            break;
          case 4:
            Vl ? (x = fr, O = Id, fr = S.stateNode.containerInfo, Id = !0, Ho(
              l,
              u,
              S
            ), fr = x, Id = O) : (Ts && ip(
              S.stateNode,
              S,
              Yo()
            ), Ho(
              l,
              u,
              S
            ));
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            Za || al(
              vo,
              S,
              u
            ), Za || $p(
              S,
              u,
              fs
            ), Ho(
              l,
              u,
              S
            );
            break;
          case 1:
            Za || (zo(S, u), x = S.stateNode, typeof x.componentWillUnmount == "function" && is(
              S,
              u,
              x
            )), Ho(
              l,
              u,
              S
            );
            break;
          case 21:
            Ho(
              l,
              u,
              S
            );
            break;
          case 22:
            Za || zo(S, u), Za = (x = Za) || S.memoizedState !== null, Ho(
              l,
              u,
              S
            ), Za = x;
            break;
          default:
            Ho(
              l,
              u,
              S
            );
        }
      }
      function $u(l, u) {
        if (os && u.memoizedState === null && (l = u.alternate, l !== null && (l = l.memoizedState, l !== null && (l = l.dehydrated, l !== null))))
          try {
            me(
              u,
              Sm,
              l
            );
          } catch (S) {
            $a(u, u.return, S);
          }
      }
      function ig(l) {
        switch (l.tag) {
          case 13:
          case 19:
            var u = l.stateNode;
            return u === null && (u = l.stateNode = new bp()), u;
          case 22:
            return l = l.stateNode, u = l._retryCache, u === null && (u = l._retryCache = new bp()), u;
          default:
            throw Error(
              "Unexpected Suspense handler tag (" + l.tag + "). This is a bug in React."
            );
        }
      }
      function $n(l, u) {
        var S = ig(l);
        u.forEach(function(x) {
          var O = Wg.bind(null, l, x);
          if (!S.has(x)) {
            if (S.add(x), Us)
              if (c0 !== null && f0 !== null)
                Lc(f0, c0);
              else
                throw Error(
                  "Expected finished root and lanes to be set. This is a bug in React."
                );
            x.then(O, O);
          }
        });
      }
      function xr(l, u, S) {
        c0 = S, f0 = l, Tf(u, l), f0 = c0 = null;
      }
      function ml(l, u) {
        var S = u.deletions;
        if (S !== null)
          for (var x = 0; x < S.length; x++) {
            var O = l, L = u, J = S[x];
            if (Vl) {
              var he = L;
              e: for (; he !== null; ) {
                switch (he.tag) {
                  case 27:
                  case 5:
                    fr = he.stateNode, Id = !1;
                    break e;
                  case 3:
                    fr = he.stateNode.containerInfo, Id = !0;
                    break e;
                  case 4:
                    fr = he.stateNode.containerInfo, Id = !0;
                    break e;
                }
                he = he.return;
              }
              if (fr === null)
                throw Error(
                  "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                );
              iv(O, L, J), fr = null, Id = !1;
            } else iv(O, L, J);
            O = J, L = O.alternate, L !== null && (L.return = null), O.return = null;
          }
        if (u.subtreeFlags & 13878)
          for (u = u.child; u !== null; )
            Tf(u, l), u = u.sibling;
      }
      function Tf(l, u) {
        var S = l.alternate, x = l.flags;
        switch (l.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            ml(u, l), Ys(l), x & 4 && (al(
              vo | $c,
              l,
              l.return
            ), ep(vo | $c, l), $p(
              l,
              l.return,
              fs | $c
            ));
            break;
          case 1:
            ml(u, l), Ys(l), x & 512 && (Za || S === null || zo(S, S.return)), x & 64 && Xn && (l = l.updateQueue, l !== null && (x = l.callbacks, x !== null && (S = l.shared.hiddenCallbacks, l.shared.hiddenCallbacks = S === null ? x : S.concat(x))));
            break;
          case 26:
            if (Dn) {
              var O = Mp;
              ml(u, l), Ys(l), x & 512 && (Za || S === null || zo(S, S.return)), x & 4 && (x = S !== null ? S.memoizedState : null, u = l.memoizedState, S === null ? u === null ? l.stateNode === null ? l.stateNode = Rs(
                O,
                l.type,
                l.memoizedProps,
                l
              ) : Ds(
                O,
                l.type,
                l.stateNode
              ) : l.stateNode = uo(
                O,
                u,
                l.memoizedProps
              ) : x !== u ? (x === null ? S.stateNode !== null && Vi(S.stateNode) : qo(x), u === null ? Ds(
                O,
                l.type,
                l.stateNode
              ) : uo(
                O,
                u,
                l.memoizedProps
              )) : u === null && l.stateNode !== null && yd(
                l,
                l.memoizedProps,
                S.memoizedProps
              ));
              break;
            }
          case 27:
            if (Fl && x & 4 && l.alternate === null) {
              O = l.stateNode;
              var L = l.memoizedProps;
              try {
                yv(O), me(
                  l,
                  fo,
                  l.type,
                  L,
                  O,
                  l
                );
              } catch (Kt) {
                $a(l, l.return, Kt);
              }
            }
          case 5:
            if (ml(u, l), Ys(l), x & 512 && (Za || S === null || zo(S, S.return)), Vl) {
              if (l.flags & 32) {
                u = l.stateNode;
                try {
                  me(l, Or, u);
                } catch (Kt) {
                  $a(
                    l,
                    l.return,
                    Kt
                  );
                }
              }
              x & 4 && l.stateNode != null && (u = l.memoizedProps, yd(
                l,
                u,
                S !== null ? S.memoizedProps : u
              )), x & 1024 && (ci = !0, l.type !== "form" && console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
            }
            break;
          case 6:
            if (ml(u, l), Ys(l), x & 4 && Vl) {
              if (l.stateNode === null)
                throw Error(
                  "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                );
              x = l.memoizedProps, S = S !== null ? S.memoizedProps : x, u = l.stateNode;
              try {
                me(
                  l,
                  Ka,
                  u,
                  S,
                  x
                );
              } catch (Kt) {
                $a(l, l.return, Kt);
              }
            }
            break;
          case 3:
            if (O = je(), Dn ? (If(), L = Mp, Mp = Ri(u.containerInfo), ml(u, l), Mp = L) : ml(u, l), Ys(l), x & 4) {
              if (Vl && os && S !== null && S.memoizedState.isDehydrated)
                try {
                  me(
                    l,
                    ym,
                    u.containerInfo
                  );
                } catch (Kt) {
                  $a(
                    l,
                    l.return,
                    Kt
                  );
                }
              if (Ts) {
                x = u.containerInfo, S = u.pendingChildren;
                try {
                  me(
                    l,
                    gm,
                    x,
                    S
                  );
                } catch (Kt) {
                  $a(
                    l,
                    l.return,
                    Kt
                  );
                }
              }
            }
            ci && (ci = !1, lg(l)), u.effectDuration += _t(O);
            break;
          case 4:
            Dn ? (S = Mp, Mp = Ri(
              l.stateNode.containerInfo
            ), ml(u, l), Ys(l), Mp = S) : (ml(u, l), Ys(l)), x & 4 && Ts && ip(
              l.stateNode,
              l,
              l.stateNode.pendingChildren
            );
            break;
          case 12:
            x = je(), ml(u, l), Ys(l), l.stateNode.effectDuration += Ut(x);
            break;
          case 13:
            ml(u, l), Ys(l), l.child.flags & 8192 && l.memoizedState !== null != (S !== null && S.memoizedState !== null) && (Nv = Z()), x & 4 && (x = l.updateQueue, x !== null && (l.updateQueue = null, $n(l, x)));
            break;
          case 22:
            x & 512 && (Za || S === null || zo(S, S.return)), O = l.memoizedState !== null;
            var J = S !== null && S.memoizedState !== null, he = Xn, Pe = Za;
            if (Xn = he || O, Za = Pe || J, ml(u, l), Za = Pe, Xn = he, Ys(l), u = l.stateNode, u._current = l, u._visibility &= -3, u._visibility |= u._pendingVisibility & 2, x & 8192 && (u._visibility = O ? u._visibility & -2 : u._visibility | 1, O && (u = Xn || Za, S === null || J || u || Cf(l)), Vl && (l.memoizedProps === null || l.memoizedProps.mode !== "manual"))) {
              e: if (S = null, Vl)
                for (u = l; ; ) {
                  if (u.tag === 5 || Dn && u.tag === 26 || Fl && u.tag === 27) {
                    if (S === null) {
                      J = S = u;
                      try {
                        L = J.stateNode, O ? me(J, pp, L) : me(
                          J,
                          Dd,
                          J.stateNode,
                          J.memoizedProps
                        );
                      } catch (Kt) {
                        $a(
                          J,
                          J.return,
                          Kt
                        );
                      }
                    }
                  } else if (u.tag === 6) {
                    if (S === null) {
                      J = u;
                      try {
                        var ht = J.stateNode;
                        O ? me(
                          J,
                          Ji,
                          ht
                        ) : me(
                          J,
                          sr,
                          ht,
                          J.memoizedProps
                        );
                      } catch (Kt) {
                        $a(
                          J,
                          J.return,
                          Kt
                        );
                      }
                    }
                  } else if ((u.tag !== 22 && u.tag !== 23 || u.memoizedState === null || u === l) && u.child !== null) {
                    u.child.return = u, u = u.child;
                    continue;
                  }
                  if (u === l) break e;
                  for (; u.sibling === null; ) {
                    if (u.return === null || u.return === l)
                      break e;
                    S === u && (S = null), u = u.return;
                  }
                  S === u && (S = null), u.sibling.return = u.return, u = u.sibling;
                }
            }
            x & 4 && (x = l.updateQueue, x !== null && (S = x.retryQueue, S !== null && (x.retryQueue = null, $n(l, S))));
            break;
          case 19:
            ml(u, l), Ys(l), x & 4 && (x = l.updateQueue, x !== null && (l.updateQueue = null, $n(l, x)));
            break;
          case 21:
            break;
          default:
            ml(u, l), Ys(l);
        }
      }
      function Ys(l) {
        var u = l.flags;
        if (u & 2) {
          try {
            me(l, em, l);
          } catch (S) {
            $a(l, l.return, S);
          }
          l.flags &= -3;
        }
        u & 4096 && (l.flags &= -4097);
      }
      function lg(l) {
        if (l.subtreeFlags & 1024)
          for (l = l.child; l !== null; ) {
            var u = l;
            lg(u), u.tag === 5 && u.flags & 1024 && gv(u.stateNode), l = l.sibling;
          }
      }
      function nm(l, u, S) {
        c0 = S, f0 = u, tm(u, l.alternate, l), f0 = c0 = null;
      }
      function _s(l, u) {
        if (u.subtreeFlags & 8772)
          for (u = u.child; u !== null; )
            tm(l, u.alternate, u), u = u.sibling;
      }
      function Sd(l) {
        switch (l.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            $p(
              l,
              l.return,
              fs
            ), Cf(l);
            break;
          case 1:
            zo(l, l.return);
            var u = l.stateNode;
            typeof u.componentWillUnmount == "function" && is(
              l,
              l.return,
              u
            ), Cf(l);
            break;
          case 26:
          case 27:
          case 5:
            zo(l, l.return), Cf(l);
            break;
          case 22:
            zo(l, l.return), l.memoizedState === null && Cf(l);
            break;
          default:
            Cf(l);
        }
      }
      function Cf(l) {
        for (l = l.child; l !== null; )
          Sd(l), l = l.sibling;
      }
      function vh(l, u, S, x) {
        var O = S.flags;
        switch (S.tag) {
          case 0:
          case 11:
          case 15:
            Su(
              l,
              S,
              x
            ), gd(S, fs);
            break;
          case 1:
            if (Su(
              l,
              S,
              x
            ), u = S.stateNode, typeof u.componentDidMount == "function" && me(
              S,
              vn,
              S,
              u
            ), u = S.updateQueue, u !== null) {
              l = S.stateNode;
              try {
                me(
                  S,
                  Kg,
                  u,
                  l
                );
              } catch (L) {
                $a(S, S.return, L);
              }
            }
            x && O & 64 && Mf(S), Wu(S, S.return);
            break;
          case 26:
          case 27:
          case 5:
            Su(
              l,
              S,
              x
            ), x && u === null && O & 4 && wc(S), Wu(S, S.return);
            break;
          case 12:
            if (x && O & 4) {
              O = je(), Su(
                l,
                S,
                x
              ), x = S.stateNode, x.effectDuration += Ut(O);
              try {
                me(
                  S,
                  mh,
                  S,
                  u,
                  Da,
                  x.effectDuration
                );
              } catch (L) {
                $a(S, S.return, L);
              }
            } else
              Su(
                l,
                S,
                x
              );
            break;
          case 13:
            Su(
              l,
              S,
              x
            ), x && O & 4 && $u(l, S);
            break;
          case 22:
            S.memoizedState === null && Su(
              l,
              S,
              x
            ), Wu(S, S.return);
            break;
          default:
            Su(
              l,
              S,
              x
            );
        }
      }
      function Su(l, u, S) {
        for (S = S && (u.subtreeFlags & 8772) !== 0, u = u.child; u !== null; )
          vh(
            l,
            u.alternate,
            u,
            S
          ), u = u.sibling;
      }
      function ls(l, u) {
        var S = null;
        l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (S = l.memoizedState.cachePool.pool), l = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (l = u.memoizedState.cachePool.pool), l !== S && (l != null && br(l), S != null && md(S));
      }
      function gh(l, u) {
        l = null, u.alternate !== null && (l = u.alternate.memoizedState.cache), u = u.memoizedState.cache, u !== l && (br(u), l != null && md(l));
      }
      function eo(l, u, S, x) {
        if (u.subtreeFlags & 10256)
          for (u = u.child; u !== null; )
            Lo(
              l,
              u,
              S,
              x
            ), u = u.sibling;
      }
      function Lo(l, u, S, x) {
        var O = u.flags;
        switch (u.tag) {
          case 0:
          case 11:
          case 15:
            eo(
              l,
              u,
              S,
              x
            ), O & 2048 && ph(u, js | $c);
            break;
          case 3:
            var L = je();
            eo(
              l,
              u,
              S,
              x
            ), O & 2048 && (S = null, u.alternate !== null && (S = u.alternate.memoizedState.cache), u = u.memoizedState.cache, u !== S && (br(u), S != null && md(S))), l.passiveEffectDuration += _t(L);
            break;
          case 12:
            if (O & 2048) {
              L = je(), eo(
                l,
                u,
                S,
                x
              ), l = u.stateNode, l.passiveEffectDuration += Ut(L);
              try {
                me(
                  u,
                  kr,
                  u,
                  u.alternate,
                  Da,
                  l.passiveEffectDuration
                );
              } catch (J) {
                $a(u, u.return, J);
              }
            } else
              eo(
                l,
                u,
                S,
                x
              );
            break;
          case 23:
            break;
          case 22:
            L = u.stateNode, u.memoizedState !== null ? L._visibility & 4 ? eo(
              l,
              u,
              S,
              x
            ) : Qi(
              l,
              u
            ) : L._visibility & 4 ? eo(
              l,
              u,
              S,
              x
            ) : (L._visibility |= 4, ea(
              l,
              u,
              S,
              x,
              (u.subtreeFlags & 10256) !== 0
            )), O & 2048 && ls(
              u.alternate,
              u
            );
            break;
          case 24:
            eo(
              l,
              u,
              S,
              x
            ), O & 2048 && gh(u.alternate, u);
            break;
          default:
            eo(
              l,
              u,
              S,
              x
            );
        }
      }
      function ea(l, u, S, x, O) {
        for (O = O && (u.subtreeFlags & 10256) !== 0, u = u.child; u !== null; )
          di(
            l,
            u,
            S,
            x,
            O
          ), u = u.sibling;
      }
      function di(l, u, S, x, O) {
        var L = u.flags;
        switch (u.tag) {
          case 0:
          case 11:
          case 15:
            ea(
              l,
              u,
              S,
              x,
              O
            ), ph(u, js);
            break;
          case 23:
            break;
          case 22:
            var J = u.stateNode;
            u.memoizedState !== null ? J._visibility & 4 ? ea(
              l,
              u,
              S,
              x,
              O
            ) : Qi(
              l,
              u
            ) : (J._visibility |= 4, ea(
              l,
              u,
              S,
              x,
              O
            )), O && L & 2048 && ls(
              u.alternate,
              u
            );
            break;
          case 24:
            ea(
              l,
              u,
              S,
              x,
              O
            ), O && L & 2048 && gh(u.alternate, u);
            break;
          default:
            ea(
              l,
              u,
              S,
              x,
              O
            );
        }
      }
      function Qi(l, u) {
        if (u.subtreeFlags & 10256)
          for (u = u.child; u !== null; ) {
            var S = l, x = u, O = x.flags;
            switch (x.tag) {
              case 22:
                Qi(
                  S,
                  x
                ), O & 2048 && ls(
                  x.alternate,
                  x
                );
                break;
              case 24:
                Qi(
                  S,
                  x
                ), O & 2048 && gh(
                  x.alternate,
                  x
                );
                break;
              default:
                Qi(
                  S,
                  x
                );
            }
            u = u.sibling;
          }
      }
      function Nc(l) {
        if (l.subtreeFlags & d0)
          for (l = l.child; l !== null; )
            Tr(l), l = l.sibling;
      }
      function Tr(l) {
        switch (l.tag) {
          case 26:
            Nc(l), l.flags & d0 && (l.memoizedState !== null ? Qc(
              Mp,
              l.memoizedState,
              l.memoizedProps
            ) : Rd(l.type, l.memoizedProps));
            break;
          case 5:
            Nc(l), l.flags & d0 && Rd(l.type, l.memoizedProps);
            break;
          case 3:
          case 4:
            if (Dn) {
              var u = Mp;
              Mp = Ri(
                l.stateNode.containerInfo
              ), Nc(l), Mp = u;
            } else Nc(l);
            break;
          case 22:
            l.memoizedState === null && (u = l.alternate, u !== null && u.memoizedState !== null ? (u = d0, d0 = 16777216, Nc(l), d0 = u) : Nc(l));
            break;
          default:
            Nc(l);
        }
      }
      function ar(l) {
        var u = l.alternate;
        if (u !== null && (l = u.child, l !== null)) {
          u.child = null;
          do
            u = l.sibling, l.sibling = null, l = u;
          while (l !== null);
        }
      }
      function Mi(l) {
        var u = l.deletions;
        if ((l.flags & 16) !== 0) {
          if (u !== null)
            for (var S = 0; S < u.length; S++) {
              var x = u[S];
              Gr = x, vl(
                x,
                l
              );
            }
          ar(l);
        }
        if (l.subtreeFlags & 10256)
          for (l = l.child; l !== null; )
            Zl(l), l = l.sibling;
      }
      function Zl(l) {
        switch (l.tag) {
          case 0:
          case 11:
          case 15:
            Mi(l), l.flags & 2048 && yu(
              l,
              l.return,
              js | $c
            );
            break;
          case 3:
            var u = je();
            Mi(l), l.stateNode.passiveEffectDuration += _t(u);
            break;
          case 12:
            u = je(), Mi(l), l.stateNode.passiveEffectDuration += Ut(u);
            break;
          case 22:
            u = l.stateNode, l.memoizedState !== null && u._visibility & 4 && (l.return === null || l.return.tag !== 13) ? (u._visibility &= -5, Tl(l)) : Mi(l);
            break;
          default:
            Mi(l);
        }
      }
      function Tl(l) {
        var u = l.deletions;
        if ((l.flags & 16) !== 0) {
          if (u !== null)
            for (var S = 0; S < u.length; S++) {
              var x = u[S];
              Gr = x, vl(
                x,
                l
              );
            }
          ar(l);
        }
        for (l = l.child; l !== null; )
          lv(l), l = l.sibling;
      }
      function lv(l) {
        switch (l.tag) {
          case 0:
          case 11:
          case 15:
            yu(
              l,
              l.return,
              js
            ), Tl(l);
            break;
          case 22:
            var u = l.stateNode;
            u._visibility & 4 && (u._visibility &= -5, Tl(l));
            break;
          default:
            Tl(l);
        }
      }
      function vl(l, u) {
        for (; Gr !== null; ) {
          var S = Gr, x = S;
          switch (x.tag) {
            case 0:
            case 11:
            case 15:
              yu(
                x,
                u,
                js
              );
              break;
            case 23:
            case 22:
              x.memoizedState !== null && x.memoizedState.cachePool !== null && (x = x.memoizedState.cachePool.pool, x != null && br(x));
              break;
            case 24:
              md(x.memoizedState.cache);
          }
          if (x = S.child, x !== null) x.return = S, Gr = x;
          else
            e: for (S = l; Gr !== null; ) {
              x = Gr;
              var O = x.sibling, L = x.return;
              if ($r(x), x === S) {
                Gr = null;
                break e;
              }
              if (O !== null) {
                O.return = L, Gr = O;
                break e;
              }
              Gr = L;
            }
        }
      }
      function As(l) {
        var u = Fc(l);
        if (u != null) {
          if (typeof u.memoizedProps["data-testname"] != "string")
            throw Error(
              "Invalid host root specified. Should be either a React container or a node with a testname attribute."
            );
          return u;
        }
        if (l = qc(l), l === null)
          throw Error(
            "Could not find React container within specified host subtree."
          );
        return l.stateNode.current;
      }
      function ec(l, u) {
        var S = l.tag;
        switch (u.$$typeof) {
          case f_:
            if (l.type === u.value) return !0;
            break;
          case d_:
            e: {
              for (u = u.value, l = [l, 0], S = 0; S < l.length; ) {
                var x = l[S++], O = x.tag, L = l[S++], J = u[L];
                if (O !== 5 && O !== 26 && O !== 27 || !Cs(x)) {
                  for (; J != null && ec(x, J); )
                    L++, J = u[L];
                  if (L === u.length) {
                    u = !0;
                    break e;
                  } else
                    for (x = x.child; x !== null; )
                      l.push(x, L), x = x.sibling;
                }
              }
              u = !1;
            }
            return u;
          case h_:
            if ((S === 5 || S === 26 || S === 27) && Gi(l.stateNode, u.value))
              return !0;
            break;
          case p_:
            if ((S === 5 || S === 6 || S === 26 || S === 27) && (l = hp(l), l !== null && 0 <= l.indexOf(u.value)))
              return !0;
            break;
          case tS:
            if ((S === 5 || S === 26 || S === 27) && (l = l.memoizedProps["data-testname"], typeof l == "string" && l.toLowerCase() === u.value.toLowerCase()))
              return !0;
            break;
          default:
            throw Error("Invalid selector type specified.");
        }
        return !1;
      }
      function Rf(l) {
        switch (l.$$typeof) {
          case f_:
            return "<" + (q(l.value) || "Unknown") + ">";
          case d_:
            return ":has(" + (Rf(l) || "") + ")";
          case h_:
            return '[role="' + l.value + '"]';
          case p_:
            return '"' + l.value + '"';
          case tS:
            return '[data-testname="' + l.value + '"]';
          default:
            throw Error("Invalid selector type specified.");
        }
      }
      function sg(l, u) {
        var S = [];
        l = [l, 0];
        for (var x = 0; x < l.length; ) {
          var O = l[x++], L = O.tag, J = l[x++], he = u[J];
          if (L !== 5 && L !== 26 && L !== 27 || !Cs(O)) {
            for (; he != null && ec(O, he); )
              J++, he = u[J];
            if (J === u.length) S.push(O);
            else
              for (O = O.child; O !== null; )
                l.push(O, J), O = O.sibling;
          }
        }
        return S;
      }
      function sv(l, u) {
        if (!ro)
          throw Error("Test selector API is not supported by this renderer.");
        l = As(l), l = sg(l, u), u = [], l = Array.from(l);
        for (var S = 0; S < l.length; ) {
          var x = l[S++], O = x.tag;
          if (O === 5 || O === 26 || O === 27)
            Cs(x) || u.push(x.stateNode);
          else
            for (x = x.child; x !== null; )
              l.push(x), x = x.sibling;
        }
        return u;
      }
      function rg() {
        ro && m_.forEach(function(l) {
          return l();
        });
      }
      function yh() {
        var l = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
        return l || ft.actQueue === null || console.error(
          "The current testing environment is not configured to support act(...)"
        ), l;
      }
      function Cr(l) {
        if ((ki & pc) !== tf && wa !== 0)
          return wa & -wa;
        var u = ft.T;
        return u !== null ? (u._updatedFibers || (u._updatedFibers = /* @__PURE__ */ new Set()), u._updatedFibers.add(l), l = gp, l !== 0 ? l : Qn()) : pm();
      }
      function qs() {
        Jf === 0 && (Jf = (wa & 536870912) === 0 || ei ? Bn() : 536870912);
        var l = Ou.current;
        return l !== null && (l.flags |= 32), Jf;
      }
      function ha(l, u, S) {
        if (Hu && console.error("useInsertionEffect must not schedule updates."), y_ && (Hv = !0), (l === El && sl === Tp || l.cancelPendingCommit !== null) && (_d(l, 0), Zs(
          l,
          wa,
          Jf,
          !1
        )), Zn(l, S), (ki & pc) !== 0 && l === El) {
          if (Dl)
            switch (u.tag) {
              case 0:
              case 11:
              case 15:
                l = ka && Y(ka) || "Unknown", Hs.has(l) || (Hs.add(l), u = Y(u) || "Unknown", console.error(
                  "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                  u,
                  l,
                  l
                ));
                break;
              case 1:
                vc || (console.error(
                  "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                ), vc = !0);
            }
        } else
          Us && Tt(l, u, S), mg(u), l === El && ((ki & pc) === tf && (zg |= S), zs === xp && Zs(
            l,
            wa,
            Jf,
            !1
          )), ca(l);
      }
      function zc(l, u, S) {
        if ((ki & (pc | wm)) !== tf)
          throw Error("Should not already be working.");
        var x = !S && (u & 60) === 0 && (u & l.expiredLanes) === 0 || Vt(l, u), O = x ? fg(l, u) : lm(l, u, !0), L = x;
        do {
          if (O === Ov) {
            yy && !x && Zs(l, u, 0, !1);
            break;
          } else if (O === lS)
            Zs(
              l,
              u,
              0,
              !Rp
            );
          else {
            if (S = l.current.alternate, L && !og(S)) {
              O = lm(l, u, !1), L = !1;
              continue;
            }
            if (O === my) {
              if (L = u, l.errorRecoveryDisabledLanes & L)
                var J = 0;
              else
                J = l.pendingLanes & -536870913, J = J !== 0 ? J : J & 536870912 ? 536870912 : 0;
              if (J !== 0) {
                u = J;
                e: {
                  O = l;
                  var he = J;
                  J = Sy;
                  var Pe = os && O.current.memoizedState.isDehydrated;
                  if (Pe && (_d(
                    O,
                    he
                  ).flags |= 256), he = lm(
                    O,
                    he,
                    !1
                  ), he !== my) {
                    if (v_ && !Pe) {
                      O.errorRecoveryDisabledLanes |= L, zg |= L, O = xp;
                      break e;
                    }
                    O = Vd, Vd = J, O !== null && _u(O);
                  }
                  O = he;
                }
                if (L = !1, O !== my) continue;
              }
            }
            if (O === aS) {
              _d(l, 0), Zs(l, u, 0, !0);
              break;
            }
            e: {
              switch (x = l, O) {
                case Ov:
                case aS:
                  throw Error("Root did not complete. This is a bug in React.");
                case xp:
                  if ((u & 4194176) === u) {
                    Zs(
                      x,
                      u,
                      Jf,
                      !Rp
                    );
                    break e;
                  }
                  break;
                case my:
                  Vd = null;
                  break;
                case iS:
                case AE:
                  break;
                default:
                  throw Error("Unknown root exit status.");
              }
              if (x.finishedWork = S, x.finishedLanes = u, ft.actQueue !== null)
                uv(
                  x,
                  Vd,
                  zh,
                  p0,
                  Jf,
                  zg,
                  Hg,
                  Pd,
                  -0,
                  0
                );
              else {
                if ((u & 62914560) === u && (O = Nv + Fd - Z(), 10 < O)) {
                  if (Zs(
                    x,
                    u,
                    Jf,
                    !Rp
                  ), ct(x, 0) !== 0) break e;
                  x.timeoutHandle = Xo(
                    Ql.bind(
                      null,
                      x,
                      S,
                      Vd,
                      zh,
                      p0,
                      u,
                      Jf,
                      zg,
                      Hg,
                      Rp,
                      Lv,
                      -0,
                      0
                    ),
                    O
                  );
                  break e;
                }
                Ql(
                  x,
                  S,
                  Vd,
                  zh,
                  p0,
                  u,
                  Jf,
                  zg,
                  Hg,
                  Rp,
                  Pd,
                  -0,
                  0
                );
              }
            }
          }
          break;
        } while (!0);
        ca(l);
      }
      function _u(l) {
        Vd === null ? Vd = l : Vd.push.apply(
          Vd,
          l
        );
      }
      function Ql(l, u, S, x, O, L, J, he, Pe, ht, Kt, ln, Sn) {
        var Na = u.subtreeFlags;
        if ((Na & 8192 || (Na & 16785408) === 16785408) && (zf(), Tr(u), u = Xc(), u !== null)) {
          l.cancelPendingCommit = u(
            uv.bind(
              null,
              l,
              S,
              x,
              O,
              J,
              he,
              Pe,
              _y,
              ln,
              Sn
            )
          ), Zs(
            l,
            L,
            J,
            !ht
          );
          return;
        }
        uv(
          l,
          S,
          x,
          O,
          J,
          he,
          Pe,
          Kt,
          ln,
          Sn
        );
      }
      function og(l) {
        for (var u = l; ; ) {
          var S = u.tag;
          if ((S === 0 || S === 11 || S === 15) && u.flags & 16384 && (S = u.updateQueue, S !== null && (S = S.stores, S !== null)))
            for (var x = 0; x < S.length; x++) {
              var O = S[x], L = O.getSnapshot;
              O = O.value;
              try {
                if (!Ke(L(), O)) return !1;
              } catch {
                return !1;
              }
            }
          if (S = u.child, u.subtreeFlags & 16384 && S !== null)
            S.return = u, u = S;
          else {
            if (u === l) break;
            for (; u.sibling === null; ) {
              if (u.return === null || u.return === l) return !0;
              u = u.return;
            }
            u.sibling.return = u.return, u = u.sibling;
          }
        }
        return !0;
      }
      function Zs(l, u, S, x) {
        u &= ~z1, u &= ~zg, l.suspendedLanes |= u, l.pingedLanes &= ~u, x && (l.warmLanes |= u), x = l.expirationTimes;
        for (var O = u; 0 < O; ) {
          var L = 31 - $i(O), J = 1 << L;
          x[L] = -1, O &= ~J;
        }
        S !== 0 && Te(l, S, u);
      }
      function tc() {
        return (ki & (pc | wm)) === tf ? (yn(0), !1) : !0;
      }
      function am() {
        if (ka !== null) {
          if (sl === jf)
            var l = ka.return;
          else
            l = ka, Jr(), Wd(l), ws = null, Hr = 0, l = ka;
          for (; l !== null; )
            $h(l.alternate, l), l = l.return;
          ka = null;
        }
      }
      function _d(l, u) {
        l.finishedWork = null, l.finishedLanes = 0;
        var S = l.timeoutHandle;
        S !== xh && (l.timeoutHandle = xh, xs(S)), S = l.cancelPendingCommit, S !== null && (l.cancelPendingCommit = null, S()), am(), El = l, ka = S = Es(l.current, null), wa = u, sl = jf, ko = null, Rp = !1, yy = Vt(l, u), v_ = !1, zs = Ov, Hg = Jf = z1 = zg = Ng = 0, Vd = Sy = null, p0 = !1, (u & 8) !== 0 && (u |= u & 32);
        var x = l.entangledLanes;
        if (x !== 0)
          for (l = l.entanglements, x &= u; 0 < x; ) {
            var O = 31 - $i(x), L = 1 << O;
            u |= l[O], x &= ~L;
          }
        return Dp = u, Gt(), cr.discardPendingWarnings(), S;
      }
      function im(l, u) {
        Gn = null, ft.H = Nu, ft.getCurrentStack = null, Dl = !1, rs = null, u === zd ? (u = Fp(), sl = h0) : u === Tg ? (u = Fp(), sl = mc) : sl = u === wg ? gy : u !== null && typeof u == "object" && typeof u.then == "function" ? Cp : wv, ko = u;
        var S = ka;
        if (S === null)
          zs = aS, mu(
            l,
            Vn(u, l.current)
          );
        else
          switch (S.mode & 2 && on(S), Et(), sl) {
            case wv:
              an !== null && typeof an.markComponentErrored == "function" && an.markComponentErrored(
                S,
                u,
                wa
              );
              break;
            case Tp:
            case h0:
            case Cp:
            case vy:
              an !== null && typeof an.markComponentSuspended == "function" && an.markComponentSuspended(
                S,
                u,
                wa
              );
          }
      }
      function Ad() {
        var l = Ou.current;
        return l === null ? !0 : (wa & 4194176) === wa ? Wc === null : (wa & 62914560) === wa || (wa & 536870912) !== 0 ? l === Wc : !1;
      }
      function ug() {
        var l = ft.H;
        return ft.H = Nu, l === null ? Nu : l;
      }
      function cg() {
        var l = ft.A;
        return ft.A = Fx, l;
      }
      function rv() {
        zs = xp, Rp || (wa & 4194176) !== wa && Ou.current !== null || (yy = !0), (Ng & 134217727) === 0 && (zg & 134217727) === 0 || El === null || Zs(
          El,
          wa,
          Jf,
          !1
        );
      }
      function lm(l, u, S) {
        var x = ki;
        ki |= pc;
        var O = ug(), L = cg();
        if (El !== l || wa !== u) {
          if (Us) {
            var J = l.memoizedUpdaters;
            0 < J.size && (Lc(l, wa), J.clear()), St(l, u);
          }
          zh = null, _d(l, u);
        }
        yt(u), u = !1, J = zs;
        e: do
          try {
            if (sl !== jf && ka !== null) {
              var he = ka, Pe = ko;
              switch (sl) {
                case gy:
                  am(), J = lS;
                  break e;
                case h0:
                case Tp:
                case Cp:
                  Ou.current === null && (u = !0);
                  var ht = sl;
                  if (sl = jf, ko = null, Ed(l, he, Pe, ht), S && yy) {
                    J = Ov;
                    break e;
                  }
                  break;
                default:
                  ht = sl, sl = jf, ko = null, Ed(l, he, Pe, ht);
              }
            }
            sm(), J = zs;
            break;
          } catch (Kt) {
            im(l, Kt);
          }
        while (!0);
        return u && l.shellSuspendCounter++, Jr(), ki = x, ft.H = O, ft.A = L, Jt(), ka === null && (El = null, wa = 0, Gt()), J;
      }
      function sm() {
        for (; ka !== null; ) ov(ka);
      }
      function fg(l, u) {
        var S = ki;
        ki |= pc;
        var x = ug(), O = cg();
        if (El !== l || wa !== u) {
          if (Us) {
            var L = l.memoizedUpdaters;
            0 < L.size && (Lc(l, wa), L.clear()), St(l, u);
          }
          zh = null, Nm = Z() + sS, _d(l, u);
        } else
          yy = Vt(
            l,
            u
          );
        yt(u);
        e: do
          try {
            if (sl !== jf && ka !== null)
              t: switch (u = ka, L = ko, sl) {
                case wv:
                  sl = jf, ko = null, Ed(
                    l,
                    u,
                    L,
                    wv
                  );
                  break;
                case Tp:
                  if (ad(L)) {
                    sl = jf, ko = null, rm(u);
                    break;
                  }
                  u = function() {
                    sl === Tp && El === l && (sl = vy), ca(l);
                  }, L.then(u, u);
                  break e;
                case h0:
                  sl = vy;
                  break e;
                case mc:
                  sl = N1;
                  break e;
                case vy:
                  ad(L) ? (sl = jf, ko = null, rm(u)) : (sl = jf, ko = null, Ed(
                    l,
                    u,
                    L,
                    vy
                  ));
                  break;
                case N1:
                  var J = null;
                  switch (ka.tag) {
                    case 26:
                      J = ka.memoizedState;
                    case 5:
                    case 27:
                      var he = ka, Pe = he.type, ht = he.pendingProps;
                      if (J ? co(J) : Nf(Pe, ht)) {
                        sl = jf, ko = null;
                        var Kt = he.sibling;
                        if (Kt !== null) ka = Kt;
                        else {
                          var ln = he.return;
                          ln !== null ? (ka = ln, om(ln)) : ka = null;
                        }
                        break t;
                      }
                      break;
                    default:
                      console.error(
                        "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                      );
                  }
                  sl = jf, ko = null, Ed(
                    l,
                    u,
                    L,
                    N1
                  );
                  break;
                case Cp:
                  sl = jf, ko = null, Ed(
                    l,
                    u,
                    L,
                    Cp
                  );
                  break;
                case gy:
                  am(), zs = lS;
                  break e;
                default:
                  throw Error(
                    "Unexpected SuspendedReason. This is a bug in React."
                  );
              }
            ft.actQueue !== null ? sm() : Wy();
            break;
          } catch (Sn) {
            im(l, Sn);
          }
        while (!0);
        return Jr(), ft.H = x, ft.A = O, ki = S, ka !== null ? (an !== null && typeof an.markRenderYielded == "function" && an.markRenderYielded(), Ov) : (Jt(), El = null, wa = 0, Gt(), zs);
      }
      function Wy() {
        for (; ka !== null && !w(); )
          ov(ka);
      }
      function ov(l) {
        var u = l.alternate;
        (l.mode & 2) !== Pi ? (It(l), u = me(
          l,
          Ju,
          u,
          l,
          Dp
        ), on(l)) : u = me(
          l,
          Ju,
          u,
          l,
          Dp
        ), l.memoizedProps = l.pendingProps, u === null ? om(l) : ka = u;
      }
      function rm(l) {
        var u = me(l, dg, l);
        l.memoizedProps = l.pendingProps, u === null ? om(l) : ka = u;
      }
      function dg(l) {
        var u = l.alternate, S = (l.mode & 2) !== Pi;
        switch (S && It(l), l.tag) {
          case 15:
          case 0:
            u = ch(
              u,
              l,
              l.pendingProps,
              l.type,
              void 0,
              wa
            );
            break;
          case 11:
            u = ch(
              u,
              l,
              l.pendingProps,
              l.type.render,
              l.ref,
              wa
            );
            break;
          case 5:
            Wd(l);
          default:
            $h(u, l), l = ka = vg(l, Dp), u = Ju(u, l, Dp);
        }
        return S && on(l), u;
      }
      function Ed(l, u, S, x) {
        Jr(), Wd(u), ws = null, Hr = 0;
        var O = u.return;
        try {
          if (Ps(
            l,
            O,
            u,
            S,
            wa
          )) {
            zs = aS, mu(
              l,
              Vn(S, l.current)
            ), ka = null;
            return;
          }
        } catch (L) {
          if (O !== null) throw ka = O, L;
          zs = aS, mu(
            l,
            Vn(S, l.current)
          ), ka = null;
          return;
        }
        u.flags & 32768 ? (ei || x === wv ? l = !0 : yy || (wa & 536870912) !== 0 ? l = !1 : (Rp = l = !0, (x === Tp || x === h0 || x === Cp) && (x = Ou.current, x !== null && x.tag === 13 && (x.flags |= 16384))), um(u, l)) : om(u);
      }
      function om(l) {
        var u = l;
        do {
          if ((u.flags & 32768) !== 0) {
            um(
              u,
              Rp
            );
            return;
          }
          var S = u.alternate;
          if (l = u.return, It(u), S = me(
            u,
            Oc,
            S,
            u,
            Dp
          ), (u.mode & 2) !== Pi && sn(u), S !== null) {
            ka = S;
            return;
          }
          if (u = u.sibling, u !== null) {
            ka = u;
            return;
          }
          ka = u = l;
        } while (u !== null);
        zs === Ov && (zs = AE);
      }
      function um(l, u) {
        do {
          var S = pl(l.alternate, l);
          if (S !== null) {
            S.flags &= 32767, ka = S;
            return;
          }
          if ((l.mode & 2) !== Pi) {
            sn(l), S = l.actualDuration;
            for (var x = l.child; x !== null; )
              S += x.actualDuration, x = x.sibling;
            l.actualDuration = S;
          }
          if (S = l.return, S !== null && (S.flags |= 32768, S.subtreeFlags = 0, S.deletions = null), !u && (l = l.sibling, l !== null)) {
            ka = l;
            return;
          }
          ka = l = S;
        } while (l !== null);
        zs = lS, ka = null;
      }
      function uv(l, u, S, x, O, L, J, he, Pe, ht) {
        var Kt = ft.T, ln = Pc();
        try {
          Tn(2), ft.T = null, Df(
            l,
            u,
            S,
            x,
            ln,
            O,
            L,
            J,
            he,
            Pe,
            ht
          );
        } finally {
          ft.T = Kt, Tn(ln);
        }
      }
      function Df(l, u, S, x, O, L, J, he) {
        do
          Hc();
        while (Xi !== null);
        if (cr.flushLegacyContextWarning(), cr.flushPendingUnsafeLifecycleWarnings(), (ki & (pc | wm)) !== tf)
          throw Error("Should not already be working.");
        var Pe = l.finishedWork;
        if (x = l.finishedLanes, an !== null && typeof an.markCommitStarted == "function" && an.markCommitStarted(x), Pe === null) return Xe(), null;
        if (x === 0 && console.error(
          "root.finishedLanes should not be empty during a commit. This is a bug in React."
        ), l.finishedWork = null, l.finishedLanes = 0, Pe === l.current)
          throw Error(
            "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
          );
        l.callbackNode = null, l.callbackPriority = 0, l.cancelPendingCommit = null;
        var ht = Pe.lanes | Pe.childLanes;
        if (ht |= _v, Rn(
          l,
          x,
          ht,
          L,
          J,
          he
        ), l === El && (ka = El = null, wa = 0), (Pe.subtreeFlags & 10256) === 0 && (Pe.flags & 10256) === 0 || zv || (zv = !0, _o = ht, Wo = S, rp(qe, function() {
          return Hc(), null;
        })), Da = Mg(), S = (Pe.flags & 15990) !== 0, (Pe.subtreeFlags & 15990) !== 0 || S ? (S = ft.T, ft.T = null, L = Pc(), Tn(2), J = ki, ki |= wm, lp(l, Pe), xr(
          l,
          Pe,
          x
        ), cp(l.containerInfo), l.current = Pe, an !== null && typeof an.markLayoutEffectsStarted == "function" && an.markLayoutEffectsStarted(
          x
        ), nm(Pe, l, x), an !== null && typeof an.markLayoutEffectsStopped == "function" && an.markLayoutEffectsStopped(), I(), ki = J, Tn(L), ft.T = S) : l.current = Pe, (S = zv) ? (zv = !1, Xi = l, rS = x) : ($y(l, ht), zm = 0, Lg = null), ht = l.pendingLanes, ht === 0 && (So = null), S || pg(l), At(Pe.stateNode, O), Us && l.memoizedUpdaters.clear(), rg(), ca(l), u !== null)
          for (O = l.onRecoverableError, Pe = 0; Pe < u.length; Pe++)
            ht = u[Pe], S = hg(ht.stack), me(
              ht.source,
              O,
              ht.value,
              S
            );
        return (rS & 3) !== 0 && Hc(), ht = l.pendingLanes, (x & 4194218) !== 0 && (ht & 42) !== 0 ? (Sa = !0, l === g_ ? m0++ : (m0 = 0, g_ = l)) : m0 = 0, yn(0), Xe(), null;
      }
      function hg(l) {
        return l = { componentStack: l }, Object.defineProperty(l, "digest", {
          get: function() {
            console.error(
              'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
            );
          }
        }), l;
      }
      function $y(l, u) {
        (l.pooledCacheLanes &= u) === 0 && (u = l.pooledCache, u != null && (l.pooledCache = null, md(u)));
      }
      function Hc() {
        if (Xi !== null) {
          var l = Xi, u = _o;
          _o = 0;
          var S = Mt(rS), x = 32 > S ? 32 : S;
          S = ft.T;
          var O = Pc();
          try {
            if (Tn(x), ft.T = null, Xi === null)
              var L = !1;
            else {
              x = Wo, Wo = null;
              var J = Xi, he = rS;
              if (Xi = null, rS = 0, (ki & (pc | wm)) !== tf)
                throw Error(
                  "Cannot flush passive effects while already rendering."
                );
              y_ = !0, Hv = !1, an !== null && typeof an.markPassiveEffectsStarted == "function" && an.markPassiveEffectsStarted(he);
              var Pe = ki;
              if (ki |= wm, Zl(J.current), Lo(
                J,
                J.current,
                he,
                x
              ), an !== null && typeof an.markPassiveEffectsStopped == "function" && an.markPassiveEffectsStopped(), pg(J), ki = Pe, yn(0, !1), Hv ? J === Lg ? zm++ : (zm = 0, Lg = J) : zm = 0, Hv = y_ = !1, Un && typeof Un.onPostCommitFiberRoot == "function")
                try {
                  Un.onPostCommitFiberRoot(cn, J);
                } catch (Kt) {
                  ur || (ur = !0, console.error(
                    "React instrumentation encountered an error: %s",
                    Kt
                  ));
                }
              var ht = J.current.stateNode;
              ht.effectDuration = 0, ht.passiveEffectDuration = 0, L = !0;
            }
            return L;
          } finally {
            Tn(O), ft.T = S, $y(l, u);
          }
        }
        return !1;
      }
      function to(l, u, S) {
        u = Vn(S, u), u = Af(l.stateNode, u, 2), l = Hl(l, u, 2), l !== null && (Zn(l, 2), ca(l));
      }
      function $a(l, u, S) {
        if (Hu = !1, l.tag === 3)
          to(l, l, S);
        else {
          for (; u !== null; ) {
            if (u.tag === 3) {
              to(
                u,
                l,
                S
              );
              return;
            }
            if (u.tag === 1) {
              var x = u.stateNode;
              if (typeof u.type.getDerivedStateFromError == "function" || typeof x.componentDidCatch == "function" && (So === null || !So.has(x))) {
                l = Vn(S, l), S = ql(2), x = Hl(u, S, 2), x !== null && (kp(
                  S,
                  x,
                  u,
                  l
                ), Zn(x, 2), ca(x));
                return;
              }
            }
            u = u.return;
          }
          console.error(
            `Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,
            S
          );
        }
      }
      function Sh(l, u, S) {
        var x = l.pingCache;
        if (x === null) {
          x = l.pingCache = new Px();
          var O = /* @__PURE__ */ new Set();
          x.set(u, O);
        } else
          O = x.get(u), O === void 0 && (O = /* @__PURE__ */ new Set(), x.set(u, O));
        O.has(S) || (v_ = !0, O.add(S), x = _h.bind(null, l, u, S), Us && Lc(l, S), u.then(x, x));
      }
      function _h(l, u, S) {
        var x = l.pingCache;
        x !== null && x.delete(u), l.pingedLanes |= l.suspendedLanes & S, l.warmLanes &= ~S, yh() && ft.actQueue === null && console.error(
          `A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`
        ), El === l && (wa & S) === S && (zs === xp || zs === iS && (wa & 62914560) === wa && Z() - Nv < Fd ? (ki & pc) === tf && _d(l, 0) : z1 |= S, Hg === wa && (Hg = 0)), ca(l);
      }
      function xi(l, u) {
        u === 0 && (u = rn()), l = Ee(l, u), l !== null && (Zn(l, u), ca(l));
      }
      function kg(l) {
        var u = l.memoizedState, S = 0;
        u !== null && (S = u.retryLane), xi(l, S);
      }
      function Wg(l, u) {
        var S = 0;
        switch (l.tag) {
          case 13:
            var x = l.stateNode, O = l.memoizedState;
            O !== null && (S = O.retryLane);
            break;
          case 19:
            x = l.stateNode;
            break;
          case 22:
            x = l.stateNode._retryCache;
            break;
          default:
            throw Error(
              "Pinged unknown suspense boundary type. This is probably a bug in React."
            );
        }
        x !== null && x.delete(u), xi(l, S);
      }
      function sp(l, u, S) {
        if ((u.subtreeFlags & 33562624) !== 0)
          for (u = u.child; u !== null; ) {
            var x = l, O = u, L = O.type === ac;
            L = S || L, O.tag !== 22 ? O.flags & 33554432 ? L && me(
              O,
              Go,
              x,
              O,
              (O.mode & 64) === Pi
            ) : sp(
              x,
              O,
              L
            ) : O.memoizedState === null && (L && O.flags & 8192 ? me(
              O,
              Go,
              x,
              O
            ) : O.subtreeFlags & 33554432 && me(
              O,
              sp,
              x,
              O,
              L
            )), u = u.sibling;
          }
      }
      function Go(l, u) {
        var S = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : !0;
        ce(!0);
        try {
          Sd(u), S && lv(u), vh(l, u.alternate, u, !1), S && di(l, u, 0, null, !1);
        } finally {
          ce(!1);
        }
      }
      function pg(l) {
        var u = !0;
        l.current.mode & 24 || (u = !1), sp(
          l,
          l.current,
          u
        );
      }
      function cv(l) {
        if ((ki & pc) === tf) {
          var u = l.tag;
          if (u === 3 || u === 1 || u === 0 || u === 11 || u === 14 || u === 15) {
            if (u = Y(l) || "ReactComponent", Hh !== null) {
              if (Hh.has(u)) return;
              Hh.add(u);
            } else Hh = /* @__PURE__ */ new Set([u]);
            me(l, function() {
              console.error(
                "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
              );
            });
          }
        }
      }
      function Lc(l, u) {
        Us && l.memoizedUpdaters.forEach(function(S) {
          Tt(l, S, u);
        });
      }
      function rp(l, u) {
        var S = ft.actQueue;
        return S !== null ? (S.push(u), Di) : m(l, u);
      }
      function mg(l) {
        yh() && ft.actQueue === null && me(l, function() {
          console.error(
            `An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`,
            Y(l)
          );
        });
      }
      function nc(l) {
        if (Ir === null) return l;
        var u = Ir(l);
        return u === void 0 ? l : u.current;
      }
      function fv(l) {
        if (Ir === null) return l;
        var u = Ir(l);
        return u === void 0 ? l != null && typeof l.render == "function" && (u = nc(l.render), l.render !== u) ? (u = { $$typeof: Vo, render: u }, l.displayName !== void 0 && (u.displayName = l.displayName), u) : l : u.current;
      }
      function $g(l, u) {
        if (Ir === null) return !1;
        var S = l.elementType;
        u = u.type;
        var x = !1, O = typeof u == "object" && u !== null ? u.$$typeof : null;
        switch (l.tag) {
          case 1:
            typeof u == "function" && (x = !0);
            break;
          case 0:
            (typeof u == "function" || O === bs) && (x = !0);
            break;
          case 11:
            (O === Vo || O === bs) && (x = !0);
            break;
          case 14:
          case 15:
            (O === xd || O === bs) && (x = !0);
            break;
          default:
            return !1;
        }
        return !!(x && (l = Ir(S), l !== void 0 && l === Ir(u)));
      }
      function e0(l) {
        Ir !== null && typeof WeakSet == "function" && (Lu === null && (Lu = /* @__PURE__ */ new WeakSet()), Lu.add(l));
      }
      function cm(l, u, S) {
        var x = l.alternate, O = l.child, L = l.sibling, J = l.tag, he = l.type, Pe = null;
        switch (J) {
          case 0:
          case 15:
          case 1:
            Pe = he;
            break;
          case 11:
            Pe = he.render;
        }
        if (Ir === null)
          throw Error("Expected resolveFamily to be set during hot reload.");
        var ht = !1;
        he = !1, Pe !== null && (Pe = Ir(Pe), Pe !== void 0 && (S.has(Pe) ? he = !0 : u.has(Pe) && (J === 1 ? he = !0 : ht = !0))), Lu !== null && (Lu.has(l) || x !== null && Lu.has(x)) && (he = !0), he && (l._debugNeedsRemount = !0), (he || ht) && (x = Ee(l, 2), x !== null && ha(x, l, 2)), O === null || he || cm(
          O,
          u,
          S
        ), L !== null && cm(
          L,
          u,
          S
        );
      }
      function t0(l, u, S, x) {
        this.tag = l, this.key = S, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = u, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = x, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null, this.actualDuration = -0, this.actualStartTime = -1.1, this.treeBaseDuration = this.selfBaseDuration = -0, this._debugOwner = this._debugInfo = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, Gg || typeof Object.preventExtensions != "function" || Object.preventExtensions(this);
      }
      function Ah(l) {
        return l = l.prototype, !(!l || !l.isReactComponent);
      }
      function Es(l, u) {
        var S = l.alternate;
        switch (S === null ? (S = E(
          l.tag,
          u,
          l.key,
          l.mode
        ), S.elementType = l.elementType, S.type = l.type, S.stateNode = l.stateNode, S._debugOwner = l._debugOwner, S._debugHookTypes = l._debugHookTypes, S.alternate = l, l.alternate = S) : (S.pendingProps = u, S.type = l.type, S.flags = 0, S.subtreeFlags = 0, S.deletions = null, S.actualDuration = -0, S.actualStartTime = -1.1), S.flags = l.flags & 31457280, S.childLanes = l.childLanes, S.lanes = l.lanes, S.child = l.child, S.memoizedProps = l.memoizedProps, S.memoizedState = l.memoizedState, S.updateQueue = l.updateQueue, u = l.dependencies, S.dependencies = u === null ? null : {
          lanes: u.lanes,
          firstContext: u.firstContext,
          _debugThenableState: u._debugThenableState
        }, S.sibling = l.sibling, S.index = l.index, S.ref = l.ref, S.refCleanup = l.refCleanup, S.selfBaseDuration = l.selfBaseDuration, S.treeBaseDuration = l.treeBaseDuration, S._debugInfo = l._debugInfo, S._debugNeedsRemount = l._debugNeedsRemount, S.tag) {
          case 0:
          case 15:
            S.type = nc(l.type);
            break;
          case 1:
            S.type = nc(l.type);
            break;
          case 11:
            S.type = fv(l.type);
        }
        return S;
      }
      function vg(l, u) {
        l.flags &= 31457282;
        var S = l.alternate;
        return S === null ? (l.childLanes = 0, l.lanes = u, l.child = null, l.subtreeFlags = 0, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null, l.selfBaseDuration = 0, l.treeBaseDuration = 0) : (l.childLanes = S.childLanes, l.lanes = S.lanes, l.child = S.child, l.subtreeFlags = 0, l.deletions = null, l.memoizedProps = S.memoizedProps, l.memoizedState = S.memoizedState, l.updateQueue = S.updateQueue, l.type = S.type, u = S.dependencies, l.dependencies = u === null ? null : {
          lanes: u.lanes,
          firstContext: u.firstContext,
          _debugThenableState: u._debugThenableState
        }, l.selfBaseDuration = S.selfBaseDuration, l.treeBaseDuration = S.treeBaseDuration), l;
      }
      function gg(l, u, S, x, O, L) {
        var J = 0, he = l;
        if (typeof l == "function")
          Ah(l) && (J = 1), he = nc(he);
        else if (typeof l == "string")
          Dn && Fl ? (J = xe(), J = qa(l, S, J) ? 26 : Bd(l) ? 27 : 5) : Dn ? (J = xe(), J = qa(l, S, J) ? 26 : 5) : J = Fl && Bd(l) ? 27 : 5;
        else
          e: switch (l) {
            case Gl:
              return bd(
                S.children,
                O,
                L,
                u
              );
            case ac:
              J = 8, O |= 24;
              break;
            case ic:
              return l = S, x = O, typeof l.id != "string" && console.error(
                'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                typeof l.id
              ), u = E(12, l, u, x | 2), u.elementType = ic, u.lanes = L, u.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, u;
            case ao:
              return u = E(13, S, u, O), u.elementType = ao, u.lanes = L, u;
            case Qs:
              return u = E(19, S, u, O), u.elementType = Qs, u.lanes = L, u;
            case lc:
              return yg(S, O, L, u);
            default:
              if (typeof l == "object" && l !== null)
                switch (l.$$typeof) {
                  case Uf:
                  case La:
                    J = 10;
                    break e;
                  case Io:
                    J = 9;
                    break e;
                  case Vo:
                    J = 11, he = fv(he);
                    break e;
                  case xd:
                    J = 14;
                    break e;
                  case bs:
                    J = 16, he = null;
                    break e;
                }
              he = "", (l === void 0 || typeof l == "object" && l !== null && Object.keys(l).length === 0) && (he += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), l === null ? S = "null" : Il(l) ? S = "array" : l !== void 0 && l.$$typeof === Br ? (S = "<" + (q(l.type) || "Unknown") + " />", he = " Did you accidentally export a JSX literal instead of a component?") : S = typeof l, J = x ? typeof x.tag == "number" ? Y(x) : typeof x.name == "string" ? x.name : null : null, J && (he += `

Check the render method of \`` + J + "`."), J = 29, S = Error(
                "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (S + "." + he)
              ), he = null;
          }
        return u = E(J, S, u, O), u.elementType = l, u.type = he, u.lanes = L, u._debugOwner = x, u;
      }
      function dv(l, u, S) {
        return u = gg(
          l.type,
          l.key,
          l.props,
          l._owner,
          u,
          S
        ), u._debugOwner = l._owner, u;
      }
      function bd(l, u, S, x) {
        return l = E(7, l, x, u), l.lanes = S, l;
      }
      function yg(l, u, S, x) {
        l = E(22, l, x, u), l.elementType = lc, l.lanes = S;
        var O = {
          _visibility: 1,
          _pendingVisibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
          _current: null,
          detach: function() {
            var L = O, J = L._current;
            if (J === null)
              throw Error(
                "Calling Offscreen.detach before instance handle has been set."
              );
            if ((L._pendingVisibility & 2) === 0) {
              var he = Ee(J, 2);
              he !== null && (L._pendingVisibility |= 2, ha(he, J, 2));
            }
          },
          attach: function() {
            var L = O, J = L._current;
            if (J === null)
              throw Error(
                "Calling Offscreen.detach before instance handle has been set."
              );
            if ((L._pendingVisibility & 2) !== 0) {
              var he = Ee(J, 2);
              he !== null && (L._pendingVisibility &= -3, ha(he, J, 2));
            }
          }
        };
        return l.stateNode = O, l;
      }
      function Md(l, u, S) {
        return l = E(6, l, null, u), l.lanes = S, l;
      }
      function Eh(l, u, S) {
        return u = E(
          4,
          l.children !== null ? l.children : [],
          l.key,
          u
        ), u.lanes = S, u.stateNode = {
          containerInfo: l.containerInfo,
          pendingChildren: null,
          implementation: l.implementation
        }, u;
      }
      function op(l, u, S, x, O, L, J, he) {
        for (this.tag = 1, this.containerInfo = l, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = xh, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = dn(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = dn(0), this.hiddenUpdates = dn(null), this.identifierPrefix = x, this.onUncaughtError = O, this.onCaughtError = L, this.onRecoverableError = J, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = he, this.incompleteTransitions = /* @__PURE__ */ new Map(), this.passiveEffectDuration = this.effectDuration = -0, this.memoizedUpdaters = /* @__PURE__ */ new Set(), l = this.pendingUpdatersLaneMap = [], u = 0; 31 > u; u++) l.push(/* @__PURE__ */ new Set());
        this._debugRootType = S ? "hydrateRoot()" : "createRoot()";
      }
      function ey(l, u, S, x, O, L, J, he, Pe, ht, Kt, ln) {
        return l = new op(
          l,
          u,
          S,
          J,
          he,
          Pe,
          ht,
          ln
        ), u = 1, L === !0 && (u |= 24), Us && (u |= 2), L = E(3, null, null, u), l.current = L, L.stateNode = l, u = bf(), br(u), l.pooledCache = u, br(u), L.memoizedState = {
          element: x,
          isDehydrated: S,
          cache: u
        }, Ya(L), l;
      }
      function no(l) {
        return "" + l;
      }
      function fm(l) {
        return l ? (l = Bs, l) : Bs;
      }
      function dm(l, u, S, x) {
        return u.tag === 0 && Hc(), hv(
          u.current,
          2,
          l,
          u,
          S,
          x
        ), 2;
      }
      function hv(l, u, S, x, O, L) {
        if (Un && typeof Un.onScheduleFiberRoot == "function")
          try {
            Un.onScheduleFiberRoot(cn, x, S);
          } catch (J) {
            ur || (ur = !0, console.error(
              "React instrumentation encountered an error: %s",
              J
            ));
          }
        an !== null && typeof an.markRenderScheduled == "function" && an.markRenderScheduled(u), O = fm(O), x.context === null ? x.context = O : x.pendingContext = O, Dl && rs !== null && !S_ && (S_ = !0, console.error(
          `Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,
          Y(rs) || "Unknown"
        )), x = Wi(u), x.payload = { element: S }, L = L === void 0 ? null : L, L !== null && (typeof L != "function" && console.error(
          "Expected the last optional `callback` argument to be a function. Instead received: %s.",
          L
        ), x.callback = L), S = Hl(l, x, u), S !== null && (ha(S, l, u), Pr(S, l, u));
      }
      function Gc(l, u) {
        if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
          var S = l.retryLane;
          l.retryLane = S !== 0 && S < u ? S : u;
        }
      }
      function Bf(l, u) {
        Gc(l, u), (l = l.alternate) && Gc(l, u);
      }
      function hm() {
        return rs;
      }
      function pv() {
        for (var l = /* @__PURE__ */ new Map(), u = 1, S = 0; 31 > S; S++) {
          var x = Me(u);
          l.set(u, x), u *= 2;
        }
        return l;
      }
      var pa = {}, Rr = Qm, Dr = Sw(), Ti = Object.assign, bh = Symbol.for("react.element"), Br = Symbol.for("react.transitional.element"), oi = Symbol.for("react.portal"), Gl = Symbol.for("react.fragment"), ac = Symbol.for("react.strict_mode"), ic = Symbol.for("react.profiler"), Uf = Symbol.for("react.provider"), Io = Symbol.for("react.consumer"), La = Symbol.for("react.context"), Vo = Symbol.for("react.forward_ref"), ao = Symbol.for("react.suspense"), Qs = Symbol.for("react.suspense_list"), xd = Symbol.for("react.memo"), bs = Symbol.for("react.lazy"), lc = Symbol.for("react.offscreen"), Mh = Symbol.for("react.memo_cache_sentinel"), Of = Symbol.iterator, mv = Symbol.for("react.client.reference"), ft = Rr.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Td = 0, Fo, vv, Sg, ir, ty, Cl, ss;
      ie.__reactDisabledLog = !0;
      var gl, io, Rl = !1, wf = new (typeof WeakMap == "function" ? WeakMap : Map)(), rs = null, Dl = !1, Il = Array.isArray, up = e.rendererVersion, Po = e.rendererPackageName, Ur = e.extraDevToolsConfig, lo = e.getPublicInstance, sc = e.getRootHostContext, Ic = e.getChildHostContext, Ms = e.prepareForCommit, cp = e.resetAfterCommit, Vc = e.createInstance, Cd = e.appendInitialChild, Bl = e.finalizeInitialChildren, Ul = e.shouldSetTextContent, Ja = e.createTextInstance, Xo = e.scheduleTimeout, xs = e.cancelTimeout, xh = e.noTimeout, jl = e.isPrimaryRenderer;
      e.warnsIfNotActing;
      var Vl = e.supportsMutation, Ts = e.supportsPersistence, os = e.supportsHydration, Fc = e.getInstanceFromNode;
      e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
      var Th = e.preparePortalMount;
      e.prepareScopeUpdate, e.getInstanceFromScope;
      var Tn = e.setCurrentUpdatePriority, Pc = e.getCurrentUpdatePriority, pm = e.resolveUpdatePriority;
      e.resolveEventType, e.resolveEventTimeStamp;
      var fp = e.shouldAttemptEagerTransition, dp = e.detachDeletedInstance;
      e.requestPostPaintCallback;
      var Au = e.maySuspendCommit, Nf = e.preloadInstance, zf = e.startSuspendingCommit, Rd = e.suspendInstance, Xc = e.waitForCommitToBeReady, so = e.NotPendingTransition, Yc = e.HostTransitionContext, gv = e.resetFormInstance, lr = e.bindToConsole, rc = e.supportsMicrotasks, Ch = e.scheduleMicrotask, ro = e.supportsTestSelectors, qc = e.findFiberRoot, ji = e.getBoundingRect, hp = e.getTextContent, Cs = e.isHiddenSubtree, Gi = e.matchAccessibilityRole, Jl = e.setFocusIfFocusable, Hf = e.setupIntersectionObserver, Ra = e.appendChild, kn = e.appendChildToContainer, Ka = e.commitTextUpdate, Eu = e.commitMount, ga = e.commitUpdate, Lf = e.insertBefore, mm = e.insertInContainerBefore, Rh = e.removeChild, us = e.removeChildFromContainer, Or = e.resetTextContent, pp = e.hideInstance, Ji = e.hideTextInstance, Dd = e.unhideInstance, sr = e.unhideTextInstance, Ci = e.clearContainer, Gf = e.cloneInstance, Yo = e.createContainerChildSet, vm = e.appendChildToContainerChildSet, ui = e.finalizeContainerChildren, gm = e.replaceContainerChildren, bu = e.cloneHiddenInstance, Oa = e.cloneHiddenTextInstance, rr = e.isSuspenseInstancePending, yl = e.isSuspenseInstanceFallback, n0 = e.getSuspenseInstanceFallbackErrorDetails, ny = e.registerSuspenseInstanceRetry, Ii = e.canHydrateFormStateMarker, _g = e.isFormStateMarkerMatching, Ol = e.getNextHydratableSibling, oc = e.getFirstHydratableChild, Sl = e.getFirstHydratableChildWithinContainer, Ag = e.getFirstHydratableChildWithinSuspenseInstance, mi = e.canHydrateInstance, ma = e.canHydrateTextInstance, Ga = e.canHydrateSuspenseInstance, Fn = e.hydrateInstance, ba = e.hydrateTextInstance, _l = e.hydrateSuspenseInstance, wr = e.getNextHydratableInstanceAfterSuspenseInstance, ym = e.commitHydratedContainer, Sm = e.commitHydratedSuspenseInstance, uc = e.clearSuspenseBoundary, il = e.clearSuspenseBoundaryFromContainer, Mu = e.shouldDeleteUnhydratedTailInstances, Zc = e.diffHydratedPropsForDevWarnings, oo = e.diffHydratedTextForDevWarnings, xu = e.describeHydratableInstanceForDevWarnings, hi = e.validateHydratableInstance, Si = e.validateHydratableTextInstance, Dn = e.supportsResources, qa = e.isHostHoistableType, Ri = e.getHoistableRoot, or = e.getResource, uo = e.acquireResource, qo = e.releaseResource, Rs = e.hydrateHoistable, Ds = e.mountHoistable, Vi = e.unmountHoistable, Al = e.createHoistableInstance, If = e.prepareToCommitHoistables, _m = e.mayResourceSuspendCommit, co = e.preloadResource, Qc = e.suspendResource, Fl = e.supportsSingletons, wl = e.resolveSingletonInstance, yv = e.clearSingleton, fo = e.acquireSingletonInstance, Vf = e.releaseSingletonInstance, Bd = e.isHostSingletonType, jc = [], Zo = [], Kl = -1, Bs = {};
      Object.freeze(Bs);
      var $i = Math.clz32 ? Math.clz32 : We, Sv = Math.log, Am = Math.LN2, cc = 128, h = 4194304, m = Dr.unstable_scheduleCallback, M = Dr.unstable_cancelCallback, w = Dr.unstable_shouldYield, I = Dr.unstable_requestPaint, Z = Dr.unstable_now, fe = Dr.unstable_ImmediatePriority, Be = Dr.unstable_UserBlockingPriority, qe = Dr.unstable_NormalPriority, wt = Dr.unstable_IdlePriority, en = Dr.log, mn = Dr.unstable_setDisableYieldValue, cn = null, Un = null, an = null, ur = !1, Us = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u", Ke = typeof Object.is == "function" ? Object.is : Wt, Ge = /* @__PURE__ */ new WeakMap(), rt = [], qt = 0, On = null, Fi = 0, Hn = [], ya = 0, Ki = null, la = 1, cs = "", Tu = ue(null), Em = ue(null), Cu = ue(null), ho = ue(null), Eg = /["'&<>\n\t]|^\s|\s$/, Qo = null, Os = null, ei = !1, Dh = !1, jo = null, Ff = null, Jo = !1, bg = Error(
        "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ), Pi = 0, Jc = [], ll = 0, _v = 0, Mg = Dr.unstable_now, Da = -0, Nr = -1.1, fc = -0, Bh = !1, Sa = !1, mp = null, Ud = null, ay = !1, xg = !1, Ru = !1, Od = !1, wd = 0, Uh = {}, vp = null, Du = 0, gp = 0, Av = null, a0 = 0, iy = 1, _a = 2, mt = 3, Kn = !1, o_ = !1, Ev = null, bv = !1, Pf = Object.prototype.hasOwnProperty, cr = {
        recordUnsafeLifecycleWarnings: function() {
        },
        flushPendingUnsafeLifecycleWarnings: function() {
        },
        recordLegacyContextWarning: function() {
        },
        flushLegacyContextWarning: function() {
        },
        discardPendingWarnings: function() {
        }
      }, Oh = [], dc = [], wh = [], Kc = [], bm = [], ly = [], Mm = /* @__PURE__ */ new Set();
      cr.recordUnsafeLifecycleWarnings = function(l, u) {
        Mm.has(l.type) || (typeof u.componentWillMount == "function" && u.componentWillMount.__suppressDeprecationWarning !== !0 && Oh.push(l), l.mode & 8 && typeof u.UNSAFE_componentWillMount == "function" && dc.push(l), typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && wh.push(l), l.mode & 8 && typeof u.UNSAFE_componentWillReceiveProps == "function" && Kc.push(l), typeof u.componentWillUpdate == "function" && u.componentWillUpdate.__suppressDeprecationWarning !== !0 && bm.push(l), l.mode & 8 && typeof u.UNSAFE_componentWillUpdate == "function" && ly.push(l));
      }, cr.flushPendingUnsafeLifecycleWarnings = function() {
        var l = /* @__PURE__ */ new Set();
        0 < Oh.length && (Oh.forEach(function(he) {
          l.add(
            Y(he) || "Component"
          ), Mm.add(he.type);
        }), Oh = []);
        var u = /* @__PURE__ */ new Set();
        0 < dc.length && (dc.forEach(function(he) {
          u.add(
            Y(he) || "Component"
          ), Mm.add(he.type);
        }), dc = []);
        var S = /* @__PURE__ */ new Set();
        0 < wh.length && (wh.forEach(function(he) {
          S.add(
            Y(he) || "Component"
          ), Mm.add(he.type);
        }), wh = []);
        var x = /* @__PURE__ */ new Set();
        0 < Kc.length && (Kc.forEach(
          function(he) {
            x.add(
              Y(he) || "Component"
            ), Mm.add(he.type);
          }
        ), Kc = []);
        var O = /* @__PURE__ */ new Set();
        0 < bm.length && (bm.forEach(function(he) {
          O.add(
            Y(he) || "Component"
          ), Mm.add(he.type);
        }), bm = []);
        var L = /* @__PURE__ */ new Set();
        if (0 < ly.length && (ly.forEach(function(he) {
          L.add(
            Y(he) || "Component"
          ), Mm.add(he.type);
        }), ly = []), 0 < u.size) {
          var J = N(
            u
          );
          console.error(
            `Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,
            J
          );
        }
        0 < x.size && (J = N(
          x
        ), console.error(
          `Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`,
          J
        )), 0 < L.size && (J = N(
          L
        ), console.error(
          `Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,
          J
        )), 0 < l.size && (J = N(l), console.warn(
          `componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
          J
        )), 0 < S.size && (J = N(
          S
        ), console.warn(
          `componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
          J
        )), 0 < O.size && (J = N(O), console.warn(
          `componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
          J
        ));
      };
      var i0 = /* @__PURE__ */ new Map(), Nd = /* @__PURE__ */ new Set();
      cr.recordLegacyContextWarning = function(l, u) {
        for (var S = null, x = l; x !== null; )
          x.mode & 8 && (S = x), x = x.return;
        S === null ? console.error(
          "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
        ) : !Nd.has(l.type) && (x = i0.get(S), l.type.contextTypes != null || l.type.childContextTypes != null || u !== null && typeof u.getChildContext == "function") && (x === void 0 && (x = [], i0.set(S, x)), x.push(l));
      }, cr.flushLegacyContextWarning = function() {
        i0.forEach(function(l) {
          if (l.length !== 0) {
            var u = l[0], S = /* @__PURE__ */ new Set();
            l.forEach(function(O) {
              S.add(Y(O) || "Component"), Nd.add(O.type);
            });
            var x = N(S);
            me(u, function() {
              console.error(
                `Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`,
                x
              );
            });
          }
        });
      }, cr.discardPendingWarnings = function() {
        Oh = [], dc = [], wh = [], Kc = [], bm = [], ly = [], i0 = /* @__PURE__ */ new Map();
      };
      var zd = Error(
        "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"
      ), Tg = Error(
        "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
      ), xm = {
        then: function() {
          console.error(
            'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
          );
        }
      }, Hd = null, l0 = !1, Cg = {
        "react-stack-bottom-frame": function(l, u, S) {
          var x = Dl;
          Dl = !0;
          try {
            return l(u, S);
          } finally {
            Dl = x;
          }
        }
      }, W0 = Cg["react-stack-bottom-frame"].bind(Cg), Xf = {
        "react-stack-bottom-frame": function(l) {
          var u = Dl;
          Dl = !0;
          try {
            return l.render();
          } finally {
            Dl = u;
          }
        }
      }, yp = Xf["react-stack-bottom-frame"].bind(Xf), zr = {
        "react-stack-bottom-frame": function(l, u) {
          try {
            u.componentDidMount();
          } catch (S) {
            $a(l, l.return, S);
          }
        }
      }, vn = zr["react-stack-bottom-frame"].bind(zr), Bu = {
        "react-stack-bottom-frame": function(l, u, S, x, O) {
          try {
            u.componentDidUpdate(S, x, O);
          } catch (L) {
            $a(l, l.return, L);
          }
        }
      }, kl = Bu["react-stack-bottom-frame"].bind(Bu), po = {
        "react-stack-bottom-frame": function(l, u) {
          var S = u.stack;
          l.componentDidCatch(u.value, {
            componentStack: S !== null ? S : ""
          });
        }
      }, s0 = po["react-stack-bottom-frame"].bind(po), Nh = {
        "react-stack-bottom-frame": function(l, u, S) {
          try {
            S.componentWillUnmount();
          } catch (x) {
            $a(l, u, x);
          }
        }
      }, sy = Nh["react-stack-bottom-frame"].bind(Nh), ry = {
        "react-stack-bottom-frame": function(l) {
          var u = l.create;
          return l = l.inst, u = u(), l.destroy = u;
        }
      }, mo = ry["react-stack-bottom-frame"].bind(ry), Yf = {
        "react-stack-bottom-frame": function(l, u, S) {
          try {
            S();
          } catch (x) {
            $a(l, u, x);
          }
        }
      }, Sp = Yf["react-stack-bottom-frame"].bind(Yf), oy = {
        "react-stack-bottom-frame": function(l) {
          var u = l._init;
          return u(l._payload);
        }
      }, Uu = oy["react-stack-bottom-frame"].bind(oy), ws = null, Hr = 0, oa = null, uy, $0 = uy = !1, Mv = {}, xv = {}, Tv = {};
      G = function(l, u, S) {
        if (S !== null && typeof S == "object" && S._store && (!S._store.validated && S.key == null || S._store.validated === 2)) {
          if (typeof S._store != "object")
            throw Error(
              "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
            );
          S._store.validated = 1;
          var x = Y(l), O = x || "null";
          if (!Mv[O]) {
            Mv[O] = !0, S = S._owner, l = l._debugOwner;
            var L = "";
            l && typeof l.tag == "number" && (O = Y(l)) && (L = `

Check the render method of \`` + O + "`."), L || x && (L = `

Check the top-level render call using <` + x + ">.");
            var J = "";
            S != null && l !== S && (x = null, typeof S.tag == "number" ? x = Y(S) : typeof S.name == "string" && (x = S.name), x && (J = " It was passed a child from " + x + ".")), me(u, function() {
              console.error(
                'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                L,
                J
              );
            });
          }
        }
      };
      var Tm = Km(!0), kc = Km(!1), qf = ue(null), cy = ue(0), Ou = ue(null), Wc = null, _p = 1, Zf = 2, Ns = ue(0), hc = 0, $c = 1, vo = 2, fs = 4, js = 8, Cv, r0 = /* @__PURE__ */ new Set(), Rg = /* @__PURE__ */ new Set(), Cm = /* @__PURE__ */ new Set(), Dg = /* @__PURE__ */ new Set(), Js = 0, Gn = null, el = null, ds = null, Bg = !1, Rm = !1, Ap = !1, Rv = 0, Dv = 0, ef = null, u_ = 0, c_ = 25, vt = null, wu = null, Qf = -1, Bv = !1, fy = function() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }, Nu = {
        readContext: Ln,
        use: mf,
        useCallback: dl,
        useContext: dl,
        useEffect: dl,
        useImperativeHandle: dl,
        useLayoutEffect: dl,
        useInsertionEffect: dl,
        useMemo: dl,
        useReducer: dl,
        useRef: dl,
        useState: dl,
        useDebugValue: dl,
        useDeferredValue: dl,
        useTransition: dl,
        useSyncExternalStore: dl,
        useId: dl
      };
      Nu.useCacheRefresh = dl, Nu.useMemoCache = dl, Nu.useHostTransitionStatus = dl, Nu.useFormState = dl, Nu.useActionState = dl, Nu.useOptimistic = dl;
      var go = null, zu = null, Ko = null, Ld = null, Lr = null, hs = null, Ep = null;
      go = {
        readContext: function(l) {
          return Ln(l);
        },
        use: mf,
        useCallback: function(l, u) {
          return vt = "useCallback", ra(), bc(u), Wm(l, u);
        },
        useContext: function(l) {
          return vt = "useContext", ra(), Ln(l);
        },
        useEffect: function(l, u) {
          return vt = "useEffect", ra(), bc(u), sh(l, u);
        },
        useImperativeHandle: function(l, u, S) {
          return vt = "useImperativeHandle", ra(), bc(S), ud(l, u, S);
        },
        useInsertionEffect: function(l, u) {
          vt = "useInsertionEffect", ra(), bc(u), $s(4, vo, l, u);
        },
        useLayoutEffect: function(l, u) {
          return vt = "useLayoutEffect", ra(), bc(u), yf(l, u);
        },
        useMemo: function(l, u) {
          vt = "useMemo", ra(), bc(u);
          var S = ft.H;
          ft.H = Lr;
          try {
            return Dc(l, u);
          } finally {
            ft.H = S;
          }
        },
        useReducer: function(l, u, S) {
          vt = "useReducer", ra();
          var x = ft.H;
          ft.H = Lr;
          try {
            return ou(l, u, S);
          } finally {
            ft.H = x;
          }
        },
        useRef: function(l) {
          return vt = "useRef", ra(), Qp(l);
        },
        useState: function(l) {
          vt = "useState", ra();
          var u = ft.H;
          ft.H = Lr;
          try {
            return xc(l);
          } finally {
            ft.H = u;
          }
        },
        useDebugValue: function() {
          vt = "useDebugValue", ra();
        },
        useDeferredValue: function(l, u) {
          return vt = "useDeferredValue", ra(), Qu(l, u);
        },
        useTransition: function() {
          return vt = "useTransition", ra(), jp();
        },
        useSyncExternalStore: function(l, u, S) {
          return vt = "useSyncExternalStore", ra(), rd(
            l,
            u,
            S
          );
        },
        useId: function() {
          return vt = "useId", ra(), Uo();
        },
        useCacheRefresh: function() {
          return vt = "useCacheRefresh", ra(), _f();
        }
      }, go.useMemoCache = vf, go.useHostTransitionStatus = ys, go.useFormState = function(l, u) {
        return vt = "useFormState", ra(), qu(), Bo(l, u);
      }, go.useActionState = function(l, u) {
        return vt = "useActionState", ra(), Bo(l, u);
      }, go.useOptimistic = function(l) {
        return vt = "useOptimistic", ra(), Zu(l);
      }, zu = {
        readContext: function(l) {
          return Ln(l);
        },
        use: mf,
        useCallback: function(l, u) {
          return vt = "useCallback", Yt(), Wm(l, u);
        },
        useContext: function(l) {
          return vt = "useContext", Yt(), Ln(l);
        },
        useEffect: function(l, u) {
          return vt = "useEffect", Yt(), sh(l, u);
        },
        useImperativeHandle: function(l, u, S) {
          return vt = "useImperativeHandle", Yt(), ud(l, u, S);
        },
        useInsertionEffect: function(l, u) {
          vt = "useInsertionEffect", Yt(), $s(4, vo, l, u);
        },
        useLayoutEffect: function(l, u) {
          return vt = "useLayoutEffect", Yt(), yf(l, u);
        },
        useMemo: function(l, u) {
          vt = "useMemo", Yt();
          var S = ft.H;
          ft.H = Lr;
          try {
            return Dc(l, u);
          } finally {
            ft.H = S;
          }
        },
        useReducer: function(l, u, S) {
          vt = "useReducer", Yt();
          var x = ft.H;
          ft.H = Lr;
          try {
            return ou(l, u, S);
          } finally {
            ft.H = x;
          }
        },
        useRef: function(l) {
          return vt = "useRef", Yt(), Qp(l);
        },
        useState: function(l) {
          vt = "useState", Yt();
          var u = ft.H;
          ft.H = Lr;
          try {
            return xc(l);
          } finally {
            ft.H = u;
          }
        },
        useDebugValue: function() {
          vt = "useDebugValue", Yt();
        },
        useDeferredValue: function(l, u) {
          return vt = "useDeferredValue", Yt(), Qu(l, u);
        },
        useTransition: function() {
          return vt = "useTransition", Yt(), jp();
        },
        useSyncExternalStore: function(l, u, S) {
          return vt = "useSyncExternalStore", Yt(), rd(
            l,
            u,
            S
          );
        },
        useId: function() {
          return vt = "useId", Yt(), Uo();
        },
        useCacheRefresh: function() {
          return vt = "useCacheRefresh", Yt(), _f();
        }
      }, zu.useMemoCache = vf, zu.useHostTransitionStatus = ys, zu.useFormState = function(l, u) {
        return vt = "useFormState", Yt(), qu(), Bo(l, u);
      }, zu.useActionState = function(l, u) {
        return vt = "useActionState", Yt(), Bo(l, u);
      }, zu.useOptimistic = function(l) {
        return vt = "useOptimistic", Yt(), Zu(l);
      }, Ko = {
        readContext: function(l) {
          return Ln(l);
        },
        use: mf,
        useCallback: function(l, u) {
          return vt = "useCallback", Yt(), Jh(l, u);
        },
        useContext: function(l) {
          return vt = "useContext", Yt(), Ln(l);
        },
        useEffect: function(l, u) {
          vt = "useEffect", Yt(), Fs(2048, js, l, u);
        },
        useImperativeHandle: function(l, u, S) {
          return vt = "useImperativeHandle", Yt(), yi(l, u, S);
        },
        useInsertionEffect: function(l, u) {
          return vt = "useInsertionEffect", Yt(), Fs(4, vo, l, u);
        },
        useLayoutEffect: function(l, u) {
          return vt = "useLayoutEffect", Yt(), Fs(4, fs, l, u);
        },
        useMemo: function(l, u) {
          vt = "useMemo", Yt();
          var S = ft.H;
          ft.H = hs;
          try {
            return gr(l, u);
          } finally {
            ft.H = S;
          }
        },
        useReducer: function(l, u, S) {
          vt = "useReducer", Yt();
          var x = ft.H;
          ft.H = hs;
          try {
            return uu(l, u, S);
          } finally {
            ft.H = x;
          }
        },
        useRef: function() {
          return vt = "useRef", Yt(), fi().memoizedState;
        },
        useState: function() {
          vt = "useState", Yt();
          var l = ft.H;
          ft.H = hs;
          try {
            return uu(Do);
          } finally {
            ft.H = l;
          }
        },
        useDebugValue: function() {
          vt = "useDebugValue", Yt();
        },
        useDeferredValue: function(l, u) {
          return vt = "useDeferredValue", Yt(), $m(l, u);
        },
        useTransition: function() {
          return vt = "useTransition", Yt(), rh();
        },
        useSyncExternalStore: function(l, u, S) {
          return vt = "useSyncExternalStore", Yt(), $d(
            l,
            u,
            S
          );
        },
        useId: function() {
          return vt = "useId", Yt(), fi().memoizedState;
        },
        useCacheRefresh: function() {
          return vt = "useCacheRefresh", Yt(), fi().memoizedState;
        }
      }, Ko.useMemoCache = vf, Ko.useHostTransitionStatus = ys, Ko.useFormState = function(l) {
        return vt = "useFormState", Yt(), qu(), lh(l);
      }, Ko.useActionState = function(l) {
        return vt = "useActionState", Yt(), lh(l);
      }, Ko.useOptimistic = function(l, u) {
        return vt = "useOptimistic", Yt(), th(l, u);
      }, Ld = {
        readContext: function(l) {
          return Ln(l);
        },
        use: mf,
        useCallback: function(l, u) {
          return vt = "useCallback", Yt(), Jh(l, u);
        },
        useContext: function(l) {
          return vt = "useContext", Yt(), Ln(l);
        },
        useEffect: function(l, u) {
          vt = "useEffect", Yt(), Fs(2048, js, l, u);
        },
        useImperativeHandle: function(l, u, S) {
          return vt = "useImperativeHandle", Yt(), yi(l, u, S);
        },
        useInsertionEffect: function(l, u) {
          return vt = "useInsertionEffect", Yt(), Fs(4, vo, l, u);
        },
        useLayoutEffect: function(l, u) {
          return vt = "useLayoutEffect", Yt(), Fs(4, fs, l, u);
        },
        useMemo: function(l, u) {
          vt = "useMemo", Yt();
          var S = ft.H;
          ft.H = Ep;
          try {
            return gr(l, u);
          } finally {
            ft.H = S;
          }
        },
        useReducer: function(l, u, S) {
          vt = "useReducer", Yt();
          var x = ft.H;
          ft.H = Ep;
          try {
            return vs(l, u, S);
          } finally {
            ft.H = x;
          }
        },
        useRef: function() {
          return vt = "useRef", Yt(), fi().memoizedState;
        },
        useState: function() {
          vt = "useState", Yt();
          var l = ft.H;
          ft.H = Ep;
          try {
            return vs(Do);
          } finally {
            ft.H = l;
          }
        },
        useDebugValue: function() {
          vt = "useDebugValue", Yt();
        },
        useDeferredValue: function(l, u) {
          return vt = "useDeferredValue", Yt(), gs(l, u);
        },
        useTransition: function() {
          return vt = "useTransition", Yt(), Sf();
        },
        useSyncExternalStore: function(l, u, S) {
          return vt = "useSyncExternalStore", Yt(), $d(
            l,
            u,
            S
          );
        },
        useId: function() {
          return vt = "useId", Yt(), fi().memoizedState;
        },
        useCacheRefresh: function() {
          return vt = "useCacheRefresh", Yt(), fi().memoizedState;
        }
      }, Ld.useMemoCache = vf, Ld.useHostTransitionStatus = ys, Ld.useFormState = function(l) {
        return vt = "useFormState", Yt(), qu(), Yr(l);
      }, Ld.useActionState = function(l) {
        return vt = "useActionState", Yt(), Yr(l);
      }, Ld.useOptimistic = function(l, u) {
        return vt = "useOptimistic", Yt(), ah(l, u);
      }, Lr = {
        readContext: function(l) {
          return z(), Ln(l);
        },
        use: function(l) {
          return B(), mf(l);
        },
        useCallback: function(l, u) {
          return vt = "useCallback", B(), ra(), Wm(l, u);
        },
        useContext: function(l) {
          return vt = "useContext", B(), ra(), Ln(l);
        },
        useEffect: function(l, u) {
          return vt = "useEffect", B(), ra(), sh(l, u);
        },
        useImperativeHandle: function(l, u, S) {
          return vt = "useImperativeHandle", B(), ra(), ud(l, u, S);
        },
        useInsertionEffect: function(l, u) {
          vt = "useInsertionEffect", B(), ra(), $s(4, vo, l, u);
        },
        useLayoutEffect: function(l, u) {
          return vt = "useLayoutEffect", B(), ra(), yf(l, u);
        },
        useMemo: function(l, u) {
          vt = "useMemo", B(), ra();
          var S = ft.H;
          ft.H = Lr;
          try {
            return Dc(l, u);
          } finally {
            ft.H = S;
          }
        },
        useReducer: function(l, u, S) {
          vt = "useReducer", B(), ra();
          var x = ft.H;
          ft.H = Lr;
          try {
            return ou(l, u, S);
          } finally {
            ft.H = x;
          }
        },
        useRef: function(l) {
          return vt = "useRef", B(), ra(), Qp(l);
        },
        useState: function(l) {
          vt = "useState", B(), ra();
          var u = ft.H;
          ft.H = Lr;
          try {
            return xc(l);
          } finally {
            ft.H = u;
          }
        },
        useDebugValue: function() {
          vt = "useDebugValue", B(), ra();
        },
        useDeferredValue: function(l, u) {
          return vt = "useDeferredValue", B(), ra(), Qu(l, u);
        },
        useTransition: function() {
          return vt = "useTransition", B(), ra(), jp();
        },
        useSyncExternalStore: function(l, u, S) {
          return vt = "useSyncExternalStore", B(), ra(), rd(
            l,
            u,
            S
          );
        },
        useId: function() {
          return vt = "useId", B(), ra(), Uo();
        },
        useCacheRefresh: function() {
          return vt = "useCacheRefresh", ra(), _f();
        },
        useMemoCache: function(l) {
          return B(), vf(l);
        }
      }, Lr.useHostTransitionStatus = ys, Lr.useFormState = function(l, u) {
        return vt = "useFormState", B(), ra(), Bo(l, u);
      }, Lr.useActionState = function(l, u) {
        return vt = "useActionState", B(), ra(), Bo(l, u);
      }, Lr.useOptimistic = function(l) {
        return vt = "useOptimistic", B(), ra(), Zu(l);
      }, hs = {
        readContext: function(l) {
          return z(), Ln(l);
        },
        use: function(l) {
          return B(), mf(l);
        },
        useCallback: function(l, u) {
          return vt = "useCallback", B(), Yt(), Jh(l, u);
        },
        useContext: function(l) {
          return vt = "useContext", B(), Yt(), Ln(l);
        },
        useEffect: function(l, u) {
          vt = "useEffect", B(), Yt(), Fs(2048, js, l, u);
        },
        useImperativeHandle: function(l, u, S) {
          return vt = "useImperativeHandle", B(), Yt(), yi(l, u, S);
        },
        useInsertionEffect: function(l, u) {
          return vt = "useInsertionEffect", B(), Yt(), Fs(4, vo, l, u);
        },
        useLayoutEffect: function(l, u) {
          return vt = "useLayoutEffect", B(), Yt(), Fs(4, fs, l, u);
        },
        useMemo: function(l, u) {
          vt = "useMemo", B(), Yt();
          var S = ft.H;
          ft.H = hs;
          try {
            return gr(l, u);
          } finally {
            ft.H = S;
          }
        },
        useReducer: function(l, u, S) {
          vt = "useReducer", B(), Yt();
          var x = ft.H;
          ft.H = hs;
          try {
            return uu(l, u, S);
          } finally {
            ft.H = x;
          }
        },
        useRef: function() {
          return vt = "useRef", B(), Yt(), fi().memoizedState;
        },
        useState: function() {
          vt = "useState", B(), Yt();
          var l = ft.H;
          ft.H = hs;
          try {
            return uu(Do);
          } finally {
            ft.H = l;
          }
        },
        useDebugValue: function() {
          vt = "useDebugValue", B(), Yt();
        },
        useDeferredValue: function(l, u) {
          return vt = "useDeferredValue", B(), Yt(), $m(l, u);
        },
        useTransition: function() {
          return vt = "useTransition", B(), Yt(), rh();
        },
        useSyncExternalStore: function(l, u, S) {
          return vt = "useSyncExternalStore", B(), Yt(), $d(
            l,
            u,
            S
          );
        },
        useId: function() {
          return vt = "useId", B(), Yt(), fi().memoizedState;
        },
        useCacheRefresh: function() {
          return vt = "useCacheRefresh", Yt(), fi().memoizedState;
        },
        useMemoCache: function(l) {
          return B(), vf(l);
        }
      }, hs.useHostTransitionStatus = ys, hs.useFormState = function(l) {
        return vt = "useFormState", B(), Yt(), lh(l);
      }, hs.useActionState = function(l) {
        return vt = "useActionState", B(), Yt(), lh(l);
      }, hs.useOptimistic = function(l, u) {
        return vt = "useOptimistic", B(), Yt(), th(l, u);
      }, Ep = {
        readContext: function(l) {
          return z(), Ln(l);
        },
        use: function(l) {
          return B(), mf(l);
        },
        useCallback: function(l, u) {
          return vt = "useCallback", B(), Yt(), Jh(l, u);
        },
        useContext: function(l) {
          return vt = "useContext", B(), Yt(), Ln(l);
        },
        useEffect: function(l, u) {
          vt = "useEffect", B(), Yt(), Fs(2048, js, l, u);
        },
        useImperativeHandle: function(l, u, S) {
          return vt = "useImperativeHandle", B(), Yt(), yi(l, u, S);
        },
        useInsertionEffect: function(l, u) {
          return vt = "useInsertionEffect", B(), Yt(), Fs(4, vo, l, u);
        },
        useLayoutEffect: function(l, u) {
          return vt = "useLayoutEffect", B(), Yt(), Fs(4, fs, l, u);
        },
        useMemo: function(l, u) {
          vt = "useMemo", B(), Yt();
          var S = ft.H;
          ft.H = hs;
          try {
            return gr(l, u);
          } finally {
            ft.H = S;
          }
        },
        useReducer: function(l, u, S) {
          vt = "useReducer", B(), Yt();
          var x = ft.H;
          ft.H = hs;
          try {
            return vs(l, u, S);
          } finally {
            ft.H = x;
          }
        },
        useRef: function() {
          return vt = "useRef", B(), Yt(), fi().memoizedState;
        },
        useState: function() {
          vt = "useState", B(), Yt();
          var l = ft.H;
          ft.H = hs;
          try {
            return vs(Do);
          } finally {
            ft.H = l;
          }
        },
        useDebugValue: function() {
          vt = "useDebugValue", B(), Yt();
        },
        useDeferredValue: function(l, u) {
          return vt = "useDeferredValue", B(), Yt(), gs(l, u);
        },
        useTransition: function() {
          return vt = "useTransition", B(), Yt(), Sf();
        },
        useSyncExternalStore: function(l, u, S) {
          return vt = "useSyncExternalStore", B(), Yt(), $d(
            l,
            u,
            S
          );
        },
        useId: function() {
          return vt = "useId", B(), Yt(), fi().memoizedState;
        },
        useCacheRefresh: function() {
          return vt = "useCacheRefresh", Yt(), fi().memoizedState;
        },
        useMemoCache: function(l) {
          return B(), vf(l);
        }
      }, Ep.useHostTransitionStatus = ys, Ep.useFormState = function(l) {
        return vt = "useFormState", B(), Yt(), Yr(l);
      }, Ep.useActionState = function(l) {
        return vt = "useActionState", B(), Yt(), Yr(l);
      }, Ep.useOptimistic = function(l, u) {
        return vt = "useOptimistic", B(), Yt(), ah(l, u);
      };
      var Dm = {}, Bm = /* @__PURE__ */ new Set(), eS = /* @__PURE__ */ new Set(), o0 = /* @__PURE__ */ new Set(), Ug = /* @__PURE__ */ new Set(), Og = /* @__PURE__ */ new Set(), Uv = /* @__PURE__ */ new Set(), dy = /* @__PURE__ */ new Set(), Um = /* @__PURE__ */ new Set(), u0 = /* @__PURE__ */ new Set(), Gd = /* @__PURE__ */ new Set();
      Object.freeze(Dm);
      var hy = {
        isMounted: function(l) {
          var u = rs;
          if (u !== null && Dl && u.tag === 1) {
            var S = u.stateNode;
            S._warnedAboutRefsInRender || console.error(
              "%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.",
              Y(u) || "A component"
            ), S._warnedAboutRefsInRender = !0;
          }
          return (l = l._reactInternals) ? Ae(l) === l : !1;
        },
        enqueueSetState: function(l, u, S) {
          l = l._reactInternals;
          var x = Cr(l), O = Wi(x);
          O.payload = u, S != null && (Jp(S), O.callback = S), u = Hl(l, O, x), u !== null && (ha(u, l, x), Pr(u, l, x)), Xt(l, x);
        },
        enqueueReplaceState: function(l, u, S) {
          l = l._reactInternals;
          var x = Cr(l), O = Wi(x);
          O.tag = iy, O.payload = u, S != null && (Jp(S), O.callback = S), u = Hl(l, O, x), u !== null && (ha(u, l, x), Pr(u, l, x)), Xt(l, x);
        },
        enqueueForceUpdate: function(l, u) {
          l = l._reactInternals;
          var S = Cr(l), x = Wi(S);
          x.tag = _a, u != null && (Jp(u), x.callback = u), u = Hl(l, x, S), u !== null && (ha(u, l, S), Pr(u, l, S)), an !== null && typeof an.markForceUpdateScheduled == "function" && an.markForceUpdateScheduled(l, S);
        }
      }, py = typeof reportError == "function" ? reportError : function(l) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var u = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof l == "object" && l !== null && typeof l.message == "string" ? String(l.message) : String(l),
            error: l
          });
          if (!window.dispatchEvent(u)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", l);
          return;
        }
        console.error(l);
      }, Om = null, yo = null, wg = Error(
        "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
      ), s = !1, f = {}, v = {}, A = {}, U = {}, H = !1, W = {}, oe = {}, be = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
      }, et = !1, Rt = ue(null), zt = ue(null), at = ue(null), lt = {}, Yn = null, In = null, ti = !1, Qe = typeof AbortController < "u" ? AbortController : function() {
        var l = [], u = this.signal = {
          aborted: !1,
          addEventListener: function(S, x) {
            l.push(x);
          }
        };
        this.abort = function() {
          u.aborted = !0, l.forEach(function(S) {
            return S();
          });
        };
      }, Ve = Dr.unstable_scheduleCallback, ke = Dr.unstable_NormalPriority, gt = {
        $$typeof: La,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
        _currentRenderer: null,
        _currentRenderer2: null
      }, Cn = ft.S;
      ft.S = function(l, u) {
        typeof u == "object" && u !== null && typeof u.then == "function" && Ta(l, u), Cn !== null && Cn(l, u);
      };
      var Aa = ue(null), Pn = null;
      Pn = /* @__PURE__ */ new Set();
      var Xn = !1, Za = !1, ci = !1, bp = typeof WeakSet == "function" ? WeakSet : Set, Gr = null, c0 = null, f0 = null, _E = !1, fr = null, Id = !1, Mp = null, d0 = 8192, Fx = {
        getCacheForType: function(l) {
          var u = Ln(gt), S = u.data.get(l);
          return S === void 0 && (S = l(), u.data.set(l, S)), S;
        },
        getOwner: function() {
          return rs;
        }
      }, f_ = 0, d_ = 1, h_ = 2, tS = 3, p_ = 4;
      if (typeof Symbol == "function" && Symbol.for) {
        var nS = Symbol.for;
        f_ = nS("selector.component"), d_ = nS("selector.has_pseudo_class"), h_ = nS("selector.role"), tS = nS("selector.test_id"), p_ = nS("selector.text");
      }
      var m_ = [], Px = typeof WeakMap == "function" ? WeakMap : Map, tf = 0, pc = 2, wm = 4, Ov = 0, aS = 1, my = 2, iS = 3, xp = 4, AE = 5, lS = 6, ki = tf, El = null, ka = null, wa = 0, jf = 0, wv = 1, Tp = 2, h0 = 3, mc = 4, N1 = 5, Cp = 6, vy = 7, gy = 8, sl = jf, ko = null, Rp = !1, yy = !1, v_ = !1, Dp = 0, zs = Ov, Ng = 0, zg = 0, z1 = 0, Jf = 0, Hg = 0, Sy = null, Vd = null, p0 = !1, Nv = 0, Fd = 300, Nm = 1 / 0, sS = 500, zh = null, So = null, zv = !1, Xi = null, rS = 0, _o = 0, Wo = null, Bp = 50, m0 = 0, g_ = null, y_ = !1, Hv = !1, v0 = 50, zm = 0, Lg = null, Hu = !1, Pd = 0, _y = 1, Lv = 2, Hh = null, vc = !1, Hs = /* @__PURE__ */ new Set(), Di = {}, Ir = null, Lu = null, Gg = !1;
      try {
        var Up = Object.preventExtensions({});
      } catch {
        Gg = !0;
      }
      var S_ = !1, H1 = {}, EE = null, L1 = null, bE = null, __ = null, A_ = null, G1 = null, oS = null, Ay = null, Ey = null;
      return EE = function(l, u, S, x) {
        u = t(l, u), u !== null && (S = a(u.memoizedState, S, 0, x), u.memoizedState = S, u.baseState = S, l.memoizedProps = Ti({}, l.memoizedProps), S = Ee(l, 2), S !== null && ha(S, l, 2));
      }, L1 = function(l, u, S) {
        u = t(l, u), u !== null && (S = p(u.memoizedState, S, 0), u.memoizedState = S, u.baseState = S, l.memoizedProps = Ti({}, l.memoizedProps), S = Ee(l, 2), S !== null && ha(S, l, 2));
      }, bE = function(l, u, S, x) {
        u = t(l, u), u !== null && (S = r(u.memoizedState, S, x), u.memoizedState = S, u.baseState = S, l.memoizedProps = Ti({}, l.memoizedProps), S = Ee(l, 2), S !== null && ha(S, l, 2));
      }, __ = function(l, u, S) {
        l.pendingProps = a(l.memoizedProps, u, 0, S), l.alternate && (l.alternate.pendingProps = l.pendingProps), u = Ee(l, 2), u !== null && ha(u, l, 2);
      }, A_ = function(l, u) {
        l.pendingProps = p(l.memoizedProps, u, 0), l.alternate && (l.alternate.pendingProps = l.pendingProps), u = Ee(l, 2), u !== null && ha(u, l, 2);
      }, G1 = function(l, u, S) {
        l.pendingProps = r(
          l.memoizedProps,
          u,
          S
        ), l.alternate && (l.alternate.pendingProps = l.pendingProps), u = Ee(l, 2), u !== null && ha(u, l, 2);
      }, oS = function(l) {
        var u = Ee(l, 2);
        u !== null && ha(u, l, 2);
      }, Ay = function(l) {
        _ = l;
      }, Ey = function(l) {
        y = l;
      }, pa.attemptContinuousHydration = function(l) {
        if (l.tag === 13) {
          var u = Ee(l, 67108864);
          u !== null && ha(u, l, 67108864), Bf(l, 67108864);
        }
      }, pa.attemptHydrationAtCurrentPriority = function(l) {
        if (l.tag === 13) {
          var u = Cr(l), S = Ee(l, u);
          S !== null && ha(S, l, u), Bf(l, u);
        }
      }, pa.attemptSynchronousHydration = function(l) {
        switch (l.tag) {
          case 3:
            if (l = l.stateNode, l.current.memoizedState.isDehydrated) {
              var u = Ze(l.pendingLanes);
              if (u !== 0) {
                for (l.pendingLanes |= 2, l.entangledLanes |= 2; u; ) {
                  var S = 1 << 31 - $i(u);
                  l.entanglements[1] |= S, u &= ~S;
                }
                ca(l), (ki & (pc | wm)) === tf && (Nm = Z() + sS, yn(0));
              }
            }
            break;
          case 13:
            u = Ee(l, 2), u !== null && ha(u, l, 2), tc(), Bf(l, 2);
        }
      }, pa.batchedUpdates = function(l, u) {
        return l(u);
      }, pa.createComponentSelector = function(l) {
        return { $$typeof: f_, value: l };
      }, pa.createContainer = function(l, u, S, x, O, L, J, he, Pe, ht) {
        return ey(
          l,
          u,
          !1,
          null,
          S,
          x,
          L,
          J,
          he,
          Pe,
          ht,
          null
        );
      }, pa.createHasPseudoClassSelector = function(l) {
        return { $$typeof: d_, value: l };
      }, pa.createHydrationContainer = function(l, u, S, x, O, L, J, he, Pe, ht, Kt, ln, Sn) {
        return l = ey(
          S,
          x,
          !0,
          l,
          O,
          L,
          he,
          Pe,
          ht,
          Kt,
          ln,
          Sn
        ), l.context = fm(null), S = l.current, x = Cr(S), O = Wi(x), O.callback = u ?? null, Hl(S, O, x), l.current.lanes = x, Zn(l, x), ca(l), l;
      }, pa.createPortal = function(l, u, S) {
        var x = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        try {
          no(x);
          var O = !1;
        } catch {
          O = !0;
        }
        return O && (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          typeof Symbol == "function" && Symbol.toStringTag && x[Symbol.toStringTag] || x.constructor.name || "Object"
        ), no(x)), {
          $$typeof: oi,
          key: x == null ? null : "" + x,
          children: l,
          containerInfo: u,
          implementation: S
        };
      }, pa.createRoleSelector = function(l) {
        return { $$typeof: h_, value: l };
      }, pa.createTestNameSelector = function(l) {
        return { $$typeof: tS, value: l };
      }, pa.createTextSelector = function(l) {
        return { $$typeof: p_, value: l };
      }, pa.defaultOnCaughtError = function(l, u) {
        var S = Om ? "The above error occurred in the <" + Om + "> component." : "The above error occurred in one of your React components.", x = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((yo || "Anonymous") + "."), O = ft.getCurrentStack, L = u.componentStack != null ? u.componentStack : "";
        ft.getCurrentStack = function() {
          return L;
        };
        try {
          typeof l == "object" && l !== null && typeof l.environmentName == "string" ? lr(
            "error",
            [
              `%o

%s

%s
`,
              l,
              S,
              x
            ],
            l.environmentName
          )() : console.error(
            `%o

%s

%s
`,
            l,
            S,
            x
          );
        } finally {
          ft.getCurrentStack = O;
        }
      }, pa.defaultOnRecoverableError = function(l) {
        py(l);
      }, pa.defaultOnUncaughtError = function(l, u) {
        py(l), l = Om ? "An error occurred in the <" + Om + "> component." : "An error occurred in one of your React components.";
        var S = ft.getCurrentStack, x = u.componentStack != null ? u.componentStack : "";
        ft.getCurrentStack = function() {
          return x;
        };
        try {
          console.warn(
            `%s

%s
`,
            l,
            `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`
          );
        } finally {
          ft.getCurrentStack = S;
        }
      }, pa.deferredUpdates = function(l) {
        var u = ft.T, S = Pc();
        try {
          return Tn(32), ft.T = null, l();
        } finally {
          Tn(S), ft.T = u;
        }
      }, pa.discreteUpdates = function(l, u, S, x, O) {
        var L = ft.T, J = Pc();
        try {
          return Tn(2), ft.T = null, l(u, S, x, O);
        } finally {
          Tn(J), ft.T = L, ki === tf && (Nm = Z() + sS);
        }
      }, pa.findAllNodes = sv, pa.findBoundingRects = function(l, u) {
        if (!ro)
          throw Error("Test selector API is not supported by this renderer.");
        u = sv(l, u), l = [];
        for (var S = 0; S < u.length; S++)
          l.push(ji(u[S]));
        for (u = l.length - 1; 0 < u; u--) {
          S = l[u];
          for (var x = S.x, O = x + S.width, L = S.y, J = L + S.height, he = u - 1; 0 <= he; he--)
            if (u !== he) {
              var Pe = l[he], ht = Pe.x, Kt = ht + Pe.width, ln = Pe.y, Sn = ln + Pe.height;
              if (x >= ht && L >= ln && O <= Kt && J <= Sn) {
                l.splice(u, 1);
                break;
              } else if (x !== ht || S.width !== Pe.width || Sn < L || ln > J) {
                if (!(L !== ln || S.height !== Pe.height || Kt < x || ht > O)) {
                  ht > x && (Pe.width += ht - x, Pe.x = x), Kt < O && (Pe.width = O - ht), l.splice(u, 1);
                  break;
                }
              } else {
                ln > L && (Pe.height += ln - L, Pe.y = L), Sn < J && (Pe.height = J - ln), l.splice(u, 1);
                break;
              }
            }
        }
        return l;
      }, pa.findHostInstance = function(l) {
        var u = l._reactInternals;
        if (u === void 0)
          throw typeof l.render == "function" ? Error("Unable to find node on an unmounted component.") : (l = Object.keys(l).join(","), Error(
            "Argument appears to not be a ReactComponent. Keys: " + l
          ));
        return l = te(u), l === null ? null : lo(l.stateNode);
      }, pa.findHostInstanceWithNoPortals = function(l) {
        return l = P(l), l = l !== null ? Se(l) : null, l === null ? null : lo(l.stateNode);
      }, pa.findHostInstanceWithWarning = function(l, u) {
        var S = l._reactInternals;
        if (S === void 0)
          throw typeof l.render == "function" ? Error("Unable to find node on an unmounted component.") : (l = Object.keys(l).join(","), Error(
            "Argument appears to not be a ReactComponent. Keys: " + l
          ));
        if (l = te(S), l === null) return null;
        if (l.mode & 8) {
          var x = Y(S) || "Component";
          H1[x] || (H1[x] = !0, me(l, function() {
            S.mode & 8 ? console.error(
              "%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node",
              u,
              u,
              x
            ) : console.error(
              "%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node",
              u,
              u,
              x
            );
          }));
        }
        return lo(l.stateNode);
      }, pa.flushPassiveEffects = Hc, pa.flushSyncFromReconciler = function(l) {
        var u = ki;
        ki |= 1;
        var S = ft.T, x = Pc();
        try {
          if (Tn(2), ft.T = null, l)
            return l();
        } finally {
          Tn(x), ft.T = S, ki = u, (ki & (pc | wm)) === tf && yn(0);
        }
      }, pa.flushSyncWork = tc, pa.focusWithin = function(l, u) {
        if (!ro)
          throw Error("Test selector API is not supported by this renderer.");
        for (l = As(l), u = sg(l, u), u = Array.from(u), l = 0; l < u.length; ) {
          var S = u[l++], x = S.tag;
          if (!Cs(S)) {
            if ((x === 5 || x === 26 || x === 27) && Jl(S.stateNode))
              return !0;
            for (S = S.child; S !== null; )
              u.push(S), S = S.sibling;
          }
        }
        return !1;
      }, pa.getFindAllNodesFailureDescription = function(l, u) {
        if (!ro)
          throw Error("Test selector API is not supported by this renderer.");
        var S = 0, x = [];
        l = [As(l), 0];
        for (var O = 0; O < l.length; ) {
          var L = l[O++], J = L.tag, he = l[O++], Pe = u[he];
          if ((J !== 5 && J !== 26 && J !== 27 || !Cs(L)) && (ec(L, Pe) && (x.push(Rf(Pe)), he++, he > S && (S = he)), he < u.length))
            for (L = L.child; L !== null; )
              l.push(L, he), L = L.sibling;
        }
        if (S < u.length) {
          for (l = []; S < u.length; S++)
            l.push(Rf(u[S]));
          return `findAllNodes was able to match part of the selector:
  ` + (x.join(" > ") + `

No matching component was found for:
  `) + l.join(" > ");
        }
        return null;
      }, pa.getPublicRootInstance = function(l) {
        if (l = l.current, !l.child) return null;
        switch (l.child.tag) {
          case 27:
          case 5:
            return lo(l.child.stateNode);
          default:
            return l.child.stateNode;
        }
      }, pa.injectIntoDevTools = function() {
        var l = {
          bundleType: 1,
          version: up,
          rendererPackageName: Po,
          currentDispatcherRef: ft,
          findFiberByHostInstance: Fc,
          reconcilerVersion: "19.0.0"
        };
        return Ur !== null && (l.rendererConfig = Ur), l.overrideHookState = EE, l.overrideHookStateDeletePath = L1, l.overrideHookStateRenamePath = bE, l.overrideProps = __, l.overridePropsDeletePath = A_, l.overridePropsRenamePath = G1, l.scheduleUpdate = oS, l.setErrorHandler = Ay, l.setSuspenseHandler = Ey, l.scheduleRefresh = C, l.scheduleRoot = T, l.setRefreshHandler = D, l.getCurrentFiber = hm, l.getLaneLabelMap = pv, l.injectProfilingHooks = se, kt(l);
      }, pa.isAlreadyRendering = function() {
        return (ki & (pc | wm)) !== tf;
      }, pa.observeVisibleRects = function(l, u, S, x) {
        function O() {
          var ht = sv(l, u);
          L.forEach(function(Kt) {
            0 > ht.indexOf(Kt) && Pe(Kt);
          }), ht.forEach(function(Kt) {
            0 > L.indexOf(Kt) && he(Kt);
          });
        }
        if (!ro)
          throw Error("Test selector API is not supported by this renderer.");
        var L = sv(l, u);
        S = Hf(L, S, x);
        var J = S.disconnect, he = S.observe, Pe = S.unobserve;
        return m_.push(O), {
          disconnect: function() {
            var ht = m_.indexOf(O);
            0 <= ht && m_.splice(ht, 1), J();
          }
        };
      }, pa.shouldError = function(l) {
        return _(l);
      }, pa.shouldSuspend = function(l) {
        return y(l);
      }, pa.startHostTransition = function(l, u, S, x) {
        if (l.tag !== 5)
          throw Error(
            "Expected the form instance to be a HostComponent. This is a bug in React."
          );
        var O = Kh(l).queue;
        Zi(
          l,
          O,
          u,
          so,
          S === null ? V : function() {
            ft.T === null && console.error(
              "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
            );
            var L = Kh(l).next.queue;
            return fu(
              l,
              L,
              {},
              Cr(l)
            ), S(x);
          }
        );
      }, pa.updateContainer = function(l, u, S, x) {
        var O = u.current, L = Cr(O);
        return hv(
          O,
          L,
          l,
          u,
          S,
          x
        ), L;
      }, pa.updateContainerSync = dm, pa;
    }, o.exports.default = o.exports, Object.defineProperty(o.exports, "__esModule", { value: !0 }));
  }(EC)), EC.exports;
}
var F3;
function a9() {
  return F3 || (F3 = 1, process.env.NODE_ENV === "production" ? qb.exports = t9() : qb.exports = n9()), qb.exports;
}
var i9 = a9();
const l9 = /* @__PURE__ */ mw(i9);
var Qb = { exports: {} }, bC = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var P3;
function s9() {
  return P3 || (P3 = 1, function(o) {
    function e(P, te) {
      var ae = P.length;
      P.push(te);
      e: for (; 0 < ae; ) {
        var Se = ae - 1 >>> 1, ue = P[Se];
        if (0 < r(ue, te))
          P[Se] = te, P[ae] = ue, ae = Se;
        else break e;
      }
    }
    function t(P) {
      return P.length === 0 ? null : P[0];
    }
    function a(P) {
      if (P.length === 0) return null;
      var te = P[0], ae = P.pop();
      if (ae !== te) {
        P[0] = ae;
        e: for (var Se = 0, ue = P.length, we = ue >>> 1; Se < we; ) {
          var De = 2 * (Se + 1) - 1, We = P[De], Me = De + 1, Ze = P[Me];
          if (0 > r(We, ae))
            Me < ue && 0 > r(Ze, We) ? (P[Se] = Ze, P[Me] = ae, Se = Me) : (P[Se] = We, P[De] = ae, Se = De);
          else if (Me < ue && 0 > r(Ze, ae))
            P[Se] = Ze, P[Me] = ae, Se = Me;
          else break e;
        }
      }
      return te;
    }
    function r(P, te) {
      var ae = P.sortIndex - te.sortIndex;
      return ae !== 0 ? ae : P.id - te.id;
    }
    if (o.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var d = performance;
      o.unstable_now = function() {
        return d.now();
      };
    } else {
      var p = Date, y = p.now();
      o.unstable_now = function() {
        return p.now() - y;
      };
    }
    var _ = [], E = [], T = 1, C = null, D = 3, B = !1, z = !1, V = !1, G = typeof setTimeout == "function" ? setTimeout : null, N = typeof clearTimeout == "function" ? clearTimeout : null, F = typeof setImmediate < "u" ? setImmediate : null;
    function q(P) {
      for (var te = t(E); te !== null; ) {
        if (te.callback === null) a(E);
        else if (te.startTime <= P)
          a(E), te.sortIndex = te.expirationTime, e(_, te);
        else break;
        te = t(E);
      }
    }
    function Y(P) {
      if (V = !1, q(P), !z)
        if (t(_) !== null)
          z = !0, Ae();
        else {
          var te = t(E);
          te !== null && He(Y, te.startTime - P);
        }
    }
    var ie = !1, k = -1, le = 5, ne = -1;
    function Q() {
      return !(o.unstable_now() - ne < le);
    }
    function j() {
      if (ie) {
        var P = o.unstable_now();
        ne = P;
        var te = !0;
        try {
          e: {
            z = !1, V && (V = !1, N(k), k = -1), B = !0;
            var ae = D;
            try {
              t: {
                for (q(P), C = t(_); C !== null && !(C.expirationTime > P && Q()); ) {
                  var Se = C.callback;
                  if (typeof Se == "function") {
                    C.callback = null, D = C.priorityLevel;
                    var ue = Se(
                      C.expirationTime <= P
                    );
                    if (P = o.unstable_now(), typeof ue == "function") {
                      C.callback = ue, q(P), te = !0;
                      break t;
                    }
                    C === t(_) && a(_), q(P);
                  } else a(_);
                  C = t(_);
                }
                if (C !== null) te = !0;
                else {
                  var we = t(E);
                  we !== null && He(
                    Y,
                    we.startTime - P
                  ), te = !1;
                }
              }
              break e;
            } finally {
              C = null, D = ae, B = !1;
            }
            te = void 0;
          }
        } finally {
          te ? re() : ie = !1;
        }
      }
    }
    var re;
    if (typeof F == "function")
      re = function() {
        F(j);
      };
    else if (typeof MessageChannel < "u") {
      var _e = new MessageChannel(), me = _e.port2;
      _e.port1.onmessage = j, re = function() {
        me.postMessage(null);
      };
    } else
      re = function() {
        G(j, 0);
      };
    function Ae() {
      ie || (ie = !0, re());
    }
    function He(P, te) {
      k = G(function() {
        P(o.unstable_now());
      }, te);
    }
    o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(P) {
      P.callback = null;
    }, o.unstable_continueExecution = function() {
      z || B || (z = !0, Ae());
    }, o.unstable_forceFrameRate = function(P) {
      0 > P || 125 < P ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : le = 0 < P ? Math.floor(1e3 / P) : 5;
    }, o.unstable_getCurrentPriorityLevel = function() {
      return D;
    }, o.unstable_getFirstCallbackNode = function() {
      return t(_);
    }, o.unstable_next = function(P) {
      switch (D) {
        case 1:
        case 2:
        case 3:
          var te = 3;
          break;
        default:
          te = D;
      }
      var ae = D;
      D = te;
      try {
        return P();
      } finally {
        D = ae;
      }
    }, o.unstable_pauseExecution = function() {
    }, o.unstable_requestPaint = function() {
    }, o.unstable_runWithPriority = function(P, te) {
      switch (P) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          P = 3;
      }
      var ae = D;
      D = P;
      try {
        return te();
      } finally {
        D = ae;
      }
    }, o.unstable_scheduleCallback = function(P, te, ae) {
      var Se = o.unstable_now();
      switch (typeof ae == "object" && ae !== null ? (ae = ae.delay, ae = typeof ae == "number" && 0 < ae ? Se + ae : Se) : ae = Se, P) {
        case 1:
          var ue = -1;
          break;
        case 2:
          ue = 250;
          break;
        case 5:
          ue = 1073741823;
          break;
        case 4:
          ue = 1e4;
          break;
        default:
          ue = 5e3;
      }
      return ue = ae + ue, P = {
        id: T++,
        callback: te,
        priorityLevel: P,
        startTime: ae,
        expirationTime: ue,
        sortIndex: -1
      }, ae > Se ? (P.sortIndex = ae, e(E, P), t(_) === null && P === t(E) && (V ? (N(k), k = -1) : V = !0, He(Y, ae - Se))) : (P.sortIndex = ue, e(_, P), z || B || (z = !0, Ae())), P;
    }, o.unstable_shouldYield = Q, o.unstable_wrapCallback = function(P) {
      var te = D;
      return function() {
        var ae = D;
        D = te;
        try {
          return P.apply(this, arguments);
        } finally {
          D = ae;
        }
      };
    };
  }(bC)), bC;
}
var MC = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var X3;
function r9() {
  return X3 || (X3 = 1, function(o) {
    process.env.NODE_ENV !== "production" && function() {
      function e() {
        if (Q) {
          var P = o.unstable_now();
          _e = P;
          var te = !0;
          try {
            e: {
              Y = !1, ie && (ie = !1, le(j), j = -1), q = !0;
              var ae = F;
              try {
                t: {
                  for (p(P), N = a(z); N !== null && !(N.expirationTime > P && _()); ) {
                    var Se = N.callback;
                    if (typeof Se == "function") {
                      N.callback = null, F = N.priorityLevel;
                      var ue = Se(
                        N.expirationTime <= P
                      );
                      if (P = o.unstable_now(), typeof ue == "function") {
                        N.callback = ue, p(P), te = !0;
                        break t;
                      }
                      N === a(z) && r(z), p(P);
                    } else r(z);
                    N = a(z);
                  }
                  if (N !== null) te = !0;
                  else {
                    var we = a(V);
                    we !== null && T(
                      y,
                      we.startTime - P
                    ), te = !1;
                  }
                }
                break e;
              } finally {
                N = null, F = ae, q = !1;
              }
              te = void 0;
            }
          } finally {
            te ? me() : Q = !1;
          }
        }
      }
      function t(P, te) {
        var ae = P.length;
        P.push(te);
        e: for (; 0 < ae; ) {
          var Se = ae - 1 >>> 1, ue = P[Se];
          if (0 < d(ue, te))
            P[Se] = te, P[ae] = ue, ae = Se;
          else break e;
        }
      }
      function a(P) {
        return P.length === 0 ? null : P[0];
      }
      function r(P) {
        if (P.length === 0) return null;
        var te = P[0], ae = P.pop();
        if (ae !== te) {
          P[0] = ae;
          e: for (var Se = 0, ue = P.length, we = ue >>> 1; Se < we; ) {
            var De = 2 * (Se + 1) - 1, We = P[De], Me = De + 1, Ze = P[Me];
            if (0 > d(We, ae))
              Me < ue && 0 > d(Ze, We) ? (P[Se] = Ze, P[Me] = ae, Se = Me) : (P[Se] = We, P[De] = ae, Se = De);
            else if (Me < ue && 0 > d(Ze, ae))
              P[Se] = Ze, P[Me] = ae, Se = Me;
            else break e;
          }
        }
        return te;
      }
      function d(P, te) {
        var ae = P.sortIndex - te.sortIndex;
        return ae !== 0 ? ae : P.id - te.id;
      }
      function p(P) {
        for (var te = a(V); te !== null; ) {
          if (te.callback === null) r(V);
          else if (te.startTime <= P)
            r(V), te.sortIndex = te.expirationTime, t(z, te);
          else break;
          te = a(V);
        }
      }
      function y(P) {
        if (ie = !1, p(P), !Y)
          if (a(z) !== null)
            Y = !0, E();
          else {
            var te = a(V);
            te !== null && T(
              y,
              te.startTime - P
            );
          }
      }
      function _() {
        return !(o.unstable_now() - _e < re);
      }
      function E() {
        Q || (Q = !0, me());
      }
      function T(P, te) {
        j = k(function() {
          P(o.unstable_now());
        }, te);
      }
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error()), o.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var C = performance;
        o.unstable_now = function() {
          return C.now();
        };
      } else {
        var D = Date, B = D.now();
        o.unstable_now = function() {
          return D.now() - B;
        };
      }
      var z = [], V = [], G = 1, N = null, F = 3, q = !1, Y = !1, ie = !1, k = typeof setTimeout == "function" ? setTimeout : null, le = typeof clearTimeout == "function" ? clearTimeout : null, ne = typeof setImmediate < "u" ? setImmediate : null, Q = !1, j = -1, re = 5, _e = -1;
      if (typeof ne == "function")
        var me = function() {
          ne(e);
        };
      else if (typeof MessageChannel < "u") {
        var Ae = new MessageChannel(), He = Ae.port2;
        Ae.port1.onmessage = e, me = function() {
          He.postMessage(null);
        };
      } else
        me = function() {
          k(e, 0);
        };
      o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(P) {
        P.callback = null;
      }, o.unstable_continueExecution = function() {
        Y || q || (Y = !0, E());
      }, o.unstable_forceFrameRate = function(P) {
        0 > P || 125 < P ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : re = 0 < P ? Math.floor(1e3 / P) : 5;
      }, o.unstable_getCurrentPriorityLevel = function() {
        return F;
      }, o.unstable_getFirstCallbackNode = function() {
        return a(z);
      }, o.unstable_next = function(P) {
        switch (F) {
          case 1:
          case 2:
          case 3:
            var te = 3;
            break;
          default:
            te = F;
        }
        var ae = F;
        F = te;
        try {
          return P();
        } finally {
          F = ae;
        }
      }, o.unstable_pauseExecution = function() {
      }, o.unstable_requestPaint = function() {
      }, o.unstable_runWithPriority = function(P, te) {
        switch (P) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            P = 3;
        }
        var ae = F;
        F = P;
        try {
          return te();
        } finally {
          F = ae;
        }
      }, o.unstable_scheduleCallback = function(P, te, ae) {
        var Se = o.unstable_now();
        switch (typeof ae == "object" && ae !== null ? (ae = ae.delay, ae = typeof ae == "number" && 0 < ae ? Se + ae : Se) : ae = Se, P) {
          case 1:
            var ue = -1;
            break;
          case 2:
            ue = 250;
            break;
          case 5:
            ue = 1073741823;
            break;
          case 4:
            ue = 1e4;
            break;
          default:
            ue = 5e3;
        }
        return ue = ae + ue, P = {
          id: G++,
          callback: te,
          priorityLevel: P,
          startTime: ae,
          expirationTime: ue,
          sortIndex: -1
        }, ae > Se ? (P.sortIndex = ae, t(V, P), a(z) === null && P === a(V) && (ie ? (le(j), j = -1) : ie = !0, T(y, ae - Se))) : (P.sortIndex = ue, t(z, P), Y || q || (Y = !0, E())), P;
      }, o.unstable_shouldYield = _, o.unstable_wrapCallback = function(P) {
        var te = F;
        return function() {
          var ae = F;
          F = te;
          try {
            return P.apply(this, arguments);
          } finally {
            F = ae;
          }
        };
      }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }(MC)), MC;
}
var Y3;
function o9() {
  return Y3 || (Y3 = 1, process.env.NODE_ENV === "production" ? Qb.exports = s9() : Qb.exports = r9()), Qb.exports;
}
var q3 = o9();
const u9 = (o) => typeof o == "object" && typeof o.then == "function", qS = [];
function _w(o, e, t = (a, r) => a === r) {
  if (o === e) return !0;
  if (!o || !e) return !1;
  const a = o.length;
  if (e.length !== a) return !1;
  for (let r = 0; r < a; r++) if (!t(o[r], e[r])) return !1;
  return !0;
}
function Aw(o, e = null, t = !1, a = {}) {
  e === null && (e = [o]);
  for (const d of qS)
    if (_w(e, d.keys, d.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(d, "error")) throw d.error;
      if (Object.prototype.hasOwnProperty.call(d, "response"))
        return a.lifespan && a.lifespan > 0 && (d.timeout && clearTimeout(d.timeout), d.timeout = setTimeout(d.remove, a.lifespan)), d.response;
      if (!t) throw d.promise;
    }
  const r = {
    keys: e,
    equal: a.equal,
    remove: () => {
      const d = qS.indexOf(r);
      d !== -1 && qS.splice(d, 1);
    },
    promise: (
      // Execute the promise
      (u9(o) ? o : o(...e)).then((d) => {
        r.response = d, a.lifespan && a.lifespan > 0 && (r.timeout = setTimeout(r.remove, a.lifespan));
      }).catch((d) => r.error = d)
    )
  };
  if (qS.push(r), !t) throw r.promise;
}
const c9 = (o, e, t) => Aw(o, e, !1, t), f9 = (o, e, t) => void Aw(o, e, !0, t), d9 = (o) => {
  if (o === void 0 || o.length === 0) qS.splice(0, qS.length);
  else {
    const e = qS.find((t) => _w(o, t.keys, t.equal));
    e && e.remove();
  }
};
var jb = { exports: {} }, _A = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Z3;
function h9() {
  if (Z3) return _A;
  Z3 = 1;
  var o = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
  function t(a, r, d) {
    var p = null;
    if (d !== void 0 && (p = "" + d), r.key !== void 0 && (p = "" + r.key), "key" in r) {
      d = {};
      for (var y in r)
        y !== "key" && (d[y] = r[y]);
    } else d = r;
    return r = d.ref, {
      $$typeof: o,
      type: a,
      key: p,
      ref: r !== void 0 ? r : null,
      props: d
    };
  }
  return _A.Fragment = e, _A.jsx = t, _A.jsxs = t, _A;
}
var AA = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Q3;
function p9() {
  return Q3 || (Q3 = 1, process.env.NODE_ENV !== "production" && function() {
    function o(ue) {
      if (ue == null) return null;
      if (typeof ue == "function")
        return ue.$$typeof === j ? null : ue.displayName || ue.name || null;
      if (typeof ue == "string") return ue;
      switch (ue) {
        case V:
          return "Fragment";
        case N:
          return "Profiler";
        case G:
          return "StrictMode";
        case ie:
          return "Suspense";
        case k:
          return "SuspenseList";
        case Q:
          return "Activity";
      }
      if (typeof ue == "object")
        switch (typeof ue.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), ue.$$typeof) {
          case z:
            return "Portal";
          case q:
            return (ue.displayName || "Context") + ".Provider";
          case F:
            return (ue._context.displayName || "Context") + ".Consumer";
          case Y:
            var we = ue.render;
            return ue = ue.displayName, ue || (ue = we.displayName || we.name || "", ue = ue !== "" ? "ForwardRef(" + ue + ")" : "ForwardRef"), ue;
          case le:
            return we = ue.displayName || null, we !== null ? we : o(ue.type) || "Memo";
          case ne:
            we = ue._payload, ue = ue._init;
            try {
              return o(ue(we));
            } catch {
            }
        }
      return null;
    }
    function e(ue) {
      return "" + ue;
    }
    function t(ue) {
      try {
        e(ue);
        var we = !1;
      } catch {
        we = !0;
      }
      if (we) {
        we = console;
        var De = we.error, We = typeof Symbol == "function" && Symbol.toStringTag && ue[Symbol.toStringTag] || ue.constructor.name || "Object";
        return De.call(
          we,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          We
        ), e(ue);
      }
    }
    function a(ue) {
      if (ue === V) return "<>";
      if (typeof ue == "object" && ue !== null && ue.$$typeof === ne)
        return "<...>";
      try {
        var we = o(ue);
        return we ? "<" + we + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function r() {
      var ue = re.A;
      return ue === null ? null : ue.getOwner();
    }
    function d() {
      return Error("react-stack-top-frame");
    }
    function p(ue) {
      if (_e.call(ue, "key")) {
        var we = Object.getOwnPropertyDescriptor(ue, "key").get;
        if (we && we.isReactWarning) return !1;
      }
      return ue.key !== void 0;
    }
    function y(ue, we) {
      function De() {
        He || (He = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          we
        ));
      }
      De.isReactWarning = !0, Object.defineProperty(ue, "key", {
        get: De,
        configurable: !0
      });
    }
    function _() {
      var ue = o(this.type);
      return P[ue] || (P[ue] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), ue = this.props.ref, ue !== void 0 ? ue : null;
    }
    function E(ue, we, De, We, Me, Ze, ct, Vt) {
      return De = Ze.ref, ue = {
        $$typeof: B,
        type: ue,
        key: we,
        props: Ze,
        _owner: Me
      }, (De !== void 0 ? De : null) !== null ? Object.defineProperty(ue, "ref", {
        enumerable: !1,
        get: _
      }) : Object.defineProperty(ue, "ref", { enumerable: !1, value: null }), ue._store = {}, Object.defineProperty(ue._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(ue, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.defineProperty(ue, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: ct
      }), Object.defineProperty(ue, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: Vt
      }), Object.freeze && (Object.freeze(ue.props), Object.freeze(ue)), ue;
    }
    function T(ue, we, De, We, Me, Ze, ct, Vt) {
      var Zt = we.children;
      if (Zt !== void 0)
        if (We)
          if (me(Zt)) {
            for (We = 0; We < Zt.length; We++)
              C(Zt[We]);
            Object.freeze && Object.freeze(Zt);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else C(Zt);
      if (_e.call(we, "key")) {
        Zt = o(ue);
        var Bn = Object.keys(we).filter(function(dn) {
          return dn !== "key";
        });
        We = 0 < Bn.length ? "{key: someKey, " + Bn.join(": ..., ") + ": ...}" : "{key: someKey}", Se[Zt + We] || (Bn = 0 < Bn.length ? "{" + Bn.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          We,
          Zt,
          Bn,
          Zt
        ), Se[Zt + We] = !0);
      }
      if (Zt = null, De !== void 0 && (t(De), Zt = "" + De), p(we) && (t(we.key), Zt = "" + we.key), "key" in we) {
        De = {};
        for (var rn in we)
          rn !== "key" && (De[rn] = we[rn]);
      } else De = we;
      return Zt && y(
        De,
        typeof ue == "function" ? ue.displayName || ue.name || "Unknown" : ue
      ), E(
        ue,
        Zt,
        Ze,
        Me,
        r(),
        De,
        ct,
        Vt
      );
    }
    function C(ue) {
      typeof ue == "object" && ue !== null && ue.$$typeof === B && ue._store && (ue._store.validated = 1);
    }
    var D = Qm, B = Symbol.for("react.transitional.element"), z = Symbol.for("react.portal"), V = Symbol.for("react.fragment"), G = Symbol.for("react.strict_mode"), N = Symbol.for("react.profiler"), F = Symbol.for("react.consumer"), q = Symbol.for("react.context"), Y = Symbol.for("react.forward_ref"), ie = Symbol.for("react.suspense"), k = Symbol.for("react.suspense_list"), le = Symbol.for("react.memo"), ne = Symbol.for("react.lazy"), Q = Symbol.for("react.activity"), j = Symbol.for("react.client.reference"), re = D.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, _e = Object.prototype.hasOwnProperty, me = Array.isArray, Ae = console.createTask ? console.createTask : function() {
      return null;
    };
    D = {
      "react-stack-bottom-frame": function(ue) {
        return ue();
      }
    };
    var He, P = {}, te = D["react-stack-bottom-frame"].bind(
      D,
      d
    )(), ae = Ae(a(d)), Se = {};
    AA.Fragment = V, AA.jsx = function(ue, we, De, We, Me) {
      var Ze = 1e4 > re.recentlyCreatedOwnerStacks++;
      return T(
        ue,
        we,
        De,
        !1,
        We,
        Me,
        Ze ? Error("react-stack-top-frame") : te,
        Ze ? Ae(a(ue)) : ae
      );
    }, AA.jsxs = function(ue, we, De, We, Me) {
      var Ze = 1e4 > re.recentlyCreatedOwnerStacks++;
      return T(
        ue,
        we,
        De,
        !0,
        We,
        Me,
        Ze ? Error("react-stack-top-frame") : te,
        Ze ? Ae(a(ue)) : ae
      );
    };
  }()), AA;
}
var j3;
function m9() {
  return j3 || (j3 = 1, process.env.NODE_ENV === "production" ? jb.exports = h9() : jb.exports = p9()), jb.exports;
}
var sf = m9();
function nR(o, e, t) {
  if (!o) return;
  if (t(o) === !0) return o;
  let a = e ? o.return : o.child;
  for (; a; ) {
    const r = nR(a, e, t);
    if (r) return r;
    a = e ? null : a.sibling;
  }
}
function Ew(o) {
  try {
    return Object.defineProperties(o, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return o;
  }
}
const aR = /* @__PURE__ */ Ew(/* @__PURE__ */ st.createContext(null));
class bw extends st.Component {
  render() {
    return /* @__PURE__ */ st.createElement(aR.Provider, { value: this._reactInternals }, this.props.children);
  }
}
function Mw() {
  const o = st.useContext(aR);
  if (o === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = st.useId();
  return st.useMemo(() => {
    for (const t of [o, o == null ? void 0 : o.alternate]) {
      if (!t) continue;
      const a = nR(t, !1, (r) => {
        let d = r.memoizedState;
        for (; d; ) {
          if (d.memoizedState === e) return !0;
          d = d.next;
        }
      });
      if (a) return a;
    }
  }, [o, e]);
}
const v9 = Symbol.for("react.context"), g9 = (o) => o !== null && typeof o == "object" && "$$typeof" in o && o.$$typeof === v9;
function y9() {
  const o = Mw(), [e] = st.useState(() => /* @__PURE__ */ new Map());
  e.clear();
  let t = o;
  for (; t; ) {
    const a = t.type;
    g9(a) && a !== aR && !e.has(a) && e.set(a, st.use(Ew(a))), t = t.return;
  }
  return e;
}
function S9() {
  const o = y9();
  return st.useMemo(
    () => Array.from(o.keys()).reduce(
      (e, t) => (a) => /* @__PURE__ */ st.createElement(e, null, /* @__PURE__ */ st.createElement(t.Provider, { ...a, value: o.get(t) })),
      (e) => /* @__PURE__ */ st.createElement(bw, { ...e })
    ),
    [o]
  );
}
function xw(o) {
  let e = o.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const Tw = (o) => o && o.isOrthographicCamera, _9 = (o) => o && o.hasOwnProperty("current"), A9 = (o) => o != null && (typeof o == "string" || typeof o == "number" || o.isColor), gE = /* @__PURE__ */ ((o, e) => typeof window < "u" && (((o = window.document) == null ? void 0 : o.createElement) || ((e = window.navigator) == null ? void 0 : e.product) === "ReactNative"))() ? st.useLayoutEffect : st.useEffect;
function iR(o) {
  const e = st.useRef(o);
  return gE(() => void (e.current = o), [o]), e;
}
function E9() {
  const o = Mw(), e = S9();
  return st.useMemo(() => ({
    children: t
  }) => {
    const r = !!nR(o, !0, (d) => d.type === st.StrictMode) ? st.StrictMode : st.Fragment;
    return /* @__PURE__ */ sf.jsx(r, {
      children: /* @__PURE__ */ sf.jsx(e, {
        children: t
      })
    });
  }, [o, e]);
}
function b9({
  set: o
}) {
  return gE(() => (o(new Promise(() => null)), () => o(!1)), [o]), null;
}
const M9 = /* @__PURE__ */ ((o) => (o = class extends st.Component {
  constructor(...t) {
    super(...t), this.state = {
      error: !1
    };
  }
  componentDidCatch(t) {
    this.props.set(t);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}, o.getDerivedStateFromError = () => ({
  error: !0
}), o))();
function Cw(o) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(o) ? Math.min(Math.max(o[0], t), o[1]) : o;
}
function i1(o) {
  var e;
  return (e = o.__r3f) == null ? void 0 : e.root.getState();
}
const ks = {
  obj: (o) => o === Object(o) && !ks.arr(o) && typeof o != "function",
  fun: (o) => typeof o == "function",
  str: (o) => typeof o == "string",
  num: (o) => typeof o == "number",
  boo: (o) => typeof o == "boolean",
  und: (o) => o === void 0,
  nul: (o) => o === null,
  arr: (o) => Array.isArray(o),
  equ(o, e, {
    arrays: t = "shallow",
    objects: a = "reference",
    strict: r = !0
  } = {}) {
    if (typeof o != typeof e || !!o != !!e) return !1;
    if (ks.str(o) || ks.num(o) || ks.boo(o)) return o === e;
    const d = ks.obj(o);
    if (d && a === "reference") return o === e;
    const p = ks.arr(o);
    if (p && t === "reference") return o === e;
    if ((p || d) && o === e) return !0;
    let y;
    for (y in o) if (!(y in e)) return !1;
    if (d && t === "shallow" && a === "shallow") {
      for (y in r ? e : o) if (!ks.equ(o[y], e[y], {
        strict: r,
        objects: "reference"
      })) return !1;
    } else
      for (y in r ? e : o) if (o[y] !== e[y]) return !1;
    if (ks.und(y)) {
      if (p && o.length === 0 && e.length === 0 || d && Object.keys(o).length === 0 && Object.keys(e).length === 0) return !0;
      if (o !== e) return !1;
    }
    return !0;
  }
};
function x9(o) {
  const e = {
    nodes: {},
    materials: {},
    meshes: {}
  };
  return o && o.traverse((t) => {
    t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material), t.isMesh && !e.meshes[t.name] && (e.meshes[t.name] = t);
  }), e;
}
function T9(o) {
  o.type !== "Scene" && (o.dispose == null || o.dispose());
  for (const e in o) {
    const t = o[e];
    (t == null ? void 0 : t.type) !== "Scene" && (t == null || t.dispose == null || t.dispose());
  }
}
const Rw = ["children", "key", "ref"];
function C9(o) {
  const e = {};
  for (const t in o)
    Rw.includes(t) || (e[t] = o[t]);
  return e;
}
function kM(o, e, t, a) {
  const r = o;
  let d = r == null ? void 0 : r.__r3f;
  return d || (d = {
    root: e,
    type: t,
    parent: null,
    children: [],
    props: C9(a),
    object: r,
    eventCount: 0,
    handlers: {},
    isHidden: !1
  }, r && (r.__r3f = d)), d;
}
function tE(o, e) {
  let t = o[e];
  if (!e.includes("-")) return {
    root: o,
    key: e,
    target: t
  };
  t = o;
  for (const r of e.split("-")) {
    var a;
    e = r, o = t, t = (a = t) == null ? void 0 : a[e];
  }
  return {
    root: o,
    key: e,
    target: t
  };
}
const J3 = /-\d+$/;
function WM(o, e) {
  if (ks.str(e.props.attach)) {
    if (J3.test(e.props.attach)) {
      const r = e.props.attach.replace(J3, ""), {
        root: d,
        key: p
      } = tE(o.object, r);
      Array.isArray(d[p]) || (d[p] = []);
    }
    const {
      root: t,
      key: a
    } = tE(o.object, e.props.attach);
    e.previousAttach = t[a], t[a] = e.object;
  } else ks.fun(e.props.attach) && (e.previousAttach = e.props.attach(o.object, e.object));
}
function $M(o, e) {
  if (ks.str(e.props.attach)) {
    const {
      root: t,
      key: a
    } = tE(o.object, e.props.attach), r = e.previousAttach;
    r === void 0 ? delete t[a] : t[a] = r;
  } else
    e.previousAttach == null || e.previousAttach(o.object, e.object);
  delete e.previousAttach;
}
const n2 = [
  ...Rw,
  // Instance props
  "args",
  "dispose",
  "attach",
  "object",
  "onUpdate",
  // Behavior flags
  "dispose"
], K3 = /* @__PURE__ */ new Map();
function R9(o) {
  let e = K3.get(o.constructor);
  try {
    e || (e = new o.constructor(), K3.set(o.constructor, e));
  } catch {
  }
  return e;
}
function D9(o, e) {
  const t = {};
  for (const a in e)
    if (!n2.includes(a) && !ks.equ(e[a], o.props[a])) {
      t[a] = e[a];
      for (const r in e)
        r.startsWith(`${a}-`) && (t[r] = e[r]);
    }
  for (const a in o.props) {
    if (n2.includes(a) || e.hasOwnProperty(a)) continue;
    const {
      root: r,
      key: d
    } = tE(o.object, a);
    if (r.constructor && r.constructor.length === 0) {
      const p = R9(r);
      ks.und(p) || (t[d] = p[d]);
    } else
      t[d] = 0;
  }
  return t;
}
const B9 = ["map", "emissiveMap", "sheenColorMap", "specularColorMap", "envMap"], U9 = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;
function Xg(o, e) {
  var t;
  const a = o.__r3f, r = a && xw(a).getState(), d = a == null ? void 0 : a.eventCount;
  for (const y in e) {
    let _ = e[y];
    if (n2.includes(y)) continue;
    if (a && U9.test(y)) {
      typeof _ == "function" ? a.handlers[y] = _ : delete a.handlers[y], a.eventCount = Object.keys(a.handlers).length;
      continue;
    }
    if (_ === void 0) continue;
    let {
      root: E,
      key: T,
      target: C
    } = tE(o, y);
    if (C instanceof A1 && _ instanceof A1)
      C.mask = _.mask;
    else if (C instanceof hn && A9(_))
      C.set(_);
    else if (C !== null && typeof C == "object" && typeof C.set == "function" && typeof C.copy == "function" && _ != null && _.constructor && C.constructor === _.constructor)
      C.copy(_);
    else if (C !== null && typeof C == "object" && typeof C.set == "function" && Array.isArray(_))
      typeof C.fromArray == "function" ? C.fromArray(_) : C.set(..._);
    else if (C !== null && typeof C == "object" && typeof C.set == "function" && typeof _ == "number")
      typeof C.setScalar == "function" ? C.setScalar(_) : C.set(_);
    else {
      var p;
      E[T] = _, r && !r.linear && B9.includes(T) && (p = E[T]) != null && p.isTexture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
      E[T].format === xo && E[T].type === qh && (E[T].colorSpace = lf);
    }
  }
  if (a != null && a.parent && r != null && r.internal && (t = a.object) != null && t.isObject3D && d !== a.eventCount) {
    const y = a.object, _ = r.internal.interaction.indexOf(y);
    _ > -1 && r.internal.interaction.splice(_, 1), a.eventCount && y.raycast !== null && r.internal.interaction.push(y);
  }
  return a && a.props.attach === void 0 && (a.object.isBufferGeometry ? a.props.attach = "geometry" : a.object.isMaterial && (a.props.attach = "material")), a && w1(a), o;
}
function w1(o) {
  var e;
  if (!o.parent) return;
  o.props.onUpdate == null || o.props.onUpdate(o.object);
  const t = (e = o.root) == null || e.getState == null ? void 0 : e.getState();
  t && t.internal.frames === 0 && t.invalidate();
}
function Dw(o, e) {
  o.manual || (Tw(o) ? (o.left = e.width / -2, o.right = e.width / 2, o.top = e.height / 2, o.bottom = e.height / -2) : o.aspect = e.width / e.height, o.updateProjectionMatrix());
}
const jd = (o) => o == null ? void 0 : o.isObject3D;
function Jb(o) {
  return (o.eventObject || o.object).uuid + "/" + o.index + o.instanceId;
}
function Bw(o, e, t, a) {
  const r = t.get(e);
  r && (t.delete(e), t.size === 0 && (o.delete(a), r.target.releasePointerCapture(a)));
}
function O9(o, e) {
  const {
    internal: t
  } = o.getState();
  t.interaction = t.interaction.filter((a) => a !== e), t.initialHits = t.initialHits.filter((a) => a !== e), t.hovered.forEach((a, r) => {
    (a.eventObject === e || a.object === e) && t.hovered.delete(r);
  }), t.capturedMap.forEach((a, r) => {
    Bw(t.capturedMap, e, a, r);
  });
}
function w9(o) {
  function e(_) {
    const {
      internal: E
    } = o.getState(), T = _.offsetX - E.initialClick[0], C = _.offsetY - E.initialClick[1];
    return Math.round(Math.sqrt(T * T + C * C));
  }
  function t(_) {
    return _.filter((E) => ["Move", "Over", "Enter", "Out", "Leave"].some((T) => {
      var C;
      return (C = E.__r3f) == null ? void 0 : C.handlers["onPointer" + T];
    }));
  }
  function a(_, E) {
    const T = o.getState(), C = /* @__PURE__ */ new Set(), D = [], B = E ? E(T.internal.interaction) : T.internal.interaction;
    for (let N = 0; N < B.length; N++) {
      const F = i1(B[N]);
      F && (F.raycaster.camera = void 0);
    }
    T.previousRoot || T.events.compute == null || T.events.compute(_, T);
    function z(N) {
      const F = i1(N);
      if (!F || !F.events.enabled || F.raycaster.camera === null) return [];
      if (F.raycaster.camera === void 0) {
        var q;
        F.events.compute == null || F.events.compute(_, F, (q = F.previousRoot) == null ? void 0 : q.getState()), F.raycaster.camera === void 0 && (F.raycaster.camera = null);
      }
      return F.raycaster.camera ? F.raycaster.intersectObject(N, !0) : [];
    }
    let V = B.flatMap(z).sort((N, F) => {
      const q = i1(N.object), Y = i1(F.object);
      return !q || !Y ? N.distance - F.distance : Y.events.priority - q.events.priority || N.distance - F.distance;
    }).filter((N) => {
      const F = Jb(N);
      return C.has(F) ? !1 : (C.add(F), !0);
    });
    T.events.filter && (V = T.events.filter(V, T));
    for (const N of V) {
      let F = N.object;
      for (; F; ) {
        var G;
        (G = F.__r3f) != null && G.eventCount && D.push({
          ...N,
          eventObject: F
        }), F = F.parent;
      }
    }
    if ("pointerId" in _ && T.internal.capturedMap.has(_.pointerId))
      for (let N of T.internal.capturedMap.get(_.pointerId).values())
        C.has(Jb(N.intersection)) || D.push(N.intersection);
    return D;
  }
  function r(_, E, T, C) {
    if (_.length) {
      const D = {
        stopped: !1
      };
      for (const B of _) {
        let z = i1(B.object);
        if (z || B.object.traverseAncestors((V) => {
          const G = i1(V);
          if (G)
            return z = G, !1;
        }), z) {
          const {
            raycaster: V,
            pointer: G,
            camera: N,
            internal: F
          } = z, q = new ve(G.x, G.y, 0).unproject(N), Y = (Q) => {
            var j, re;
            return (j = (re = F.capturedMap.get(Q)) == null ? void 0 : re.has(B.eventObject)) != null ? j : !1;
          }, ie = (Q) => {
            const j = {
              intersection: B,
              target: E.target
            };
            F.capturedMap.has(Q) ? F.capturedMap.get(Q).set(B.eventObject, j) : F.capturedMap.set(Q, /* @__PURE__ */ new Map([[B.eventObject, j]])), E.target.setPointerCapture(Q);
          }, k = (Q) => {
            const j = F.capturedMap.get(Q);
            j && Bw(F.capturedMap, B.eventObject, j, Q);
          };
          let le = {};
          for (let Q in E) {
            let j = E[Q];
            typeof j != "function" && (le[Q] = j);
          }
          let ne = {
            ...B,
            ...le,
            pointer: G,
            intersections: _,
            stopped: D.stopped,
            delta: T,
            unprojectedPoint: q,
            ray: V.ray,
            camera: N,
            // Hijack stopPropagation, which just sets a flag
            stopPropagation() {
              const Q = "pointerId" in E && F.capturedMap.get(E.pointerId);
              if (
                // ...if this pointer hasn't been captured
                (!Q || // ... or if the hit object is capturing the pointer
                Q.has(B.eventObject)) && (ne.stopped = D.stopped = !0, F.hovered.size && Array.from(F.hovered.values()).find((j) => j.eventObject === B.eventObject))
              ) {
                const j = _.slice(0, _.indexOf(B));
                d([...j, B]);
              }
            },
            // there should be a distinction between target and currentTarget
            target: {
              hasPointerCapture: Y,
              setPointerCapture: ie,
              releasePointerCapture: k
            },
            currentTarget: {
              hasPointerCapture: Y,
              setPointerCapture: ie,
              releasePointerCapture: k
            },
            nativeEvent: E
          };
          if (C(ne), D.stopped === !0) break;
        }
      }
    }
    return _;
  }
  function d(_) {
    const {
      internal: E
    } = o.getState();
    for (const T of E.hovered.values())
      if (!_.length || !_.find((C) => C.object === T.object && C.index === T.index && C.instanceId === T.instanceId)) {
        const D = T.eventObject.__r3f;
        if (E.hovered.delete(Jb(T)), D != null && D.eventCount) {
          const B = D.handlers, z = {
            ...T,
            intersections: _
          };
          B.onPointerOut == null || B.onPointerOut(z), B.onPointerLeave == null || B.onPointerLeave(z);
        }
      }
  }
  function p(_, E) {
    for (let T = 0; T < E.length; T++) {
      const C = E[T].__r3f;
      C == null || C.handlers.onPointerMissed == null || C.handlers.onPointerMissed(_);
    }
  }
  function y(_) {
    switch (_) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => d([]);
      case "onLostPointerCapture":
        return (E) => {
          const {
            internal: T
          } = o.getState();
          "pointerId" in E && T.capturedMap.has(E.pointerId) && requestAnimationFrame(() => {
            T.capturedMap.has(E.pointerId) && (T.capturedMap.delete(E.pointerId), d([]));
          });
        };
    }
    return function(T) {
      const {
        onPointerMissed: C,
        internal: D
      } = o.getState();
      D.lastEvent.current = T;
      const B = _ === "onPointerMove", z = _ === "onClick" || _ === "onContextMenu" || _ === "onDoubleClick", G = a(T, B ? t : void 0), N = z ? e(T) : 0;
      _ === "onPointerDown" && (D.initialClick = [T.offsetX, T.offsetY], D.initialHits = G.map((q) => q.eventObject)), z && !G.length && N <= 2 && (p(T, D.interaction), C && C(T)), B && d(G);
      function F(q) {
        const Y = q.eventObject, ie = Y.__r3f;
        if (!(ie != null && ie.eventCount)) return;
        const k = ie.handlers;
        if (B) {
          if (k.onPointerOver || k.onPointerEnter || k.onPointerOut || k.onPointerLeave) {
            const le = Jb(q), ne = D.hovered.get(le);
            ne ? ne.stopped && q.stopPropagation() : (D.hovered.set(le, q), k.onPointerOver == null || k.onPointerOver(q), k.onPointerEnter == null || k.onPointerEnter(q));
          }
          k.onPointerMove == null || k.onPointerMove(q);
        } else {
          const le = k[_];
          le ? (!z || D.initialHits.includes(Y)) && (p(T, D.interaction.filter((ne) => !D.initialHits.includes(ne))), le(q)) : z && D.initialHits.includes(Y) && p(T, D.interaction.filter((ne) => !D.initialHits.includes(ne)));
        }
      }
      r(G, T, N, F);
    };
  }
  return {
    handlePointer: y
  };
}
const k3 = (o) => !!(o != null && o.render), lR = /* @__PURE__ */ st.createContext(null), N9 = (o, e) => {
  const t = yw((y, _) => {
    const E = new ve(), T = new ve(), C = new ve();
    function D(N = _().camera, F = T, q = _().size) {
      const {
        width: Y,
        height: ie,
        top: k,
        left: le
      } = q, ne = Y / ie;
      F.isVector3 ? C.copy(F) : C.set(...F);
      const Q = N.getWorldPosition(E).distanceTo(C);
      if (Tw(N))
        return {
          width: Y / N.zoom,
          height: ie / N.zoom,
          top: k,
          left: le,
          factor: 1,
          distance: Q,
          aspect: ne
        };
      {
        const j = N.fov * Math.PI / 180, re = 2 * Math.tan(j / 2) * Q, _e = re * (Y / ie);
        return {
          width: _e,
          height: re,
          top: k,
          left: le,
          factor: Y / _e,
          distance: Q,
          aspect: ne
        };
      }
    }
    let B;
    const z = (N) => y((F) => ({
      performance: {
        ...F.performance,
        current: N
      }
    })), V = new Ot();
    return {
      set: y,
      get: _,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      scene: null,
      xr: null,
      invalidate: (N = 1) => o(_(), N),
      advance: (N, F) => e(N, F, _()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new J2(),
      pointer: V,
      mouse: V,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const N = _();
          B && clearTimeout(B), N.performance.current !== N.performance.min && z(N.performance.min), B = setTimeout(() => z(_().performance.max), N.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: D
      },
      setEvents: (N) => y((F) => ({
        ...F,
        events: {
          ...F.events,
          ...N
        }
      })),
      setSize: (N, F, q = 0, Y = 0) => {
        const ie = _().camera, k = {
          width: N,
          height: F,
          top: q,
          left: Y
        };
        y((le) => ({
          size: k,
          viewport: {
            ...le.viewport,
            ...D(ie, T, k)
          }
        }));
      },
      setDpr: (N) => y((F) => {
        const q = Cw(N);
        return {
          viewport: {
            ...F.viewport,
            dpr: q,
            initialDpr: F.viewport.initialDpr || q
          }
        };
      }),
      setFrameloop: (N = "always") => {
        const F = _().clock;
        F.stop(), F.elapsedTime = 0, N !== "never" && (F.start(), F.elapsedTime = 0), y(() => ({
          frameloop: N
        }));
      },
      previousRoot: void 0,
      internal: {
        // Events
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        lastEvent: /* @__PURE__ */ st.createRef(),
        // Updates
        active: !1,
        frames: 0,
        priority: 0,
        subscribe: (N, F, q) => {
          const Y = _().internal;
          return Y.priority = Y.priority + (F > 0 ? 1 : 0), Y.subscribers.push({
            ref: N,
            priority: F,
            store: q
          }), Y.subscribers = Y.subscribers.sort((ie, k) => ie.priority - k.priority), () => {
            const ie = _().internal;
            ie != null && ie.subscribers && (ie.priority = ie.priority - (F > 0 ? 1 : 0), ie.subscribers = ie.subscribers.filter((k) => k.ref !== N));
          };
        }
      }
    };
  }), a = t.getState();
  let r = a.size, d = a.viewport.dpr, p = a.camera;
  return t.subscribe(() => {
    const {
      camera: y,
      size: _,
      viewport: E,
      gl: T,
      set: C
    } = t.getState();
    if (_.width !== r.width || _.height !== r.height || E.dpr !== d) {
      r = _, d = E.dpr, Dw(y, _), E.dpr > 0 && T.setPixelRatio(E.dpr);
      const D = typeof HTMLCanvasElement < "u" && T.domElement instanceof HTMLCanvasElement;
      T.setSize(_.width, _.height, D);
    }
    y !== p && (p = y, C((D) => ({
      viewport: {
        ...D.viewport,
        ...D.viewport.getCurrentViewport(y)
      }
    })));
  }), t.subscribe((y) => o(y)), t;
};
function sR() {
  const o = st.useContext(lR);
  if (!o) throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return o;
}
function nu(o = (t) => t, e) {
  return sR()(o, e);
}
function k0(o, e = 0) {
  const t = sR(), a = t.getState().internal.subscribe, r = iR(o);
  return gE(() => a(r, e, t), [e, a, t]), null;
}
const W3 = /* @__PURE__ */ new WeakMap(), z9 = (o) => {
  var e;
  return typeof o == "function" && (o == null || (e = o.prototype) == null ? void 0 : e.constructor) === o;
};
function Uw(o, e) {
  return function(t, ...a) {
    let r;
    return z9(t) ? (r = W3.get(t), r || (r = new t(), W3.set(t, r))) : r = t, o && o(r), Promise.all(a.map((d) => new Promise((p, y) => r.load(d, (_) => {
      jd(_ == null ? void 0 : _.scene) && Object.assign(_, x9(_.scene)), p(_);
    }, e, (_) => y(new Error(`Could not load ${d}: ${_ == null ? void 0 : _.message}`))))));
  };
}
function jy(o, e, t, a) {
  const r = Array.isArray(e) ? e : [e], d = c9(Uw(t, a), [o, ...r], {
    equal: ks.equ
  });
  return Array.isArray(e) ? d : d[0];
}
jy.preload = function(o, e, t) {
  const a = Array.isArray(e) ? e : [e];
  return f9(Uw(t), [o, ...a]);
};
jy.clear = function(o, e) {
  const t = Array.isArray(e) ? e : [e];
  return d9([o, ...t]);
};
function H9(o) {
  const e = l9(o);
  return e.injectIntoDevTools({
    bundleType: typeof process < "u" && process.env.NODE_ENV !== "production" ? 1 : 0,
    rendererPackageName: "@react-three/fiber",
    version: st.version
  }), e;
}
const Ow = 0, x1 = {}, L9 = /^three(?=[A-Z])/, Lx = (o) => `${o[0].toUpperCase()}${o.slice(1)}`;
let G9 = 0;
const I9 = (o) => typeof o == "function";
function Gx(o) {
  if (I9(o)) {
    const e = `${G9++}`;
    return x1[e] = o, e;
  } else
    Object.assign(x1, o);
}
function ww(o, e) {
  const t = Lx(o), a = x1[t];
  if (o !== "primitive" && !a) throw new Error(`R3F: ${t} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
  if (o === "primitive" && !e.object) throw new Error("R3F: Primitives without 'object' are invalid!");
  if (e.args !== void 0 && !Array.isArray(e.args)) throw new Error("R3F: The args prop must be an array!");
}
function V9(o, e, t) {
  var a;
  return o = Lx(o) in x1 ? o : o.replace(L9, ""), ww(o, e), o === "primitive" && (a = e.object) != null && a.__r3f && delete e.object.__r3f, kM(e.object, t, o, e);
}
function F9(o) {
  if (!o.isHidden) {
    var e;
    o.props.attach && (e = o.parent) != null && e.object ? $M(o.parent, o) : jd(o.object) && (o.object.visible = !1), o.isHidden = !0, w1(o);
  }
}
function Nw(o) {
  if (o.isHidden) {
    var e;
    o.props.attach && (e = o.parent) != null && e.object ? WM(o.parent, o) : jd(o.object) && o.props.visible !== !1 && (o.object.visible = !0), o.isHidden = !1, w1(o);
  }
}
function rR(o, e, t) {
  const a = e.root.getState();
  if (!(!o.parent && o.object !== a.scene)) {
    if (!e.object) {
      var r, d;
      const p = x1[Lx(e.type)];
      e.object = (r = e.props.object) != null ? r : new p(...(d = e.props.args) != null ? d : []), e.object.__r3f = e;
    }
    if (Xg(e.object, e.props), e.props.attach)
      WM(o, e);
    else if (jd(e.object) && jd(o.object)) {
      const p = o.object.children.indexOf(t == null ? void 0 : t.object);
      if (t && p !== -1) {
        const y = o.object.children.indexOf(e.object);
        if (y !== -1) {
          o.object.children.splice(y, 1);
          const _ = y < p ? p - 1 : p;
          o.object.children.splice(_, 0, e.object);
        } else
          e.object.parent = o.object, o.object.children.splice(p, 0, e.object), e.object.dispatchEvent({
            type: "added"
          }), o.object.dispatchEvent({
            type: "childadded",
            child: e.object
          });
      } else
        o.object.add(e.object);
    }
    for (const p of e.children) rR(e, p);
    w1(e);
  }
}
function xC(o, e) {
  e && (e.parent = o, o.children.push(e), rR(o, e));
}
function $3(o, e, t) {
  if (!e || !t) return;
  e.parent = o;
  const a = o.children.indexOf(t);
  a !== -1 ? o.children.splice(a, 0, e) : o.children.push(e), rR(o, e, t);
}
function zw(o) {
  if (typeof o.dispose == "function") {
    const e = () => {
      try {
        o.dispose();
      } catch {
      }
    };
    typeof IS_REACT_ACT_ENVIRONMENT < "u" ? e() : q3.unstable_scheduleCallback(q3.unstable_IdlePriority, e);
  }
}
function a2(o, e, t) {
  if (!e) return;
  e.parent = null;
  const a = o.children.indexOf(e);
  a !== -1 && o.children.splice(a, 1), e.props.attach ? $M(o, e) : jd(e.object) && jd(o.object) && (o.object.remove(e.object), O9(xw(e), e.object));
  const r = e.props.dispose !== null && t !== !1;
  for (let d = e.children.length - 1; d >= 0; d--) {
    const p = e.children[d];
    a2(e, p, r);
  }
  e.children.length = 0, delete e.object.__r3f, r && e.type !== "primitive" && e.object.type !== "Scene" && zw(e.object), t === void 0 && w1(e);
}
function P9(o, e) {
  for (const t of [o, o.alternate])
    if (t !== null)
      if (typeof t.ref == "function") {
        t.refCleanup == null || t.refCleanup();
        const a = t.ref(e);
        typeof a == "function" && (t.refCleanup = a);
      } else t.ref && (t.ref.current = e);
}
const uM = [];
function X9() {
  for (const [t] of uM) {
    const a = t.parent;
    if (a) {
      t.props.attach ? $M(a, t) : jd(t.object) && jd(a.object) && a.object.remove(t.object);
      for (const r of t.children)
        r.props.attach ? $M(t, r) : jd(r.object) && jd(t.object) && t.object.remove(r.object);
    }
    t.isHidden && Nw(t), t.object.__r3f && delete t.object.__r3f, t.type !== "primitive" && zw(t.object);
  }
  for (const [t, a, r] of uM) {
    t.props = a;
    const d = t.parent;
    if (d) {
      var o, e;
      const p = x1[Lx(t.type)];
      t.object = (o = t.props.object) != null ? o : new p(...(e = t.props.args) != null ? e : []), t.object.__r3f = t, P9(r, t.object), Xg(t.object, t.props), t.props.attach ? WM(d, t) : jd(t.object) && jd(d.object) && d.object.add(t.object);
      for (const y of t.children)
        y.props.attach ? WM(t, y) : jd(y.object) && jd(t.object) && t.object.add(y.object);
      w1(t);
    }
  }
  uM.length = 0;
}
const TC = () => {
}, eU = {};
let Kb = Ow;
const Y9 = 0, q9 = 4, ex = /* @__PURE__ */ H9({
  isPrimaryRenderer: !1,
  warnsIfNotActing: !1,
  supportsMutation: !0,
  supportsPersistence: !1,
  supportsHydration: !1,
  createInstance: V9,
  removeChild: a2,
  appendChild: xC,
  appendInitialChild: xC,
  insertBefore: $3,
  appendChildToContainer(o, e) {
    const t = o.getState().scene.__r3f;
    !e || !t || xC(t, e);
  },
  removeChildFromContainer(o, e) {
    const t = o.getState().scene.__r3f;
    !e || !t || a2(t, e);
  },
  insertInContainerBefore(o, e, t) {
    const a = o.getState().scene.__r3f;
    !e || !t || !a || $3(a, e, t);
  },
  getRootHostContext: () => eU,
  getChildHostContext: () => eU,
  commitUpdate(o, e, t, a, r) {
    var d, p, y;
    ww(e, a);
    let _ = !1;
    if ((o.type === "primitive" && t.object !== a.object || ((d = a.args) == null ? void 0 : d.length) !== ((p = t.args) == null ? void 0 : p.length) || (y = a.args) != null && y.some((T, C) => {
      var D;
      return T !== ((D = t.args) == null ? void 0 : D[C]);
    })) && (_ = !0), _)
      uM.push([o, {
        ...a
      }, r]);
    else {
      const T = D9(o, a);
      Object.keys(T).length && (Object.assign(o.props, T), Xg(o.object, T));
    }
    (r.sibling === null || (r.flags & q9) === Y9) && X9();
  },
  finalizeInitialChildren: () => !1,
  commitMount() {
  },
  getPublicInstance: (o) => o == null ? void 0 : o.object,
  prepareForCommit: () => null,
  preparePortalMount: (o) => kM(o.getState().scene, o, "", {}),
  resetAfterCommit: () => {
  },
  shouldSetTextContent: () => !1,
  clearContainer: () => !1,
  hideInstance: F9,
  unhideInstance: Nw,
  createTextInstance: TC,
  hideTextInstance: TC,
  unhideTextInstance: TC,
  scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0,
  cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0,
  noTimeout: -1,
  getInstanceFromNode: () => null,
  beforeActiveInstanceBlur() {
  },
  afterActiveInstanceBlur() {
  },
  detachDeletedInstance() {
  },
  prepareScopeUpdate() {
  },
  getInstanceFromScope: () => null,
  shouldAttemptEagerTransition: () => !1,
  trackSchedulerEvent: () => {
  },
  resolveEventType: () => null,
  resolveEventTimeStamp: () => -1.1,
  requestPostPaintCallback() {
  },
  maySuspendCommit: () => !1,
  preloadInstance: () => !0,
  // true indicates already loaded
  startSuspendingCommit() {
  },
  suspendInstance() {
  },
  waitForCommitToBeReady: () => null,
  NotPendingTransition: null,
  HostTransitionContext: /* @__PURE__ */ st.createContext(null),
  setCurrentUpdatePriority(o) {
    Kb = o;
  },
  getCurrentUpdatePriority() {
    return Kb;
  },
  resolveUpdatePriority() {
    var o;
    if (Kb !== Ow) return Kb;
    switch (typeof window < "u" && ((o = window.event) == null ? void 0 : o.type)) {
      case "click":
      case "contextmenu":
      case "dblclick":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
        return oM.DiscreteEventPriority;
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "pointerenter":
      case "pointerleave":
      case "wheel":
        return oM.ContinuousEventPriority;
      default:
        return oM.DefaultEventPriority;
    }
  },
  resetFormInstance() {
  }
}), i_ = /* @__PURE__ */ new Map(), l1 = {
  objects: "shallow",
  strict: !1
};
function Z9(o, e) {
  if (!e && typeof HTMLCanvasElement < "u" && o instanceof HTMLCanvasElement && o.parentElement) {
    const {
      width: t,
      height: a,
      top: r,
      left: d
    } = o.parentElement.getBoundingClientRect();
    return {
      width: t,
      height: a,
      top: r,
      left: d
    };
  } else if (!e && typeof OffscreenCanvas < "u" && o instanceof OffscreenCanvas)
    return {
      width: o.width,
      height: o.height,
      top: 0,
      left: 0
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    ...e
  };
}
function Q9(o) {
  const e = i_.get(o), t = e == null ? void 0 : e.fiber, a = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), d = a || N9(s2, nU), p = t || ex.createContainer(
    d,
    // container
    oM.ConcurrentRoot,
    // tag
    null,
    // hydration callbacks
    !1,
    // isStrictMode
    null,
    // concurrentUpdatesByDefaultOverride
    "",
    // identifierPrefix
    r,
    // onUncaughtError
    r,
    // onCaughtError
    r,
    // onRecoverableError
    null
    // transitionCallbacks
  );
  e || i_.set(o, {
    fiber: p,
    store: d
  });
  let y, _, E = !1, T = null;
  return {
    async configure(C = {}) {
      let D;
      T = new Promise((we) => D = we);
      let {
        gl: B,
        size: z,
        scene: V,
        events: G,
        onCreated: N,
        shadows: F = !1,
        linear: q = !1,
        flat: Y = !1,
        legacy: ie = !1,
        orthographic: k = !1,
        frameloop: le = "always",
        dpr: ne = [1, 2],
        performance: Q,
        raycaster: j,
        camera: re,
        onPointerMissed: _e
      } = C, me = d.getState(), Ae = me.gl;
      if (!me.gl) {
        const we = {
          canvas: o,
          powerPreference: "high-performance",
          antialias: !0,
          alpha: !0
        }, De = typeof B == "function" ? await B(we) : B;
        k3(De) ? Ae = De : Ae = new tR({
          ...we,
          ...B
        }), me.set({
          gl: Ae
        });
      }
      let He = me.raycaster;
      He || me.set({
        raycaster: He = new W2()
      });
      const {
        params: P,
        ...te
      } = j || {};
      if (ks.equ(te, He, l1) || Xg(He, {
        ...te
      }), ks.equ(P, He.params, l1) || Xg(He, {
        params: {
          ...He.params,
          ...P
        }
      }), !me.camera || me.camera === _ && !ks.equ(_, re, l1)) {
        _ = re;
        const we = re == null ? void 0 : re.isCamera, De = we ? re : k ? new Zm(0, 0, 0, 0, 0.1, 1e3) : new Ls(75, 0, 0.1, 1e3);
        we || (De.position.z = 5, re && (Xg(De, re), De.manual || ("aspect" in re || "left" in re || "right" in re || "bottom" in re || "top" in re) && (De.manual = !0, De.updateProjectionMatrix())), !me.camera && !(re != null && re.rotation) && De.lookAt(0, 0, 0)), me.set({
          camera: De
        }), He.camera = De;
      }
      if (!me.scene) {
        let we;
        V != null && V.isScene ? (we = V, kM(we, d, "", {})) : (we = new R1(), kM(we, d, "", {}), V && Xg(we, V)), me.set({
          scene: we
        });
      }
      G && !me.events.handlers && me.set({
        events: G(d)
      });
      const ae = Z9(o, z);
      if (ks.equ(ae, me.size, l1) || me.setSize(ae.width, ae.height, ae.top, ae.left), ne && me.viewport.dpr !== Cw(ne) && me.setDpr(ne), me.frameloop !== le && me.setFrameloop(le), me.onPointerMissed || me.set({
        onPointerMissed: _e
      }), Q && !ks.equ(Q, me.performance, l1) && me.set((we) => ({
        performance: {
          ...we.performance,
          ...Q
        }
      })), !me.xr) {
        var Se;
        const we = (Me, Ze) => {
          const ct = d.getState();
          ct.frameloop !== "never" && nU(Me, !0, ct, Ze);
        }, De = () => {
          const Me = d.getState();
          Me.gl.xr.enabled = Me.gl.xr.isPresenting, Me.gl.xr.setAnimationLoop(Me.gl.xr.isPresenting ? we : null), Me.gl.xr.isPresenting || s2(Me);
        }, We = {
          connect() {
            const Me = d.getState().gl;
            Me.xr.addEventListener("sessionstart", De), Me.xr.addEventListener("sessionend", De);
          },
          disconnect() {
            const Me = d.getState().gl;
            Me.xr.removeEventListener("sessionstart", De), Me.xr.removeEventListener("sessionend", De);
          }
        };
        typeof ((Se = Ae.xr) == null ? void 0 : Se.addEventListener) == "function" && We.connect(), me.set({
          xr: We
        });
      }
      if (Ae.shadowMap) {
        const we = Ae.shadowMap.enabled, De = Ae.shadowMap.type;
        if (Ae.shadowMap.enabled = !!F, ks.boo(F))
          Ae.shadowMap.type = wA;
        else if (ks.str(F)) {
          var ue;
          const We = {
            basic: xU,
            percentage: ax,
            soft: wA,
            variance: qv
          };
          Ae.shadowMap.type = (ue = We[F]) != null ? ue : wA;
        } else ks.obj(F) && Object.assign(Ae.shadowMap, F);
        (we !== Ae.shadowMap.enabled || De !== Ae.shadowMap.type) && (Ae.shadowMap.needsUpdate = !0);
      }
      return wi.enabled = !ie, E || (Ae.outputColorSpace = q ? Kv : lf, Ae.toneMapping = Y ? Yg : d2), me.legacy !== ie && me.set(() => ({
        legacy: ie
      })), me.linear !== q && me.set(() => ({
        linear: q
      })), me.flat !== Y && me.set(() => ({
        flat: Y
      })), B && !ks.fun(B) && !k3(B) && !ks.equ(B, Ae, l1) && Xg(Ae, B), y = N, E = !0, D(), this;
    },
    render(C) {
      return !E && !T && this.configure(), T.then(() => {
        ex.updateContainer(/* @__PURE__ */ sf.jsx(j9, {
          store: d,
          children: C,
          onCreated: y,
          rootElement: o
        }), p, null, () => {
        });
      }), d;
    },
    unmount() {
      Hw(o);
    }
  };
}
function j9({
  store: o,
  children: e,
  onCreated: t,
  rootElement: a
}) {
  return gE(() => {
    const r = o.getState();
    r.set((d) => ({
      internal: {
        ...d.internal,
        active: !0
      }
    })), t && t(r), o.getState().events.connected || r.events.connect == null || r.events.connect(a);
  }, []), /* @__PURE__ */ sf.jsx(lR.Provider, {
    value: o,
    children: e
  });
}
function Hw(o, e) {
  const t = i_.get(o), a = t == null ? void 0 : t.fiber;
  if (a) {
    const r = t == null ? void 0 : t.store.getState();
    r && (r.internal.active = !1), ex.updateContainer(null, a, null, () => {
      r && setTimeout(() => {
        try {
          var d, p, y, _;
          r.events.disconnect == null || r.events.disconnect(), (d = r.gl) == null || (p = d.renderLists) == null || p.dispose == null || p.dispose(), (y = r.gl) == null || y.forceContextLoss == null || y.forceContextLoss(), (_ = r.gl) != null && _.xr && r.xr.disconnect(), T9(r.scene), i_.delete(o);
        } catch {
        }
      }, 500);
    });
  }
}
function J9(o, e, t) {
  return /* @__PURE__ */ sf.jsx(K9, {
    children: o,
    container: e,
    state: t
  });
}
function K9({
  state: o = {},
  children: e,
  container: t
}) {
  const {
    events: a,
    size: r,
    ...d
  } = o, p = sR(), [y] = st.useState(() => new W2()), [_] = st.useState(() => new Ot()), E = iR((C, D) => {
    let B;
    if (D.camera && r) {
      const z = D.camera;
      B = C.viewport.getCurrentViewport(z, new ve(), r), z !== C.camera && Dw(z, r);
    }
    return {
      // The intersect consists of the previous root state
      ...C,
      ...D,
      // Portals have their own scene, which forms the root, a raycaster and a pointer
      scene: t,
      raycaster: y,
      pointer: _,
      mouse: _,
      // Their previous root is the layer before it
      previousRoot: p,
      // Events, size and viewport can be overridden by the inject layer
      events: {
        ...C.events,
        ...D.events,
        ...a
      },
      size: {
        ...C.size,
        ...r
      },
      viewport: {
        ...C.viewport,
        ...B
      },
      // Layers are allowed to override events
      setEvents: (z) => D.set((V) => ({
        ...V,
        events: {
          ...V.events,
          ...z
        }
      }))
    };
  }), T = st.useMemo(() => {
    const C = yw((B, z) => ({
      ...d,
      set: B,
      get: z
    })), D = (B) => C.setState((z) => E.current(B, z));
    return D(p.getState()), p.subscribe(D), C;
  }, [p, t]);
  return (
    // @ts-ignore, reconciler types are not maintained
    /* @__PURE__ */ sf.jsx(sf.Fragment, {
      children: ex.createPortal(/* @__PURE__ */ sf.jsx(lR.Provider, {
        value: T,
        children: e
      }), T, null)
    })
  );
}
const k9 = /* @__PURE__ */ new Set(), W9 = /* @__PURE__ */ new Set(), $9 = /* @__PURE__ */ new Set();
function CC(o, e) {
  if (o.size)
    for (const {
      callback: t
    } of o.values())
      t(e);
}
function PA(o, e) {
  switch (o) {
    case "before":
      return CC(k9, e);
    case "after":
      return CC(W9, e);
    case "tail":
      return CC($9, e);
  }
}
let RC, DC;
function i2(o, e, t) {
  let a = e.clock.getDelta();
  e.frameloop === "never" && typeof o == "number" && (a = o - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = o), RC = e.internal.subscribers;
  for (let r = 0; r < RC.length; r++)
    DC = RC[r], DC.ref.current(DC.store.getState(), a, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
let tx = !1, l2 = !1, BC, tU, s1;
function Lw(o) {
  tU = requestAnimationFrame(Lw), tx = !0, BC = 0, PA("before", o), l2 = !0;
  for (const t of i_.values()) {
    var e;
    s1 = t.store.getState(), s1.internal.active && (s1.frameloop === "always" || s1.internal.frames > 0) && !((e = s1.gl.xr) != null && e.isPresenting) && (BC += i2(o, s1));
  }
  if (l2 = !1, PA("after", o), BC === 0)
    return PA("tail", o), tx = !1, cancelAnimationFrame(tU);
}
function s2(o, e = 1) {
  var t;
  if (!o) return i_.forEach((a) => s2(a.store.getState(), e));
  (t = o.gl.xr) != null && t.isPresenting || !o.internal.active || o.frameloop === "never" || (e > 1 ? o.internal.frames = Math.min(60, o.internal.frames + e) : l2 ? o.internal.frames = 2 : o.internal.frames = 1, tx || (tx = !0, requestAnimationFrame(Lw)));
}
function nU(o, e = !0, t, a) {
  if (e && PA("before", o), t) i2(o, t, a);
  else for (const r of i_.values()) i2(o, r.store.getState());
  e && PA("after", o);
}
const UC = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function eI(o) {
  const {
    handlePointer: e
  } = w9(o);
  return {
    priority: 1,
    enabled: !0,
    compute(t, a, r) {
      a.pointer.set(t.offsetX / a.size.width * 2 - 1, -(t.offsetY / a.size.height) * 2 + 1), a.raycaster.setFromCamera(a.pointer, a.camera);
    },
    connected: void 0,
    handlers: Object.keys(UC).reduce((t, a) => ({
      ...t,
      [a]: e(a)
    }), {}),
    update: () => {
      var t;
      const {
        events: a,
        internal: r
      } = o.getState();
      (t = r.lastEvent) != null && t.current && a.handlers && a.handlers.onPointerMove(r.lastEvent.current);
    },
    connect: (t) => {
      const {
        set: a,
        events: r
      } = o.getState();
      if (r.disconnect == null || r.disconnect(), a((d) => ({
        events: {
          ...d.events,
          connected: t
        }
      })), r.handlers)
        for (const d in r.handlers) {
          const p = r.handlers[d], [y, _] = UC[d];
          t.addEventListener(y, p, {
            passive: _
          });
        }
    },
    disconnect: () => {
      const {
        set: t,
        events: a
      } = o.getState();
      if (a.connected) {
        if (a.handlers)
          for (const r in a.handlers) {
            const d = a.handlers[r], [p] = UC[r];
            a.connected.removeEventListener(p, d);
          }
        t((r) => ({
          events: {
            ...r.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
function aU(o, e) {
  let t;
  return (...a) => {
    window.clearTimeout(t), t = window.setTimeout(() => o(...a), e);
  };
}
function tI({ debounce: o, scroll: e, polyfill: t, offsetSize: a } = { debounce: 0, scroll: !1, offsetSize: !1 }) {
  const r = t || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!r) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [d, p] = NN({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), y = QD({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: d, orientationHandler: null }), _ = o ? typeof o == "number" ? o : o.scroll : null, E = o ? typeof o == "number" ? o : o.resize : null, T = QD(!1);
  OA(() => (T.current = !0, () => void (T.current = !1)));
  const [C, D, B] = zN(() => {
    const N = () => {
      if (!y.current.element) return;
      const { left: F, top: q, width: Y, height: ie, bottom: k, right: le, x: ne, y: Q } = y.current.element.getBoundingClientRect(), j = { left: F, top: q, width: Y, height: ie, bottom: k, right: le, x: ne, y: Q };
      y.current.element instanceof HTMLElement && a && (j.height = y.current.element.offsetHeight, j.width = y.current.element.offsetWidth), Object.freeze(j), T.current && !lI(y.current.lastBounds, j) && p(y.current.lastBounds = j);
    };
    return [N, E ? aU(N, E) : N, _ ? aU(N, _) : N];
  }, [p, a, _, E]);
  function z() {
    y.current.scrollContainers && (y.current.scrollContainers.forEach((N) => N.removeEventListener("scroll", B, !0)), y.current.scrollContainers = null), y.current.resizeObserver && (y.current.resizeObserver.disconnect(), y.current.resizeObserver = null), y.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", y.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", y.current.orientationHandler));
  }
  function V() {
    y.current.element && (y.current.resizeObserver = new r(B), y.current.resizeObserver.observe(y.current.element), e && y.current.scrollContainers && y.current.scrollContainers.forEach((N) => N.addEventListener("scroll", B, { capture: !0, passive: !0 })), y.current.orientationHandler = () => {
      B();
    }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", y.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", y.current.orientationHandler));
  }
  const G = (N) => {
    !N || N === y.current.element || (z(), y.current.element = N, y.current.scrollContainers = Gw(N), V());
  };
  return aI(B, !!e), nI(D), OA(() => {
    z(), V();
  }, [e, B, D]), OA(() => z, []), [G, d, C];
}
function nI(o) {
  OA(() => {
    const e = o;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [o]);
}
function aI(o, e) {
  OA(() => {
    if (e) {
      const t = o;
      return window.addEventListener("scroll", t, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [o, e]);
}
function Gw(o) {
  const e = [];
  if (!o || o === document.body) return e;
  const { overflow: t, overflowX: a, overflowY: r } = window.getComputedStyle(o);
  return [t, a, r].some((d) => d === "auto" || d === "scroll") && e.push(o), [...e, ...Gw(o.parentElement)];
}
const iI = ["x", "y", "top", "bottom", "left", "right", "width", "height"], lI = (o, e) => iI.every((t) => o[t] === e[t]);
function sI({
  ref: o,
  children: e,
  fallback: t,
  resize: a,
  style: r,
  gl: d,
  events: p = eI,
  eventSource: y,
  eventPrefix: _,
  shadows: E,
  linear: T,
  flat: C,
  legacy: D,
  orthographic: B,
  frameloop: z,
  dpr: V,
  performance: G,
  raycaster: N,
  camera: F,
  scene: q,
  onPointerMissed: Y,
  onCreated: ie,
  ...k
}) {
  st.useMemo(() => Gx(IG), []);
  const le = E9(), [ne, Q] = tI({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...a
  }), j = st.useRef(null), re = st.useRef(null);
  st.useImperativeHandle(o, () => j.current);
  const _e = iR(Y), [me, Ae] = st.useState(!1), [He, P] = st.useState(!1);
  if (me) throw me;
  if (He) throw He;
  const te = st.useRef(null);
  gE(() => {
    const Se = j.current;
    if (Q.width > 0 && Q.height > 0 && Se) {
      te.current || (te.current = Q9(Se));
      async function ue() {
        await te.current.configure({
          gl: d,
          scene: q,
          events: p,
          shadows: E,
          linear: T,
          flat: C,
          legacy: D,
          orthographic: B,
          frameloop: z,
          dpr: V,
          performance: G,
          raycaster: N,
          camera: F,
          size: Q,
          // Pass mutable reference to onPointerMissed so it's free to update
          onPointerMissed: (...we) => _e.current == null ? void 0 : _e.current(...we),
          onCreated: (we) => {
            we.events.connect == null || we.events.connect(y ? _9(y) ? y.current : y : re.current), _ && we.setEvents({
              compute: (De, We) => {
                const Me = De[_ + "X"], Ze = De[_ + "Y"];
                We.pointer.set(Me / We.size.width * 2 - 1, -(Ze / We.size.height) * 2 + 1), We.raycaster.setFromCamera(We.pointer, We.camera);
              }
            }), ie == null || ie(we);
          }
        }), te.current.render(/* @__PURE__ */ sf.jsx(le, {
          children: /* @__PURE__ */ sf.jsx(M9, {
            set: P,
            children: /* @__PURE__ */ sf.jsx(st.Suspense, {
              fallback: /* @__PURE__ */ sf.jsx(b9, {
                set: Ae
              }),
              children: e ?? null
            })
          })
        }));
      }
      ue();
    }
  }), st.useEffect(() => {
    const Se = j.current;
    if (Se) return () => Hw(Se);
  }, []);
  const ae = y ? "none" : "auto";
  return /* @__PURE__ */ sf.jsx("div", {
    ref: re,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: ae,
      ...r
    },
    ...k,
    children: /* @__PURE__ */ sf.jsx("div", {
      ref: ne,
      style: {
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ sf.jsx("canvas", {
        ref: j,
        style: {
          display: "block"
        },
        children: t
      })
    })
  });
}
function dF(o) {
  return /* @__PURE__ */ sf.jsx(bw, {
    children: /* @__PURE__ */ sf.jsx(sI, {
      ...o
    })
  });
}
function Jy() {
  return Jy = Object.assign ? Object.assign.bind() : function(o) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var a in t) ({}).hasOwnProperty.call(t, a) && (o[a] = t[a]);
    }
    return o;
  }, Jy.apply(null, arguments);
}
var kb = { exports: {} }, EA = {}, Wb = { exports: {} }, OC = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iU;
function rI() {
  return iU || (iU = 1, function(o) {
    function e(P, te) {
      var ae = P.length;
      P.push(te);
      e: for (; 0 < ae; ) {
        var Se = ae - 1 >>> 1, ue = P[Se];
        if (0 < r(ue, te))
          P[Se] = te, P[ae] = ue, ae = Se;
        else break e;
      }
    }
    function t(P) {
      return P.length === 0 ? null : P[0];
    }
    function a(P) {
      if (P.length === 0) return null;
      var te = P[0], ae = P.pop();
      if (ae !== te) {
        P[0] = ae;
        e: for (var Se = 0, ue = P.length, we = ue >>> 1; Se < we; ) {
          var De = 2 * (Se + 1) - 1, We = P[De], Me = De + 1, Ze = P[Me];
          if (0 > r(We, ae))
            Me < ue && 0 > r(Ze, We) ? (P[Se] = Ze, P[Me] = ae, Se = Me) : (P[Se] = We, P[De] = ae, Se = De);
          else if (Me < ue && 0 > r(Ze, ae))
            P[Se] = Ze, P[Me] = ae, Se = Me;
          else break e;
        }
      }
      return te;
    }
    function r(P, te) {
      var ae = P.sortIndex - te.sortIndex;
      return ae !== 0 ? ae : P.id - te.id;
    }
    if (o.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var d = performance;
      o.unstable_now = function() {
        return d.now();
      };
    } else {
      var p = Date, y = p.now();
      o.unstable_now = function() {
        return p.now() - y;
      };
    }
    var _ = [], E = [], T = 1, C = null, D = 3, B = !1, z = !1, V = !1, G = !1, N = typeof setTimeout == "function" ? setTimeout : null, F = typeof clearTimeout == "function" ? clearTimeout : null, q = typeof setImmediate < "u" ? setImmediate : null;
    function Y(P) {
      for (var te = t(E); te !== null; ) {
        if (te.callback === null) a(E);
        else if (te.startTime <= P)
          a(E), te.sortIndex = te.expirationTime, e(_, te);
        else break;
        te = t(E);
      }
    }
    function ie(P) {
      if (V = !1, Y(P), !z)
        if (t(_) !== null)
          z = !0, k || (k = !0, _e());
        else {
          var te = t(E);
          te !== null && He(ie, te.startTime - P);
        }
    }
    var k = !1, le = -1, ne = 5, Q = -1;
    function j() {
      return G ? !0 : !(o.unstable_now() - Q < ne);
    }
    function re() {
      if (G = !1, k) {
        var P = o.unstable_now();
        Q = P;
        var te = !0;
        try {
          e: {
            z = !1, V && (V = !1, F(le), le = -1), B = !0;
            var ae = D;
            try {
              t: {
                for (Y(P), C = t(_); C !== null && !(C.expirationTime > P && j()); ) {
                  var Se = C.callback;
                  if (typeof Se == "function") {
                    C.callback = null, D = C.priorityLevel;
                    var ue = Se(
                      C.expirationTime <= P
                    );
                    if (P = o.unstable_now(), typeof ue == "function") {
                      C.callback = ue, Y(P), te = !0;
                      break t;
                    }
                    C === t(_) && a(_), Y(P);
                  } else a(_);
                  C = t(_);
                }
                if (C !== null) te = !0;
                else {
                  var we = t(E);
                  we !== null && He(
                    ie,
                    we.startTime - P
                  ), te = !1;
                }
              }
              break e;
            } finally {
              C = null, D = ae, B = !1;
            }
            te = void 0;
          }
        } finally {
          te ? _e() : k = !1;
        }
      }
    }
    var _e;
    if (typeof q == "function")
      _e = function() {
        q(re);
      };
    else if (typeof MessageChannel < "u") {
      var me = new MessageChannel(), Ae = me.port2;
      me.port1.onmessage = re, _e = function() {
        Ae.postMessage(null);
      };
    } else
      _e = function() {
        N(re, 0);
      };
    function He(P, te) {
      le = N(function() {
        P(o.unstable_now());
      }, te);
    }
    o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(P) {
      P.callback = null;
    }, o.unstable_forceFrameRate = function(P) {
      0 > P || 125 < P ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : ne = 0 < P ? Math.floor(1e3 / P) : 5;
    }, o.unstable_getCurrentPriorityLevel = function() {
      return D;
    }, o.unstable_next = function(P) {
      switch (D) {
        case 1:
        case 2:
        case 3:
          var te = 3;
          break;
        default:
          te = D;
      }
      var ae = D;
      D = te;
      try {
        return P();
      } finally {
        D = ae;
      }
    }, o.unstable_requestPaint = function() {
      G = !0;
    }, o.unstable_runWithPriority = function(P, te) {
      switch (P) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          P = 3;
      }
      var ae = D;
      D = P;
      try {
        return te();
      } finally {
        D = ae;
      }
    }, o.unstable_scheduleCallback = function(P, te, ae) {
      var Se = o.unstable_now();
      switch (typeof ae == "object" && ae !== null ? (ae = ae.delay, ae = typeof ae == "number" && 0 < ae ? Se + ae : Se) : ae = Se, P) {
        case 1:
          var ue = -1;
          break;
        case 2:
          ue = 250;
          break;
        case 5:
          ue = 1073741823;
          break;
        case 4:
          ue = 1e4;
          break;
        default:
          ue = 5e3;
      }
      return ue = ae + ue, P = {
        id: T++,
        callback: te,
        priorityLevel: P,
        startTime: ae,
        expirationTime: ue,
        sortIndex: -1
      }, ae > Se ? (P.sortIndex = ae, e(E, P), t(_) === null && P === t(E) && (V ? (F(le), le = -1) : V = !0, He(ie, ae - Se))) : (P.sortIndex = ue, e(_, P), z || B || (z = !0, k || (k = !0, _e()))), P;
    }, o.unstable_shouldYield = j, o.unstable_wrapCallback = function(P) {
      var te = D;
      return function() {
        var ae = D;
        D = te;
        try {
          return P.apply(this, arguments);
        } finally {
          D = ae;
        }
      };
    };
  }(OC)), OC;
}
var wC = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lU;
function oI() {
  return lU || (lU = 1, function(o) {
    process.env.NODE_ENV !== "production" && function() {
      function e() {
        if (ie = !1, Q) {
          var P = o.unstable_now();
          _e = P;
          var te = !0;
          try {
            e: {
              q = !1, Y && (Y = !1, le(j), j = -1), F = !0;
              var ae = N;
              try {
                t: {
                  for (p(P), G = a(B); G !== null && !(G.expirationTime > P && _()); ) {
                    var Se = G.callback;
                    if (typeof Se == "function") {
                      G.callback = null, N = G.priorityLevel;
                      var ue = Se(
                        G.expirationTime <= P
                      );
                      if (P = o.unstable_now(), typeof ue == "function") {
                        G.callback = ue, p(P), te = !0;
                        break t;
                      }
                      G === a(B) && r(B), p(P);
                    } else r(B);
                    G = a(B);
                  }
                  if (G !== null) te = !0;
                  else {
                    var we = a(z);
                    we !== null && E(
                      y,
                      we.startTime - P
                    ), te = !1;
                  }
                }
                break e;
              } finally {
                G = null, N = ae, F = !1;
              }
              te = void 0;
            }
          } finally {
            te ? me() : Q = !1;
          }
        }
      }
      function t(P, te) {
        var ae = P.length;
        P.push(te);
        e: for (; 0 < ae; ) {
          var Se = ae - 1 >>> 1, ue = P[Se];
          if (0 < d(ue, te))
            P[Se] = te, P[ae] = ue, ae = Se;
          else break e;
        }
      }
      function a(P) {
        return P.length === 0 ? null : P[0];
      }
      function r(P) {
        if (P.length === 0) return null;
        var te = P[0], ae = P.pop();
        if (ae !== te) {
          P[0] = ae;
          e: for (var Se = 0, ue = P.length, we = ue >>> 1; Se < we; ) {
            var De = 2 * (Se + 1) - 1, We = P[De], Me = De + 1, Ze = P[Me];
            if (0 > d(We, ae))
              Me < ue && 0 > d(Ze, We) ? (P[Se] = Ze, P[Me] = ae, Se = Me) : (P[Se] = We, P[De] = ae, Se = De);
            else if (Me < ue && 0 > d(Ze, ae))
              P[Se] = Ze, P[Me] = ae, Se = Me;
            else break e;
          }
        }
        return te;
      }
      function d(P, te) {
        var ae = P.sortIndex - te.sortIndex;
        return ae !== 0 ? ae : P.id - te.id;
      }
      function p(P) {
        for (var te = a(z); te !== null; ) {
          if (te.callback === null) r(z);
          else if (te.startTime <= P)
            r(z), te.sortIndex = te.expirationTime, t(B, te);
          else break;
          te = a(z);
        }
      }
      function y(P) {
        if (Y = !1, p(P), !q)
          if (a(B) !== null)
            q = !0, Q || (Q = !0, me());
          else {
            var te = a(z);
            te !== null && E(
              y,
              te.startTime - P
            );
          }
      }
      function _() {
        return ie ? !0 : !(o.unstable_now() - _e < re);
      }
      function E(P, te) {
        j = k(function() {
          P(o.unstable_now());
        }, te);
      }
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error()), o.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var T = performance;
        o.unstable_now = function() {
          return T.now();
        };
      } else {
        var C = Date, D = C.now();
        o.unstable_now = function() {
          return C.now() - D;
        };
      }
      var B = [], z = [], V = 1, G = null, N = 3, F = !1, q = !1, Y = !1, ie = !1, k = typeof setTimeout == "function" ? setTimeout : null, le = typeof clearTimeout == "function" ? clearTimeout : null, ne = typeof setImmediate < "u" ? setImmediate : null, Q = !1, j = -1, re = 5, _e = -1;
      if (typeof ne == "function")
        var me = function() {
          ne(e);
        };
      else if (typeof MessageChannel < "u") {
        var Ae = new MessageChannel(), He = Ae.port2;
        Ae.port1.onmessage = e, me = function() {
          He.postMessage(null);
        };
      } else
        me = function() {
          k(e, 0);
        };
      o.unstable_IdlePriority = 5, o.unstable_ImmediatePriority = 1, o.unstable_LowPriority = 4, o.unstable_NormalPriority = 3, o.unstable_Profiling = null, o.unstable_UserBlockingPriority = 2, o.unstable_cancelCallback = function(P) {
        P.callback = null;
      }, o.unstable_forceFrameRate = function(P) {
        0 > P || 125 < P ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : re = 0 < P ? Math.floor(1e3 / P) : 5;
      }, o.unstable_getCurrentPriorityLevel = function() {
        return N;
      }, o.unstable_next = function(P) {
        switch (N) {
          case 1:
          case 2:
          case 3:
            var te = 3;
            break;
          default:
            te = N;
        }
        var ae = N;
        N = te;
        try {
          return P();
        } finally {
          N = ae;
        }
      }, o.unstable_requestPaint = function() {
        ie = !0;
      }, o.unstable_runWithPriority = function(P, te) {
        switch (P) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            P = 3;
        }
        var ae = N;
        N = P;
        try {
          return te();
        } finally {
          N = ae;
        }
      }, o.unstable_scheduleCallback = function(P, te, ae) {
        var Se = o.unstable_now();
        switch (typeof ae == "object" && ae !== null ? (ae = ae.delay, ae = typeof ae == "number" && 0 < ae ? Se + ae : Se) : ae = Se, P) {
          case 1:
            var ue = -1;
            break;
          case 2:
            ue = 250;
            break;
          case 5:
            ue = 1073741823;
            break;
          case 4:
            ue = 1e4;
            break;
          default:
            ue = 5e3;
        }
        return ue = ae + ue, P = {
          id: V++,
          callback: te,
          priorityLevel: P,
          startTime: ae,
          expirationTime: ue,
          sortIndex: -1
        }, ae > Se ? (P.sortIndex = ae, t(z, P), a(B) === null && P === a(z) && (Y ? (le(j), j = -1) : Y = !0, E(y, ae - Se))) : (P.sortIndex = ue, t(B, P), q || F || (q = !0, Q || (Q = !0, me()))), P;
      }, o.unstable_shouldYield = _, o.unstable_wrapCallback = function(P) {
        var te = N;
        return function() {
          var ae = N;
          N = te;
          try {
            return P.apply(this, arguments);
          } finally {
            N = ae;
          }
        };
      }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    }();
  }(wC)), wC;
}
var sU;
function Iw() {
  return sU || (sU = 1, process.env.NODE_ENV === "production" ? Wb.exports = rI() : Wb.exports = oI()), Wb.exports;
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rU;
function uI() {
  if (rU) return EA;
  rU = 1;
  var o = Iw(), e = Qm, t = EU;
  function a(s) {
    var f = "https://react.dev/errors/" + s;
    if (1 < arguments.length) {
      f += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var v = 2; v < arguments.length; v++)
        f += "&args[]=" + encodeURIComponent(arguments[v]);
    }
    return "Minified React error #" + s + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function r(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11);
  }
  function d(s) {
    var f = s, v = s;
    if (s.alternate) for (; f.return; ) f = f.return;
    else {
      s = f;
      do
        f = s, (f.flags & 4098) !== 0 && (v = f.return), s = f.return;
      while (s);
    }
    return f.tag === 3 ? v : null;
  }
  function p(s) {
    if (s.tag === 13) {
      var f = s.memoizedState;
      if (f === null && (s = s.alternate, s !== null && (f = s.memoizedState)), f !== null) return f.dehydrated;
    }
    return null;
  }
  function y(s) {
    if (d(s) !== s)
      throw Error(a(188));
  }
  function _(s) {
    var f = s.alternate;
    if (!f) {
      if (f = d(s), f === null) throw Error(a(188));
      return f !== s ? null : s;
    }
    for (var v = s, A = f; ; ) {
      var U = v.return;
      if (U === null) break;
      var H = U.alternate;
      if (H === null) {
        if (A = U.return, A !== null) {
          v = A;
          continue;
        }
        break;
      }
      if (U.child === H.child) {
        for (H = U.child; H; ) {
          if (H === v) return y(U), s;
          if (H === A) return y(U), f;
          H = H.sibling;
        }
        throw Error(a(188));
      }
      if (v.return !== A.return) v = U, A = H;
      else {
        for (var W = !1, oe = U.child; oe; ) {
          if (oe === v) {
            W = !0, v = U, A = H;
            break;
          }
          if (oe === A) {
            W = !0, A = U, v = H;
            break;
          }
          oe = oe.sibling;
        }
        if (!W) {
          for (oe = H.child; oe; ) {
            if (oe === v) {
              W = !0, v = H, A = U;
              break;
            }
            if (oe === A) {
              W = !0, A = H, v = U;
              break;
            }
            oe = oe.sibling;
          }
          if (!W) throw Error(a(189));
        }
      }
      if (v.alternate !== A) throw Error(a(190));
    }
    if (v.tag !== 3) throw Error(a(188));
    return v.stateNode.current === v ? s : f;
  }
  function E(s) {
    var f = s.tag;
    if (f === 5 || f === 26 || f === 27 || f === 6) return s;
    for (s = s.child; s !== null; ) {
      if (f = E(s), f !== null) return f;
      s = s.sibling;
    }
    return null;
  }
  var T = Object.assign, C = Symbol.for("react.element"), D = Symbol.for("react.transitional.element"), B = Symbol.for("react.portal"), z = Symbol.for("react.fragment"), V = Symbol.for("react.strict_mode"), G = Symbol.for("react.profiler"), N = Symbol.for("react.provider"), F = Symbol.for("react.consumer"), q = Symbol.for("react.context"), Y = Symbol.for("react.forward_ref"), ie = Symbol.for("react.suspense"), k = Symbol.for("react.suspense_list"), le = Symbol.for("react.memo"), ne = Symbol.for("react.lazy"), Q = Symbol.for("react.activity"), j = Symbol.for("react.memo_cache_sentinel"), re = Symbol.iterator;
  function _e(s) {
    return s === null || typeof s != "object" ? null : (s = re && s[re] || s["@@iterator"], typeof s == "function" ? s : null);
  }
  var me = Symbol.for("react.client.reference");
  function Ae(s) {
    if (s == null) return null;
    if (typeof s == "function")
      return s.$$typeof === me ? null : s.displayName || s.name || null;
    if (typeof s == "string") return s;
    switch (s) {
      case z:
        return "Fragment";
      case G:
        return "Profiler";
      case V:
        return "StrictMode";
      case ie:
        return "Suspense";
      case k:
        return "SuspenseList";
      case Q:
        return "Activity";
    }
    if (typeof s == "object")
      switch (s.$$typeof) {
        case B:
          return "Portal";
        case q:
          return (s.displayName || "Context") + ".Provider";
        case F:
          return (s._context.displayName || "Context") + ".Consumer";
        case Y:
          var f = s.render;
          return s = s.displayName, s || (s = f.displayName || f.name || "", s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"), s;
        case le:
          return f = s.displayName || null, f !== null ? f : Ae(s.type) || "Memo";
        case ne:
          f = s._payload, s = s._init;
          try {
            return Ae(s(f));
          } catch {
          }
      }
    return null;
  }
  var He = Array.isArray, P = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, te = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ae = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Se = [], ue = -1;
  function we(s) {
    return { current: s };
  }
  function De(s) {
    0 > ue || (s.current = Se[ue], Se[ue] = null, ue--);
  }
  function We(s, f) {
    ue++, Se[ue] = s.current, s.current = f;
  }
  var Me = we(null), Ze = we(null), ct = we(null), Vt = we(null);
  function Zt(s, f) {
    switch (We(ct, f), We(Ze, s), We(Me, null), f.nodeType) {
      case 9:
      case 11:
        s = (s = f.documentElement) && (s = s.namespaceURI) ? cr(s) : 0;
        break;
      default:
        if (s = f.tagName, f = f.namespaceURI)
          f = cr(f), s = Oh(f, s);
        else
          switch (s) {
            case "svg":
              s = 1;
              break;
            case "math":
              s = 2;
              break;
            default:
              s = 0;
          }
    }
    De(Me), We(Me, s);
  }
  function Bn() {
    De(Me), De(Ze), De(ct);
  }
  function rn(s) {
    s.memoizedState !== null && We(Vt, s);
    var f = Me.current, v = Oh(f, s.type);
    f !== v && (We(Ze, s), We(Me, v));
  }
  function dn(s) {
    Ze.current === s && (De(Me), De(Ze)), Vt.current === s && (De(Vt), Gn._currentValue = ae);
  }
  var Zn = Object.prototype.hasOwnProperty, Rn = o.unstable_scheduleCallback, Te = o.unstable_cancelCallback, Ha = o.unstable_shouldYield, Tt = o.unstable_requestPaint, St = o.unstable_now, Mt = o.unstable_getCurrentPriorityLevel, kt = o.unstable_ImmediatePriority, At = o.unstable_UserBlockingPriority, ce = o.unstable_NormalPriority, se = o.unstable_LowPriority, Xe = o.unstable_IdlePriority, dt = o.log, Et = o.unstable_setDisableYieldValue, yt = null, Jt = null;
  function Xt(s) {
    if (typeof dt == "function" && Et(s), Jt && typeof Jt.setStrictMode == "function")
      try {
        Jt.setStrictMode(yt, s);
      } catch {
      }
  }
  var Wt = Math.clz32 ? Math.clz32 : pn, Vn = Math.log, Pt = Math.LN2;
  function pn(s) {
    return s >>>= 0, s === 0 ? 32 : 31 - (Vn(s) / Pt | 0) | 0;
  }
  var gn = 256, nn = 4194304;
  function jt(s) {
    var f = s & 42;
    if (f !== 0) return f;
    switch (s & -s) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return s & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return s & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return s;
    }
  }
  function Ue(s, f, v) {
    var A = s.pendingLanes;
    if (A === 0) return 0;
    var U = 0, H = s.suspendedLanes, W = s.pingedLanes;
    s = s.warmLanes;
    var oe = A & 134217727;
    return oe !== 0 ? (A = oe & ~H, A !== 0 ? U = jt(A) : (W &= oe, W !== 0 ? U = jt(W) : v || (v = oe & ~s, v !== 0 && (U = jt(v))))) : (oe = A & ~H, oe !== 0 ? U = jt(oe) : W !== 0 ? U = jt(W) : v || (v = A & ~s, v !== 0 && (U = jt(v)))), U === 0 ? 0 : f !== 0 && f !== U && (f & H) === 0 && (H = U & -U, v = f & -f, H >= v || H === 32 && (v & 4194048) !== 0) ? f : U;
  }
  function ot(s, f) {
    return (s.pendingLanes & ~(s.suspendedLanes & ~s.pingedLanes) & f) === 0;
  }
  function Ht(s, f) {
    switch (s) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return f + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function xe() {
    var s = gn;
    return gn <<= 1, (gn & 4194048) === 0 && (gn = 256), s;
  }
  function Je() {
    var s = nn;
    return nn <<= 1, (nn & 62914560) === 0 && (nn = 4194304), s;
  }
  function tt(s) {
    for (var f = [], v = 0; 31 > v; v++) f.push(s);
    return f;
  }
  function Ct(s, f) {
    s.pendingLanes |= f, f !== 268435456 && (s.suspendedLanes = 0, s.pingedLanes = 0, s.warmLanes = 0);
  }
  function $t(s, f, v, A, U, H) {
    var W = s.pendingLanes;
    s.pendingLanes = v, s.suspendedLanes = 0, s.pingedLanes = 0, s.warmLanes = 0, s.expiredLanes &= v, s.entangledLanes &= v, s.errorRecoveryDisabledLanes &= v, s.shellSuspendCounter = 0;
    var oe = s.entanglements, be = s.expirationTimes, et = s.hiddenUpdates;
    for (v = W & ~v; 0 < v; ) {
      var Rt = 31 - Wt(v), zt = 1 << Rt;
      oe[Rt] = 0, be[Rt] = -1;
      var at = et[Rt];
      if (at !== null)
        for (et[Rt] = null, Rt = 0; Rt < at.length; Rt++) {
          var lt = at[Rt];
          lt !== null && (lt.lane &= -536870913);
        }
      v &= ~zt;
    }
    A !== 0 && tn(s, A, 0), H !== 0 && U === 0 && s.tag !== 0 && (s.suspendedLanes |= H & ~(W & ~f));
  }
  function tn(s, f, v) {
    s.pendingLanes |= f, s.suspendedLanes &= ~f;
    var A = 31 - Wt(f);
    s.entangledLanes |= f, s.entanglements[A] = s.entanglements[A] | 1073741824 | v & 4194090;
  }
  function Mn(s, f) {
    var v = s.entangledLanes |= f;
    for (s = s.entanglements; v; ) {
      var A = 31 - Wt(v), U = 1 << A;
      U & f | s[A] & f && (s[A] |= f), v &= ~U;
    }
  }
  function Wn(s) {
    switch (s) {
      case 2:
        s = 1;
        break;
      case 8:
        s = 4;
        break;
      case 32:
        s = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        s = 128;
        break;
      case 268435456:
        s = 134217728;
        break;
      default:
        s = 0;
    }
    return s;
  }
  function Xa(s) {
    return s &= -s, 2 < s ? 8 < s ? (s & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function sa() {
    var s = te.p;
    return s !== 0 ? s : (s = window.event, s === void 0 ? 32 : fy(s.type));
  }
  function ul(s, f) {
    var v = te.p;
    try {
      return te.p = s, f();
    } finally {
      te.p = v;
    }
  }
  var xa = Math.random().toString(36).slice(2), Ui = "__reactFiber$" + xa, cl = "__reactProps$" + xa, Xl = "__reactContainer$" + xa, Ws = "__reactEvents$" + xa, lu = "__reactListeners$" + xa, zl = "__reactHandles$" + xa, Jn = "__reactResources$" + xa, un = "__reactMarker$" + xa;
  function li(s) {
    delete s[Ui], delete s[cl], delete s[Ws], delete s[lu], delete s[zl];
  }
  function $(s) {
    var f = s[Ui];
    if (f) return f;
    for (var v = s.parentNode; v; ) {
      if (f = v[Xl] || v[Ui]) {
        if (v = f.alternate, f.child !== null || v !== null && v.child !== null)
          for (s = zr(s); s !== null; ) {
            if (v = s[Ui]) return v;
            s = zr(s);
          }
        return f;
      }
      s = v, v = s.parentNode;
    }
    return null;
  }
  function pe(s) {
    if (s = s[Ui] || s[Xl]) {
      var f = s.tag;
      if (f === 5 || f === 6 || f === 13 || f === 26 || f === 27 || f === 3)
        return s;
    }
    return null;
  }
  function Ne(s) {
    var f = s.tag;
    if (f === 5 || f === 26 || f === 27 || f === 6) return s.stateNode;
    throw Error(a(33));
  }
  function $e(s) {
    var f = s[Jn];
    return f || (f = s[Jn] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), f;
  }
  function nt(s) {
    s[un] = !0;
  }
  var pt = /* @__PURE__ */ new Set(), Ft = {};
  function Gt(s, f) {
    ee(s, f), ee(s + "Capture", f);
  }
  function ee(s, f) {
    for (Ft[s] = f, s = 0; s < f.length; s++)
      pt.add(f[s]);
  }
  var ye = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), Ee = {}, Re = {};
  function Ie(s) {
    return Zn.call(Re, s) ? !0 : Zn.call(Ee, s) ? !1 : ye.test(s) ? Re[s] = !0 : (Ee[s] = !0, !1);
  }
  function je(s, f, v) {
    if (Ie(f))
      if (v === null) s.removeAttribute(f);
      else {
        switch (typeof v) {
          case "undefined":
          case "function":
          case "symbol":
            s.removeAttribute(f);
            return;
          case "boolean":
            var A = f.toLowerCase().slice(0, 5);
            if (A !== "data-" && A !== "aria-") {
              s.removeAttribute(f);
              return;
            }
        }
        s.setAttribute(f, "" + v);
      }
  }
  function _t(s, f, v) {
    if (v === null) s.removeAttribute(f);
    else {
      switch (typeof v) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          s.removeAttribute(f);
          return;
      }
      s.setAttribute(f, "" + v);
    }
  }
  function Ut(s, f, v, A) {
    if (A === null) s.removeAttribute(v);
    else {
      switch (typeof A) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          s.removeAttribute(v);
          return;
      }
      s.setAttributeNS(f, v, "" + A);
    }
  }
  var It, on;
  function sn(s) {
    if (It === void 0)
      try {
        throw Error();
      } catch (v) {
        var f = v.stack.trim().match(/\n( *(at )?)/);
        It = f && f[1] || "", on = -1 < v.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < v.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + It + s + on;
  }
  var Qt = !1;
  function bn(s, f) {
    if (!s || Qt) return "";
    Qt = !0;
    var v = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var A = {
        DetermineComponentFrameRoot: function() {
          try {
            if (f) {
              var zt = function() {
                throw Error();
              };
              if (Object.defineProperty(zt.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(zt, []);
                } catch (lt) {
                  var at = lt;
                }
                Reflect.construct(s, [], zt);
              } else {
                try {
                  zt.call();
                } catch (lt) {
                  at = lt;
                }
                s.call(zt.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (lt) {
                at = lt;
              }
              (zt = s()) && typeof zt.catch == "function" && zt.catch(function() {
              });
            }
          } catch (lt) {
            if (lt && at && typeof lt.stack == "string")
              return [lt.stack, at.stack];
          }
          return [null, null];
        }
      };
      A.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var U = Object.getOwnPropertyDescriptor(
        A.DetermineComponentFrameRoot,
        "name"
      );
      U && U.configurable && Object.defineProperty(
        A.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var H = A.DetermineComponentFrameRoot(), W = H[0], oe = H[1];
      if (W && oe) {
        var be = W.split(`
`), et = oe.split(`
`);
        for (U = A = 0; A < be.length && !be[A].includes("DetermineComponentFrameRoot"); )
          A++;
        for (; U < et.length && !et[U].includes(
          "DetermineComponentFrameRoot"
        ); )
          U++;
        if (A === be.length || U === et.length)
          for (A = be.length - 1, U = et.length - 1; 1 <= A && 0 <= U && be[A] !== et[U]; )
            U--;
        for (; 1 <= A && 0 <= U; A--, U--)
          if (be[A] !== et[U]) {
            if (A !== 1 || U !== 1)
              do
                if (A--, U--, 0 > U || be[A] !== et[U]) {
                  var Rt = `
` + be[A].replace(" at new ", " at ");
                  return s.displayName && Rt.includes("<anonymous>") && (Rt = Rt.replace("<anonymous>", s.displayName)), Rt;
                }
              while (1 <= A && 0 <= U);
            break;
          }
      }
    } finally {
      Qt = !1, Error.prepareStackTrace = v;
    }
    return (v = s ? s.displayName || s.name : "") ? sn(v) : "";
  }
  function En(s) {
    switch (s.tag) {
      case 26:
      case 27:
      case 5:
        return sn(s.type);
      case 16:
        return sn("Lazy");
      case 13:
        return sn("Suspense");
      case 19:
        return sn("SuspenseList");
      case 0:
      case 15:
        return bn(s.type, !1);
      case 11:
        return bn(s.type.render, !1);
      case 1:
        return bn(s.type, !0);
      case 31:
        return sn("Activity");
      default:
        return "";
    }
  }
  function ca(s) {
    try {
      var f = "";
      do
        f += En(s), s = s.return;
      while (s);
      return f;
    } catch (v) {
      return `
Error generating stack: ` + v.message + `
` + v.stack;
    }
  }
  function yn(s) {
    switch (typeof s) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return s;
      case "object":
        return s;
      default:
        return "";
    }
  }
  function zn(s) {
    var f = s.type;
    return (s = s.nodeName) && s.toLowerCase() === "input" && (f === "checkbox" || f === "radio");
  }
  function xn(s) {
    var f = zn(s) ? "checked" : "value", v = Object.getOwnPropertyDescriptor(
      s.constructor.prototype,
      f
    ), A = "" + s[f];
    if (!s.hasOwnProperty(f) && typeof v < "u" && typeof v.get == "function" && typeof v.set == "function") {
      var U = v.get, H = v.set;
      return Object.defineProperty(s, f, {
        configurable: !0,
        get: function() {
          return U.call(this);
        },
        set: function(W) {
          A = "" + W, H.call(this, W);
        }
      }), Object.defineProperty(s, f, {
        enumerable: v.enumerable
      }), {
        getValue: function() {
          return A;
        },
        setValue: function(W) {
          A = "" + W;
        },
        stopTracking: function() {
          s._valueTracker = null, delete s[f];
        }
      };
    }
  }
  function si(s) {
    s._valueTracker || (s._valueTracker = xn(s));
  }
  function jn(s) {
    if (!s) return !1;
    var f = s._valueTracker;
    if (!f) return !0;
    var v = f.getValue(), A = "";
    return s && (A = zn(s) ? s.checked ? "true" : "false" : s.value), s = A, s !== v ? (f.setValue(s), !0) : !1;
  }
  function ta(s) {
    if (s = s || (typeof document < "u" ? document : void 0), typeof s > "u") return null;
    try {
      return s.activeElement || s.body;
    } catch {
      return s.body;
    }
  }
  var Li = /[\n"\\]/g;
  function Qn(s) {
    return s.replace(
      Li,
      function(f) {
        return "\\" + f.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Ta(s, f, v, A, U, H, W, oe) {
    s.name = "", W != null && typeof W != "function" && typeof W != "symbol" && typeof W != "boolean" ? s.type = W : s.removeAttribute("type"), f != null ? W === "number" ? (f === 0 && s.value === "" || s.value != f) && (s.value = "" + yn(f)) : s.value !== "" + yn(f) && (s.value = "" + yn(f)) : W !== "submit" && W !== "reset" || s.removeAttribute("value"), f != null ? qi(s, W, yn(f)) : v != null ? qi(s, W, yn(v)) : A != null && s.removeAttribute("value"), U == null && H != null && (s.defaultChecked = !!H), U != null && (s.checked = U && typeof U != "function" && typeof U != "symbol"), oe != null && typeof oe != "function" && typeof oe != "symbol" && typeof oe != "boolean" ? s.name = "" + yn(oe) : s.removeAttribute("name");
  }
  function da(s, f, v, A, U, H, W, oe) {
    if (H != null && typeof H != "function" && typeof H != "symbol" && typeof H != "boolean" && (s.type = H), f != null || v != null) {
      if (!(H !== "submit" && H !== "reset" || f != null))
        return;
      v = v != null ? "" + yn(v) : "", f = f != null ? "" + yn(f) : v, oe || f === s.value || (s.value = f), s.defaultValue = f;
    }
    A = A ?? U, A = typeof A != "function" && typeof A != "symbol" && !!A, s.checked = oe ? s.checked : !!A, s.defaultChecked = !!A, W != null && typeof W != "function" && typeof W != "symbol" && typeof W != "boolean" && (s.name = W);
  }
  function qi(s, f, v) {
    f === "number" && ta(s.ownerDocument) === s || s.defaultValue === "" + v || (s.defaultValue = "" + v);
  }
  function Ya(s, f, v, A) {
    if (s = s.options, f) {
      f = {};
      for (var U = 0; U < v.length; U++)
        f["$" + v[U]] = !0;
      for (v = 0; v < s.length; v++)
        U = f.hasOwnProperty("$" + s[v].value), s[v].selected !== U && (s[v].selected = U), U && A && (s[v].defaultSelected = !0);
    } else {
      for (v = "" + yn(v), f = null, U = 0; U < s.length; U++) {
        if (s[U].value === v) {
          s[U].selected = !0, A && (s[U].defaultSelected = !0);
          return;
        }
        f !== null || s[U].disabled || (f = s[U]);
      }
      f !== null && (f.selected = !0);
    }
  }
  function Ei(s, f, v) {
    if (f != null && (f = "" + yn(f), f !== s.value && (s.value = f), v == null)) {
      s.defaultValue !== f && (s.defaultValue = f);
      return;
    }
    s.defaultValue = v != null ? "" + yn(v) : "";
  }
  function Wi(s, f, v, A) {
    if (f == null) {
      if (A != null) {
        if (v != null) throw Error(a(92));
        if (He(A)) {
          if (1 < A.length) throw Error(a(93));
          A = A[0];
        }
        v = A;
      }
      v == null && (v = ""), f = v;
    }
    v = yn(f), s.defaultValue = v, A = s.textContent, A === v && A !== "" && A !== null && (s.value = A);
  }
  function Hl(s, f) {
    if (f) {
      var v = s.firstChild;
      if (v && v === s.lastChild && v.nodeType === 3) {
        v.nodeValue = f;
        return;
      }
    }
    s.textContent = f;
  }
  var Pr = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function ff(s, f, v) {
    var A = f.indexOf("--") === 0;
    v == null || typeof v == "boolean" || v === "" ? A ? s.setProperty(f, "") : f === "float" ? s.cssFloat = "" : s[f] = "" : A ? s.setProperty(f, v) : typeof v != "number" || v === 0 || Pr.has(f) ? f === "float" ? s.cssFloat = v : s[f] = ("" + v).trim() : s[f] = v + "px";
  }
  function Xu(s, f, v) {
    if (f != null && typeof f != "object")
      throw Error(a(62));
    if (s = s.style, v != null) {
      for (var A in v)
        !v.hasOwnProperty(A) || f != null && f.hasOwnProperty(A) || (A.indexOf("--") === 0 ? s.setProperty(A, "") : A === "float" ? s.cssFloat = "" : s[A] = "");
      for (var U in f)
        A = f[U], f.hasOwnProperty(U) && v[U] !== A && ff(s, U, A);
    } else
      for (var H in f)
        f.hasOwnProperty(H) && ff(s, H, f[H]);
  }
  function Yu(s) {
    if (s.indexOf("-") === -1) return !1;
    switch (s) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var $v = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), Kg = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Zh(s) {
    return Kg.test("" + s) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : s;
  }
  var Ec = null;
  function Vp(s) {
    return s = s.target || s.srcElement || window, s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === 3 ? s.parentNode : s;
  }
  var ad = null, df = null;
  function eg(s) {
    var f = pe(s);
    if (f && (s = f.stateNode)) {
      var v = s[cl] || null;
      e: switch (s = f.stateNode, f.type) {
        case "input":
          if (Ta(
            s,
            v.value,
            v.defaultValue,
            v.defaultValue,
            v.checked,
            v.defaultChecked,
            v.type,
            v.name
          ), f = v.name, v.type === "radio" && f != null) {
            for (v = s; v.parentNode; ) v = v.parentNode;
            for (v = v.querySelectorAll(
              'input[name="' + Qn(
                "" + f
              ) + '"][type="radio"]'
            ), f = 0; f < v.length; f++) {
              var A = v[f];
              if (A !== s && A.form === s.form) {
                var U = A[cl] || null;
                if (!U) throw Error(a(90));
                Ta(
                  A,
                  U.value,
                  U.defaultValue,
                  U.defaultValue,
                  U.checked,
                  U.defaultChecked,
                  U.type,
                  U.name
                );
              }
            }
            for (f = 0; f < v.length; f++)
              A = v[f], A.form === s.form && jn(A);
          }
          break e;
        case "textarea":
          Ei(s, v.value, v.defaultValue);
          break e;
        case "select":
          f = v.value, f != null && Ya(s, !!v.multiple, f, !1);
      }
    }
  }
  var Fp = !1;
  function Kd(s, f, v) {
    if (Fp) return s(f, v);
    Fp = !0;
    try {
      var A = s(f);
      return A;
    } finally {
      if (Fp = !1, (ad !== null || df !== null) && (Kl(), ad && (f = ad, s = df, df = ad = null, eg(f), s)))
        for (f = 0; f < s.length; f++) eg(s[f]);
    }
  }
  function fl(s, f) {
    var v = s.stateNode;
    if (v === null) return null;
    var A = v[cl] || null;
    if (A === null) return null;
    v = A[f];
    e: switch (f) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (A = !A.disabled) || (s = s.type, A = !(s === "button" || s === "input" || s === "select" || s === "textarea")), s = !A;
        break e;
      default:
        s = !1;
    }
    if (s) return null;
    if (v && typeof v != "function")
      throw Error(
        a(231, f, typeof v)
      );
    return v;
  }
  var To = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), id = !1;
  if (To)
    try {
      var Co = {};
      Object.defineProperty(Co, "passive", {
        get: function() {
          id = !0;
        }
      }), window.addEventListener("test", Co, Co), window.removeEventListener("test", Co, Co);
    } catch {
      id = !1;
    }
  var su = null, ld = null, hf = null;
  function Km() {
    if (hf) return hf;
    var s, f = ld, v = f.length, A, U = "value" in su ? su.value : su.textContent, H = U.length;
    for (s = 0; s < v && f[s] === U[s]; s++) ;
    var W = v - s;
    for (A = 1; A <= W && f[v - A] === U[H - A]; A++) ;
    return hf = U.slice(s, 1 < A ? 1 - A : void 0);
  }
  function Ll(s) {
    var f = s.keyCode;
    return "charCode" in s ? (s = s.charCode, s === 0 && f === 13 && (s = 13)) : s = f, s === 10 && (s = 13), 32 <= s || s === 13 ? s : 0;
  }
  function kd() {
    return !0;
  }
  function sd() {
    return !1;
  }
  function xl(s) {
    function f(v, A, U, H, W) {
      this._reactName = v, this._targetInst = U, this.type = A, this.nativeEvent = H, this.target = W, this.currentTarget = null;
      for (var oe in s)
        s.hasOwnProperty(oe) && (v = s[oe], this[oe] = v ? v(H) : H[oe]);
      return this.isDefaultPrevented = (H.defaultPrevented != null ? H.defaultPrevented : H.returnValue === !1) ? kd : sd, this.isPropagationStopped = sd, this;
    }
    return T(f.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var v = this.nativeEvent;
        v && (v.preventDefault ? v.preventDefault() : typeof v.returnValue != "unknown" && (v.returnValue = !1), this.isDefaultPrevented = kd);
      },
      stopPropagation: function() {
        var v = this.nativeEvent;
        v && (v.stopPropagation ? v.stopPropagation() : typeof v.cancelBubble != "unknown" && (v.cancelBubble = !0), this.isPropagationStopped = kd);
      },
      persist: function() {
      },
      isPersistent: kd
    }), f;
  }
  var pf = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(s) {
      return s.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, ru = xl(pf), Ro = T({}, pf, { view: 0, detail: 0 }), Pp = xl(Ro), ra, Yt, bc, qu = T({}, Ro, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: ou,
    button: 0,
    buttons: 0,
    relatedTarget: function(s) {
      return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget;
    },
    movementX: function(s) {
      return "movementX" in s ? s.movementX : (s !== bc && (bc && s.type === "mousemove" ? (ra = s.screenX - bc.screenX, Yt = s.screenY - bc.screenY) : Yt = ra = 0, bc = s), ra);
    },
    movementY: function(s) {
      return "movementY" in s ? s.movementY : Yt;
    }
  }), dl = xl(qu), km = T({}, qu, { dataTransfer: 0 }), tg = xl(km), Is = T({}, Ro, { relatedTarget: 0 }), Xp = xl(Is), ky = T({}, pf, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), ng = xl(ky), ag = T({}, pf, {
    clipboardData: function(s) {
      return "clipboardData" in s ? s.clipboardData : window.clipboardData;
    }
  }), Wd = xl(ag), ms = T({}, pf, { data: 0 }), fi = xl(ms), Qh = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, mf = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, vf = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function Do(s) {
    var f = this.nativeEvent;
    return f.getModifierState ? f.getModifierState(s) : (s = vf[s]) ? !!f[s] : !1;
  }
  function ou() {
    return Do;
  }
  var uu = T({}, Ro, {
    key: function(s) {
      if (s.key) {
        var f = Qh[s.key] || s.key;
        if (f !== "Unidentified") return f;
      }
      return s.type === "keypress" ? (s = Ll(s), s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? mf[s.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: ou,
    charCode: function(s) {
      return s.type === "keypress" ? Ll(s) : 0;
    },
    keyCode: function(s) {
      return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
    },
    which: function(s) {
      return s.type === "keypress" ? Ll(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
    }
  }), Xr = xl(uu), vs = T({}, qu, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), rd = xl(vs), $d = T({}, Ro, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: ou
  }), Yp = xl($d), mr = T({}, pf, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Mc = xl(mr), jh = T({}, qu, {
    deltaX: function(s) {
      return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0;
    },
    deltaY: function(s) {
      return "deltaY" in s ? s.deltaY : "wheelDeltaY" in s ? -s.wheelDeltaY : "wheelDelta" in s ? -s.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), eh = xl(jh), qp = T({}, pf, {
    newState: 0,
    oldState: 0
  }), xc = xl(qp), Zu = [9, 13, 27, 32], th = To && "CompositionEvent" in window, nh = null;
  To && "documentMode" in document && (nh = document.documentMode);
  var ah = To && "TextEvent" in window && !nh, cu = To && (!th || nh && 8 < nh && 11 >= nh), gf = " ", ts = !1;
  function od(s, f) {
    switch (s) {
      case "keyup":
        return Zu.indexOf(f.keyCode) !== -1;
      case "keydown":
        return f.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Tc(s) {
    return s = s.detail, typeof s == "object" && "data" in s ? s.data : null;
  }
  var Cc = !1;
  function ih(s, f) {
    switch (s) {
      case "compositionend":
        return Tc(f);
      case "keypress":
        return f.which !== 32 ? null : (ts = !0, gf);
      case "textInput":
        return s = f.data, s === gf && ts ? null : s;
      default:
        return null;
    }
  }
  function Bo(s, f) {
    if (Cc)
      return s === "compositionend" || !th && od(s, f) ? (s = Km(), hf = ld = su = null, Cc = !1, s) : null;
    switch (s) {
      case "paste":
        return null;
      case "keypress":
        if (!(f.ctrlKey || f.altKey || f.metaKey) || f.ctrlKey && f.altKey) {
          if (f.char && 1 < f.char.length)
            return f.char;
          if (f.which) return String.fromCharCode(f.which);
        }
        return null;
      case "compositionend":
        return cu && f.locale !== "ko" ? null : f.data;
      default:
        return null;
    }
  }
  var lh = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Zp(s) {
    var f = s && s.nodeName && s.nodeName.toLowerCase();
    return f === "input" ? !!lh[s.type] : f === "textarea";
  }
  function vr(s, f, v, A) {
    ad ? df ? df.push(A) : df = [A] : ad = A, f = wd(f, "onChange"), 0 < f.length && (v = new ru(
      "onChange",
      "change",
      null,
      v,
      A
    ), s.push({ event: v, listeners: f }));
  }
  var Yr = null, Vs = null;
  function Qp(s) {
    Bh(s, 0);
  }
  function $s(s) {
    var f = Ne(s);
    if (jn(f)) return s;
  }
  function Fs(s, f) {
    if (s === "change") return f;
  }
  var sh = !1;
  if (To) {
    var yf;
    if (To) {
      var Rc = "oninput" in document;
      if (!Rc) {
        var ud = document.createElement("div");
        ud.setAttribute("oninput", "return;"), Rc = typeof ud.oninput == "function";
      }
      yf = Rc;
    } else yf = !1;
    sh = yf && (!document.documentMode || 9 < document.documentMode);
  }
  function yi() {
    Yr && (Yr.detachEvent("onpropertychange", Wm), Vs = Yr = null);
  }
  function Wm(s) {
    if (s.propertyName === "value" && $s(Vs)) {
      var f = [];
      vr(
        f,
        Vs,
        s,
        Vp(s)
      ), Kd(Qp, f);
    }
  }
  function Jh(s, f, v) {
    s === "focusin" ? (yi(), Yr = f, Vs = v, Yr.attachEvent("onpropertychange", Wm)) : s === "focusout" && yi();
  }
  function Dc(s) {
    if (s === "selectionchange" || s === "keyup" || s === "keydown")
      return $s(Vs);
  }
  function gr(s, f) {
    if (s === "click") return $s(f);
  }
  function Qu(s, f) {
    if (s === "input" || s === "change")
      return $s(f);
  }
  function $m(s, f) {
    return s === f && (s !== 0 || 1 / s === 1 / f) || s !== s && f !== f;
  }
  var gs = typeof Object.is == "function" ? Object.is : $m;
  function yr(s, f) {
    if (gs(s, f)) return !0;
    if (typeof s != "object" || s === null || typeof f != "object" || f === null)
      return !1;
    var v = Object.keys(s), A = Object.keys(f);
    if (v.length !== A.length) return !1;
    for (A = 0; A < v.length; A++) {
      var U = v[A];
      if (!Zn.call(f, U) || !gs(s[U], f[U]))
        return !1;
    }
    return !0;
  }
  function Yl(s) {
    for (; s && s.firstChild; ) s = s.firstChild;
    return s;
  }
  function Zi(s, f) {
    var v = Yl(s);
    s = 0;
    for (var A; v; ) {
      if (v.nodeType === 3) {
        if (A = s + v.textContent.length, s <= f && A >= f)
          return { node: v, offset: f - s };
        s = A;
      }
      e: {
        for (; v; ) {
          if (v.nextSibling) {
            v = v.nextSibling;
            break e;
          }
          v = v.parentNode;
        }
        v = void 0;
      }
      v = Yl(v);
    }
  }
  function Kh(s, f) {
    return s && f ? s === f ? !0 : s && s.nodeType === 3 ? !1 : f && f.nodeType === 3 ? Kh(s, f.parentNode) : "contains" in s ? s.contains(f) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(f) & 16) : !1 : !1;
  }
  function jp(s) {
    s = s != null && s.ownerDocument != null && s.ownerDocument.defaultView != null ? s.ownerDocument.defaultView : window;
    for (var f = ta(s.document); f instanceof s.HTMLIFrameElement; ) {
      try {
        var v = typeof f.contentWindow.location.href == "string";
      } catch {
        v = !1;
      }
      if (v) s = f.contentWindow;
      else break;
      f = ta(s.document);
    }
    return f;
  }
  function rh(s) {
    var f = s && s.nodeName && s.nodeName.toLowerCase();
    return f && (f === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || f === "textarea" || s.contentEditable === "true");
  }
  var Sf = To && "documentMode" in document && 11 >= document.documentMode, ys = null, Uo = null, _f = null, oh = !1;
  function ev(s, f, v) {
    var A = v.window === v ? v.document : v.nodeType === 9 ? v : v.ownerDocument;
    oh || ys == null || ys !== ta(A) || (A = ys, "selectionStart" in A && rh(A) ? A = { start: A.selectionStart, end: A.selectionEnd } : (A = (A.ownerDocument && A.ownerDocument.defaultView || window).getSelection(), A = {
      anchorNode: A.anchorNode,
      anchorOffset: A.anchorOffset,
      focusNode: A.focusNode,
      focusOffset: A.focusOffset
    }), _f && yr(_f, A) || (_f = A, A = wd(Uo, "onSelect"), 0 < A.length && (f = new ru(
      "onSelect",
      "select",
      null,
      f,
      v
    ), s.push({ event: f, listeners: A }), f.target = ys)));
  }
  function ns(s, f) {
    var v = {};
    return v[s.toLowerCase()] = f.toLowerCase(), v["Webkit" + s] = "webkit" + f, v["Moz" + s] = "moz" + f, v;
  }
  var fu = {
    animationend: ns("Animation", "AnimationEnd"),
    animationiteration: ns("Animation", "AnimationIteration"),
    animationstart: ns("Animation", "AnimationStart"),
    transitionrun: ns("Transition", "TransitionRun"),
    transitionstart: ns("Transition", "TransitionStart"),
    transitioncancel: ns("Transition", "TransitionCancel"),
    transitionend: ns("Transition", "TransitionEnd")
  }, qr = {}, Oo = {};
  To && (Oo = document.createElement("div").style, "AnimationEvent" in window || (delete fu.animationend.animation, delete fu.animationiteration.animation, delete fu.animationstart.animation), "TransitionEvent" in window || delete fu.transitionend.transition);
  function du(s) {
    if (qr[s]) return qr[s];
    if (!fu[s]) return s;
    var f = fu[s], v;
    for (v in f)
      if (f.hasOwnProperty(v) && v in Oo)
        return qr[s] = f[v];
    return s;
  }
  var Sr = du("animationend"), Jp = du("animationiteration"), _r = du("animationstart"), tv = du("transitionrun"), hu = du("transitionstart"), pu = du("transitioncancel"), mu = du("transitionend"), Kp = /* @__PURE__ */ new Map(), Af = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Af.push("scrollEnd");
  function ql(s, f) {
    Kp.set(s, f), Gt(f, [s]);
  }
  var kp = /* @__PURE__ */ new WeakMap();
  function Ps(s, f) {
    if (typeof s == "object" && s !== null) {
      var v = kp.get(s);
      return v !== void 0 ? v : (f = {
        value: s,
        source: f,
        stack: ca(f)
      }, kp.set(s, f), f);
    }
    return {
      value: s,
      source: f,
      stack: ca(f)
    };
  }
  var ri = [], Zr = 0, ju = 0;
  function vu() {
    for (var s = Zr, f = ju = Zr = 0; f < s; ) {
      var v = ri[f];
      ri[f++] = null;
      var A = ri[f];
      ri[f++] = null;
      var U = ri[f];
      ri[f++] = null;
      var H = ri[f];
      if (ri[f++] = null, A !== null && U !== null) {
        var W = A.pending;
        W === null ? U.next = U : (U.next = W.next, W.next = U), A.pending = U;
      }
      H !== 0 && cd(v, U, H);
    }
  }
  function gu(s, f, v, A) {
    ri[Zr++] = s, ri[Zr++] = f, ri[Zr++] = v, ri[Zr++] = A, ju |= A, s.lanes |= A, s = s.alternate, s !== null && (s.lanes |= A);
  }
  function uh(s, f, v, A) {
    return gu(s, f, v, A), ch(s);
  }
  function er(s, f) {
    return gu(s, null, null, f), ch(s);
  }
  function cd(s, f, v) {
    s.lanes |= v;
    var A = s.alternate;
    A !== null && (A.lanes |= v);
    for (var U = !1, H = s.return; H !== null; )
      H.childLanes |= v, A = H.alternate, A !== null && (A.childLanes |= v), H.tag === 22 && (s = H.stateNode, s === null || s._visibility & 1 || (U = !0)), s = H, H = H.return;
    return s.tag === 3 ? (H = s.stateNode, U && f !== null && (U = 31 - Wt(v), s = H.hiddenUpdates, A = s[U], A === null ? s[U] = [f] : A.push(f), f.lane = v | 536870912), H) : null;
  }
  function ch(s) {
    if (50 < Qc)
      throw Qc = 0, Fl = null, Error(a(185));
    for (var f = s.return; f !== null; )
      s = f, f = s.return;
    return s.tag === 3 ? s.stateNode : null;
  }
  var fd = {};
  function nv(s, f, v, A) {
    this.tag = s, this.key = v, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = f, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = A, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function tr(s, f, v, A) {
    return new nv(s, f, v, A);
  }
  function dd(s) {
    return s = s.prototype, !(!s || !s.isReactComponent);
  }
  function tl(s, f) {
    var v = s.alternate;
    return v === null ? (v = tr(
      s.tag,
      f,
      s.key,
      s.mode
    ), v.elementType = s.elementType, v.type = s.type, v.stateNode = s.stateNode, v.alternate = s, s.alternate = v) : (v.pendingProps = f, v.type = s.type, v.flags = 0, v.subtreeFlags = 0, v.deletions = null), v.flags = s.flags & 65011712, v.childLanes = s.childLanes, v.lanes = s.lanes, v.child = s.child, v.memoizedProps = s.memoizedProps, v.memoizedState = s.memoizedState, v.updateQueue = s.updateQueue, f = s.dependencies, v.dependencies = f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }, v.sibling = s.sibling, v.index = s.index, v.ref = s.ref, v.refCleanup = s.refCleanup, v;
  }
  function Ca(s, f) {
    s.flags &= 65011714;
    var v = s.alternate;
    return v === null ? (s.childLanes = 0, s.lanes = f, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = v.childLanes, s.lanes = v.lanes, s.child = v.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = v.memoizedProps, s.memoizedState = v.memoizedState, s.updateQueue = v.updateQueue, s.type = v.type, f = v.dependencies, s.dependencies = f === null ? null : {
      lanes: f.lanes,
      firstContext: f.firstContext
    }), s;
  }
  function Lt(s, f, v, A, U, H) {
    var W = 0;
    if (A = s, typeof s == "function") dd(s) && (W = 1);
    else if (typeof s == "string")
      W = $c(
        s,
        v,
        Me.current
      ) ? 26 : s === "html" || s === "head" || s === "body" ? 27 : 5;
    else
      e: switch (s) {
        case Q:
          return s = tr(31, v, f, U), s.elementType = Q, s.lanes = H, s;
        case z:
          return Qr(v.children, U, H, f);
        case V:
          W = 8, U |= 24;
          break;
        case G:
          return s = tr(12, v, f, U | 2), s.elementType = G, s.lanes = H, s;
        case ie:
          return s = tr(13, v, f, U), s.elementType = ie, s.lanes = H, s;
        case k:
          return s = tr(19, v, f, U), s.elementType = k, s.lanes = H, s;
        default:
          if (typeof s == "object" && s !== null)
            switch (s.$$typeof) {
              case N:
              case q:
                W = 10;
                break e;
              case F:
                W = 9;
                break e;
              case Y:
                W = 11;
                break e;
              case le:
                W = 14;
                break e;
              case ne:
                W = 16, A = null;
                break e;
            }
          W = 29, v = Error(
            a(130, s === null ? "null" : typeof s, "")
          ), A = null;
      }
    return f = tr(W, v, f, U), f.elementType = s, f.type = A, f.lanes = H, f;
  }
  function Qr(s, f, v, A) {
    return s = tr(7, s, A, f), s.lanes = v, s;
  }
  function Ef(s, f, v) {
    return s = tr(6, s, null, f), s.lanes = v, s;
  }
  function nl(s, f, v) {
    return f = tr(
      4,
      s.children !== null ? s.children : [],
      s.key,
      f
    ), f.lanes = v, f.stateNode = {
      containerInfo: s.containerInfo,
      pendingChildren: null,
      implementation: s.implementation
    }, f;
  }
  var hd = [], Xs = 0, kh = null, Ar = 0, Ss = [], jr = 0, Ju = null, Jr = 1, bi = "";
  function fa(s, f) {
    hd[Xs++] = Ar, hd[Xs++] = kh, kh = s, Ar = f;
  }
  function fh(s, f, v) {
    Ss[jr++] = Jr, Ss[jr++] = bi, Ss[jr++] = Ju, Ju = s;
    var A = Jr;
    s = bi;
    var U = 32 - Wt(A) - 1;
    A &= ~(1 << U), v += 1;
    var H = 32 - Wt(f) + U;
    if (30 < H) {
      var W = U - U % 5;
      H = (A & (1 << W) - 1).toString(32), A >>= W, U -= W, Jr = 1 << 32 - Wt(f) + U | v << U | A, bi = H + s;
    } else
      Jr = 1 << H | v << U | A, bi = s;
  }
  function pd(s) {
    s.return !== null && (fa(s, 1), fh(s, 1, 0));
  }
  function wo(s) {
    for (; s === kh; )
      kh = hd[--Xs], hd[Xs] = null, Ar = hd[--Xs], hd[Xs] = null;
    for (; s === Ju; )
      Ju = Ss[--jr], Ss[jr] = null, bi = Ss[--jr], Ss[jr] = null, Jr = Ss[--jr], Ss[jr] = null;
  }
  var hl = null, Ua = null, Ln = !1, as = null, Er = !1, bf = Error(a(519));
  function br(s) {
    var f = Error(a(418, ""));
    throw vd(Ps(f, s)), bf;
  }
  function md(s) {
    var f = s.stateNode, v = s.type, A = s.memoizedProps;
    switch (f[Ui] = s, f[cl] = A, v) {
      case "dialog":
        Sa("cancel", f), Sa("close", f);
        break;
      case "iframe":
      case "object":
      case "embed":
        Sa("load", f);
        break;
      case "video":
      case "audio":
        for (v = 0; v < Nr.length; v++)
          Sa(Nr[v], f);
        break;
      case "source":
        Sa("error", f);
        break;
      case "img":
      case "image":
      case "link":
        Sa("error", f), Sa("load", f);
        break;
      case "details":
        Sa("toggle", f);
        break;
      case "input":
        Sa("invalid", f), da(
          f,
          A.value,
          A.defaultValue,
          A.checked,
          A.defaultChecked,
          A.type,
          A.name,
          !0
        ), si(f);
        break;
      case "select":
        Sa("invalid", f);
        break;
      case "textarea":
        Sa("invalid", f), Wi(f, A.value, A.defaultValue, A.children), si(f);
    }
    v = A.children, typeof v != "string" && typeof v != "number" && typeof v != "bigint" || f.textContent === "" + v || A.suppressHydrationWarning === !0 || a0(f.textContent, v) ? (A.popover != null && (Sa("beforetoggle", f), Sa("toggle", f)), A.onScroll != null && Sa("scroll", f), A.onScrollEnd != null && Sa("scrollend", f), A.onClick != null && (f.onclick = iy), f = !0) : f = !1, f || br(s);
  }
  function Wp(s) {
    for (hl = s.return; hl; )
      switch (hl.tag) {
        case 5:
        case 13:
          Er = !1;
          return;
        case 27:
        case 3:
          Er = !0;
          return;
        default:
          hl = hl.return;
      }
  }
  function Kr(s) {
    if (s !== hl) return !1;
    if (!Ln) return Wp(s), Ln = !0, !1;
    var f = s.tag, v;
    if ((v = f !== 3 && f !== 27) && ((v = f === 5) && (v = s.type, v = !(v !== "form" && v !== "button") || dc(s.type, s.memoizedProps)), v = !v), v && Ua && br(s), Wp(s), f === 13) {
      if (s = s.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(a(317));
      e: {
        for (s = s.nextSibling, f = 0; s; ) {
          if (s.nodeType === 8)
            if (v = s.data, v === "/$") {
              if (f === 0) {
                Ua = Xf(s.nextSibling);
                break e;
              }
              f--;
            } else
              v !== "$" && v !== "$!" && v !== "$?" || f++;
          s = s.nextSibling;
        }
        Ua = null;
      }
    } else
      f === 27 ? (f = Ua, zd(s.type) ? (s = yp, yp = null, Ua = s) : Ua = f) : Ua = hl ? Xf(s.stateNode.nextSibling) : null;
    return !0;
  }
  function dh() {
    Ua = hl = null, Ln = !1;
  }
  function va() {
    var s = as;
    return s !== null && (Dn === null ? Dn = s : Dn.push.apply(
      Dn,
      s
    ), as = null), s;
  }
  function vd(s) {
    as === null ? as = [s] : as.push(s);
  }
  var Wh = we(null), Bc = null, Ku = null;
  function Uc(s, f, v) {
    We(Wh, f._currentValue), f._currentValue = v;
  }
  function ku(s) {
    s._currentValue = Wh.current, De(Wh);
  }
  function av(s, f, v) {
    for (; s !== null; ) {
      var A = s.alternate;
      if ((s.childLanes & f) !== f ? (s.childLanes |= f, A !== null && (A.childLanes |= f)) : A !== null && (A.childLanes & f) !== f && (A.childLanes |= f), s === v) break;
      s = s.return;
    }
  }
  function hh(s, f, v, A) {
    var U = s.child;
    for (U !== null && (U.return = s); U !== null; ) {
      var H = U.dependencies;
      if (H !== null) {
        var W = U.child;
        H = H.firstContext;
        e: for (; H !== null; ) {
          var oe = H;
          H = U;
          for (var be = 0; be < f.length; be++)
            if (oe.context === f[be]) {
              H.lanes |= v, oe = H.alternate, oe !== null && (oe.lanes |= v), av(
                H.return,
                v,
                s
              ), A || (W = null);
              break e;
            }
          H = oe.next;
        }
      } else if (U.tag === 18) {
        if (W = U.return, W === null) throw Error(a(341));
        W.lanes |= v, H = W.alternate, H !== null && (H.lanes |= v), av(W, v, s), W = null;
      } else W = U.child;
      if (W !== null) W.return = U;
      else
        for (W = U; W !== null; ) {
          if (W === s) {
            W = null;
            break;
          }
          if (U = W.sibling, U !== null) {
            U.return = W.return, W = U;
            break;
          }
          W = W.return;
        }
      U = W;
    }
  }
  function nr(s, f, v, A) {
    s = null;
    for (var U = f, H = !1; U !== null; ) {
      if (!H) {
        if ((U.flags & 524288) !== 0) H = !0;
        else if ((U.flags & 262144) !== 0) break;
      }
      if (U.tag === 10) {
        var W = U.alternate;
        if (W === null) throw Error(a(387));
        if (W = W.memoizedProps, W !== null) {
          var oe = U.type;
          gs(U.pendingProps.value, W.value) || (s !== null ? s.push(oe) : s = [oe]);
        }
      } else if (U === Vt.current) {
        if (W = U.alternate, W === null) throw Error(a(387));
        W.memoizedState.memoizedState !== U.memoizedState.memoizedState && (s !== null ? s.push(Gn) : s = [Gn]);
      }
      U = U.return;
    }
    s !== null && hh(
      f,
      s,
      v,
      A
    ), f.flags |= 262144;
  }
  function Oi(s) {
    for (s = s.firstContext; s !== null; ) {
      if (!gs(
        s.context._currentValue,
        s.memoizedValue
      ))
        return !0;
      s = s.next;
    }
    return !1;
  }
  function Oc(s) {
    Bc = s, Ku = null, s = s.dependencies, s !== null && (s.firstContext = null);
  }
  function pl(s) {
    return No(Bc, s);
  }
  function $h(s, f) {
    return Bc === null && Oc(s), No(s, f);
  }
  function No(s, f) {
    var v = f._currentValue;
    if (f = { context: f, memoizedValue: v, next: null }, Ku === null) {
      if (s === null) throw Error(a(308));
      Ku = f, s.dependencies = { lanes: 0, firstContext: f }, s.flags |= 524288;
    } else Ku = Ku.next = f;
    return v;
  }
  var gd = typeof AbortController < "u" ? AbortController : function() {
    var s = [], f = this.signal = {
      aborted: !1,
      addEventListener: function(v, A) {
        s.push(A);
      }
    };
    this.abort = function() {
      f.aborted = !0, s.forEach(function(v) {
        return v();
      });
    };
  }, $p = o.unstable_scheduleCallback, ep = o.unstable_NormalPriority, al = {
    $$typeof: q,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function ph() {
    return {
      controller: new gd(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function yu(s) {
    s.refCount--, s.refCount === 0 && $p(ep, function() {
      s.controller.abort();
    });
  }
  var Mf = null, tp = 0, na = 0, is = null;
  function Mr(s, f) {
    if (Mf === null) {
      var v = Mf = [];
      tp = 0, na = Jo(), is = {
        status: "pending",
        value: void 0,
        then: function(A) {
          v.push(A);
        }
      };
    }
    return tp++, f.then(Wu, Wu), f;
  }
  function Wu() {
    if (--tp === 0 && Mf !== null) {
      is !== null && (is.status = "fulfilled");
      var s = Mf;
      Mf = null, na = 0, is = null;
      for (var f = 0; f < s.length; f++) (0, s[f])();
    }
  }
  function zo(s, f) {
    var v = [], A = {
      status: "pending",
      value: null,
      reason: null,
      then: function(U) {
        v.push(U);
      }
    };
    return s.then(
      function() {
        A.status = "fulfilled", A.value = f;
        for (var U = 0; U < v.length; U++) (0, v[U])(f);
      },
      function(U) {
        for (A.status = "rejected", A.reason = U, U = 0; U < v.length; U++)
          (0, v[U])(void 0);
      }
    ), A;
  }
  var mh = P.S;
  P.S = function(s, f) {
    typeof f == "object" && f !== null && typeof f.then == "function" && Mr(s, f), mh !== null && mh(s, f);
  };
  var kr = we(null);
  function wc() {
    var s = kr.current;
    return s !== null ? s : ma.pooledCache;
  }
  function yd(s, f) {
    f === null ? We(kr, kr.current) : We(kr, f.pool);
  }
  function np() {
    var s = wc();
    return s === null ? null : { parent: al._currentValue, pool: s };
  }
  var xf = Error(a(460)), ap = Error(a(474)), Wr = Error(a(542)), em = { then: function() {
  } };
  function ip(s) {
    return s = s.status, s === "fulfilled" || s === "rejected";
  }
  function lp() {
  }
  function tm(s, f, v) {
    switch (v = s[v], v === void 0 ? s.push(f) : v !== f && (f.then(lp, lp), f = v), f.status) {
      case "fulfilled":
        return f.value;
      case "rejected":
        throw s = f.reason, iv(s), s;
      default:
        if (typeof f.status == "string") f.then(lp, lp);
        else {
          if (s = ma, s !== null && 100 < s.shellSuspendCounter)
            throw Error(a(482));
          s = f, s.status = "pending", s.then(
            function(A) {
              if (f.status === "pending") {
                var U = f;
                U.status = "fulfilled", U.value = A;
              }
            },
            function(A) {
              if (f.status === "pending") {
                var U = f;
                U.status = "rejected", U.reason = A;
              }
            }
          );
        }
        switch (f.status) {
          case "fulfilled":
            return f.value;
          case "rejected":
            throw s = f.reason, iv(s), s;
        }
        throw $r = f, xf;
    }
  }
  var $r = null;
  function Ho() {
    if ($r === null) throw Error(a(459));
    var s = $r;
    return $r = null, s;
  }
  function iv(s) {
    if (s === xf || s === Wr)
      throw Error(a(483));
  }
  var $u = !1;
  function ig(s) {
    s.updateQueue = {
      baseState: s.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function $n(s, f) {
    s = s.updateQueue, f.updateQueue === s && (f.updateQueue = {
      baseState: s.baseState,
      firstBaseUpdate: s.firstBaseUpdate,
      lastBaseUpdate: s.lastBaseUpdate,
      shared: s.shared,
      callbacks: null
    });
  }
  function xr(s) {
    return { lane: s, tag: 0, payload: null, callback: null, next: null };
  }
  function ml(s, f, v) {
    var A = s.updateQueue;
    if (A === null) return null;
    if (A = A.shared, (mi & 2) !== 0) {
      var U = A.pending;
      return U === null ? f.next = f : (f.next = U.next, U.next = f), A.pending = f, f = ch(s), cd(s, null, v), f;
    }
    return gu(s, A, f, v), ch(s);
  }
  function Tf(s, f, v) {
    if (f = f.updateQueue, f !== null && (f = f.shared, (v & 4194048) !== 0)) {
      var A = f.lanes;
      A &= s.pendingLanes, v |= A, f.lanes = v, Mn(s, v);
    }
  }
  function Ys(s, f) {
    var v = s.updateQueue, A = s.alternate;
    if (A !== null && (A = A.updateQueue, v === A)) {
      var U = null, H = null;
      if (v = v.firstBaseUpdate, v !== null) {
        do {
          var W = {
            lane: v.lane,
            tag: v.tag,
            payload: v.payload,
            callback: null,
            next: null
          };
          H === null ? U = H = W : H = H.next = W, v = v.next;
        } while (v !== null);
        H === null ? U = H = f : H = H.next = f;
      } else U = H = f;
      v = {
        baseState: A.baseState,
        firstBaseUpdate: U,
        lastBaseUpdate: H,
        shared: A.shared,
        callbacks: A.callbacks
      }, s.updateQueue = v;
      return;
    }
    s = v.lastBaseUpdate, s === null ? v.firstBaseUpdate = f : s.next = f, v.lastBaseUpdate = f;
  }
  var lg = !1;
  function nm() {
    if (lg) {
      var s = is;
      if (s !== null) throw s;
    }
  }
  function _s(s, f, v, A) {
    lg = !1;
    var U = s.updateQueue;
    $u = !1;
    var H = U.firstBaseUpdate, W = U.lastBaseUpdate, oe = U.shared.pending;
    if (oe !== null) {
      U.shared.pending = null;
      var be = oe, et = be.next;
      be.next = null, W === null ? H = et : W.next = et, W = be;
      var Rt = s.alternate;
      Rt !== null && (Rt = Rt.updateQueue, oe = Rt.lastBaseUpdate, oe !== W && (oe === null ? Rt.firstBaseUpdate = et : oe.next = et, Rt.lastBaseUpdate = be));
    }
    if (H !== null) {
      var zt = U.baseState;
      W = 0, Rt = et = be = null, oe = H;
      do {
        var at = oe.lane & -536870913, lt = at !== oe.lane;
        if (lt ? (Fn & at) === at : (A & at) === at) {
          at !== 0 && at === na && (lg = !0), Rt !== null && (Rt = Rt.next = {
            lane: 0,
            tag: oe.tag,
            payload: oe.payload,
            callback: null,
            next: null
          });
          e: {
            var Yn = s, In = oe;
            at = f;
            var ti = v;
            switch (In.tag) {
              case 1:
                if (Yn = In.payload, typeof Yn == "function") {
                  zt = Yn.call(ti, zt, at);
                  break e;
                }
                zt = Yn;
                break e;
              case 3:
                Yn.flags = Yn.flags & -65537 | 128;
              case 0:
                if (Yn = In.payload, at = typeof Yn == "function" ? Yn.call(ti, zt, at) : Yn, at == null) break e;
                zt = T({}, zt, at);
                break e;
              case 2:
                $u = !0;
            }
          }
          at = oe.callback, at !== null && (s.flags |= 64, lt && (s.flags |= 8192), lt = U.callbacks, lt === null ? U.callbacks = [at] : lt.push(at));
        } else
          lt = {
            lane: at,
            tag: oe.tag,
            payload: oe.payload,
            callback: oe.callback,
            next: null
          }, Rt === null ? (et = Rt = lt, be = zt) : Rt = Rt.next = lt, W |= at;
        if (oe = oe.next, oe === null) {
          if (oe = U.shared.pending, oe === null)
            break;
          lt = oe, oe = lt.next, lt.next = null, U.lastBaseUpdate = lt, U.shared.pending = null;
        }
      } while (!0);
      Rt === null && (be = zt), U.baseState = be, U.firstBaseUpdate = et, U.lastBaseUpdate = Rt, H === null && (U.shared.lanes = 0), Mu |= W, s.lanes = W, s.memoizedState = zt;
    }
  }
  function Sd(s, f) {
    if (typeof s != "function")
      throw Error(a(191, s));
    s.call(f);
  }
  function Cf(s, f) {
    var v = s.callbacks;
    if (v !== null)
      for (s.callbacks = null, s = 0; s < v.length; s++)
        Sd(v[s], f);
  }
  var vh = we(null), Su = we(0);
  function ls(s, f) {
    s = uc, We(Su, s), We(vh, f), uc = s | f.baseLanes;
  }
  function gh() {
    We(Su, uc), We(vh, vh.current);
  }
  function eo() {
    uc = Su.current, De(vh), De(Su);
  }
  var Lo = 0, ea = null, di = null, Qi = null, Nc = !1, Tr = !1, ar = !1, Mi = 0, Zl = 0, Tl = null, lv = 0;
  function vl() {
    throw Error(a(321));
  }
  function As(s, f) {
    if (f === null) return !1;
    for (var v = 0; v < f.length && v < s.length; v++)
      if (!gs(s[v], f[v])) return !1;
    return !0;
  }
  function ec(s, f, v, A, U, H) {
    return Lo = H, ea = f, f.memoizedState = null, f.updateQueue = null, f.lanes = 0, P.H = s === null || s.memoizedState === null ? dm : hv, ar = !1, H = v(A, U), ar = !1, Tr && (H = sg(
      f,
      v,
      A,
      U
    )), Rf(s), H;
  }
  function Rf(s) {
    P.H = fm;
    var f = di !== null && di.next !== null;
    if (Lo = 0, Qi = di = ea = null, Nc = !1, Zl = 0, Tl = null, f) throw Error(a(300));
    s === null || ss || (s = s.dependencies, s !== null && Oi(s) && (ss = !0));
  }
  function sg(s, f, v, A) {
    ea = s;
    var U = 0;
    do {
      if (Tr && (Tl = null), Zl = 0, Tr = !1, 25 <= U) throw Error(a(301));
      if (U += 1, Qi = di = null, s.updateQueue != null) {
        var H = s.updateQueue;
        H.lastEffect = null, H.events = null, H.stores = null, H.memoCache != null && (H.memoCache.index = 0);
      }
      P.H = Gc, H = f(v, A);
    } while (Tr);
    return H;
  }
  function sv() {
    var s = P.H, f = s.useState()[0];
    return f = typeof f.then == "function" ? _u(f) : f, s = s.useState()[0], (di !== null ? di.memoizedState : null) !== s && (ea.flags |= 1024), f;
  }
  function rg() {
    var s = Mi !== 0;
    return Mi = 0, s;
  }
  function yh(s, f, v) {
    f.updateQueue = s.updateQueue, f.flags &= -2053, s.lanes &= ~v;
  }
  function Cr(s) {
    if (Nc) {
      for (s = s.memoizedState; s !== null; ) {
        var f = s.queue;
        f !== null && (f.pending = null), s = s.next;
      }
      Nc = !1;
    }
    Lo = 0, Qi = di = ea = null, Tr = !1, Zl = Mi = 0, Tl = null;
  }
  function qs() {
    var s = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Qi === null ? ea.memoizedState = Qi = s : Qi = Qi.next = s, Qi;
  }
  function ha() {
    if (di === null) {
      var s = ea.alternate;
      s = s !== null ? s.memoizedState : null;
    } else s = di.next;
    var f = Qi === null ? ea.memoizedState : Qi.next;
    if (f !== null)
      Qi = f, di = s;
    else {
      if (s === null)
        throw ea.alternate === null ? Error(a(467)) : Error(a(310));
      di = s, s = {
        memoizedState: di.memoizedState,
        baseState: di.baseState,
        baseQueue: di.baseQueue,
        queue: di.queue,
        next: null
      }, Qi === null ? ea.memoizedState = Qi = s : Qi = Qi.next = s;
    }
    return Qi;
  }
  function zc() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function _u(s) {
    var f = Zl;
    return Zl += 1, Tl === null && (Tl = []), s = tm(Tl, s, f), f = ea, (Qi === null ? f.memoizedState : Qi.next) === null && (f = f.alternate, P.H = f === null || f.memoizedState === null ? dm : hv), s;
  }
  function Ql(s) {
    if (s !== null && typeof s == "object") {
      if (typeof s.then == "function") return _u(s);
      if (s.$$typeof === q) return pl(s);
    }
    throw Error(a(438, String(s)));
  }
  function og(s) {
    var f = null, v = ea.updateQueue;
    if (v !== null && (f = v.memoCache), f == null) {
      var A = ea.alternate;
      A !== null && (A = A.updateQueue, A !== null && (A = A.memoCache, A != null && (f = {
        data: A.data.map(function(U) {
          return U.slice();
        }),
        index: 0
      })));
    }
    if (f == null && (f = { data: [], index: 0 }), v === null && (v = zc(), ea.updateQueue = v), v.memoCache = f, v = f.data[f.index], v === void 0)
      for (v = f.data[f.index] = Array(s), A = 0; A < s; A++)
        v[A] = j;
    return f.index++, v;
  }
  function Zs(s, f) {
    return typeof f == "function" ? f(s) : f;
  }
  function tc(s) {
    var f = ha();
    return am(f, di, s);
  }
  function am(s, f, v) {
    var A = s.queue;
    if (A === null) throw Error(a(311));
    A.lastRenderedReducer = v;
    var U = s.baseQueue, H = A.pending;
    if (H !== null) {
      if (U !== null) {
        var W = U.next;
        U.next = H.next, H.next = W;
      }
      f.baseQueue = U = H, A.pending = null;
    }
    if (H = s.baseState, U === null) s.memoizedState = H;
    else {
      f = U.next;
      var oe = W = null, be = null, et = f, Rt = !1;
      do {
        var zt = et.lane & -536870913;
        if (zt !== et.lane ? (Fn & zt) === zt : (Lo & zt) === zt) {
          var at = et.revertLane;
          if (at === 0)
            be !== null && (be = be.next = {
              lane: 0,
              revertLane: 0,
              action: et.action,
              hasEagerState: et.hasEagerState,
              eagerState: et.eagerState,
              next: null
            }), zt === na && (Rt = !0);
          else if ((Lo & at) === at) {
            et = et.next, at === na && (Rt = !0);
            continue;
          } else
            zt = {
              lane: 0,
              revertLane: et.revertLane,
              action: et.action,
              hasEagerState: et.hasEagerState,
              eagerState: et.eagerState,
              next: null
            }, be === null ? (oe = be = zt, W = H) : be = be.next = zt, ea.lanes |= at, Mu |= at;
          zt = et.action, ar && v(H, zt), H = et.hasEagerState ? et.eagerState : v(H, zt);
        } else
          at = {
            lane: zt,
            revertLane: et.revertLane,
            action: et.action,
            hasEagerState: et.hasEagerState,
            eagerState: et.eagerState,
            next: null
          }, be === null ? (oe = be = at, W = H) : be = be.next = at, ea.lanes |= zt, Mu |= zt;
        et = et.next;
      } while (et !== null && et !== f);
      if (be === null ? W = H : be.next = oe, !gs(H, s.memoizedState) && (ss = !0, Rt && (v = is, v !== null)))
        throw v;
      s.memoizedState = H, s.baseState = W, s.baseQueue = be, A.lastRenderedState = H;
    }
    return U === null && (A.lanes = 0), [s.memoizedState, A.dispatch];
  }
  function _d(s) {
    var f = ha(), v = f.queue;
    if (v === null) throw Error(a(311));
    v.lastRenderedReducer = s;
    var A = v.dispatch, U = v.pending, H = f.memoizedState;
    if (U !== null) {
      v.pending = null;
      var W = U = U.next;
      do
        H = s(H, W.action), W = W.next;
      while (W !== U);
      gs(H, f.memoizedState) || (ss = !0), f.memoizedState = H, f.baseQueue === null && (f.baseState = H), v.lastRenderedState = H;
    }
    return [H, A];
  }
  function im(s, f, v) {
    var A = ea, U = ha(), H = Ln;
    if (H) {
      if (v === void 0) throw Error(a(407));
      v = v();
    } else v = f();
    var W = !gs(
      (di || U).memoizedState,
      v
    );
    W && (U.memoizedState = v, ss = !0), U = U.queue;
    var oe = cg.bind(null, A, U, s);
    if (xi(2048, 8, oe, [s]), U.getSnapshot !== f || W || Qi !== null && Qi.memoizedState.tag & 1) {
      if (A.flags |= 2048, to(
        9,
        $a(),
        ug.bind(
          null,
          A,
          U,
          v,
          f
        ),
        null
      ), ma === null) throw Error(a(349));
      H || (Lo & 124) !== 0 || Ad(A, f, v);
    }
    return v;
  }
  function Ad(s, f, v) {
    s.flags |= 16384, s = { getSnapshot: f, value: v }, f = ea.updateQueue, f === null ? (f = zc(), ea.updateQueue = f, f.stores = [s]) : (v = f.stores, v === null ? f.stores = [s] : v.push(s));
  }
  function ug(s, f, v, A) {
    f.value = v, f.getSnapshot = A, rv(f) && lm(s);
  }
  function cg(s, f, v) {
    return v(function() {
      rv(f) && lm(s);
    });
  }
  function rv(s) {
    var f = s.getSnapshot;
    s = s.value;
    try {
      var v = f();
      return !gs(s, v);
    } catch {
      return !0;
    }
  }
  function lm(s) {
    var f = er(s, 2);
    f !== null && fo(f, s, 2);
  }
  function sm(s) {
    var f = qs();
    if (typeof s == "function") {
      var v = s;
      if (s = v(), ar) {
        Xt(!0);
        try {
          v();
        } finally {
          Xt(!1);
        }
      }
    }
    return f.memoizedState = f.baseState = s, f.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Zs,
      lastRenderedState: s
    }, f;
  }
  function fg(s, f, v, A) {
    return s.baseState = v, am(
      s,
      di,
      typeof A == "function" ? A : Zs
    );
  }
  function Wy(s, f, v, A, U) {
    if (op(s)) throw Error(a(485));
    if (s = f.action, s !== null) {
      var H = {
        payload: U,
        action: s,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(W) {
          H.listeners.push(W);
        }
      };
      P.T !== null ? v(!0) : H.isTransition = !1, A(H), v = f.pending, v === null ? (H.next = f.pending = H, ov(f, H)) : (H.next = v.next, f.pending = v.next = H);
    }
  }
  function ov(s, f) {
    var v = f.action, A = f.payload, U = s.state;
    if (f.isTransition) {
      var H = P.T, W = {};
      P.T = W;
      try {
        var oe = v(U, A), be = P.S;
        be !== null && be(W, oe), rm(s, f, oe);
      } catch (et) {
        Ed(s, f, et);
      } finally {
        P.T = H;
      }
    } else
      try {
        H = v(U, A), rm(s, f, H);
      } catch (et) {
        Ed(s, f, et);
      }
  }
  function rm(s, f, v) {
    v !== null && typeof v == "object" && typeof v.then == "function" ? v.then(
      function(A) {
        dg(s, f, A);
      },
      function(A) {
        return Ed(s, f, A);
      }
    ) : dg(s, f, v);
  }
  function dg(s, f, v) {
    f.status = "fulfilled", f.value = v, om(f), s.state = v, f = s.pending, f !== null && (v = f.next, v === f ? s.pending = null : (v = v.next, f.next = v, ov(s, v)));
  }
  function Ed(s, f, v) {
    var A = s.pending;
    if (s.pending = null, A !== null) {
      A = A.next;
      do
        f.status = "rejected", f.reason = v, om(f), f = f.next;
      while (f !== A);
    }
    s.action = null;
  }
  function om(s) {
    s = s.listeners;
    for (var f = 0; f < s.length; f++) (0, s[f])();
  }
  function um(s, f) {
    return f;
  }
  function uv(s, f) {
    if (Ln) {
      var v = ma.formState;
      if (v !== null) {
        e: {
          var A = ea;
          if (Ln) {
            if (Ua) {
              t: {
                for (var U = Ua, H = Er; U.nodeType !== 8; ) {
                  if (!H) {
                    U = null;
                    break t;
                  }
                  if (U = Xf(
                    U.nextSibling
                  ), U === null) {
                    U = null;
                    break t;
                  }
                }
                H = U.data, U = H === "F!" || H === "F" ? U : null;
              }
              if (U) {
                Ua = Xf(
                  U.nextSibling
                ), A = U.data === "F!";
                break e;
              }
            }
            br(A);
          }
          A = !1;
        }
        A && (f = v[0]);
      }
    }
    return v = qs(), v.memoizedState = v.baseState = f, A = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: um,
      lastRenderedState: f
    }, v.queue = A, v = yg.bind(
      null,
      ea,
      A
    ), A.dispatch = v, A = sm(!1), H = Eh.bind(
      null,
      ea,
      !1,
      A.queue
    ), A = qs(), U = {
      state: f,
      dispatch: null,
      action: s,
      pending: null
    }, A.queue = U, v = Wy.bind(
      null,
      ea,
      U,
      H,
      v
    ), U.dispatch = v, A.memoizedState = s, [f, v, !1];
  }
  function Df(s) {
    var f = ha();
    return hg(f, di, s);
  }
  function hg(s, f, v) {
    if (f = am(
      s,
      f,
      um
    )[0], s = tc(Zs)[0], typeof f == "object" && f !== null && typeof f.then == "function")
      try {
        var A = _u(f);
      } catch (W) {
        throw W === xf ? Wr : W;
      }
    else A = f;
    f = ha();
    var U = f.queue, H = U.dispatch;
    return v !== f.memoizedState && (ea.flags |= 2048, to(
      9,
      $a(),
      $y.bind(null, U, v),
      null
    )), [A, H, s];
  }
  function $y(s, f) {
    s.action = f;
  }
  function Hc(s) {
    var f = ha(), v = di;
    if (v !== null)
      return hg(f, v, s);
    ha(), f = f.memoizedState, v = ha();
    var A = v.queue.dispatch;
    return v.memoizedState = s, [f, A, !1];
  }
  function to(s, f, v, A) {
    return s = { tag: s, create: v, deps: A, inst: f, next: null }, f = ea.updateQueue, f === null && (f = zc(), ea.updateQueue = f), v = f.lastEffect, v === null ? f.lastEffect = s.next = s : (A = v.next, v.next = s, s.next = A, f.lastEffect = s), s;
  }
  function $a() {
    return { destroy: void 0, resource: void 0 };
  }
  function Sh() {
    return ha().memoizedState;
  }
  function _h(s, f, v, A) {
    var U = qs();
    A = A === void 0 ? null : A, ea.flags |= s, U.memoizedState = to(
      1 | f,
      $a(),
      v,
      A
    );
  }
  function xi(s, f, v, A) {
    var U = ha();
    A = A === void 0 ? null : A;
    var H = U.memoizedState.inst;
    di !== null && A !== null && As(A, di.memoizedState.deps) ? U.memoizedState = to(f, H, v, A) : (ea.flags |= s, U.memoizedState = to(
      1 | f,
      H,
      v,
      A
    ));
  }
  function kg(s, f) {
    _h(8390656, 8, s, f);
  }
  function Wg(s, f) {
    xi(2048, 8, s, f);
  }
  function sp(s, f) {
    return xi(4, 2, s, f);
  }
  function Go(s, f) {
    return xi(4, 4, s, f);
  }
  function pg(s, f) {
    if (typeof f == "function") {
      s = s();
      var v = f(s);
      return function() {
        typeof v == "function" ? v() : f(null);
      };
    }
    if (f != null)
      return s = s(), f.current = s, function() {
        f.current = null;
      };
  }
  function cv(s, f, v) {
    v = v != null ? v.concat([s]) : null, xi(4, 4, pg.bind(null, f, s), v);
  }
  function Lc() {
  }
  function rp(s, f) {
    var v = ha();
    f = f === void 0 ? null : f;
    var A = v.memoizedState;
    return f !== null && As(f, A[1]) ? A[0] : (v.memoizedState = [s, f], s);
  }
  function mg(s, f) {
    var v = ha();
    f = f === void 0 ? null : f;
    var A = v.memoizedState;
    if (f !== null && As(f, A[1]))
      return A[0];
    if (A = s(), ar) {
      Xt(!0);
      try {
        s();
      } finally {
        Xt(!1);
      }
    }
    return v.memoizedState = [A, f], A;
  }
  function nc(s, f, v) {
    return v === void 0 || (Lo & 1073741824) !== 0 ? s.memoizedState = f : (s.memoizedState = v, s = yv(), ea.lanes |= s, Mu |= s, v);
  }
  function fv(s, f, v, A) {
    return gs(v, f) ? v : vh.current !== null ? (s = nc(s, v, A), gs(s, f) || (ss = !0), s) : (Lo & 42) === 0 ? (ss = !0, s.memoizedState = v) : (s = yv(), ea.lanes |= s, Mu |= s, f);
  }
  function $g(s, f, v, A, U) {
    var H = te.p;
    te.p = H !== 0 && 8 > H ? H : 8;
    var W = P.T, oe = {};
    P.T = oe, Eh(s, !1, f, v);
    try {
      var be = U(), et = P.S;
      if (et !== null && et(oe, be), be !== null && typeof be == "object" && typeof be.then == "function") {
        var Rt = zo(
          be,
          A
        );
        Md(
          s,
          f,
          Rt,
          wl(s)
        );
      } else
        Md(
          s,
          f,
          A,
          wl(s)
        );
    } catch (zt) {
      Md(
        s,
        f,
        { then: function() {
        }, status: "rejected", reason: zt },
        wl()
      );
    } finally {
      te.p = H, P.T = W;
    }
  }
  function e0() {
  }
  function cm(s, f, v, A) {
    if (s.tag !== 5) throw Error(a(476));
    var U = t0(s).queue;
    $g(
      s,
      U,
      f,
      ae,
      v === null ? e0 : function() {
        return Ah(s), v(A);
      }
    );
  }
  function t0(s) {
    var f = s.memoizedState;
    if (f !== null) return f;
    f = {
      memoizedState: ae,
      baseState: ae,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Zs,
        lastRenderedState: ae
      },
      next: null
    };
    var v = {};
    return f.next = {
      memoizedState: v,
      baseState: v,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Zs,
        lastRenderedState: v
      },
      next: null
    }, s.memoizedState = f, s = s.alternate, s !== null && (s.memoizedState = f), f;
  }
  function Ah(s) {
    var f = t0(s).next.queue;
    Md(s, f, {}, wl());
  }
  function Es() {
    return pl(Gn);
  }
  function vg() {
    return ha().memoizedState;
  }
  function gg() {
    return ha().memoizedState;
  }
  function dv(s) {
    for (var f = s.return; f !== null; ) {
      switch (f.tag) {
        case 24:
        case 3:
          var v = wl();
          s = xr(v);
          var A = ml(f, s, v);
          A !== null && (fo(A, f, v), Tf(A, f, v)), f = { cache: ph() }, s.payload = f;
          return;
      }
      f = f.return;
    }
  }
  function bd(s, f, v) {
    var A = wl();
    v = {
      lane: A,
      revertLane: 0,
      action: v,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, op(s) ? ey(f, v) : (v = uh(s, f, v, A), v !== null && (fo(v, s, A), no(v, f, A)));
  }
  function yg(s, f, v) {
    var A = wl();
    Md(s, f, v, A);
  }
  function Md(s, f, v, A) {
    var U = {
      lane: A,
      revertLane: 0,
      action: v,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (op(s)) ey(f, U);
    else {
      var H = s.alternate;
      if (s.lanes === 0 && (H === null || H.lanes === 0) && (H = f.lastRenderedReducer, H !== null))
        try {
          var W = f.lastRenderedState, oe = H(W, v);
          if (U.hasEagerState = !0, U.eagerState = oe, gs(oe, W))
            return gu(s, f, U, 0), ma === null && vu(), !1;
        } catch {
        } finally {
        }
      if (v = uh(s, f, U, A), v !== null)
        return fo(v, s, A), no(v, f, A), !0;
    }
    return !1;
  }
  function Eh(s, f, v, A) {
    if (A = {
      lane: 2,
      revertLane: Jo(),
      action: A,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, op(s)) {
      if (f) throw Error(a(479));
    } else
      f = uh(
        s,
        v,
        A,
        2
      ), f !== null && fo(f, s, 2);
  }
  function op(s) {
    var f = s.alternate;
    return s === ea || f !== null && f === ea;
  }
  function ey(s, f) {
    Tr = Nc = !0;
    var v = s.pending;
    v === null ? f.next = f : (f.next = v.next, v.next = f), s.pending = f;
  }
  function no(s, f, v) {
    if ((v & 4194048) !== 0) {
      var A = f.lanes;
      A &= s.pendingLanes, v |= A, f.lanes = v, Mn(s, v);
    }
  }
  var fm = {
    readContext: pl,
    use: Ql,
    useCallback: vl,
    useContext: vl,
    useEffect: vl,
    useImperativeHandle: vl,
    useLayoutEffect: vl,
    useInsertionEffect: vl,
    useMemo: vl,
    useReducer: vl,
    useRef: vl,
    useState: vl,
    useDebugValue: vl,
    useDeferredValue: vl,
    useTransition: vl,
    useSyncExternalStore: vl,
    useId: vl,
    useHostTransitionStatus: vl,
    useFormState: vl,
    useActionState: vl,
    useOptimistic: vl,
    useMemoCache: vl,
    useCacheRefresh: vl
  }, dm = {
    readContext: pl,
    use: Ql,
    useCallback: function(s, f) {
      return qs().memoizedState = [
        s,
        f === void 0 ? null : f
      ], s;
    },
    useContext: pl,
    useEffect: kg,
    useImperativeHandle: function(s, f, v) {
      v = v != null ? v.concat([s]) : null, _h(
        4194308,
        4,
        pg.bind(null, f, s),
        v
      );
    },
    useLayoutEffect: function(s, f) {
      return _h(4194308, 4, s, f);
    },
    useInsertionEffect: function(s, f) {
      _h(4, 2, s, f);
    },
    useMemo: function(s, f) {
      var v = qs();
      f = f === void 0 ? null : f;
      var A = s();
      if (ar) {
        Xt(!0);
        try {
          s();
        } finally {
          Xt(!1);
        }
      }
      return v.memoizedState = [A, f], A;
    },
    useReducer: function(s, f, v) {
      var A = qs();
      if (v !== void 0) {
        var U = v(f);
        if (ar) {
          Xt(!0);
          try {
            v(f);
          } finally {
            Xt(!1);
          }
        }
      } else U = f;
      return A.memoizedState = A.baseState = U, s = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: s,
        lastRenderedState: U
      }, A.queue = s, s = s.dispatch = bd.bind(
        null,
        ea,
        s
      ), [A.memoizedState, s];
    },
    useRef: function(s) {
      var f = qs();
      return s = { current: s }, f.memoizedState = s;
    },
    useState: function(s) {
      s = sm(s);
      var f = s.queue, v = yg.bind(null, ea, f);
      return f.dispatch = v, [s.memoizedState, v];
    },
    useDebugValue: Lc,
    useDeferredValue: function(s, f) {
      var v = qs();
      return nc(v, s, f);
    },
    useTransition: function() {
      var s = sm(!1);
      return s = $g.bind(
        null,
        ea,
        s.queue,
        !0,
        !1
      ), qs().memoizedState = s, [!1, s];
    },
    useSyncExternalStore: function(s, f, v) {
      var A = ea, U = qs();
      if (Ln) {
        if (v === void 0)
          throw Error(a(407));
        v = v();
      } else {
        if (v = f(), ma === null)
          throw Error(a(349));
        (Fn & 124) !== 0 || Ad(A, f, v);
      }
      U.memoizedState = v;
      var H = { value: v, getSnapshot: f };
      return U.queue = H, kg(cg.bind(null, A, H, s), [
        s
      ]), A.flags |= 2048, to(
        9,
        $a(),
        ug.bind(
          null,
          A,
          H,
          v,
          f
        ),
        null
      ), v;
    },
    useId: function() {
      var s = qs(), f = ma.identifierPrefix;
      if (Ln) {
        var v = bi, A = Jr;
        v = (A & ~(1 << 32 - Wt(A) - 1)).toString(32) + v, f = "" + f + "R" + v, v = Mi++, 0 < v && (f += "H" + v.toString(32)), f += "";
      } else
        v = lv++, f = "" + f + "r" + v.toString(32) + "";
      return s.memoizedState = f;
    },
    useHostTransitionStatus: Es,
    useFormState: uv,
    useActionState: uv,
    useOptimistic: function(s) {
      var f = qs();
      f.memoizedState = f.baseState = s;
      var v = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return f.queue = v, f = Eh.bind(
        null,
        ea,
        !0,
        v
      ), v.dispatch = f, [s, f];
    },
    useMemoCache: og,
    useCacheRefresh: function() {
      return qs().memoizedState = dv.bind(
        null,
        ea
      );
    }
  }, hv = {
    readContext: pl,
    use: Ql,
    useCallback: rp,
    useContext: pl,
    useEffect: Wg,
    useImperativeHandle: cv,
    useInsertionEffect: sp,
    useLayoutEffect: Go,
    useMemo: mg,
    useReducer: tc,
    useRef: Sh,
    useState: function() {
      return tc(Zs);
    },
    useDebugValue: Lc,
    useDeferredValue: function(s, f) {
      var v = ha();
      return fv(
        v,
        di.memoizedState,
        s,
        f
      );
    },
    useTransition: function() {
      var s = tc(Zs)[0], f = ha().memoizedState;
      return [
        typeof s == "boolean" ? s : _u(s),
        f
      ];
    },
    useSyncExternalStore: im,
    useId: vg,
    useHostTransitionStatus: Es,
    useFormState: Df,
    useActionState: Df,
    useOptimistic: function(s, f) {
      var v = ha();
      return fg(v, di, s, f);
    },
    useMemoCache: og,
    useCacheRefresh: gg
  }, Gc = {
    readContext: pl,
    use: Ql,
    useCallback: rp,
    useContext: pl,
    useEffect: Wg,
    useImperativeHandle: cv,
    useInsertionEffect: sp,
    useLayoutEffect: Go,
    useMemo: mg,
    useReducer: _d,
    useRef: Sh,
    useState: function() {
      return _d(Zs);
    },
    useDebugValue: Lc,
    useDeferredValue: function(s, f) {
      var v = ha();
      return di === null ? nc(v, s, f) : fv(
        v,
        di.memoizedState,
        s,
        f
      );
    },
    useTransition: function() {
      var s = _d(Zs)[0], f = ha().memoizedState;
      return [
        typeof s == "boolean" ? s : _u(s),
        f
      ];
    },
    useSyncExternalStore: im,
    useId: vg,
    useHostTransitionStatus: Es,
    useFormState: Hc,
    useActionState: Hc,
    useOptimistic: function(s, f) {
      var v = ha();
      return di !== null ? fg(v, di, s, f) : (v.baseState = s, [s, v.queue.dispatch]);
    },
    useMemoCache: og,
    useCacheRefresh: gg
  }, Bf = null, hm = 0;
  function pv(s) {
    var f = hm;
    return hm += 1, Bf === null && (Bf = []), tm(Bf, s, f);
  }
  function pa(s, f) {
    f = f.props.ref, s.ref = f !== void 0 ? f : null;
  }
  function Rr(s, f) {
    throw f.$$typeof === C ? Error(a(525)) : (s = Object.prototype.toString.call(f), Error(
      a(
        31,
        s === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : s
      )
    ));
  }
  function Dr(s) {
    var f = s._init;
    return f(s._payload);
  }
  function Ti(s) {
    function f(Qe, Ve) {
      if (s) {
        var ke = Qe.deletions;
        ke === null ? (Qe.deletions = [Ve], Qe.flags |= 16) : ke.push(Ve);
      }
    }
    function v(Qe, Ve) {
      if (!s) return null;
      for (; Ve !== null; )
        f(Qe, Ve), Ve = Ve.sibling;
      return null;
    }
    function A(Qe) {
      for (var Ve = /* @__PURE__ */ new Map(); Qe !== null; )
        Qe.key !== null ? Ve.set(Qe.key, Qe) : Ve.set(Qe.index, Qe), Qe = Qe.sibling;
      return Ve;
    }
    function U(Qe, Ve) {
      return Qe = tl(Qe, Ve), Qe.index = 0, Qe.sibling = null, Qe;
    }
    function H(Qe, Ve, ke) {
      return Qe.index = ke, s ? (ke = Qe.alternate, ke !== null ? (ke = ke.index, ke < Ve ? (Qe.flags |= 67108866, Ve) : ke) : (Qe.flags |= 67108866, Ve)) : (Qe.flags |= 1048576, Ve);
    }
    function W(Qe) {
      return s && Qe.alternate === null && (Qe.flags |= 67108866), Qe;
    }
    function oe(Qe, Ve, ke, gt) {
      return Ve === null || Ve.tag !== 6 ? (Ve = Ef(ke, Qe.mode, gt), Ve.return = Qe, Ve) : (Ve = U(Ve, ke), Ve.return = Qe, Ve);
    }
    function be(Qe, Ve, ke, gt) {
      var Cn = ke.type;
      return Cn === z ? Rt(
        Qe,
        Ve,
        ke.props.children,
        gt,
        ke.key
      ) : Ve !== null && (Ve.elementType === Cn || typeof Cn == "object" && Cn !== null && Cn.$$typeof === ne && Dr(Cn) === Ve.type) ? (Ve = U(Ve, ke.props), pa(Ve, ke), Ve.return = Qe, Ve) : (Ve = Lt(
        ke.type,
        ke.key,
        ke.props,
        null,
        Qe.mode,
        gt
      ), pa(Ve, ke), Ve.return = Qe, Ve);
    }
    function et(Qe, Ve, ke, gt) {
      return Ve === null || Ve.tag !== 4 || Ve.stateNode.containerInfo !== ke.containerInfo || Ve.stateNode.implementation !== ke.implementation ? (Ve = nl(ke, Qe.mode, gt), Ve.return = Qe, Ve) : (Ve = U(Ve, ke.children || []), Ve.return = Qe, Ve);
    }
    function Rt(Qe, Ve, ke, gt, Cn) {
      return Ve === null || Ve.tag !== 7 ? (Ve = Qr(
        ke,
        Qe.mode,
        gt,
        Cn
      ), Ve.return = Qe, Ve) : (Ve = U(Ve, ke), Ve.return = Qe, Ve);
    }
    function zt(Qe, Ve, ke) {
      if (typeof Ve == "string" && Ve !== "" || typeof Ve == "number" || typeof Ve == "bigint")
        return Ve = Ef(
          "" + Ve,
          Qe.mode,
          ke
        ), Ve.return = Qe, Ve;
      if (typeof Ve == "object" && Ve !== null) {
        switch (Ve.$$typeof) {
          case D:
            return ke = Lt(
              Ve.type,
              Ve.key,
              Ve.props,
              null,
              Qe.mode,
              ke
            ), pa(ke, Ve), ke.return = Qe, ke;
          case B:
            return Ve = nl(
              Ve,
              Qe.mode,
              ke
            ), Ve.return = Qe, Ve;
          case ne:
            var gt = Ve._init;
            return Ve = gt(Ve._payload), zt(Qe, Ve, ke);
        }
        if (He(Ve) || _e(Ve))
          return Ve = Qr(
            Ve,
            Qe.mode,
            ke,
            null
          ), Ve.return = Qe, Ve;
        if (typeof Ve.then == "function")
          return zt(Qe, pv(Ve), ke);
        if (Ve.$$typeof === q)
          return zt(
            Qe,
            $h(Qe, Ve),
            ke
          );
        Rr(Qe, Ve);
      }
      return null;
    }
    function at(Qe, Ve, ke, gt) {
      var Cn = Ve !== null ? Ve.key : null;
      if (typeof ke == "string" && ke !== "" || typeof ke == "number" || typeof ke == "bigint")
        return Cn !== null ? null : oe(Qe, Ve, "" + ke, gt);
      if (typeof ke == "object" && ke !== null) {
        switch (ke.$$typeof) {
          case D:
            return ke.key === Cn ? be(Qe, Ve, ke, gt) : null;
          case B:
            return ke.key === Cn ? et(Qe, Ve, ke, gt) : null;
          case ne:
            return Cn = ke._init, ke = Cn(ke._payload), at(Qe, Ve, ke, gt);
        }
        if (He(ke) || _e(ke))
          return Cn !== null ? null : Rt(Qe, Ve, ke, gt, null);
        if (typeof ke.then == "function")
          return at(
            Qe,
            Ve,
            pv(ke),
            gt
          );
        if (ke.$$typeof === q)
          return at(
            Qe,
            Ve,
            $h(Qe, ke),
            gt
          );
        Rr(Qe, ke);
      }
      return null;
    }
    function lt(Qe, Ve, ke, gt, Cn) {
      if (typeof gt == "string" && gt !== "" || typeof gt == "number" || typeof gt == "bigint")
        return Qe = Qe.get(ke) || null, oe(Ve, Qe, "" + gt, Cn);
      if (typeof gt == "object" && gt !== null) {
        switch (gt.$$typeof) {
          case D:
            return Qe = Qe.get(
              gt.key === null ? ke : gt.key
            ) || null, be(Ve, Qe, gt, Cn);
          case B:
            return Qe = Qe.get(
              gt.key === null ? ke : gt.key
            ) || null, et(Ve, Qe, gt, Cn);
          case ne:
            var Aa = gt._init;
            return gt = Aa(gt._payload), lt(
              Qe,
              Ve,
              ke,
              gt,
              Cn
            );
        }
        if (He(gt) || _e(gt))
          return Qe = Qe.get(ke) || null, Rt(Ve, Qe, gt, Cn, null);
        if (typeof gt.then == "function")
          return lt(
            Qe,
            Ve,
            ke,
            pv(gt),
            Cn
          );
        if (gt.$$typeof === q)
          return lt(
            Qe,
            Ve,
            ke,
            $h(Ve, gt),
            Cn
          );
        Rr(Ve, gt);
      }
      return null;
    }
    function Yn(Qe, Ve, ke, gt) {
      for (var Cn = null, Aa = null, Pn = Ve, Xn = Ve = 0, Za = null; Pn !== null && Xn < ke.length; Xn++) {
        Pn.index > Xn ? (Za = Pn, Pn = null) : Za = Pn.sibling;
        var ci = at(
          Qe,
          Pn,
          ke[Xn],
          gt
        );
        if (ci === null) {
          Pn === null && (Pn = Za);
          break;
        }
        s && Pn && ci.alternate === null && f(Qe, Pn), Ve = H(ci, Ve, Xn), Aa === null ? Cn = ci : Aa.sibling = ci, Aa = ci, Pn = Za;
      }
      if (Xn === ke.length)
        return v(Qe, Pn), Ln && fa(Qe, Xn), Cn;
      if (Pn === null) {
        for (; Xn < ke.length; Xn++)
          Pn = zt(Qe, ke[Xn], gt), Pn !== null && (Ve = H(
            Pn,
            Ve,
            Xn
          ), Aa === null ? Cn = Pn : Aa.sibling = Pn, Aa = Pn);
        return Ln && fa(Qe, Xn), Cn;
      }
      for (Pn = A(Pn); Xn < ke.length; Xn++)
        Za = lt(
          Pn,
          Qe,
          Xn,
          ke[Xn],
          gt
        ), Za !== null && (s && Za.alternate !== null && Pn.delete(
          Za.key === null ? Xn : Za.key
        ), Ve = H(
          Za,
          Ve,
          Xn
        ), Aa === null ? Cn = Za : Aa.sibling = Za, Aa = Za);
      return s && Pn.forEach(function(bp) {
        return f(Qe, bp);
      }), Ln && fa(Qe, Xn), Cn;
    }
    function In(Qe, Ve, ke, gt) {
      if (ke == null) throw Error(a(151));
      for (var Cn = null, Aa = null, Pn = Ve, Xn = Ve = 0, Za = null, ci = ke.next(); Pn !== null && !ci.done; Xn++, ci = ke.next()) {
        Pn.index > Xn ? (Za = Pn, Pn = null) : Za = Pn.sibling;
        var bp = at(Qe, Pn, ci.value, gt);
        if (bp === null) {
          Pn === null && (Pn = Za);
          break;
        }
        s && Pn && bp.alternate === null && f(Qe, Pn), Ve = H(bp, Ve, Xn), Aa === null ? Cn = bp : Aa.sibling = bp, Aa = bp, Pn = Za;
      }
      if (ci.done)
        return v(Qe, Pn), Ln && fa(Qe, Xn), Cn;
      if (Pn === null) {
        for (; !ci.done; Xn++, ci = ke.next())
          ci = zt(Qe, ci.value, gt), ci !== null && (Ve = H(ci, Ve, Xn), Aa === null ? Cn = ci : Aa.sibling = ci, Aa = ci);
        return Ln && fa(Qe, Xn), Cn;
      }
      for (Pn = A(Pn); !ci.done; Xn++, ci = ke.next())
        ci = lt(Pn, Qe, Xn, ci.value, gt), ci !== null && (s && ci.alternate !== null && Pn.delete(ci.key === null ? Xn : ci.key), Ve = H(ci, Ve, Xn), Aa === null ? Cn = ci : Aa.sibling = ci, Aa = ci);
      return s && Pn.forEach(function(Gr) {
        return f(Qe, Gr);
      }), Ln && fa(Qe, Xn), Cn;
    }
    function ti(Qe, Ve, ke, gt) {
      if (typeof ke == "object" && ke !== null && ke.type === z && ke.key === null && (ke = ke.props.children), typeof ke == "object" && ke !== null) {
        switch (ke.$$typeof) {
          case D:
            e: {
              for (var Cn = ke.key; Ve !== null; ) {
                if (Ve.key === Cn) {
                  if (Cn = ke.type, Cn === z) {
                    if (Ve.tag === 7) {
                      v(
                        Qe,
                        Ve.sibling
                      ), gt = U(
                        Ve,
                        ke.props.children
                      ), gt.return = Qe, Qe = gt;
                      break e;
                    }
                  } else if (Ve.elementType === Cn || typeof Cn == "object" && Cn !== null && Cn.$$typeof === ne && Dr(Cn) === Ve.type) {
                    v(
                      Qe,
                      Ve.sibling
                    ), gt = U(Ve, ke.props), pa(gt, ke), gt.return = Qe, Qe = gt;
                    break e;
                  }
                  v(Qe, Ve);
                  break;
                } else f(Qe, Ve);
                Ve = Ve.sibling;
              }
              ke.type === z ? (gt = Qr(
                ke.props.children,
                Qe.mode,
                gt,
                ke.key
              ), gt.return = Qe, Qe = gt) : (gt = Lt(
                ke.type,
                ke.key,
                ke.props,
                null,
                Qe.mode,
                gt
              ), pa(gt, ke), gt.return = Qe, Qe = gt);
            }
            return W(Qe);
          case B:
            e: {
              for (Cn = ke.key; Ve !== null; ) {
                if (Ve.key === Cn)
                  if (Ve.tag === 4 && Ve.stateNode.containerInfo === ke.containerInfo && Ve.stateNode.implementation === ke.implementation) {
                    v(
                      Qe,
                      Ve.sibling
                    ), gt = U(Ve, ke.children || []), gt.return = Qe, Qe = gt;
                    break e;
                  } else {
                    v(Qe, Ve);
                    break;
                  }
                else f(Qe, Ve);
                Ve = Ve.sibling;
              }
              gt = nl(ke, Qe.mode, gt), gt.return = Qe, Qe = gt;
            }
            return W(Qe);
          case ne:
            return Cn = ke._init, ke = Cn(ke._payload), ti(
              Qe,
              Ve,
              ke,
              gt
            );
        }
        if (He(ke))
          return Yn(
            Qe,
            Ve,
            ke,
            gt
          );
        if (_e(ke)) {
          if (Cn = _e(ke), typeof Cn != "function") throw Error(a(150));
          return ke = Cn.call(ke), In(
            Qe,
            Ve,
            ke,
            gt
          );
        }
        if (typeof ke.then == "function")
          return ti(
            Qe,
            Ve,
            pv(ke),
            gt
          );
        if (ke.$$typeof === q)
          return ti(
            Qe,
            Ve,
            $h(Qe, ke),
            gt
          );
        Rr(Qe, ke);
      }
      return typeof ke == "string" && ke !== "" || typeof ke == "number" || typeof ke == "bigint" ? (ke = "" + ke, Ve !== null && Ve.tag === 6 ? (v(Qe, Ve.sibling), gt = U(Ve, ke), gt.return = Qe, Qe = gt) : (v(Qe, Ve), gt = Ef(ke, Qe.mode, gt), gt.return = Qe, Qe = gt), W(Qe)) : v(Qe, Ve);
    }
    return function(Qe, Ve, ke, gt) {
      try {
        hm = 0;
        var Cn = ti(
          Qe,
          Ve,
          ke,
          gt
        );
        return Bf = null, Cn;
      } catch (Pn) {
        if (Pn === xf || Pn === Wr) throw Pn;
        var Aa = tr(29, Pn, null, Qe.mode);
        return Aa.lanes = gt, Aa.return = Qe, Aa;
      } finally {
      }
    };
  }
  var bh = Ti(!0), Br = Ti(!1), oi = we(null), Gl = null;
  function ac(s) {
    var f = s.alternate;
    We(La, La.current & 1), We(oi, s), Gl === null && (f === null || vh.current !== null || f.memoizedState !== null) && (Gl = s);
  }
  function ic(s) {
    if (s.tag === 22) {
      if (We(La, La.current), We(oi, s), Gl === null) {
        var f = s.alternate;
        f !== null && f.memoizedState !== null && (Gl = s);
      }
    } else Uf();
  }
  function Uf() {
    We(La, La.current), We(oi, oi.current);
  }
  function Io(s) {
    De(oi), Gl === s && (Gl = null), De(La);
  }
  var La = we(0);
  function Vo(s) {
    for (var f = s; f !== null; ) {
      if (f.tag === 13) {
        var v = f.memoizedState;
        if (v !== null && (v = v.dehydrated, v === null || v.data === "$?" || Cg(v)))
          return f;
      } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
        if ((f.flags & 128) !== 0) return f;
      } else if (f.child !== null) {
        f.child.return = f, f = f.child;
        continue;
      }
      if (f === s) break;
      for (; f.sibling === null; ) {
        if (f.return === null || f.return === s) return null;
        f = f.return;
      }
      f.sibling.return = f.return, f = f.sibling;
    }
    return null;
  }
  function ao(s, f, v, A) {
    f = s.memoizedState, v = v(A, f), v = v == null ? f : T({}, f, v), s.memoizedState = v, s.lanes === 0 && (s.updateQueue.baseState = v);
  }
  var Qs = {
    enqueueSetState: function(s, f, v) {
      s = s._reactInternals;
      var A = wl(), U = xr(A);
      U.payload = f, v != null && (U.callback = v), f = ml(s, U, A), f !== null && (fo(f, s, A), Tf(f, s, A));
    },
    enqueueReplaceState: function(s, f, v) {
      s = s._reactInternals;
      var A = wl(), U = xr(A);
      U.tag = 1, U.payload = f, v != null && (U.callback = v), f = ml(s, U, A), f !== null && (fo(f, s, A), Tf(f, s, A));
    },
    enqueueForceUpdate: function(s, f) {
      s = s._reactInternals;
      var v = wl(), A = xr(v);
      A.tag = 2, f != null && (A.callback = f), f = ml(s, A, v), f !== null && (fo(f, s, v), Tf(f, s, v));
    }
  };
  function xd(s, f, v, A, U, H, W) {
    return s = s.stateNode, typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(A, H, W) : f.prototype && f.prototype.isPureReactComponent ? !yr(v, A) || !yr(U, H) : !0;
  }
  function bs(s, f, v, A) {
    s = f.state, typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(v, A), typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(v, A), f.state !== s && Qs.enqueueReplaceState(f, f.state, null);
  }
  function lc(s, f) {
    var v = f;
    if ("ref" in f) {
      v = {};
      for (var A in f)
        A !== "ref" && (v[A] = f[A]);
    }
    if (s = s.defaultProps) {
      v === f && (v = T({}, v));
      for (var U in s)
        v[U] === void 0 && (v[U] = s[U]);
    }
    return v;
  }
  var Mh = typeof reportError == "function" ? reportError : function(s) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var f = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof s == "object" && s !== null && typeof s.message == "string" ? String(s.message) : String(s),
        error: s
      });
      if (!window.dispatchEvent(f)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", s);
      return;
    }
    console.error(s);
  };
  function Of(s) {
    Mh(s);
  }
  function mv(s) {
    console.error(s);
  }
  function ft(s) {
    Mh(s);
  }
  function Td(s, f) {
    try {
      var v = s.onUncaughtError;
      v(f.value, { componentStack: f.stack });
    } catch (A) {
      setTimeout(function() {
        throw A;
      });
    }
  }
  function Fo(s, f, v) {
    try {
      var A = s.onCaughtError;
      A(v.value, {
        componentStack: v.stack,
        errorBoundary: f.tag === 1 ? f.stateNode : null
      });
    } catch (U) {
      setTimeout(function() {
        throw U;
      });
    }
  }
  function vv(s, f, v) {
    return v = xr(v), v.tag = 3, v.payload = { element: null }, v.callback = function() {
      Td(s, f);
    }, v;
  }
  function Sg(s) {
    return s = xr(s), s.tag = 3, s;
  }
  function ir(s, f, v, A) {
    var U = v.type.getDerivedStateFromError;
    if (typeof U == "function") {
      var H = A.value;
      s.payload = function() {
        return U(H);
      }, s.callback = function() {
        Fo(f, v, A);
      };
    }
    var W = v.stateNode;
    W !== null && typeof W.componentDidCatch == "function" && (s.callback = function() {
      Fo(f, v, A), typeof U != "function" && (qo === null ? qo = /* @__PURE__ */ new Set([this]) : qo.add(this));
      var oe = A.stack;
      this.componentDidCatch(A.value, {
        componentStack: oe !== null ? oe : ""
      });
    });
  }
  function ty(s, f, v, A, U) {
    if (v.flags |= 32768, A !== null && typeof A == "object" && typeof A.then == "function") {
      if (f = v.alternate, f !== null && nr(
        f,
        v,
        U,
        !0
      ), v = oi.current, v !== null) {
        switch (v.tag) {
          case 13:
            return Gl === null ? h() : v.alternate === null && il === 0 && (il = 3), v.flags &= -257, v.flags |= 65536, v.lanes = U, A === em ? v.flags |= 16384 : (f = v.updateQueue, f === null ? v.updateQueue = /* @__PURE__ */ new Set([A]) : f.add(A), rt(s, A, U)), !1;
          case 22:
            return v.flags |= 65536, A === em ? v.flags |= 16384 : (f = v.updateQueue, f === null ? (f = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([A])
            }, v.updateQueue = f) : (v = f.retryQueue, v === null ? f.retryQueue = /* @__PURE__ */ new Set([A]) : v.add(A)), rt(s, A, U)), !1;
        }
        throw Error(a(435, v.tag));
      }
      return rt(s, A, U), h(), !1;
    }
    if (Ln)
      return f = oi.current, f !== null ? ((f.flags & 65536) === 0 && (f.flags |= 256), f.flags |= 65536, f.lanes = U, A !== bf && (s = Error(a(422), { cause: A }), vd(Ps(s, v)))) : (A !== bf && (f = Error(a(423), {
        cause: A
      }), vd(
        Ps(f, v)
      )), s = s.current.alternate, s.flags |= 65536, U &= -U, s.lanes |= U, A = Ps(A, v), U = vv(
        s.stateNode,
        A,
        U
      ), Ys(s, U), il !== 4 && (il = 2)), !1;
    var H = Error(a(520), { cause: A });
    if (H = Ps(H, v), Si === null ? Si = [H] : Si.push(H), il !== 4 && (il = 2), f === null) return !0;
    A = Ps(A, v), v = f;
    do {
      switch (v.tag) {
        case 3:
          return v.flags |= 65536, s = U & -U, v.lanes |= s, s = vv(v.stateNode, A, s), Ys(v, s), !1;
        case 1:
          if (f = v.type, H = v.stateNode, (v.flags & 128) === 0 && (typeof f.getDerivedStateFromError == "function" || H !== null && typeof H.componentDidCatch == "function" && (qo === null || !qo.has(H))))
            return v.flags |= 65536, U &= -U, v.lanes |= U, U = Sg(U), ir(
              U,
              s,
              v,
              A
            ), Ys(v, U), !1;
      }
      v = v.return;
    } while (v !== null);
    return !1;
  }
  var Cl = Error(a(461)), ss = !1;
  function gl(s, f, v, A) {
    f.child = s === null ? Br(f, null, v, A) : bh(
      f,
      s.child,
      v,
      A
    );
  }
  function io(s, f, v, A, U) {
    v = v.render;
    var H = f.ref;
    if ("ref" in A) {
      var W = {};
      for (var oe in A)
        oe !== "ref" && (W[oe] = A[oe]);
    } else W = A;
    return Oc(f), A = ec(
      s,
      f,
      v,
      W,
      H,
      U
    ), oe = rg(), s !== null && !ss ? (yh(s, f, U), xs(s, f, U)) : (Ln && oe && pd(f), f.flags |= 1, gl(s, f, A, U), f.child);
  }
  function Rl(s, f, v, A, U) {
    if (s === null) {
      var H = v.type;
      return typeof H == "function" && !dd(H) && H.defaultProps === void 0 && v.compare === null ? (f.tag = 15, f.type = H, wf(
        s,
        f,
        H,
        A,
        U
      )) : (s = Lt(
        v.type,
        null,
        A,
        f,
        f.mode,
        U
      ), s.ref = f.ref, s.return = f, f.child = s);
    }
    if (H = s.child, !xh(s, U)) {
      var W = H.memoizedProps;
      if (v = v.compare, v = v !== null ? v : yr, v(W, A) && s.ref === f.ref)
        return xs(s, f, U);
    }
    return f.flags |= 1, s = tl(H, A), s.ref = f.ref, s.return = f, f.child = s;
  }
  function wf(s, f, v, A, U) {
    if (s !== null) {
      var H = s.memoizedProps;
      if (yr(H, A) && s.ref === f.ref)
        if (ss = !1, f.pendingProps = A = H, xh(s, U))
          (s.flags & 131072) !== 0 && (ss = !0);
        else
          return f.lanes = s.lanes, xs(s, f, U);
    }
    return up(
      s,
      f,
      v,
      A,
      U
    );
  }
  function rs(s, f, v) {
    var A = f.pendingProps, U = A.children, H = s !== null ? s.memoizedState : null;
    if (A.mode === "hidden") {
      if ((f.flags & 128) !== 0) {
        if (A = H !== null ? H.baseLanes | v : v, s !== null) {
          for (U = f.child = s.child, H = 0; U !== null; )
            H = H | U.lanes | U.childLanes, U = U.sibling;
          f.childLanes = H & ~A;
        } else f.childLanes = 0, f.child = null;
        return Dl(
          s,
          f,
          A,
          v
        );
      }
      if ((v & 536870912) !== 0)
        f.memoizedState = { baseLanes: 0, cachePool: null }, s !== null && yd(
          f,
          H !== null ? H.cachePool : null
        ), H !== null ? ls(f, H) : gh(), ic(f);
      else
        return f.lanes = f.childLanes = 536870912, Dl(
          s,
          f,
          H !== null ? H.baseLanes | v : v,
          v
        );
    } else
      H !== null ? (yd(f, H.cachePool), ls(f, H), Uf(), f.memoizedState = null) : (s !== null && yd(f, null), gh(), Uf());
    return gl(s, f, U, v), f.child;
  }
  function Dl(s, f, v, A) {
    var U = wc();
    return U = U === null ? null : { parent: al._currentValue, pool: U }, f.memoizedState = {
      baseLanes: v,
      cachePool: U
    }, s !== null && yd(f, null), gh(), ic(f), s !== null && nr(s, f, A, !0), null;
  }
  function Il(s, f) {
    var v = f.ref;
    if (v === null)
      s !== null && s.ref !== null && (f.flags |= 4194816);
    else {
      if (typeof v != "function" && typeof v != "object")
        throw Error(a(284));
      (s === null || s.ref !== v) && (f.flags |= 4194816);
    }
  }
  function up(s, f, v, A, U) {
    return Oc(f), v = ec(
      s,
      f,
      v,
      A,
      void 0,
      U
    ), A = rg(), s !== null && !ss ? (yh(s, f, U), xs(s, f, U)) : (Ln && A && pd(f), f.flags |= 1, gl(s, f, v, U), f.child);
  }
  function Po(s, f, v, A, U, H) {
    return Oc(f), f.updateQueue = null, v = sg(
      f,
      A,
      v,
      U
    ), Rf(s), A = rg(), s !== null && !ss ? (yh(s, f, H), xs(s, f, H)) : (Ln && A && pd(f), f.flags |= 1, gl(s, f, v, H), f.child);
  }
  function Ur(s, f, v, A, U) {
    if (Oc(f), f.stateNode === null) {
      var H = fd, W = v.contextType;
      typeof W == "object" && W !== null && (H = pl(W)), H = new v(A, H), f.memoizedState = H.state !== null && H.state !== void 0 ? H.state : null, H.updater = Qs, f.stateNode = H, H._reactInternals = f, H = f.stateNode, H.props = A, H.state = f.memoizedState, H.refs = {}, ig(f), W = v.contextType, H.context = typeof W == "object" && W !== null ? pl(W) : fd, H.state = f.memoizedState, W = v.getDerivedStateFromProps, typeof W == "function" && (ao(
        f,
        v,
        W,
        A
      ), H.state = f.memoizedState), typeof v.getDerivedStateFromProps == "function" || typeof H.getSnapshotBeforeUpdate == "function" || typeof H.UNSAFE_componentWillMount != "function" && typeof H.componentWillMount != "function" || (W = H.state, typeof H.componentWillMount == "function" && H.componentWillMount(), typeof H.UNSAFE_componentWillMount == "function" && H.UNSAFE_componentWillMount(), W !== H.state && Qs.enqueueReplaceState(H, H.state, null), _s(f, A, H, U), nm(), H.state = f.memoizedState), typeof H.componentDidMount == "function" && (f.flags |= 4194308), A = !0;
    } else if (s === null) {
      H = f.stateNode;
      var oe = f.memoizedProps, be = lc(v, oe);
      H.props = be;
      var et = H.context, Rt = v.contextType;
      W = fd, typeof Rt == "object" && Rt !== null && (W = pl(Rt));
      var zt = v.getDerivedStateFromProps;
      Rt = typeof zt == "function" || typeof H.getSnapshotBeforeUpdate == "function", oe = f.pendingProps !== oe, Rt || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (oe || et !== W) && bs(
        f,
        H,
        A,
        W
      ), $u = !1;
      var at = f.memoizedState;
      H.state = at, _s(f, A, H, U), nm(), et = f.memoizedState, oe || at !== et || $u ? (typeof zt == "function" && (ao(
        f,
        v,
        zt,
        A
      ), et = f.memoizedState), (be = $u || xd(
        f,
        v,
        be,
        A,
        at,
        et,
        W
      )) ? (Rt || typeof H.UNSAFE_componentWillMount != "function" && typeof H.componentWillMount != "function" || (typeof H.componentWillMount == "function" && H.componentWillMount(), typeof H.UNSAFE_componentWillMount == "function" && H.UNSAFE_componentWillMount()), typeof H.componentDidMount == "function" && (f.flags |= 4194308)) : (typeof H.componentDidMount == "function" && (f.flags |= 4194308), f.memoizedProps = A, f.memoizedState = et), H.props = A, H.state = et, H.context = W, A = be) : (typeof H.componentDidMount == "function" && (f.flags |= 4194308), A = !1);
    } else {
      H = f.stateNode, $n(s, f), W = f.memoizedProps, Rt = lc(v, W), H.props = Rt, zt = f.pendingProps, at = H.context, et = v.contextType, be = fd, typeof et == "object" && et !== null && (be = pl(et)), oe = v.getDerivedStateFromProps, (et = typeof oe == "function" || typeof H.getSnapshotBeforeUpdate == "function") || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (W !== zt || at !== be) && bs(
        f,
        H,
        A,
        be
      ), $u = !1, at = f.memoizedState, H.state = at, _s(f, A, H, U), nm();
      var lt = f.memoizedState;
      W !== zt || at !== lt || $u || s !== null && s.dependencies !== null && Oi(s.dependencies) ? (typeof oe == "function" && (ao(
        f,
        v,
        oe,
        A
      ), lt = f.memoizedState), (Rt = $u || xd(
        f,
        v,
        Rt,
        A,
        at,
        lt,
        be
      ) || s !== null && s.dependencies !== null && Oi(s.dependencies)) ? (et || typeof H.UNSAFE_componentWillUpdate != "function" && typeof H.componentWillUpdate != "function" || (typeof H.componentWillUpdate == "function" && H.componentWillUpdate(A, lt, be), typeof H.UNSAFE_componentWillUpdate == "function" && H.UNSAFE_componentWillUpdate(
        A,
        lt,
        be
      )), typeof H.componentDidUpdate == "function" && (f.flags |= 4), typeof H.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024)) : (typeof H.componentDidUpdate != "function" || W === s.memoizedProps && at === s.memoizedState || (f.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || W === s.memoizedProps && at === s.memoizedState || (f.flags |= 1024), f.memoizedProps = A, f.memoizedState = lt), H.props = A, H.state = lt, H.context = be, A = Rt) : (typeof H.componentDidUpdate != "function" || W === s.memoizedProps && at === s.memoizedState || (f.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || W === s.memoizedProps && at === s.memoizedState || (f.flags |= 1024), A = !1);
    }
    return H = A, Il(s, f), A = (f.flags & 128) !== 0, H || A ? (H = f.stateNode, v = A && typeof v.getDerivedStateFromError != "function" ? null : H.render(), f.flags |= 1, s !== null && A ? (f.child = bh(
      f,
      s.child,
      null,
      U
    ), f.child = bh(
      f,
      null,
      v,
      U
    )) : gl(s, f, v, U), f.memoizedState = H.state, s = f.child) : s = xs(
      s,
      f,
      U
    ), s;
  }
  function lo(s, f, v, A) {
    return dh(), f.flags |= 256, gl(s, f, v, A), f.child;
  }
  var sc = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function Ic(s) {
    return { baseLanes: s, cachePool: np() };
  }
  function Ms(s, f, v) {
    return s = s !== null ? s.childLanes & ~v : 0, f && (s |= xu), s;
  }
  function cp(s, f, v) {
    var A = f.pendingProps, U = !1, H = (f.flags & 128) !== 0, W;
    if ((W = H) || (W = s !== null && s.memoizedState === null ? !1 : (La.current & 2) !== 0), W && (U = !0, f.flags &= -129), W = (f.flags & 32) !== 0, f.flags &= -33, s === null) {
      if (Ln) {
        if (U ? ac(f) : Uf(), Ln) {
          var oe = Ua, be;
          if (be = oe) {
            e: {
              for (be = oe, oe = Er; be.nodeType !== 8; ) {
                if (!oe) {
                  oe = null;
                  break e;
                }
                if (be = Xf(
                  be.nextSibling
                ), be === null) {
                  oe = null;
                  break e;
                }
              }
              oe = be;
            }
            oe !== null ? (f.memoizedState = {
              dehydrated: oe,
              treeContext: Ju !== null ? { id: Jr, overflow: bi } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, be = tr(
              18,
              null,
              null,
              0
            ), be.stateNode = oe, be.return = f, f.child = be, hl = f, Ua = null, be = !0) : be = !1;
          }
          be || br(f);
        }
        if (oe = f.memoizedState, oe !== null && (oe = oe.dehydrated, oe !== null))
          return Cg(oe) ? f.lanes = 32 : f.lanes = 536870912, null;
        Io(f);
      }
      return oe = A.children, A = A.fallback, U ? (Uf(), U = f.mode, oe = Cd(
        { mode: "hidden", children: oe },
        U
      ), A = Qr(
        A,
        U,
        v,
        null
      ), oe.return = f, A.return = f, oe.sibling = A, f.child = oe, U = f.child, U.memoizedState = Ic(v), U.childLanes = Ms(
        s,
        W,
        v
      ), f.memoizedState = sc, A) : (ac(f), Vc(f, oe));
    }
    if (be = s.memoizedState, be !== null && (oe = be.dehydrated, oe !== null)) {
      if (H)
        f.flags & 256 ? (ac(f), f.flags &= -257, f = Bl(
          s,
          f,
          v
        )) : f.memoizedState !== null ? (Uf(), f.child = s.child, f.flags |= 128, f = null) : (Uf(), U = A.fallback, oe = f.mode, A = Cd(
          { mode: "visible", children: A.children },
          oe
        ), U = Qr(
          U,
          oe,
          v,
          null
        ), U.flags |= 2, A.return = f, U.return = f, A.sibling = U, f.child = A, bh(
          f,
          s.child,
          null,
          v
        ), A = f.child, A.memoizedState = Ic(v), A.childLanes = Ms(
          s,
          W,
          v
        ), f.memoizedState = sc, f = U);
      else if (ac(f), Cg(oe)) {
        if (W = oe.nextSibling && oe.nextSibling.dataset, W) var et = W.dgst;
        W = et, A = Error(a(419)), A.stack = "", A.digest = W, vd({ value: A, source: null, stack: null }), f = Bl(
          s,
          f,
          v
        );
      } else if (ss || nr(s, f, v, !1), W = (v & s.childLanes) !== 0, ss || W) {
        if (W = ma, W !== null && (A = v & -v, A = (A & 42) !== 0 ? 1 : Wn(A), A = (A & (W.suspendedLanes | v)) !== 0 ? 0 : A, A !== 0 && A !== be.retryLane))
          throw be.retryLane = A, er(s, A), fo(W, s, A), Cl;
        oe.data === "$?" || h(), f = Bl(
          s,
          f,
          v
        );
      } else
        oe.data === "$?" ? (f.flags |= 192, f.child = s.child, f = null) : (s = be.treeContext, Ua = Xf(
          oe.nextSibling
        ), hl = f, Ln = !0, as = null, Er = !1, s !== null && (Ss[jr++] = Jr, Ss[jr++] = bi, Ss[jr++] = Ju, Jr = s.id, bi = s.overflow, Ju = f), f = Vc(
          f,
          A.children
        ), f.flags |= 4096);
      return f;
    }
    return U ? (Uf(), U = A.fallback, oe = f.mode, be = s.child, et = be.sibling, A = tl(be, {
      mode: "hidden",
      children: A.children
    }), A.subtreeFlags = be.subtreeFlags & 65011712, et !== null ? U = tl(et, U) : (U = Qr(
      U,
      oe,
      v,
      null
    ), U.flags |= 2), U.return = f, A.return = f, A.sibling = U, f.child = A, A = U, U = f.child, oe = s.child.memoizedState, oe === null ? oe = Ic(v) : (be = oe.cachePool, be !== null ? (et = al._currentValue, be = be.parent !== et ? { parent: et, pool: et } : be) : be = np(), oe = {
      baseLanes: oe.baseLanes | v,
      cachePool: be
    }), U.memoizedState = oe, U.childLanes = Ms(
      s,
      W,
      v
    ), f.memoizedState = sc, A) : (ac(f), v = s.child, s = v.sibling, v = tl(v, {
      mode: "visible",
      children: A.children
    }), v.return = f, v.sibling = null, s !== null && (W = f.deletions, W === null ? (f.deletions = [s], f.flags |= 16) : W.push(s)), f.child = v, f.memoizedState = null, v);
  }
  function Vc(s, f) {
    return f = Cd(
      { mode: "visible", children: f },
      s.mode
    ), f.return = s, s.child = f;
  }
  function Cd(s, f) {
    return s = tr(22, s, null, f), s.lanes = 0, s.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, s;
  }
  function Bl(s, f, v) {
    return bh(f, s.child, null, v), s = Vc(
      f,
      f.pendingProps.children
    ), s.flags |= 2, f.memoizedState = null, s;
  }
  function Ul(s, f, v) {
    s.lanes |= f;
    var A = s.alternate;
    A !== null && (A.lanes |= f), av(s.return, f, v);
  }
  function Ja(s, f, v, A, U) {
    var H = s.memoizedState;
    H === null ? s.memoizedState = {
      isBackwards: f,
      rendering: null,
      renderingStartTime: 0,
      last: A,
      tail: v,
      tailMode: U
    } : (H.isBackwards = f, H.rendering = null, H.renderingStartTime = 0, H.last = A, H.tail = v, H.tailMode = U);
  }
  function Xo(s, f, v) {
    var A = f.pendingProps, U = A.revealOrder, H = A.tail;
    if (gl(s, f, A.children, v), A = La.current, (A & 2) !== 0)
      A = A & 1 | 2, f.flags |= 128;
    else {
      if (s !== null && (s.flags & 128) !== 0)
        e: for (s = f.child; s !== null; ) {
          if (s.tag === 13)
            s.memoizedState !== null && Ul(s, v, f);
          else if (s.tag === 19)
            Ul(s, v, f);
          else if (s.child !== null) {
            s.child.return = s, s = s.child;
            continue;
          }
          if (s === f) break e;
          for (; s.sibling === null; ) {
            if (s.return === null || s.return === f)
              break e;
            s = s.return;
          }
          s.sibling.return = s.return, s = s.sibling;
        }
      A &= 1;
    }
    switch (We(La, A), U) {
      case "forwards":
        for (v = f.child, U = null; v !== null; )
          s = v.alternate, s !== null && Vo(s) === null && (U = v), v = v.sibling;
        v = U, v === null ? (U = f.child, f.child = null) : (U = v.sibling, v.sibling = null), Ja(
          f,
          !1,
          U,
          v,
          H
        );
        break;
      case "backwards":
        for (v = null, U = f.child, f.child = null; U !== null; ) {
          if (s = U.alternate, s !== null && Vo(s) === null) {
            f.child = U;
            break;
          }
          s = U.sibling, U.sibling = v, v = U, U = s;
        }
        Ja(
          f,
          !0,
          v,
          null,
          H
        );
        break;
      case "together":
        Ja(f, !1, null, null, void 0);
        break;
      default:
        f.memoizedState = null;
    }
    return f.child;
  }
  function xs(s, f, v) {
    if (s !== null && (f.dependencies = s.dependencies), Mu |= f.lanes, (v & f.childLanes) === 0)
      if (s !== null) {
        if (nr(
          s,
          f,
          v,
          !1
        ), (v & f.childLanes) === 0)
          return null;
      } else return null;
    if (s !== null && f.child !== s.child)
      throw Error(a(153));
    if (f.child !== null) {
      for (s = f.child, v = tl(s, s.pendingProps), f.child = v, v.return = f; s.sibling !== null; )
        s = s.sibling, v = v.sibling = tl(s, s.pendingProps), v.return = f;
      v.sibling = null;
    }
    return f.child;
  }
  function xh(s, f) {
    return (s.lanes & f) !== 0 ? !0 : (s = s.dependencies, !!(s !== null && Oi(s)));
  }
  function jl(s, f, v) {
    switch (f.tag) {
      case 3:
        Zt(f, f.stateNode.containerInfo), Uc(f, al, s.memoizedState.cache), dh();
        break;
      case 27:
      case 5:
        rn(f);
        break;
      case 4:
        Zt(f, f.stateNode.containerInfo);
        break;
      case 10:
        Uc(
          f,
          f.type,
          f.memoizedProps.value
        );
        break;
      case 13:
        var A = f.memoizedState;
        if (A !== null)
          return A.dehydrated !== null ? (ac(f), f.flags |= 128, null) : (v & f.child.childLanes) !== 0 ? cp(s, f, v) : (ac(f), s = xs(
            s,
            f,
            v
          ), s !== null ? s.sibling : null);
        ac(f);
        break;
      case 19:
        var U = (s.flags & 128) !== 0;
        if (A = (v & f.childLanes) !== 0, A || (nr(
          s,
          f,
          v,
          !1
        ), A = (v & f.childLanes) !== 0), U) {
          if (A)
            return Xo(
              s,
              f,
              v
            );
          f.flags |= 128;
        }
        if (U = f.memoizedState, U !== null && (U.rendering = null, U.tail = null, U.lastEffect = null), We(La, La.current), A) break;
        return null;
      case 22:
      case 23:
        return f.lanes = 0, rs(s, f, v);
      case 24:
        Uc(f, al, s.memoizedState.cache);
    }
    return xs(s, f, v);
  }
  function Vl(s, f, v) {
    if (s !== null)
      if (s.memoizedProps !== f.pendingProps)
        ss = !0;
      else {
        if (!xh(s, v) && (f.flags & 128) === 0)
          return ss = !1, jl(
            s,
            f,
            v
          );
        ss = (s.flags & 131072) !== 0;
      }
    else
      ss = !1, Ln && (f.flags & 1048576) !== 0 && fh(f, Ar, f.index);
    switch (f.lanes = 0, f.tag) {
      case 16:
        e: {
          s = f.pendingProps;
          var A = f.elementType, U = A._init;
          if (A = U(A._payload), f.type = A, typeof A == "function")
            dd(A) ? (s = lc(A, s), f.tag = 1, f = Ur(
              null,
              f,
              A,
              s,
              v
            )) : (f.tag = 0, f = up(
              null,
              f,
              A,
              s,
              v
            ));
          else {
            if (A != null) {
              if (U = A.$$typeof, U === Y) {
                f.tag = 11, f = io(
                  null,
                  f,
                  A,
                  s,
                  v
                );
                break e;
              } else if (U === le) {
                f.tag = 14, f = Rl(
                  null,
                  f,
                  A,
                  s,
                  v
                );
                break e;
              }
            }
            throw f = Ae(A) || A, Error(a(306, f, ""));
          }
        }
        return f;
      case 0:
        return up(
          s,
          f,
          f.type,
          f.pendingProps,
          v
        );
      case 1:
        return A = f.type, U = lc(
          A,
          f.pendingProps
        ), Ur(
          s,
          f,
          A,
          U,
          v
        );
      case 3:
        e: {
          if (Zt(
            f,
            f.stateNode.containerInfo
          ), s === null) throw Error(a(387));
          A = f.pendingProps;
          var H = f.memoizedState;
          U = H.element, $n(s, f), _s(f, A, null, v);
          var W = f.memoizedState;
          if (A = W.cache, Uc(f, al, A), A !== H.cache && hh(
            f,
            [al],
            v,
            !0
          ), nm(), A = W.element, H.isDehydrated)
            if (H = {
              element: A,
              isDehydrated: !1,
              cache: W.cache
            }, f.updateQueue.baseState = H, f.memoizedState = H, f.flags & 256) {
              f = lo(
                s,
                f,
                A,
                v
              );
              break e;
            } else if (A !== U) {
              U = Ps(
                Error(a(424)),
                f
              ), vd(U), f = lo(
                s,
                f,
                A,
                v
              );
              break e;
            } else {
              switch (s = f.stateNode.containerInfo, s.nodeType) {
                case 9:
                  s = s.body;
                  break;
                default:
                  s = s.nodeName === "HTML" ? s.ownerDocument.body : s;
              }
              for (Ua = Xf(s.firstChild), hl = f, Ln = !0, as = null, Er = !0, v = Br(
                f,
                null,
                A,
                v
              ), f.child = v; v; )
                v.flags = v.flags & -3 | 4096, v = v.sibling;
            }
          else {
            if (dh(), A === U) {
              f = xs(
                s,
                f,
                v
              );
              break e;
            }
            gl(
              s,
              f,
              A,
              v
            );
          }
          f = f.child;
        }
        return f;
      case 26:
        return Il(s, f), s === null ? (v = $0(
          f.type,
          null,
          f.pendingProps,
          null
        )) ? f.memoizedState = v : Ln || (v = f.type, s = f.pendingProps, A = Pf(
          ct.current
        ).createElement(v), A[Ui] = f, A[cl] = s, Kn(A, v, s), nt(A), f.stateNode = A) : f.memoizedState = $0(
          f.type,
          s.memoizedProps,
          f.pendingProps,
          s.memoizedState
        ), null;
      case 27:
        return rn(f), s === null && Ln && (A = f.stateNode = vn(
          f.type,
          f.pendingProps,
          ct.current
        ), hl = f, Er = !0, U = Ua, zd(f.type) ? (yp = U, Ua = Xf(
          A.firstChild
        )) : Ua = U), gl(
          s,
          f,
          f.pendingProps.children,
          v
        ), Il(s, f), s === null && (f.flags |= 4194304), f.child;
      case 5:
        return s === null && Ln && ((U = A = Ua) && (A = Hd(
          A,
          f.type,
          f.pendingProps,
          Er
        ), A !== null ? (f.stateNode = A, hl = f, Ua = Xf(
          A.firstChild
        ), Er = !1, U = !0) : U = !1), U || br(f)), rn(f), U = f.type, H = f.pendingProps, W = s !== null ? s.memoizedProps : null, A = H.children, dc(U, H) ? A = null : W !== null && dc(U, W) && (f.flags |= 32), f.memoizedState !== null && (U = ec(
          s,
          f,
          sv,
          null,
          null,
          v
        ), Gn._currentValue = U), Il(s, f), gl(s, f, A, v), f.child;
      case 6:
        return s === null && Ln && ((s = v = Ua) && (v = l0(
          v,
          f.pendingProps,
          Er
        ), v !== null ? (f.stateNode = v, hl = f, Ua = null, s = !0) : s = !1), s || br(f)), null;
      case 13:
        return cp(s, f, v);
      case 4:
        return Zt(
          f,
          f.stateNode.containerInfo
        ), A = f.pendingProps, s === null ? f.child = bh(
          f,
          null,
          A,
          v
        ) : gl(
          s,
          f,
          A,
          v
        ), f.child;
      case 11:
        return io(
          s,
          f,
          f.type,
          f.pendingProps,
          v
        );
      case 7:
        return gl(
          s,
          f,
          f.pendingProps,
          v
        ), f.child;
      case 8:
        return gl(
          s,
          f,
          f.pendingProps.children,
          v
        ), f.child;
      case 12:
        return gl(
          s,
          f,
          f.pendingProps.children,
          v
        ), f.child;
      case 10:
        return A = f.pendingProps, Uc(f, f.type, A.value), gl(
          s,
          f,
          A.children,
          v
        ), f.child;
      case 9:
        return U = f.type._context, A = f.pendingProps.children, Oc(f), U = pl(U), A = A(U), f.flags |= 1, gl(s, f, A, v), f.child;
      case 14:
        return Rl(
          s,
          f,
          f.type,
          f.pendingProps,
          v
        );
      case 15:
        return wf(
          s,
          f,
          f.type,
          f.pendingProps,
          v
        );
      case 19:
        return Xo(s, f, v);
      case 31:
        return A = f.pendingProps, v = f.mode, A = {
          mode: A.mode,
          children: A.children
        }, s === null ? (v = Cd(
          A,
          v
        ), v.ref = f.ref, f.child = v, v.return = f, f = v) : (v = tl(s.child, A), v.ref = f.ref, f.child = v, v.return = f, f = v), f;
      case 22:
        return rs(s, f, v);
      case 24:
        return Oc(f), A = pl(al), s === null ? (U = wc(), U === null && (U = ma, H = ph(), U.pooledCache = H, H.refCount++, H !== null && (U.pooledCacheLanes |= v), U = H), f.memoizedState = {
          parent: A,
          cache: U
        }, ig(f), Uc(f, al, U)) : ((s.lanes & v) !== 0 && ($n(s, f), _s(f, null, null, v), nm()), U = s.memoizedState, H = f.memoizedState, U.parent !== A ? (U = { parent: A, cache: A }, f.memoizedState = U, f.lanes === 0 && (f.memoizedState = f.updateQueue.baseState = U), Uc(f, al, A)) : (A = H.cache, Uc(f, al, A), A !== U.cache && hh(
          f,
          [al],
          v,
          !0
        ))), gl(
          s,
          f,
          f.pendingProps.children,
          v
        ), f.child;
      case 29:
        throw f.pendingProps;
    }
    throw Error(a(156, f.tag));
  }
  function Ts(s) {
    s.flags |= 4;
  }
  function os(s, f) {
    if (f.type !== "stylesheet" || (f.state.loading & 4) !== 0)
      s.flags &= -16777217;
    else if (s.flags |= 16777216, !vo(f)) {
      if (f = oi.current, f !== null && ((Fn & 4194048) === Fn ? Gl !== null : (Fn & 62914560) !== Fn && (Fn & 536870912) === 0 || f !== Gl))
        throw $r = em, ap;
      s.flags |= 8192;
    }
  }
  function Fc(s, f) {
    f !== null && (s.flags |= 4), s.flags & 16384 && (f = s.tag !== 22 ? Je() : 536870912, s.lanes |= f, hi |= f);
  }
  function Th(s, f) {
    if (!Ln)
      switch (s.tailMode) {
        case "hidden":
          f = s.tail;
          for (var v = null; f !== null; )
            f.alternate !== null && (v = f), f = f.sibling;
          v === null ? s.tail = null : v.sibling = null;
          break;
        case "collapsed":
          v = s.tail;
          for (var A = null; v !== null; )
            v.alternate !== null && (A = v), v = v.sibling;
          A === null ? f || s.tail === null ? s.tail = null : s.tail.sibling = null : A.sibling = null;
      }
  }
  function Tn(s) {
    var f = s.alternate !== null && s.alternate.child === s.child, v = 0, A = 0;
    if (f)
      for (var U = s.child; U !== null; )
        v |= U.lanes | U.childLanes, A |= U.subtreeFlags & 65011712, A |= U.flags & 65011712, U.return = s, U = U.sibling;
    else
      for (U = s.child; U !== null; )
        v |= U.lanes | U.childLanes, A |= U.subtreeFlags, A |= U.flags, U.return = s, U = U.sibling;
    return s.subtreeFlags |= A, s.childLanes = v, f;
  }
  function Pc(s, f, v) {
    var A = f.pendingProps;
    switch (wo(f), f.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Tn(f), null;
      case 1:
        return Tn(f), null;
      case 3:
        return v = f.stateNode, A = null, s !== null && (A = s.memoizedState.cache), f.memoizedState.cache !== A && (f.flags |= 2048), ku(al), Bn(), v.pendingContext && (v.context = v.pendingContext, v.pendingContext = null), (s === null || s.child === null) && (Kr(f) ? Ts(f) : s === null || s.memoizedState.isDehydrated && (f.flags & 256) === 0 || (f.flags |= 1024, va())), Tn(f), null;
      case 26:
        return v = f.memoizedState, s === null ? (Ts(f), v !== null ? (Tn(f), os(f, v)) : (Tn(f), f.flags &= -16777217)) : v ? v !== s.memoizedState ? (Ts(f), Tn(f), os(f, v)) : (Tn(f), f.flags &= -16777217) : (s.memoizedProps !== A && Ts(f), Tn(f), f.flags &= -16777217), null;
      case 27:
        dn(f), v = ct.current;
        var U = f.type;
        if (s !== null && f.stateNode != null)
          s.memoizedProps !== A && Ts(f);
        else {
          if (!A) {
            if (f.stateNode === null)
              throw Error(a(166));
            return Tn(f), null;
          }
          s = Me.current, Kr(f) ? md(f) : (s = vn(U, A, v), f.stateNode = s, Ts(f));
        }
        return Tn(f), null;
      case 5:
        if (dn(f), v = f.type, s !== null && f.stateNode != null)
          s.memoizedProps !== A && Ts(f);
        else {
          if (!A) {
            if (f.stateNode === null)
              throw Error(a(166));
            return Tn(f), null;
          }
          if (s = Me.current, Kr(f))
            md(f);
          else {
            switch (U = Pf(
              ct.current
            ), s) {
              case 1:
                s = U.createElementNS(
                  "http://www.w3.org/2000/svg",
                  v
                );
                break;
              case 2:
                s = U.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  v
                );
                break;
              default:
                switch (v) {
                  case "svg":
                    s = U.createElementNS(
                      "http://www.w3.org/2000/svg",
                      v
                    );
                    break;
                  case "math":
                    s = U.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      v
                    );
                    break;
                  case "script":
                    s = U.createElement("div"), s.innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild);
                    break;
                  case "select":
                    s = typeof A.is == "string" ? U.createElement("select", { is: A.is }) : U.createElement("select"), A.multiple ? s.multiple = !0 : A.size && (s.size = A.size);
                    break;
                  default:
                    s = typeof A.is == "string" ? U.createElement(v, { is: A.is }) : U.createElement(v);
                }
            }
            s[Ui] = f, s[cl] = A;
            e: for (U = f.child; U !== null; ) {
              if (U.tag === 5 || U.tag === 6)
                s.appendChild(U.stateNode);
              else if (U.tag !== 4 && U.tag !== 27 && U.child !== null) {
                U.child.return = U, U = U.child;
                continue;
              }
              if (U === f) break e;
              for (; U.sibling === null; ) {
                if (U.return === null || U.return === f)
                  break e;
                U = U.return;
              }
              U.sibling.return = U.return, U = U.sibling;
            }
            f.stateNode = s;
            e: switch (Kn(s, v, A), v) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                s = !!A.autoFocus;
                break e;
              case "img":
                s = !0;
                break e;
              default:
                s = !1;
            }
            s && Ts(f);
          }
        }
        return Tn(f), f.flags &= -16777217, null;
      case 6:
        if (s && f.stateNode != null)
          s.memoizedProps !== A && Ts(f);
        else {
          if (typeof A != "string" && f.stateNode === null)
            throw Error(a(166));
          if (s = ct.current, Kr(f)) {
            if (s = f.stateNode, v = f.memoizedProps, A = null, U = hl, U !== null)
              switch (U.tag) {
                case 27:
                case 5:
                  A = U.memoizedProps;
              }
            s[Ui] = f, s = !!(s.nodeValue === v || A !== null && A.suppressHydrationWarning === !0 || a0(s.nodeValue, v)), s || br(f);
          } else
            s = Pf(s).createTextNode(
              A
            ), s[Ui] = f, f.stateNode = s;
        }
        return Tn(f), null;
      case 13:
        if (A = f.memoizedState, s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
          if (U = Kr(f), A !== null && A.dehydrated !== null) {
            if (s === null) {
              if (!U) throw Error(a(318));
              if (U = f.memoizedState, U = U !== null ? U.dehydrated : null, !U) throw Error(a(317));
              U[Ui] = f;
            } else
              dh(), (f.flags & 128) === 0 && (f.memoizedState = null), f.flags |= 4;
            Tn(f), U = !1;
          } else
            U = va(), s !== null && s.memoizedState !== null && (s.memoizedState.hydrationErrors = U), U = !0;
          if (!U)
            return f.flags & 256 ? (Io(f), f) : (Io(f), null);
        }
        if (Io(f), (f.flags & 128) !== 0)
          return f.lanes = v, f;
        if (v = A !== null, s = s !== null && s.memoizedState !== null, v) {
          A = f.child, U = null, A.alternate !== null && A.alternate.memoizedState !== null && A.alternate.memoizedState.cachePool !== null && (U = A.alternate.memoizedState.cachePool.pool);
          var H = null;
          A.memoizedState !== null && A.memoizedState.cachePool !== null && (H = A.memoizedState.cachePool.pool), H !== U && (A.flags |= 2048);
        }
        return v !== s && v && (f.child.flags |= 8192), Fc(f, f.updateQueue), Tn(f), null;
      case 4:
        return Bn(), s === null && ay(f.stateNode.containerInfo), Tn(f), null;
      case 10:
        return ku(f.type), Tn(f), null;
      case 19:
        if (De(La), U = f.memoizedState, U === null) return Tn(f), null;
        if (A = (f.flags & 128) !== 0, H = U.rendering, H === null)
          if (A) Th(U, !1);
          else {
            if (il !== 0 || s !== null && (s.flags & 128) !== 0)
              for (s = f.child; s !== null; ) {
                if (H = Vo(s), H !== null) {
                  for (f.flags |= 128, Th(U, !1), s = H.updateQueue, f.updateQueue = s, Fc(f, s), f.subtreeFlags = 0, s = v, v = f.child; v !== null; )
                    Ca(v, s), v = v.sibling;
                  return We(
                    La,
                    La.current & 1 | 2
                  ), f.child;
                }
                s = s.sibling;
              }
            U.tail !== null && St() > or && (f.flags |= 128, A = !0, Th(U, !1), f.lanes = 4194304);
          }
        else {
          if (!A)
            if (s = Vo(H), s !== null) {
              if (f.flags |= 128, A = !0, s = s.updateQueue, f.updateQueue = s, Fc(f, s), Th(U, !0), U.tail === null && U.tailMode === "hidden" && !H.alternate && !Ln)
                return Tn(f), null;
            } else
              2 * St() - U.renderingStartTime > or && v !== 536870912 && (f.flags |= 128, A = !0, Th(U, !1), f.lanes = 4194304);
          U.isBackwards ? (H.sibling = f.child, f.child = H) : (s = U.last, s !== null ? s.sibling = H : f.child = H, U.last = H);
        }
        return U.tail !== null ? (f = U.tail, U.rendering = f, U.tail = f.sibling, U.renderingStartTime = St(), f.sibling = null, s = La.current, We(La, A ? s & 1 | 2 : s & 1), f) : (Tn(f), null);
      case 22:
      case 23:
        return Io(f), eo(), A = f.memoizedState !== null, s !== null ? s.memoizedState !== null !== A && (f.flags |= 8192) : A && (f.flags |= 8192), A ? (v & 536870912) !== 0 && (f.flags & 128) === 0 && (Tn(f), f.subtreeFlags & 6 && (f.flags |= 8192)) : Tn(f), v = f.updateQueue, v !== null && Fc(f, v.retryQueue), v = null, s !== null && s.memoizedState !== null && s.memoizedState.cachePool !== null && (v = s.memoizedState.cachePool.pool), A = null, f.memoizedState !== null && f.memoizedState.cachePool !== null && (A = f.memoizedState.cachePool.pool), A !== v && (f.flags |= 2048), s !== null && De(kr), null;
      case 24:
        return v = null, s !== null && (v = s.memoizedState.cache), f.memoizedState.cache !== v && (f.flags |= 2048), ku(al), Tn(f), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(a(156, f.tag));
  }
  function pm(s, f) {
    switch (wo(f), f.tag) {
      case 1:
        return s = f.flags, s & 65536 ? (f.flags = s & -65537 | 128, f) : null;
      case 3:
        return ku(al), Bn(), s = f.flags, (s & 65536) !== 0 && (s & 128) === 0 ? (f.flags = s & -65537 | 128, f) : null;
      case 26:
      case 27:
      case 5:
        return dn(f), null;
      case 13:
        if (Io(f), s = f.memoizedState, s !== null && s.dehydrated !== null) {
          if (f.alternate === null)
            throw Error(a(340));
          dh();
        }
        return s = f.flags, s & 65536 ? (f.flags = s & -65537 | 128, f) : null;
      case 19:
        return De(La), null;
      case 4:
        return Bn(), null;
      case 10:
        return ku(f.type), null;
      case 22:
      case 23:
        return Io(f), eo(), s !== null && De(kr), s = f.flags, s & 65536 ? (f.flags = s & -65537 | 128, f) : null;
      case 24:
        return ku(al), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function fp(s, f) {
    switch (wo(f), f.tag) {
      case 3:
        ku(al), Bn();
        break;
      case 26:
      case 27:
      case 5:
        dn(f);
        break;
      case 4:
        Bn();
        break;
      case 13:
        Io(f);
        break;
      case 19:
        De(La);
        break;
      case 10:
        ku(f.type);
        break;
      case 22:
      case 23:
        Io(f), eo(), s !== null && De(kr);
        break;
      case 24:
        ku(al);
    }
  }
  function dp(s, f) {
    try {
      var v = f.updateQueue, A = v !== null ? v.lastEffect : null;
      if (A !== null) {
        var U = A.next;
        v = U;
        do {
          if ((v.tag & s) === s) {
            A = void 0;
            var H = v.create, W = v.inst;
            A = H(), W.destroy = A;
          }
          v = v.next;
        } while (v !== U);
      }
    } catch (oe) {
      Ge(f, f.return, oe);
    }
  }
  function Au(s, f, v) {
    try {
      var A = f.updateQueue, U = A !== null ? A.lastEffect : null;
      if (U !== null) {
        var H = U.next;
        A = H;
        do {
          if ((A.tag & s) === s) {
            var W = A.inst, oe = W.destroy;
            if (oe !== void 0) {
              W.destroy = void 0, U = f;
              var be = v, et = oe;
              try {
                et();
              } catch (Rt) {
                Ge(
                  U,
                  be,
                  Rt
                );
              }
            }
          }
          A = A.next;
        } while (A !== H);
      }
    } catch (Rt) {
      Ge(f, f.return, Rt);
    }
  }
  function Nf(s) {
    var f = s.updateQueue;
    if (f !== null) {
      var v = s.stateNode;
      try {
        Cf(f, v);
      } catch (A) {
        Ge(s, s.return, A);
      }
    }
  }
  function zf(s, f, v) {
    v.props = lc(
      s.type,
      s.memoizedProps
    ), v.state = s.memoizedState;
    try {
      v.componentWillUnmount();
    } catch (A) {
      Ge(s, f, A);
    }
  }
  function Rd(s, f) {
    try {
      var v = s.ref;
      if (v !== null) {
        switch (s.tag) {
          case 26:
          case 27:
          case 5:
            var A = s.stateNode;
            break;
          case 30:
            A = s.stateNode;
            break;
          default:
            A = s.stateNode;
        }
        typeof v == "function" ? s.refCleanup = v(A) : v.current = A;
      }
    } catch (U) {
      Ge(s, f, U);
    }
  }
  function Xc(s, f) {
    var v = s.ref, A = s.refCleanup;
    if (v !== null)
      if (typeof A == "function")
        try {
          A();
        } catch (U) {
          Ge(s, f, U);
        } finally {
          s.refCleanup = null, s = s.alternate, s != null && (s.refCleanup = null);
        }
      else if (typeof v == "function")
        try {
          v(null);
        } catch (U) {
          Ge(s, f, U);
        }
      else v.current = null;
  }
  function so(s) {
    var f = s.type, v = s.memoizedProps, A = s.stateNode;
    try {
      e: switch (f) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          v.autoFocus && A.focus();
          break e;
        case "img":
          v.src ? A.src = v.src : v.srcSet && (A.srcset = v.srcSet);
      }
    } catch (U) {
      Ge(s, s.return, U);
    }
  }
  function Yc(s, f, v) {
    try {
      var A = s.stateNode;
      o_(A, s.type, v, f), A[cl] = f;
    } catch (U) {
      Ge(s, s.return, U);
    }
  }
  function gv(s) {
    return s.tag === 5 || s.tag === 3 || s.tag === 26 || s.tag === 27 && zd(s.type) || s.tag === 4;
  }
  function lr(s) {
    e: for (; ; ) {
      for (; s.sibling === null; ) {
        if (s.return === null || gv(s.return)) return null;
        s = s.return;
      }
      for (s.sibling.return = s.return, s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18; ) {
        if (s.tag === 27 && zd(s.type) || s.flags & 2 || s.child === null || s.tag === 4) continue e;
        s.child.return = s, s = s.child;
      }
      if (!(s.flags & 2)) return s.stateNode;
    }
  }
  function rc(s, f, v) {
    var A = s.tag;
    if (A === 5 || A === 6)
      s = s.stateNode, f ? (v.nodeType === 9 ? v.body : v.nodeName === "HTML" ? v.ownerDocument.body : v).insertBefore(s, f) : (f = v.nodeType === 9 ? v.body : v.nodeName === "HTML" ? v.ownerDocument.body : v, f.appendChild(s), v = v._reactRootContainer, v != null || f.onclick !== null || (f.onclick = iy));
    else if (A !== 4 && (A === 27 && zd(s.type) && (v = s.stateNode, f = null), s = s.child, s !== null))
      for (rc(s, f, v), s = s.sibling; s !== null; )
        rc(s, f, v), s = s.sibling;
  }
  function Ch(s, f, v) {
    var A = s.tag;
    if (A === 5 || A === 6)
      s = s.stateNode, f ? v.insertBefore(s, f) : v.appendChild(s);
    else if (A !== 4 && (A === 27 && zd(s.type) && (v = s.stateNode), s = s.child, s !== null))
      for (Ch(s, f, v), s = s.sibling; s !== null; )
        Ch(s, f, v), s = s.sibling;
  }
  function ro(s) {
    var f = s.stateNode, v = s.memoizedProps;
    try {
      for (var A = s.type, U = f.attributes; U.length; )
        f.removeAttributeNode(U[0]);
      Kn(f, A, v), f[Ui] = s, f[cl] = v;
    } catch (H) {
      Ge(s, s.return, H);
    }
  }
  var qc = !1, ji = !1, hp = !1, Cs = typeof WeakSet == "function" ? WeakSet : Set, Gi = null;
  function Jl(s, f) {
    if (s = s.containerInfo, Ev = ef, s = jp(s), rh(s)) {
      if ("selectionStart" in s)
        var v = {
          start: s.selectionStart,
          end: s.selectionEnd
        };
      else
        e: {
          v = (v = s.ownerDocument) && v.defaultView || window;
          var A = v.getSelection && v.getSelection();
          if (A && A.rangeCount !== 0) {
            v = A.anchorNode;
            var U = A.anchorOffset, H = A.focusNode;
            A = A.focusOffset;
            try {
              v.nodeType, H.nodeType;
            } catch {
              v = null;
              break e;
            }
            var W = 0, oe = -1, be = -1, et = 0, Rt = 0, zt = s, at = null;
            t: for (; ; ) {
              for (var lt; zt !== v || U !== 0 && zt.nodeType !== 3 || (oe = W + U), zt !== H || A !== 0 && zt.nodeType !== 3 || (be = W + A), zt.nodeType === 3 && (W += zt.nodeValue.length), (lt = zt.firstChild) !== null; )
                at = zt, zt = lt;
              for (; ; ) {
                if (zt === s) break t;
                if (at === v && ++et === U && (oe = W), at === H && ++Rt === A && (be = W), (lt = zt.nextSibling) !== null) break;
                zt = at, at = zt.parentNode;
              }
              zt = lt;
            }
            v = oe === -1 || be === -1 ? null : { start: oe, end: be };
          } else v = null;
        }
      v = v || { start: 0, end: 0 };
    } else v = null;
    for (bv = { focusedElem: s, selectionRange: v }, ef = !1, Gi = f; Gi !== null; )
      if (f = Gi, s = f.child, (f.subtreeFlags & 1024) !== 0 && s !== null)
        s.return = f, Gi = s;
      else
        for (; Gi !== null; ) {
          switch (f = Gi, H = f.alternate, s = f.flags, f.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((s & 1024) !== 0 && H !== null) {
                s = void 0, v = f, U = H.memoizedProps, H = H.memoizedState, A = v.stateNode;
                try {
                  var Yn = lc(
                    v.type,
                    U,
                    v.elementType === v.type
                  );
                  s = A.getSnapshotBeforeUpdate(
                    Yn,
                    H
                  ), A.__reactInternalSnapshotBeforeUpdate = s;
                } catch (In) {
                  Ge(
                    v,
                    v.return,
                    In
                  );
                }
              }
              break;
            case 3:
              if ((s & 1024) !== 0) {
                if (s = f.stateNode.containerInfo, v = s.nodeType, v === 9)
                  xm(s);
                else if (v === 1)
                  switch (s.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      xm(s);
                      break;
                    default:
                      s.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((s & 1024) !== 0) throw Error(a(163));
          }
          if (s = f.sibling, s !== null) {
            s.return = f.return, Gi = s;
            break;
          }
          Gi = f.return;
        }
  }
  function Hf(s, f, v) {
    var A = v.flags;
    switch (v.tag) {
      case 0:
      case 11:
      case 15:
        sr(s, v), A & 4 && dp(5, v);
        break;
      case 1:
        if (sr(s, v), A & 4)
          if (s = v.stateNode, f === null)
            try {
              s.componentDidMount();
            } catch (W) {
              Ge(v, v.return, W);
            }
          else {
            var U = lc(
              v.type,
              f.memoizedProps
            );
            f = f.memoizedState;
            try {
              s.componentDidUpdate(
                U,
                f,
                s.__reactInternalSnapshotBeforeUpdate
              );
            } catch (W) {
              Ge(
                v,
                v.return,
                W
              );
            }
          }
        A & 64 && Nf(v), A & 512 && Rd(v, v.return);
        break;
      case 3:
        if (sr(s, v), A & 64 && (s = v.updateQueue, s !== null)) {
          if (f = null, v.child !== null)
            switch (v.child.tag) {
              case 27:
              case 5:
                f = v.child.stateNode;
                break;
              case 1:
                f = v.child.stateNode;
            }
          try {
            Cf(s, f);
          } catch (W) {
            Ge(v, v.return, W);
          }
        }
        break;
      case 27:
        f === null && A & 4 && ro(v);
      case 26:
      case 5:
        sr(s, v), f === null && A & 4 && so(v), A & 512 && Rd(v, v.return);
        break;
      case 12:
        sr(s, v);
        break;
      case 13:
        sr(s, v), A & 4 && Lf(s, v), A & 64 && (s = v.memoizedState, s !== null && (s = s.dehydrated, s !== null && (v = Fi.bind(
          null,
          v
        ), W0(s, v))));
        break;
      case 22:
        if (A = v.memoizedState !== null || qc, !A) {
          f = f !== null && f.memoizedState !== null || ji, U = qc;
          var H = ji;
          qc = A, (ji = f) && !H ? Gf(
            s,
            v,
            (v.subtreeFlags & 8772) !== 0
          ) : sr(s, v), qc = U, ji = H;
        }
        break;
      case 30:
        break;
      default:
        sr(s, v);
    }
  }
  function Ra(s) {
    var f = s.alternate;
    f !== null && (s.alternate = null, Ra(f)), s.child = null, s.deletions = null, s.sibling = null, s.tag === 5 && (f = s.stateNode, f !== null && li(f)), s.stateNode = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null;
  }
  var kn = null, Ka = !1;
  function Eu(s, f, v) {
    for (v = v.child; v !== null; )
      ga(s, f, v), v = v.sibling;
  }
  function ga(s, f, v) {
    if (Jt && typeof Jt.onCommitFiberUnmount == "function")
      try {
        Jt.onCommitFiberUnmount(yt, v);
      } catch {
      }
    switch (v.tag) {
      case 26:
        ji || Xc(v, f), Eu(
          s,
          f,
          v
        ), v.memoizedState ? v.memoizedState.count-- : v.stateNode && (v = v.stateNode, v.parentNode.removeChild(v));
        break;
      case 27:
        ji || Xc(v, f);
        var A = kn, U = Ka;
        zd(v.type) && (kn = v.stateNode, Ka = !1), Eu(
          s,
          f,
          v
        ), Bu(v.stateNode), kn = A, Ka = U;
        break;
      case 5:
        ji || Xc(v, f);
      case 6:
        if (A = kn, U = Ka, kn = null, Eu(
          s,
          f,
          v
        ), kn = A, Ka = U, kn !== null)
          if (Ka)
            try {
              (kn.nodeType === 9 ? kn.body : kn.nodeName === "HTML" ? kn.ownerDocument.body : kn).removeChild(v.stateNode);
            } catch (H) {
              Ge(
                v,
                f,
                H
              );
            }
          else
            try {
              kn.removeChild(v.stateNode);
            } catch (H) {
              Ge(
                v,
                f,
                H
              );
            }
        break;
      case 18:
        kn !== null && (Ka ? (s = kn, Tg(
          s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s,
          v.stateNode
        ), Gd(s)) : Tg(kn, v.stateNode));
        break;
      case 4:
        A = kn, U = Ka, kn = v.stateNode.containerInfo, Ka = !0, Eu(
          s,
          f,
          v
        ), kn = A, Ka = U;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        ji || Au(2, v, f), ji || Au(4, v, f), Eu(
          s,
          f,
          v
        );
        break;
      case 1:
        ji || (Xc(v, f), A = v.stateNode, typeof A.componentWillUnmount == "function" && zf(
          v,
          f,
          A
        )), Eu(
          s,
          f,
          v
        );
        break;
      case 21:
        Eu(
          s,
          f,
          v
        );
        break;
      case 22:
        ji = (A = ji) || v.memoizedState !== null, Eu(
          s,
          f,
          v
        ), ji = A;
        break;
      default:
        Eu(
          s,
          f,
          v
        );
    }
  }
  function Lf(s, f) {
    if (f.memoizedState === null && (s = f.alternate, s !== null && (s = s.memoizedState, s !== null && (s = s.dehydrated, s !== null))))
      try {
        Gd(s);
      } catch (v) {
        Ge(f, f.return, v);
      }
  }
  function mm(s) {
    switch (s.tag) {
      case 13:
      case 19:
        var f = s.stateNode;
        return f === null && (f = s.stateNode = new Cs()), f;
      case 22:
        return s = s.stateNode, f = s._retryCache, f === null && (f = s._retryCache = new Cs()), f;
      default:
        throw Error(a(435, s.tag));
    }
  }
  function Rh(s, f) {
    var v = mm(s);
    f.forEach(function(A) {
      var U = Hn.bind(null, s, A);
      v.has(A) || (v.add(A), A.then(U, U));
    });
  }
  function us(s, f) {
    var v = f.deletions;
    if (v !== null)
      for (var A = 0; A < v.length; A++) {
        var U = v[A], H = s, W = f, oe = W;
        e: for (; oe !== null; ) {
          switch (oe.tag) {
            case 27:
              if (zd(oe.type)) {
                kn = oe.stateNode, Ka = !1;
                break e;
              }
              break;
            case 5:
              kn = oe.stateNode, Ka = !1;
              break e;
            case 3:
            case 4:
              kn = oe.stateNode.containerInfo, Ka = !0;
              break e;
          }
          oe = oe.return;
        }
        if (kn === null) throw Error(a(160));
        ga(H, W, U), kn = null, Ka = !1, H = U.alternate, H !== null && (H.return = null), U.return = null;
      }
    if (f.subtreeFlags & 13878)
      for (f = f.child; f !== null; )
        pp(f, s), f = f.sibling;
  }
  var Or = null;
  function pp(s, f) {
    var v = s.alternate, A = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        us(f, s), Ji(s), A & 4 && (Au(3, s, s.return), dp(3, s), Au(5, s, s.return));
        break;
      case 1:
        us(f, s), Ji(s), A & 512 && (ji || v === null || Xc(v, v.return)), A & 64 && qc && (s = s.updateQueue, s !== null && (A = s.callbacks, A !== null && (v = s.shared.hiddenCallbacks, s.shared.hiddenCallbacks = v === null ? A : v.concat(A))));
        break;
      case 26:
        var U = Or;
        if (us(f, s), Ji(s), A & 512 && (ji || v === null || Xc(v, v.return)), A & 4) {
          var H = v !== null ? v.memoizedState : null;
          if (A = s.memoizedState, v === null)
            if (A === null)
              if (s.stateNode === null) {
                e: {
                  A = s.type, v = s.memoizedProps, U = U.ownerDocument || U;
                  t: switch (A) {
                    case "title":
                      H = U.getElementsByTagName("title")[0], (!H || H[un] || H[Ui] || H.namespaceURI === "http://www.w3.org/2000/svg" || H.hasAttribute("itemprop")) && (H = U.createElement(A), U.head.insertBefore(
                        H,
                        U.querySelector("head > title")
                      )), Kn(H, A, v), H[Ui] = s, nt(H), A = H;
                      break e;
                    case "link":
                      var W = Ns(
                        "link",
                        "href",
                        U
                      ).get(A + (v.href || ""));
                      if (W) {
                        for (var oe = 0; oe < W.length; oe++)
                          if (H = W[oe], H.getAttribute("href") === (v.href == null || v.href === "" ? null : v.href) && H.getAttribute("rel") === (v.rel == null ? null : v.rel) && H.getAttribute("title") === (v.title == null ? null : v.title) && H.getAttribute("crossorigin") === (v.crossOrigin == null ? null : v.crossOrigin)) {
                            W.splice(oe, 1);
                            break t;
                          }
                      }
                      H = U.createElement(A), Kn(H, A, v), U.head.appendChild(H);
                      break;
                    case "meta":
                      if (W = Ns(
                        "meta",
                        "content",
                        U
                      ).get(A + (v.content || ""))) {
                        for (oe = 0; oe < W.length; oe++)
                          if (H = W[oe], H.getAttribute("content") === (v.content == null ? null : "" + v.content) && H.getAttribute("name") === (v.name == null ? null : v.name) && H.getAttribute("property") === (v.property == null ? null : v.property) && H.getAttribute("http-equiv") === (v.httpEquiv == null ? null : v.httpEquiv) && H.getAttribute("charset") === (v.charSet == null ? null : v.charSet)) {
                            W.splice(oe, 1);
                            break t;
                          }
                      }
                      H = U.createElement(A), Kn(H, A, v), U.head.appendChild(H);
                      break;
                    default:
                      throw Error(a(468, A));
                  }
                  H[Ui] = s, nt(H), A = H;
                }
                s.stateNode = A;
              } else
                hc(
                  U,
                  s.type,
                  s.stateNode
                );
            else
              s.stateNode = cy(
                U,
                A,
                s.memoizedProps
              );
          else
            H !== A ? (H === null ? v.stateNode !== null && (v = v.stateNode, v.parentNode.removeChild(v)) : H.count--, A === null ? hc(
              U,
              s.type,
              s.stateNode
            ) : cy(
              U,
              A,
              s.memoizedProps
            )) : A === null && s.stateNode !== null && Yc(
              s,
              s.memoizedProps,
              v.memoizedProps
            );
        }
        break;
      case 27:
        us(f, s), Ji(s), A & 512 && (ji || v === null || Xc(v, v.return)), v !== null && A & 4 && Yc(
          s,
          s.memoizedProps,
          v.memoizedProps
        );
        break;
      case 5:
        if (us(f, s), Ji(s), A & 512 && (ji || v === null || Xc(v, v.return)), s.flags & 32) {
          U = s.stateNode;
          try {
            Hl(U, "");
          } catch (lt) {
            Ge(s, s.return, lt);
          }
        }
        A & 4 && s.stateNode != null && (U = s.memoizedProps, Yc(
          s,
          U,
          v !== null ? v.memoizedProps : U
        )), A & 1024 && (hp = !0);
        break;
      case 6:
        if (us(f, s), Ji(s), A & 4) {
          if (s.stateNode === null)
            throw Error(a(162));
          A = s.memoizedProps, v = s.stateNode;
          try {
            v.nodeValue = A;
          } catch (lt) {
            Ge(s, s.return, lt);
          }
        }
        break;
      case 3:
        if (Zf = null, U = Or, Or = s0(f.containerInfo), us(f, s), Or = U, Ji(s), A & 4 && v !== null && v.memoizedState.isDehydrated)
          try {
            Gd(f.containerInfo);
          } catch (lt) {
            Ge(s, s.return, lt);
          }
        hp && (hp = !1, Dd(s));
        break;
      case 4:
        A = Or, Or = s0(
          s.stateNode.containerInfo
        ), us(f, s), Ji(s), Or = A;
        break;
      case 12:
        us(f, s), Ji(s);
        break;
      case 13:
        us(f, s), Ji(s), s.child.flags & 8192 && s.memoizedState !== null != (v !== null && v.memoizedState !== null) && (Ri = St()), A & 4 && (A = s.updateQueue, A !== null && (s.updateQueue = null, Rh(s, A)));
        break;
      case 22:
        U = s.memoizedState !== null;
        var be = v !== null && v.memoizedState !== null, et = qc, Rt = ji;
        if (qc = et || U, ji = Rt || be, us(f, s), ji = Rt, qc = et, Ji(s), A & 8192)
          e: for (f = s.stateNode, f._visibility = U ? f._visibility & -2 : f._visibility | 1, U && (v === null || be || qc || ji || Ci(s)), v = null, f = s; ; ) {
            if (f.tag === 5 || f.tag === 26) {
              if (v === null) {
                be = v = f;
                try {
                  if (H = be.stateNode, U)
                    W = H.style, typeof W.setProperty == "function" ? W.setProperty("display", "none", "important") : W.display = "none";
                  else {
                    oe = be.stateNode;
                    var zt = be.memoizedProps.style, at = zt != null && zt.hasOwnProperty("display") ? zt.display : null;
                    oe.style.display = at == null || typeof at == "boolean" ? "" : ("" + at).trim();
                  }
                } catch (lt) {
                  Ge(be, be.return, lt);
                }
              }
            } else if (f.tag === 6) {
              if (v === null) {
                be = f;
                try {
                  be.stateNode.nodeValue = U ? "" : be.memoizedProps;
                } catch (lt) {
                  Ge(be, be.return, lt);
                }
              }
            } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === s) && f.child !== null) {
              f.child.return = f, f = f.child;
              continue;
            }
            if (f === s) break e;
            for (; f.sibling === null; ) {
              if (f.return === null || f.return === s) break e;
              v === f && (v = null), f = f.return;
            }
            v === f && (v = null), f.sibling.return = f.return, f = f.sibling;
          }
        A & 4 && (A = s.updateQueue, A !== null && (v = A.retryQueue, v !== null && (A.retryQueue = null, Rh(s, v))));
        break;
      case 19:
        us(f, s), Ji(s), A & 4 && (A = s.updateQueue, A !== null && (s.updateQueue = null, Rh(s, A)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        us(f, s), Ji(s);
    }
  }
  function Ji(s) {
    var f = s.flags;
    if (f & 2) {
      try {
        for (var v, A = s.return; A !== null; ) {
          if (gv(A)) {
            v = A;
            break;
          }
          A = A.return;
        }
        if (v == null) throw Error(a(160));
        switch (v.tag) {
          case 27:
            var U = v.stateNode, H = lr(s);
            Ch(s, H, U);
            break;
          case 5:
            var W = v.stateNode;
            v.flags & 32 && (Hl(W, ""), v.flags &= -33);
            var oe = lr(s);
            Ch(s, oe, W);
            break;
          case 3:
          case 4:
            var be = v.stateNode.containerInfo, et = lr(s);
            rc(
              s,
              et,
              be
            );
            break;
          default:
            throw Error(a(161));
        }
      } catch (Rt) {
        Ge(s, s.return, Rt);
      }
      s.flags &= -3;
    }
    f & 4096 && (s.flags &= -4097);
  }
  function Dd(s) {
    if (s.subtreeFlags & 1024)
      for (s = s.child; s !== null; ) {
        var f = s;
        Dd(f), f.tag === 5 && f.flags & 1024 && f.stateNode.reset(), s = s.sibling;
      }
  }
  function sr(s, f) {
    if (f.subtreeFlags & 8772)
      for (f = f.child; f !== null; )
        Hf(s, f.alternate, f), f = f.sibling;
  }
  function Ci(s) {
    for (s = s.child; s !== null; ) {
      var f = s;
      switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Au(4, f, f.return), Ci(f);
          break;
        case 1:
          Xc(f, f.return);
          var v = f.stateNode;
          typeof v.componentWillUnmount == "function" && zf(
            f,
            f.return,
            v
          ), Ci(f);
          break;
        case 27:
          Bu(f.stateNode);
        case 26:
        case 5:
          Xc(f, f.return), Ci(f);
          break;
        case 22:
          f.memoizedState === null && Ci(f);
          break;
        case 30:
          Ci(f);
          break;
        default:
          Ci(f);
      }
      s = s.sibling;
    }
  }
  function Gf(s, f, v) {
    for (v = v && (f.subtreeFlags & 8772) !== 0, f = f.child; f !== null; ) {
      var A = f.alternate, U = s, H = f, W = H.flags;
      switch (H.tag) {
        case 0:
        case 11:
        case 15:
          Gf(
            U,
            H,
            v
          ), dp(4, H);
          break;
        case 1:
          if (Gf(
            U,
            H,
            v
          ), A = H, U = A.stateNode, typeof U.componentDidMount == "function")
            try {
              U.componentDidMount();
            } catch (et) {
              Ge(A, A.return, et);
            }
          if (A = H, U = A.updateQueue, U !== null) {
            var oe = A.stateNode;
            try {
              var be = U.shared.hiddenCallbacks;
              if (be !== null)
                for (U.shared.hiddenCallbacks = null, U = 0; U < be.length; U++)
                  Sd(be[U], oe);
            } catch (et) {
              Ge(A, A.return, et);
            }
          }
          v && W & 64 && Nf(H), Rd(H, H.return);
          break;
        case 27:
          ro(H);
        case 26:
        case 5:
          Gf(
            U,
            H,
            v
          ), v && A === null && W & 4 && so(H), Rd(H, H.return);
          break;
        case 12:
          Gf(
            U,
            H,
            v
          );
          break;
        case 13:
          Gf(
            U,
            H,
            v
          ), v && W & 4 && Lf(U, H);
          break;
        case 22:
          H.memoizedState === null && Gf(
            U,
            H,
            v
          ), Rd(H, H.return);
          break;
        case 30:
          break;
        default:
          Gf(
            U,
            H,
            v
          );
      }
      f = f.sibling;
    }
  }
  function Yo(s, f) {
    var v = null;
    s !== null && s.memoizedState !== null && s.memoizedState.cachePool !== null && (v = s.memoizedState.cachePool.pool), s = null, f.memoizedState !== null && f.memoizedState.cachePool !== null && (s = f.memoizedState.cachePool.pool), s !== v && (s != null && s.refCount++, v != null && yu(v));
  }
  function vm(s, f) {
    s = null, f.alternate !== null && (s = f.alternate.memoizedState.cache), f = f.memoizedState.cache, f !== s && (f.refCount++, s != null && yu(s));
  }
  function ui(s, f, v, A) {
    if (f.subtreeFlags & 10256)
      for (f = f.child; f !== null; )
        gm(
          s,
          f,
          v,
          A
        ), f = f.sibling;
  }
  function gm(s, f, v, A) {
    var U = f.flags;
    switch (f.tag) {
      case 0:
      case 11:
      case 15:
        ui(
          s,
          f,
          v,
          A
        ), U & 2048 && dp(9, f);
        break;
      case 1:
        ui(
          s,
          f,
          v,
          A
        );
        break;
      case 3:
        ui(
          s,
          f,
          v,
          A
        ), U & 2048 && (s = null, f.alternate !== null && (s = f.alternate.memoizedState.cache), f = f.memoizedState.cache, f !== s && (f.refCount++, s != null && yu(s)));
        break;
      case 12:
        if (U & 2048) {
          ui(
            s,
            f,
            v,
            A
          ), s = f.stateNode;
          try {
            var H = f.memoizedProps, W = H.id, oe = H.onPostCommit;
            typeof oe == "function" && oe(
              W,
              f.alternate === null ? "mount" : "update",
              s.passiveEffectDuration,
              -0
            );
          } catch (be) {
            Ge(f, f.return, be);
          }
        } else
          ui(
            s,
            f,
            v,
            A
          );
        break;
      case 13:
        ui(
          s,
          f,
          v,
          A
        );
        break;
      case 23:
        break;
      case 22:
        H = f.stateNode, W = f.alternate, f.memoizedState !== null ? H._visibility & 2 ? ui(
          s,
          f,
          v,
          A
        ) : Oa(s, f) : H._visibility & 2 ? ui(
          s,
          f,
          v,
          A
        ) : (H._visibility |= 2, bu(
          s,
          f,
          v,
          A,
          (f.subtreeFlags & 10256) !== 0
        )), U & 2048 && Yo(W, f);
        break;
      case 24:
        ui(
          s,
          f,
          v,
          A
        ), U & 2048 && vm(f.alternate, f);
        break;
      default:
        ui(
          s,
          f,
          v,
          A
        );
    }
  }
  function bu(s, f, v, A, U) {
    for (U = U && (f.subtreeFlags & 10256) !== 0, f = f.child; f !== null; ) {
      var H = s, W = f, oe = v, be = A, et = W.flags;
      switch (W.tag) {
        case 0:
        case 11:
        case 15:
          bu(
            H,
            W,
            oe,
            be,
            U
          ), dp(8, W);
          break;
        case 23:
          break;
        case 22:
          var Rt = W.stateNode;
          W.memoizedState !== null ? Rt._visibility & 2 ? bu(
            H,
            W,
            oe,
            be,
            U
          ) : Oa(
            H,
            W
          ) : (Rt._visibility |= 2, bu(
            H,
            W,
            oe,
            be,
            U
          )), U && et & 2048 && Yo(
            W.alternate,
            W
          );
          break;
        case 24:
          bu(
            H,
            W,
            oe,
            be,
            U
          ), U && et & 2048 && vm(W.alternate, W);
          break;
        default:
          bu(
            H,
            W,
            oe,
            be,
            U
          );
      }
      f = f.sibling;
    }
  }
  function Oa(s, f) {
    if (f.subtreeFlags & 10256)
      for (f = f.child; f !== null; ) {
        var v = s, A = f, U = A.flags;
        switch (A.tag) {
          case 22:
            Oa(v, A), U & 2048 && Yo(
              A.alternate,
              A
            );
            break;
          case 24:
            Oa(v, A), U & 2048 && vm(A.alternate, A);
            break;
          default:
            Oa(v, A);
        }
        f = f.sibling;
      }
  }
  var rr = 8192;
  function yl(s) {
    if (s.subtreeFlags & rr)
      for (s = s.child; s !== null; )
        n0(s), s = s.sibling;
  }
  function n0(s) {
    switch (s.tag) {
      case 26:
        yl(s), s.flags & rr && s.memoizedState !== null && Cv(
          Or,
          s.memoizedState,
          s.memoizedProps
        );
        break;
      case 5:
        yl(s);
        break;
      case 3:
      case 4:
        var f = Or;
        Or = s0(s.stateNode.containerInfo), yl(s), Or = f;
        break;
      case 22:
        s.memoizedState === null && (f = s.alternate, f !== null && f.memoizedState !== null ? (f = rr, rr = 16777216, yl(s), rr = f) : yl(s));
        break;
      default:
        yl(s);
    }
  }
  function ny(s) {
    var f = s.alternate;
    if (f !== null && (s = f.child, s !== null)) {
      f.child = null;
      do
        f = s.sibling, s.sibling = null, s = f;
      while (s !== null);
    }
  }
  function Ii(s) {
    var f = s.deletions;
    if ((s.flags & 16) !== 0) {
      if (f !== null)
        for (var v = 0; v < f.length; v++) {
          var A = f[v];
          Gi = A, oc(
            A,
            s
          );
        }
      ny(s);
    }
    if (s.subtreeFlags & 10256)
      for (s = s.child; s !== null; )
        _g(s), s = s.sibling;
  }
  function _g(s) {
    switch (s.tag) {
      case 0:
      case 11:
      case 15:
        Ii(s), s.flags & 2048 && Au(9, s, s.return);
        break;
      case 3:
        Ii(s);
        break;
      case 12:
        Ii(s);
        break;
      case 22:
        var f = s.stateNode;
        s.memoizedState !== null && f._visibility & 2 && (s.return === null || s.return.tag !== 13) ? (f._visibility &= -3, Ol(s)) : Ii(s);
        break;
      default:
        Ii(s);
    }
  }
  function Ol(s) {
    var f = s.deletions;
    if ((s.flags & 16) !== 0) {
      if (f !== null)
        for (var v = 0; v < f.length; v++) {
          var A = f[v];
          Gi = A, oc(
            A,
            s
          );
        }
      ny(s);
    }
    for (s = s.child; s !== null; ) {
      switch (f = s, f.tag) {
        case 0:
        case 11:
        case 15:
          Au(8, f, f.return), Ol(f);
          break;
        case 22:
          v = f.stateNode, v._visibility & 2 && (v._visibility &= -3, Ol(f));
          break;
        default:
          Ol(f);
      }
      s = s.sibling;
    }
  }
  function oc(s, f) {
    for (; Gi !== null; ) {
      var v = Gi;
      switch (v.tag) {
        case 0:
        case 11:
        case 15:
          Au(8, v, f);
          break;
        case 23:
        case 22:
          if (v.memoizedState !== null && v.memoizedState.cachePool !== null) {
            var A = v.memoizedState.cachePool.pool;
            A != null && A.refCount++;
          }
          break;
        case 24:
          yu(v.memoizedState.cache);
      }
      if (A = v.child, A !== null) A.return = v, Gi = A;
      else
        e: for (v = s; Gi !== null; ) {
          A = Gi;
          var U = A.sibling, H = A.return;
          if (Ra(A), A === v) {
            Gi = null;
            break e;
          }
          if (U !== null) {
            U.return = H, Gi = U;
            break e;
          }
          Gi = H;
        }
    }
  }
  var Sl = {
    getCacheForType: function(s) {
      var f = pl(al), v = f.data.get(s);
      return v === void 0 && (v = s(), f.data.set(s, v)), v;
    }
  }, Ag = typeof WeakMap == "function" ? WeakMap : Map, mi = 0, ma = null, Ga = null, Fn = 0, ba = 0, _l = null, wr = !1, ym = !1, Sm = !1, uc = 0, il = 0, Mu = 0, Zc = 0, oo = 0, xu = 0, hi = 0, Si = null, Dn = null, qa = !1, Ri = 0, or = 1 / 0, uo = null, qo = null, Rs = 0, Ds = null, Vi = null, Al = 0, If = 0, _m = null, co = null, Qc = 0, Fl = null;
  function wl() {
    if ((mi & 2) !== 0 && Fn !== 0)
      return Fn & -Fn;
    if (P.T !== null) {
      var s = na;
      return s !== 0 ? s : Jo();
    }
    return sa();
  }
  function yv() {
    xu === 0 && (xu = (Fn & 536870912) === 0 || Ln ? xe() : 536870912);
    var s = oi.current;
    return s !== null && (s.flags |= 32), xu;
  }
  function fo(s, f, v) {
    (s === ma && (ba === 2 || ba === 9) || s.cancelPendingCommit !== null) && ($i(s, 0), Zo(
      s,
      Fn,
      xu,
      !1
    )), Ct(s, v), ((mi & 2) === 0 || s !== ma) && (s === ma && ((mi & 2) === 0 && (Zc |= v), il === 4 && Zo(
      s,
      Fn,
      xu,
      !1
    )), ho(s));
  }
  function Vf(s, f, v) {
    if ((mi & 6) !== 0) throw Error(a(327));
    var A = !v && (f & 124) === 0 && (f & s.expiredLanes) === 0 || ot(s, f), U = A ? w(s, f) : m(s, f, !0), H = A;
    do {
      if (U === 0) {
        ym && !A && Zo(s, f, 0, !1);
        break;
      } else {
        if (v = s.current.alternate, H && !jc(v)) {
          U = m(s, f, !1), H = !1;
          continue;
        }
        if (U === 2) {
          if (H = f, s.errorRecoveryDisabledLanes & H)
            var W = 0;
          else
            W = s.pendingLanes & -536870913, W = W !== 0 ? W : W & 536870912 ? 536870912 : 0;
          if (W !== 0) {
            f = W;
            e: {
              var oe = s;
              U = Si;
              var be = oe.current.memoizedState.isDehydrated;
              if (be && ($i(oe, W).flags |= 256), W = m(
                oe,
                W,
                !1
              ), W !== 2) {
                if (Sm && !be) {
                  oe.errorRecoveryDisabledLanes |= H, Zc |= H, U = 4;
                  break e;
                }
                H = Dn, Dn = U, H !== null && (Dn === null ? Dn = H : Dn.push.apply(
                  Dn,
                  H
                ));
              }
              U = W;
            }
            if (H = !1, U !== 2) continue;
          }
        }
        if (U === 1) {
          $i(s, 0), Zo(s, f, 0, !0);
          break;
        }
        e: {
          switch (A = s, H = U, H) {
            case 0:
            case 1:
              throw Error(a(345));
            case 4:
              if ((f & 4194048) !== f) break;
            case 6:
              Zo(
                A,
                f,
                xu,
                !wr
              );
              break e;
            case 2:
              Dn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(a(329));
          }
          if ((f & 62914560) === f && (U = Ri + 300 - St(), 10 < U)) {
            if (Zo(
              A,
              f,
              xu,
              !wr
            ), Ue(A, 0, !0) !== 0) break e;
            A.timeoutHandle = bm(
              Bd.bind(
                null,
                A,
                v,
                Dn,
                uo,
                qa,
                f,
                xu,
                Zc,
                hi,
                wr,
                H,
                2,
                -0,
                0
              ),
              U
            );
            break e;
          }
          Bd(
            A,
            v,
            Dn,
            uo,
            qa,
            f,
            xu,
            Zc,
            hi,
            wr,
            H,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    ho(s);
  }
  function Bd(s, f, v, A, U, H, W, oe, be, et, Rt, zt, at, lt) {
    if (s.timeoutHandle = -1, zt = f.subtreeFlags, (zt & 8192 || (zt & 16785408) === 16785408) && (fs = { stylesheets: null, count: 0, unsuspend: js }, n0(f), zt = r0(), zt !== null)) {
      s.cancelPendingCommit = zt(
        en.bind(
          null,
          s,
          f,
          H,
          v,
          A,
          U,
          W,
          oe,
          be,
          Rt,
          1,
          at,
          lt
        )
      ), Zo(s, H, W, !et);
      return;
    }
    en(
      s,
      f,
      H,
      v,
      A,
      U,
      W,
      oe,
      be
    );
  }
  function jc(s) {
    for (var f = s; ; ) {
      var v = f.tag;
      if ((v === 0 || v === 11 || v === 15) && f.flags & 16384 && (v = f.updateQueue, v !== null && (v = v.stores, v !== null)))
        for (var A = 0; A < v.length; A++) {
          var U = v[A], H = U.getSnapshot;
          U = U.value;
          try {
            if (!gs(H(), U)) return !1;
          } catch {
            return !1;
          }
        }
      if (v = f.child, f.subtreeFlags & 16384 && v !== null)
        v.return = f, f = v;
      else {
        if (f === s) break;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === s) return !0;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
    }
    return !0;
  }
  function Zo(s, f, v, A) {
    f &= ~oo, f &= ~Zc, s.suspendedLanes |= f, s.pingedLanes &= ~f, A && (s.warmLanes |= f), A = s.expirationTimes;
    for (var U = f; 0 < U; ) {
      var H = 31 - Wt(U), W = 1 << H;
      A[H] = -1, U &= ~W;
    }
    v !== 0 && tn(s, v, f);
  }
  function Kl() {
    return (mi & 6) === 0 ? (Eg(0), !1) : !0;
  }
  function Bs() {
    if (Ga !== null) {
      if (ba === 0)
        var s = Ga.return;
      else
        s = Ga, Ku = Bc = null, Cr(s), Bf = null, hm = 0, s = Ga;
      for (; s !== null; )
        fp(s.alternate, s), s = s.return;
      Ga = null;
    }
  }
  function $i(s, f) {
    var v = s.timeoutHandle;
    v !== -1 && (s.timeoutHandle = -1, ly(v)), v = s.cancelPendingCommit, v !== null && (s.cancelPendingCommit = null, v()), Bs(), ma = s, Ga = v = tl(s.current, null), Fn = f, ba = 0, _l = null, wr = !1, ym = ot(s, f), Sm = !1, hi = xu = oo = Zc = Mu = il = 0, Dn = Si = null, qa = !1, (f & 8) !== 0 && (f |= f & 32);
    var A = s.entangledLanes;
    if (A !== 0)
      for (s = s.entanglements, A &= f; 0 < A; ) {
        var U = 31 - Wt(A), H = 1 << U;
        f |= s[U], A &= ~H;
      }
    return uc = f, vu(), v;
  }
  function Sv(s, f) {
    ea = null, P.H = fm, f === xf || f === Wr ? (f = Ho(), ba = 3) : f === ap ? (f = Ho(), ba = 4) : ba = f === Cl ? 8 : f !== null && typeof f == "object" && typeof f.then == "function" ? 6 : 1, _l = f, Ga === null && (il = 1, Td(
      s,
      Ps(f, s.current)
    ));
  }
  function Am() {
    var s = P.H;
    return P.H = fm, s === null ? fm : s;
  }
  function cc() {
    var s = P.A;
    return P.A = Sl, s;
  }
  function h() {
    il = 4, wr || (Fn & 4194048) !== Fn && oi.current !== null || (ym = !0), (Mu & 134217727) === 0 && (Zc & 134217727) === 0 || ma === null || Zo(
      ma,
      Fn,
      xu,
      !1
    );
  }
  function m(s, f, v) {
    var A = mi;
    mi |= 2;
    var U = Am(), H = cc();
    (ma !== s || Fn !== f) && (uo = null, $i(s, f)), f = !1;
    var W = il;
    e: do
      try {
        if (ba !== 0 && Ga !== null) {
          var oe = Ga, be = _l;
          switch (ba) {
            case 8:
              Bs(), W = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              oi.current === null && (f = !0);
              var et = ba;
              if (ba = 0, _l = null, Be(s, oe, be, et), v && ym) {
                W = 0;
                break e;
              }
              break;
            default:
              et = ba, ba = 0, _l = null, Be(s, oe, be, et);
          }
        }
        M(), W = il;
        break;
      } catch (Rt) {
        Sv(s, Rt);
      }
    while (!0);
    return f && s.shellSuspendCounter++, Ku = Bc = null, mi = A, P.H = U, P.A = H, Ga === null && (ma = null, Fn = 0, vu()), W;
  }
  function M() {
    for (; Ga !== null; ) Z(Ga);
  }
  function w(s, f) {
    var v = mi;
    mi |= 2;
    var A = Am(), U = cc();
    ma !== s || Fn !== f ? (uo = null, or = St() + 500, $i(s, f)) : ym = ot(
      s,
      f
    );
    e: do
      try {
        if (ba !== 0 && Ga !== null) {
          f = Ga;
          var H = _l;
          t: switch (ba) {
            case 1:
              ba = 0, _l = null, Be(s, f, H, 1);
              break;
            case 2:
            case 9:
              if (ip(H)) {
                ba = 0, _l = null, fe(f);
                break;
              }
              f = function() {
                ba !== 2 && ba !== 9 || ma !== s || (ba = 7), ho(s);
              }, H.then(f, f);
              break e;
            case 3:
              ba = 7;
              break e;
            case 4:
              ba = 5;
              break e;
            case 7:
              ip(H) ? (ba = 0, _l = null, fe(f)) : (ba = 0, _l = null, Be(s, f, H, 7));
              break;
            case 5:
              var W = null;
              switch (Ga.tag) {
                case 26:
                  W = Ga.memoizedState;
                case 5:
                case 27:
                  var oe = Ga;
                  if (!W || vo(W)) {
                    ba = 0, _l = null;
                    var be = oe.sibling;
                    if (be !== null) Ga = be;
                    else {
                      var et = oe.return;
                      et !== null ? (Ga = et, qe(et)) : Ga = null;
                    }
                    break t;
                  }
              }
              ba = 0, _l = null, Be(s, f, H, 5);
              break;
            case 6:
              ba = 0, _l = null, Be(s, f, H, 6);
              break;
            case 8:
              Bs(), il = 6;
              break e;
            default:
              throw Error(a(462));
          }
        }
        I();
        break;
      } catch (Rt) {
        Sv(s, Rt);
      }
    while (!0);
    return Ku = Bc = null, P.H = A, P.A = U, mi = v, Ga !== null ? 0 : (ma = null, Fn = 0, vu(), il);
  }
  function I() {
    for (; Ga !== null && !Ha(); )
      Z(Ga);
  }
  function Z(s) {
    var f = Vl(s.alternate, s, uc);
    s.memoizedProps = s.pendingProps, f === null ? qe(s) : Ga = f;
  }
  function fe(s) {
    var f = s, v = f.alternate;
    switch (f.tag) {
      case 15:
      case 0:
        f = Po(
          v,
          f,
          f.pendingProps,
          f.type,
          void 0,
          Fn
        );
        break;
      case 11:
        f = Po(
          v,
          f,
          f.pendingProps,
          f.type.render,
          f.ref,
          Fn
        );
        break;
      case 5:
        Cr(f);
      default:
        fp(v, f), f = Ga = Ca(f, uc), f = Vl(v, f, uc);
    }
    s.memoizedProps = s.pendingProps, f === null ? qe(s) : Ga = f;
  }
  function Be(s, f, v, A) {
    Ku = Bc = null, Cr(f), Bf = null, hm = 0;
    var U = f.return;
    try {
      if (ty(
        s,
        U,
        f,
        v,
        Fn
      )) {
        il = 1, Td(
          s,
          Ps(v, s.current)
        ), Ga = null;
        return;
      }
    } catch (H) {
      if (U !== null) throw Ga = U, H;
      il = 1, Td(
        s,
        Ps(v, s.current)
      ), Ga = null;
      return;
    }
    f.flags & 32768 ? (Ln || A === 1 ? s = !0 : ym || (Fn & 536870912) !== 0 ? s = !1 : (wr = s = !0, (A === 2 || A === 9 || A === 3 || A === 6) && (A = oi.current, A !== null && A.tag === 13 && (A.flags |= 16384))), wt(f, s)) : qe(f);
  }
  function qe(s) {
    var f = s;
    do {
      if ((f.flags & 32768) !== 0) {
        wt(
          f,
          wr
        );
        return;
      }
      s = f.return;
      var v = Pc(
        f.alternate,
        f,
        uc
      );
      if (v !== null) {
        Ga = v;
        return;
      }
      if (f = f.sibling, f !== null) {
        Ga = f;
        return;
      }
      Ga = f = s;
    } while (f !== null);
    il === 0 && (il = 5);
  }
  function wt(s, f) {
    do {
      var v = pm(s.alternate, s);
      if (v !== null) {
        v.flags &= 32767, Ga = v;
        return;
      }
      if (v = s.return, v !== null && (v.flags |= 32768, v.subtreeFlags = 0, v.deletions = null), !f && (s = s.sibling, s !== null)) {
        Ga = s;
        return;
      }
      Ga = s = v;
    } while (s !== null);
    il = 6, Ga = null;
  }
  function en(s, f, v, A, U, H, W, oe, be) {
    s.cancelPendingCommit = null;
    do
      ur();
    while (Rs !== 0);
    if ((mi & 6) !== 0) throw Error(a(327));
    if (f !== null) {
      if (f === s.current) throw Error(a(177));
      if (H = f.lanes | f.childLanes, H |= ju, $t(
        s,
        v,
        H,
        W,
        oe,
        be
      ), s === ma && (Ga = ma = null, Fn = 0), Vi = f, Ds = s, Al = v, If = H, _m = U, co = A, (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0 ? (s.callbackNode = null, s.callbackPriority = 0, ya(ce, function() {
        return Us(), null;
      })) : (s.callbackNode = null, s.callbackPriority = 0), A = (f.flags & 13878) !== 0, (f.subtreeFlags & 13878) !== 0 || A) {
        A = P.T, P.T = null, U = te.p, te.p = 2, W = mi, mi |= 4;
        try {
          Jl(s, f, v);
        } finally {
          mi = W, te.p = U, P.T = A;
        }
      }
      Rs = 1, mn(), cn(), Un();
    }
  }
  function mn() {
    if (Rs === 1) {
      Rs = 0;
      var s = Ds, f = Vi, v = (f.flags & 13878) !== 0;
      if ((f.subtreeFlags & 13878) !== 0 || v) {
        v = P.T, P.T = null;
        var A = te.p;
        te.p = 2;
        var U = mi;
        mi |= 4;
        try {
          pp(f, s);
          var H = bv, W = jp(s.containerInfo), oe = H.focusedElem, be = H.selectionRange;
          if (W !== oe && oe && oe.ownerDocument && Kh(
            oe.ownerDocument.documentElement,
            oe
          )) {
            if (be !== null && rh(oe)) {
              var et = be.start, Rt = be.end;
              if (Rt === void 0 && (Rt = et), "selectionStart" in oe)
                oe.selectionStart = et, oe.selectionEnd = Math.min(
                  Rt,
                  oe.value.length
                );
              else {
                var zt = oe.ownerDocument || document, at = zt && zt.defaultView || window;
                if (at.getSelection) {
                  var lt = at.getSelection(), Yn = oe.textContent.length, In = Math.min(be.start, Yn), ti = be.end === void 0 ? In : Math.min(be.end, Yn);
                  !lt.extend && In > ti && (W = ti, ti = In, In = W);
                  var Qe = Zi(
                    oe,
                    In
                  ), Ve = Zi(
                    oe,
                    ti
                  );
                  if (Qe && Ve && (lt.rangeCount !== 1 || lt.anchorNode !== Qe.node || lt.anchorOffset !== Qe.offset || lt.focusNode !== Ve.node || lt.focusOffset !== Ve.offset)) {
                    var ke = zt.createRange();
                    ke.setStart(Qe.node, Qe.offset), lt.removeAllRanges(), In > ti ? (lt.addRange(ke), lt.extend(Ve.node, Ve.offset)) : (ke.setEnd(Ve.node, Ve.offset), lt.addRange(ke));
                  }
                }
              }
            }
            for (zt = [], lt = oe; lt = lt.parentNode; )
              lt.nodeType === 1 && zt.push({
                element: lt,
                left: lt.scrollLeft,
                top: lt.scrollTop
              });
            for (typeof oe.focus == "function" && oe.focus(), oe = 0; oe < zt.length; oe++) {
              var gt = zt[oe];
              gt.element.scrollLeft = gt.left, gt.element.scrollTop = gt.top;
            }
          }
          ef = !!Ev, bv = Ev = null;
        } finally {
          mi = U, te.p = A, P.T = v;
        }
      }
      s.current = f, Rs = 2;
    }
  }
  function cn() {
    if (Rs === 2) {
      Rs = 0;
      var s = Ds, f = Vi, v = (f.flags & 8772) !== 0;
      if ((f.subtreeFlags & 8772) !== 0 || v) {
        v = P.T, P.T = null;
        var A = te.p;
        te.p = 2;
        var U = mi;
        mi |= 4;
        try {
          Hf(s, f.alternate, f);
        } finally {
          mi = U, te.p = A, P.T = v;
        }
      }
      Rs = 3;
    }
  }
  function Un() {
    if (Rs === 4 || Rs === 3) {
      Rs = 0, Tt();
      var s = Ds, f = Vi, v = Al, A = co;
      (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0 ? Rs = 5 : (Rs = 0, Vi = Ds = null, an(s, s.pendingLanes));
      var U = s.pendingLanes;
      if (U === 0 && (qo = null), Xa(v), f = f.stateNode, Jt && typeof Jt.onCommitFiberRoot == "function")
        try {
          Jt.onCommitFiberRoot(
            yt,
            f,
            void 0,
            (f.current.flags & 128) === 128
          );
        } catch {
        }
      if (A !== null) {
        f = P.T, U = te.p, te.p = 2, P.T = null;
        try {
          for (var H = s.onRecoverableError, W = 0; W < A.length; W++) {
            var oe = A[W];
            H(oe.value, {
              componentStack: oe.stack
            });
          }
        } finally {
          P.T = f, te.p = U;
        }
      }
      (Al & 3) !== 0 && ur(), ho(s), U = s.pendingLanes, (v & 4194090) !== 0 && (U & 42) !== 0 ? s === Fl ? Qc++ : (Qc = 0, Fl = s) : Qc = 0, Eg(0);
    }
  }
  function an(s, f) {
    (s.pooledCacheLanes &= f) === 0 && (f = s.pooledCache, f != null && (s.pooledCache = null, yu(f)));
  }
  function ur(s) {
    return mn(), cn(), Un(), Us();
  }
  function Us() {
    if (Rs !== 5) return !1;
    var s = Ds, f = If;
    If = 0;
    var v = Xa(Al), A = P.T, U = te.p;
    try {
      te.p = 32 > v ? 32 : v, P.T = null, v = _m, _m = null;
      var H = Ds, W = Al;
      if (Rs = 0, Vi = Ds = null, Al = 0, (mi & 6) !== 0) throw Error(a(331));
      var oe = mi;
      if (mi |= 4, _g(H.current), gm(
        H,
        H.current,
        W,
        v
      ), mi = oe, Eg(0, !1), Jt && typeof Jt.onPostCommitFiberRoot == "function")
        try {
          Jt.onPostCommitFiberRoot(yt, H);
        } catch {
        }
      return !0;
    } finally {
      te.p = U, P.T = A, an(s, f);
    }
  }
  function Ke(s, f, v) {
    f = Ps(v, f), f = vv(s.stateNode, f, 2), s = ml(s, f, 2), s !== null && (Ct(s, 2), ho(s));
  }
  function Ge(s, f, v) {
    if (s.tag === 3)
      Ke(s, s, v);
    else
      for (; f !== null; ) {
        if (f.tag === 3) {
          Ke(
            f,
            s,
            v
          );
          break;
        } else if (f.tag === 1) {
          var A = f.stateNode;
          if (typeof f.type.getDerivedStateFromError == "function" || typeof A.componentDidCatch == "function" && (qo === null || !qo.has(A))) {
            s = Ps(v, s), v = Sg(2), A = ml(f, v, 2), A !== null && (ir(
              v,
              A,
              f,
              s
            ), Ct(A, 2), ho(A));
            break;
          }
        }
        f = f.return;
      }
  }
  function rt(s, f, v) {
    var A = s.pingCache;
    if (A === null) {
      A = s.pingCache = new Ag();
      var U = /* @__PURE__ */ new Set();
      A.set(f, U);
    } else
      U = A.get(f), U === void 0 && (U = /* @__PURE__ */ new Set(), A.set(f, U));
    U.has(v) || (Sm = !0, U.add(v), s = qt.bind(null, s, f, v), f.then(s, s));
  }
  function qt(s, f, v) {
    var A = s.pingCache;
    A !== null && A.delete(f), s.pingedLanes |= s.suspendedLanes & v, s.warmLanes &= ~v, ma === s && (Fn & v) === v && (il === 4 || il === 3 && (Fn & 62914560) === Fn && 300 > St() - Ri ? (mi & 2) === 0 && $i(s, 0) : oo |= v, hi === Fn && (hi = 0)), ho(s);
  }
  function On(s, f) {
    f === 0 && (f = Je()), s = er(s, f), s !== null && (Ct(s, f), ho(s));
  }
  function Fi(s) {
    var f = s.memoizedState, v = 0;
    f !== null && (v = f.retryLane), On(s, v);
  }
  function Hn(s, f) {
    var v = 0;
    switch (s.tag) {
      case 13:
        var A = s.stateNode, U = s.memoizedState;
        U !== null && (v = U.retryLane);
        break;
      case 19:
        A = s.stateNode;
        break;
      case 22:
        A = s.stateNode._retryCache;
        break;
      default:
        throw Error(a(314));
    }
    A !== null && A.delete(f), On(s, v);
  }
  function ya(s, f) {
    return Rn(s, f);
  }
  var Ki = null, la = null, cs = !1, Tu = !1, Em = !1, Cu = 0;
  function ho(s) {
    s !== la && s.next === null && (la === null ? Ki = la = s : la = la.next = s), Tu = !0, cs || (cs = !0, Ff());
  }
  function Eg(s, f) {
    if (!Em && Tu) {
      Em = !0;
      do
        for (var v = !1, A = Ki; A !== null; ) {
          if (s !== 0) {
            var U = A.pendingLanes;
            if (U === 0) var H = 0;
            else {
              var W = A.suspendedLanes, oe = A.pingedLanes;
              H = (1 << 31 - Wt(42 | s) + 1) - 1, H &= U & ~(W & ~oe), H = H & 201326741 ? H & 201326741 | 1 : H ? H | 2 : 0;
            }
            H !== 0 && (v = !0, jo(A, H));
          } else
            H = Fn, H = Ue(
              A,
              A === ma ? H : 0,
              A.cancelPendingCommit !== null || A.timeoutHandle !== -1
            ), (H & 3) === 0 || ot(A, H) || (v = !0, jo(A, H));
          A = A.next;
        }
      while (v);
      Em = !1;
    }
  }
  function Qo() {
    Os();
  }
  function Os() {
    Tu = cs = !1;
    var s = 0;
    Cu !== 0 && (Kc() && (s = Cu), Cu = 0);
    for (var f = St(), v = null, A = Ki; A !== null; ) {
      var U = A.next, H = ei(A, f);
      H === 0 ? (A.next = null, v === null ? Ki = U : v.next = U, U === null && (la = v)) : (v = A, (s !== 0 || (H & 3) !== 0) && (Tu = !0)), A = U;
    }
    Eg(s);
  }
  function ei(s, f) {
    for (var v = s.suspendedLanes, A = s.pingedLanes, U = s.expirationTimes, H = s.pendingLanes & -62914561; 0 < H; ) {
      var W = 31 - Wt(H), oe = 1 << W, be = U[W];
      be === -1 ? ((oe & v) === 0 || (oe & A) !== 0) && (U[W] = Ht(oe, f)) : be <= f && (s.expiredLanes |= oe), H &= ~oe;
    }
    if (f = ma, v = Fn, v = Ue(
      s,
      s === f ? v : 0,
      s.cancelPendingCommit !== null || s.timeoutHandle !== -1
    ), A = s.callbackNode, v === 0 || s === f && (ba === 2 || ba === 9) || s.cancelPendingCommit !== null)
      return A !== null && A !== null && Te(A), s.callbackNode = null, s.callbackPriority = 0;
    if ((v & 3) === 0 || ot(s, v)) {
      if (f = v & -v, f === s.callbackPriority) return f;
      switch (A !== null && Te(A), Xa(v)) {
        case 2:
        case 8:
          v = At;
          break;
        case 32:
          v = ce;
          break;
        case 268435456:
          v = Xe;
          break;
        default:
          v = ce;
      }
      return A = Dh.bind(null, s), v = Rn(v, A), s.callbackPriority = f, s.callbackNode = v, f;
    }
    return A !== null && A !== null && Te(A), s.callbackPriority = 2, s.callbackNode = null, 2;
  }
  function Dh(s, f) {
    if (Rs !== 0 && Rs !== 5)
      return s.callbackNode = null, s.callbackPriority = 0, null;
    var v = s.callbackNode;
    if (ur() && s.callbackNode !== v)
      return null;
    var A = Fn;
    return A = Ue(
      s,
      s === ma ? A : 0,
      s.cancelPendingCommit !== null || s.timeoutHandle !== -1
    ), A === 0 ? null : (Vf(s, A, f), ei(s, St()), s.callbackNode != null && s.callbackNode === v ? Dh.bind(null, s) : null);
  }
  function jo(s, f) {
    if (ur()) return null;
    Vf(s, f, !0);
  }
  function Ff() {
    i0(function() {
      (mi & 6) !== 0 ? Rn(
        kt,
        Qo
      ) : Os();
    });
  }
  function Jo() {
    return Cu === 0 && (Cu = xe()), Cu;
  }
  function bg(s) {
    return s == null || typeof s == "symbol" || typeof s == "boolean" ? null : typeof s == "function" ? s : Zh("" + s);
  }
  function Pi(s, f) {
    var v = f.ownerDocument.createElement("input");
    return v.name = f.name, v.value = f.value, s.id && v.setAttribute("form", s.id), f.parentNode.insertBefore(v, f), s = new FormData(s), v.parentNode.removeChild(v), s;
  }
  function Jc(s, f, v, A, U) {
    if (f === "submit" && v && v.stateNode === U) {
      var H = bg(
        (U[cl] || null).action
      ), W = A.submitter;
      W && (f = (f = W[cl] || null) ? bg(f.formAction) : W.getAttribute("formAction"), f !== null && (H = f, W = null));
      var oe = new ru(
        "action",
        "action",
        null,
        A,
        U
      );
      s.push({
        event: oe,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (A.defaultPrevented) {
                if (Cu !== 0) {
                  var be = W ? Pi(U, W) : new FormData(U);
                  cm(
                    v,
                    {
                      pending: !0,
                      data: be,
                      method: U.method,
                      action: H
                    },
                    null,
                    be
                  );
                }
              } else
                typeof H == "function" && (oe.preventDefault(), be = W ? Pi(U, W) : new FormData(U), cm(
                  v,
                  {
                    pending: !0,
                    data: be,
                    method: U.method,
                    action: H
                  },
                  H,
                  be
                ));
            },
            currentTarget: U
          }
        ]
      });
    }
  }
  for (var ll = 0; ll < Af.length; ll++) {
    var _v = Af[ll], Mg = _v.toLowerCase(), Da = _v[0].toUpperCase() + _v.slice(1);
    ql(
      Mg,
      "on" + Da
    );
  }
  ql(Sr, "onAnimationEnd"), ql(Jp, "onAnimationIteration"), ql(_r, "onAnimationStart"), ql("dblclick", "onDoubleClick"), ql("focusin", "onFocus"), ql("focusout", "onBlur"), ql(tv, "onTransitionRun"), ql(hu, "onTransitionStart"), ql(pu, "onTransitionCancel"), ql(mu, "onTransitionEnd"), ee("onMouseEnter", ["mouseout", "mouseover"]), ee("onMouseLeave", ["mouseout", "mouseover"]), ee("onPointerEnter", ["pointerout", "pointerover"]), ee("onPointerLeave", ["pointerout", "pointerover"]), Gt(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Gt(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Gt("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Gt(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Gt(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Gt(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Nr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), fc = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Nr)
  );
  function Bh(s, f) {
    f = (f & 4) !== 0;
    for (var v = 0; v < s.length; v++) {
      var A = s[v], U = A.event;
      A = A.listeners;
      e: {
        var H = void 0;
        if (f)
          for (var W = A.length - 1; 0 <= W; W--) {
            var oe = A[W], be = oe.instance, et = oe.currentTarget;
            if (oe = oe.listener, be !== H && U.isPropagationStopped())
              break e;
            H = oe, U.currentTarget = et;
            try {
              H(U);
            } catch (Rt) {
              Mh(Rt);
            }
            U.currentTarget = null, H = be;
          }
        else
          for (W = 0; W < A.length; W++) {
            if (oe = A[W], be = oe.instance, et = oe.currentTarget, oe = oe.listener, be !== H && U.isPropagationStopped())
              break e;
            H = oe, U.currentTarget = et;
            try {
              H(U);
            } catch (Rt) {
              Mh(Rt);
            }
            U.currentTarget = null, H = be;
          }
      }
    }
  }
  function Sa(s, f) {
    var v = f[Ws];
    v === void 0 && (v = f[Ws] = /* @__PURE__ */ new Set());
    var A = s + "__bubble";
    v.has(A) || (xg(f, s, 2, !1), v.add(A));
  }
  function mp(s, f, v) {
    var A = 0;
    f && (A |= 4), xg(
      v,
      s,
      A,
      f
    );
  }
  var Ud = "_reactListening" + Math.random().toString(36).slice(2);
  function ay(s) {
    if (!s[Ud]) {
      s[Ud] = !0, pt.forEach(function(v) {
        v !== "selectionchange" && (fc.has(v) || mp(v, !1, s), mp(v, !0, s));
      });
      var f = s.nodeType === 9 ? s : s.ownerDocument;
      f === null || f[Ud] || (f[Ud] = !0, mp("selectionchange", !1, f));
    }
  }
  function xg(s, f, v, A) {
    switch (fy(f)) {
      case 2:
        var U = u_;
        break;
      case 8:
        U = c_;
        break;
      default:
        U = vt;
    }
    v = U.bind(
      null,
      f,
      v,
      s
    ), U = void 0, !id || f !== "touchstart" && f !== "touchmove" && f !== "wheel" || (U = !0), A ? U !== void 0 ? s.addEventListener(f, v, {
      capture: !0,
      passive: U
    }) : s.addEventListener(f, v, !0) : U !== void 0 ? s.addEventListener(f, v, {
      passive: U
    }) : s.addEventListener(f, v, !1);
  }
  function Ru(s, f, v, A, U) {
    var H = A;
    if ((f & 1) === 0 && (f & 2) === 0 && A !== null)
      e: for (; ; ) {
        if (A === null) return;
        var W = A.tag;
        if (W === 3 || W === 4) {
          var oe = A.stateNode.containerInfo;
          if (oe === U) break;
          if (W === 4)
            for (W = A.return; W !== null; ) {
              var be = W.tag;
              if ((be === 3 || be === 4) && W.stateNode.containerInfo === U)
                return;
              W = W.return;
            }
          for (; oe !== null; ) {
            if (W = $(oe), W === null) return;
            if (be = W.tag, be === 5 || be === 6 || be === 26 || be === 27) {
              A = H = W;
              continue e;
            }
            oe = oe.parentNode;
          }
        }
        A = A.return;
      }
    Kd(function() {
      var et = H, Rt = Vp(v), zt = [];
      e: {
        var at = Kp.get(s);
        if (at !== void 0) {
          var lt = ru, Yn = s;
          switch (s) {
            case "keypress":
              if (Ll(v) === 0) break e;
            case "keydown":
            case "keyup":
              lt = Xr;
              break;
            case "focusin":
              Yn = "focus", lt = Xp;
              break;
            case "focusout":
              Yn = "blur", lt = Xp;
              break;
            case "beforeblur":
            case "afterblur":
              lt = Xp;
              break;
            case "click":
              if (v.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              lt = dl;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              lt = tg;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              lt = Yp;
              break;
            case Sr:
            case Jp:
            case _r:
              lt = ng;
              break;
            case mu:
              lt = Mc;
              break;
            case "scroll":
            case "scrollend":
              lt = Pp;
              break;
            case "wheel":
              lt = eh;
              break;
            case "copy":
            case "cut":
            case "paste":
              lt = Wd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              lt = rd;
              break;
            case "toggle":
            case "beforetoggle":
              lt = xc;
          }
          var In = (f & 4) !== 0, ti = !In && (s === "scroll" || s === "scrollend"), Qe = In ? at !== null ? at + "Capture" : null : at;
          In = [];
          for (var Ve = et, ke; Ve !== null; ) {
            var gt = Ve;
            if (ke = gt.stateNode, gt = gt.tag, gt !== 5 && gt !== 26 && gt !== 27 || ke === null || Qe === null || (gt = fl(Ve, Qe), gt != null && In.push(
              Od(Ve, gt, ke)
            )), ti) break;
            Ve = Ve.return;
          }
          0 < In.length && (at = new lt(
            at,
            Yn,
            null,
            v,
            Rt
          ), zt.push({ event: at, listeners: In }));
        }
      }
      if ((f & 7) === 0) {
        e: {
          if (at = s === "mouseover" || s === "pointerover", lt = s === "mouseout" || s === "pointerout", at && v !== Ec && (Yn = v.relatedTarget || v.fromElement) && ($(Yn) || Yn[Xl]))
            break e;
          if ((lt || at) && (at = Rt.window === Rt ? Rt : (at = Rt.ownerDocument) ? at.defaultView || at.parentWindow : window, lt ? (Yn = v.relatedTarget || v.toElement, lt = et, Yn = Yn ? $(Yn) : null, Yn !== null && (ti = d(Yn), In = Yn.tag, Yn !== ti || In !== 5 && In !== 27 && In !== 6) && (Yn = null)) : (lt = null, Yn = et), lt !== Yn)) {
            if (In = dl, gt = "onMouseLeave", Qe = "onMouseEnter", Ve = "mouse", (s === "pointerout" || s === "pointerover") && (In = rd, gt = "onPointerLeave", Qe = "onPointerEnter", Ve = "pointer"), ti = lt == null ? at : Ne(lt), ke = Yn == null ? at : Ne(Yn), at = new In(
              gt,
              Ve + "leave",
              lt,
              v,
              Rt
            ), at.target = ti, at.relatedTarget = ke, gt = null, $(Rt) === et && (In = new In(
              Qe,
              Ve + "enter",
              Yn,
              v,
              Rt
            ), In.target = ke, In.relatedTarget = ti, gt = In), ti = gt, lt && Yn)
              t: {
                for (In = lt, Qe = Yn, Ve = 0, ke = In; ke; ke = Uh(ke))
                  Ve++;
                for (ke = 0, gt = Qe; gt; gt = Uh(gt))
                  ke++;
                for (; 0 < Ve - ke; )
                  In = Uh(In), Ve--;
                for (; 0 < ke - Ve; )
                  Qe = Uh(Qe), ke--;
                for (; Ve--; ) {
                  if (In === Qe || Qe !== null && In === Qe.alternate)
                    break t;
                  In = Uh(In), Qe = Uh(Qe);
                }
                In = null;
              }
            else In = null;
            lt !== null && vp(
              zt,
              at,
              lt,
              In,
              !1
            ), Yn !== null && ti !== null && vp(
              zt,
              ti,
              Yn,
              In,
              !0
            );
          }
        }
        e: {
          if (at = et ? Ne(et) : window, lt = at.nodeName && at.nodeName.toLowerCase(), lt === "select" || lt === "input" && at.type === "file")
            var Cn = Fs;
          else if (Zp(at))
            if (sh)
              Cn = Qu;
            else {
              Cn = Dc;
              var Aa = Jh;
            }
          else
            lt = at.nodeName, !lt || lt.toLowerCase() !== "input" || at.type !== "checkbox" && at.type !== "radio" ? et && Yu(et.elementType) && (Cn = Fs) : Cn = gr;
          if (Cn && (Cn = Cn(s, et))) {
            vr(
              zt,
              Cn,
              v,
              Rt
            );
            break e;
          }
          Aa && Aa(s, at, et), s === "focusout" && et && at.type === "number" && et.memoizedProps.value != null && qi(at, "number", at.value);
        }
        switch (Aa = et ? Ne(et) : window, s) {
          case "focusin":
            (Zp(Aa) || Aa.contentEditable === "true") && (ys = Aa, Uo = et, _f = null);
            break;
          case "focusout":
            _f = Uo = ys = null;
            break;
          case "mousedown":
            oh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            oh = !1, ev(zt, v, Rt);
            break;
          case "selectionchange":
            if (Sf) break;
          case "keydown":
          case "keyup":
            ev(zt, v, Rt);
        }
        var Pn;
        if (th)
          e: {
            switch (s) {
              case "compositionstart":
                var Xn = "onCompositionStart";
                break e;
              case "compositionend":
                Xn = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Xn = "onCompositionUpdate";
                break e;
            }
            Xn = void 0;
          }
        else
          Cc ? od(s, v) && (Xn = "onCompositionEnd") : s === "keydown" && v.keyCode === 229 && (Xn = "onCompositionStart");
        Xn && (cu && v.locale !== "ko" && (Cc || Xn !== "onCompositionStart" ? Xn === "onCompositionEnd" && Cc && (Pn = Km()) : (su = Rt, ld = "value" in su ? su.value : su.textContent, Cc = !0)), Aa = wd(et, Xn), 0 < Aa.length && (Xn = new fi(
          Xn,
          s,
          null,
          v,
          Rt
        ), zt.push({ event: Xn, listeners: Aa }), Pn ? Xn.data = Pn : (Pn = Tc(v), Pn !== null && (Xn.data = Pn)))), (Pn = ah ? ih(s, v) : Bo(s, v)) && (Xn = wd(et, "onBeforeInput"), 0 < Xn.length && (Aa = new fi(
          "onBeforeInput",
          "beforeinput",
          null,
          v,
          Rt
        ), zt.push({
          event: Aa,
          listeners: Xn
        }), Aa.data = Pn)), Jc(
          zt,
          s,
          et,
          v,
          Rt
        );
      }
      Bh(zt, f);
    });
  }
  function Od(s, f, v) {
    return {
      instance: s,
      listener: f,
      currentTarget: v
    };
  }
  function wd(s, f) {
    for (var v = f + "Capture", A = []; s !== null; ) {
      var U = s, H = U.stateNode;
      if (U = U.tag, U !== 5 && U !== 26 && U !== 27 || H === null || (U = fl(s, v), U != null && A.unshift(
        Od(s, U, H)
      ), U = fl(s, f), U != null && A.push(
        Od(s, U, H)
      )), s.tag === 3) return A;
      s = s.return;
    }
    return [];
  }
  function Uh(s) {
    if (s === null) return null;
    do
      s = s.return;
    while (s && s.tag !== 5 && s.tag !== 27);
    return s || null;
  }
  function vp(s, f, v, A, U) {
    for (var H = f._reactName, W = []; v !== null && v !== A; ) {
      var oe = v, be = oe.alternate, et = oe.stateNode;
      if (oe = oe.tag, be !== null && be === A) break;
      oe !== 5 && oe !== 26 && oe !== 27 || et === null || (be = et, U ? (et = fl(v, H), et != null && W.unshift(
        Od(v, et, be)
      )) : U || (et = fl(v, H), et != null && W.push(
        Od(v, et, be)
      ))), v = v.return;
    }
    W.length !== 0 && s.push({ event: f, listeners: W });
  }
  var Du = /\r\n?/g, gp = /\u0000|\uFFFD/g;
  function Av(s) {
    return (typeof s == "string" ? s : "" + s).replace(Du, `
`).replace(gp, "");
  }
  function a0(s, f) {
    return f = Av(f), Av(s) === f;
  }
  function iy() {
  }
  function _a(s, f, v, A, U, H) {
    switch (v) {
      case "children":
        typeof A == "string" ? f === "body" || f === "textarea" && A === "" || Hl(s, A) : (typeof A == "number" || typeof A == "bigint") && f !== "body" && Hl(s, "" + A);
        break;
      case "className":
        _t(s, "class", A);
        break;
      case "tabIndex":
        _t(s, "tabindex", A);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        _t(s, v, A);
        break;
      case "style":
        Xu(s, A, H);
        break;
      case "data":
        if (f !== "object") {
          _t(s, "data", A);
          break;
        }
      case "src":
      case "href":
        if (A === "" && (f !== "a" || v !== "href")) {
          s.removeAttribute(v);
          break;
        }
        if (A == null || typeof A == "function" || typeof A == "symbol" || typeof A == "boolean") {
          s.removeAttribute(v);
          break;
        }
        A = Zh("" + A), s.setAttribute(v, A);
        break;
      case "action":
      case "formAction":
        if (typeof A == "function") {
          s.setAttribute(
            v,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof H == "function" && (v === "formAction" ? (f !== "input" && _a(s, f, "name", U.name, U, null), _a(
            s,
            f,
            "formEncType",
            U.formEncType,
            U,
            null
          ), _a(
            s,
            f,
            "formMethod",
            U.formMethod,
            U,
            null
          ), _a(
            s,
            f,
            "formTarget",
            U.formTarget,
            U,
            null
          )) : (_a(s, f, "encType", U.encType, U, null), _a(s, f, "method", U.method, U, null), _a(s, f, "target", U.target, U, null)));
        if (A == null || typeof A == "symbol" || typeof A == "boolean") {
          s.removeAttribute(v);
          break;
        }
        A = Zh("" + A), s.setAttribute(v, A);
        break;
      case "onClick":
        A != null && (s.onclick = iy);
        break;
      case "onScroll":
        A != null && Sa("scroll", s);
        break;
      case "onScrollEnd":
        A != null && Sa("scrollend", s);
        break;
      case "dangerouslySetInnerHTML":
        if (A != null) {
          if (typeof A != "object" || !("__html" in A))
            throw Error(a(61));
          if (v = A.__html, v != null) {
            if (U.children != null) throw Error(a(60));
            s.innerHTML = v;
          }
        }
        break;
      case "multiple":
        s.multiple = A && typeof A != "function" && typeof A != "symbol";
        break;
      case "muted":
        s.muted = A && typeof A != "function" && typeof A != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (A == null || typeof A == "function" || typeof A == "boolean" || typeof A == "symbol") {
          s.removeAttribute("xlink:href");
          break;
        }
        v = Zh("" + A), s.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          v
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        A != null && typeof A != "function" && typeof A != "symbol" ? s.setAttribute(v, "" + A) : s.removeAttribute(v);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        A && typeof A != "function" && typeof A != "symbol" ? s.setAttribute(v, "") : s.removeAttribute(v);
        break;
      case "capture":
      case "download":
        A === !0 ? s.setAttribute(v, "") : A !== !1 && A != null && typeof A != "function" && typeof A != "symbol" ? s.setAttribute(v, A) : s.removeAttribute(v);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        A != null && typeof A != "function" && typeof A != "symbol" && !isNaN(A) && 1 <= A ? s.setAttribute(v, A) : s.removeAttribute(v);
        break;
      case "rowSpan":
      case "start":
        A == null || typeof A == "function" || typeof A == "symbol" || isNaN(A) ? s.removeAttribute(v) : s.setAttribute(v, A);
        break;
      case "popover":
        Sa("beforetoggle", s), Sa("toggle", s), je(s, "popover", A);
        break;
      case "xlinkActuate":
        Ut(
          s,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          A
        );
        break;
      case "xlinkArcrole":
        Ut(
          s,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          A
        );
        break;
      case "xlinkRole":
        Ut(
          s,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          A
        );
        break;
      case "xlinkShow":
        Ut(
          s,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          A
        );
        break;
      case "xlinkTitle":
        Ut(
          s,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          A
        );
        break;
      case "xlinkType":
        Ut(
          s,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          A
        );
        break;
      case "xmlBase":
        Ut(
          s,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          A
        );
        break;
      case "xmlLang":
        Ut(
          s,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          A
        );
        break;
      case "xmlSpace":
        Ut(
          s,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          A
        );
        break;
      case "is":
        je(s, "is", A);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < v.length) || v[0] !== "o" && v[0] !== "O" || v[1] !== "n" && v[1] !== "N") && (v = $v.get(v) || v, je(s, v, A));
    }
  }
  function mt(s, f, v, A, U, H) {
    switch (v) {
      case "style":
        Xu(s, A, H);
        break;
      case "dangerouslySetInnerHTML":
        if (A != null) {
          if (typeof A != "object" || !("__html" in A))
            throw Error(a(61));
          if (v = A.__html, v != null) {
            if (U.children != null) throw Error(a(60));
            s.innerHTML = v;
          }
        }
        break;
      case "children":
        typeof A == "string" ? Hl(s, A) : (typeof A == "number" || typeof A == "bigint") && Hl(s, "" + A);
        break;
      case "onScroll":
        A != null && Sa("scroll", s);
        break;
      case "onScrollEnd":
        A != null && Sa("scrollend", s);
        break;
      case "onClick":
        A != null && (s.onclick = iy);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!Ft.hasOwnProperty(v))
          e: {
            if (v[0] === "o" && v[1] === "n" && (U = v.endsWith("Capture"), f = v.slice(2, U ? v.length - 7 : void 0), H = s[cl] || null, H = H != null ? H[v] : null, typeof H == "function" && s.removeEventListener(f, H, U), typeof A == "function")) {
              typeof H != "function" && H !== null && (v in s ? s[v] = null : s.hasAttribute(v) && s.removeAttribute(v)), s.addEventListener(f, A, U);
              break e;
            }
            v in s ? s[v] = A : A === !0 ? s.setAttribute(v, "") : je(s, v, A);
          }
    }
  }
  function Kn(s, f, v) {
    switch (f) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Sa("error", s), Sa("load", s);
        var A = !1, U = !1, H;
        for (H in v)
          if (v.hasOwnProperty(H)) {
            var W = v[H];
            if (W != null)
              switch (H) {
                case "src":
                  A = !0;
                  break;
                case "srcSet":
                  U = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(a(137, f));
                default:
                  _a(s, f, H, W, v, null);
              }
          }
        U && _a(s, f, "srcSet", v.srcSet, v, null), A && _a(s, f, "src", v.src, v, null);
        return;
      case "input":
        Sa("invalid", s);
        var oe = H = W = U = null, be = null, et = null;
        for (A in v)
          if (v.hasOwnProperty(A)) {
            var Rt = v[A];
            if (Rt != null)
              switch (A) {
                case "name":
                  U = Rt;
                  break;
                case "type":
                  W = Rt;
                  break;
                case "checked":
                  be = Rt;
                  break;
                case "defaultChecked":
                  et = Rt;
                  break;
                case "value":
                  H = Rt;
                  break;
                case "defaultValue":
                  oe = Rt;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Rt != null)
                    throw Error(a(137, f));
                  break;
                default:
                  _a(s, f, A, Rt, v, null);
              }
          }
        da(
          s,
          H,
          oe,
          be,
          et,
          W,
          U,
          !1
        ), si(s);
        return;
      case "select":
        Sa("invalid", s), A = W = H = null;
        for (U in v)
          if (v.hasOwnProperty(U) && (oe = v[U], oe != null))
            switch (U) {
              case "value":
                H = oe;
                break;
              case "defaultValue":
                W = oe;
                break;
              case "multiple":
                A = oe;
              default:
                _a(s, f, U, oe, v, null);
            }
        f = H, v = W, s.multiple = !!A, f != null ? Ya(s, !!A, f, !1) : v != null && Ya(s, !!A, v, !0);
        return;
      case "textarea":
        Sa("invalid", s), H = U = A = null;
        for (W in v)
          if (v.hasOwnProperty(W) && (oe = v[W], oe != null))
            switch (W) {
              case "value":
                A = oe;
                break;
              case "defaultValue":
                U = oe;
                break;
              case "children":
                H = oe;
                break;
              case "dangerouslySetInnerHTML":
                if (oe != null) throw Error(a(91));
                break;
              default:
                _a(s, f, W, oe, v, null);
            }
        Wi(s, A, U, H), si(s);
        return;
      case "option":
        for (be in v)
          if (v.hasOwnProperty(be) && (A = v[be], A != null))
            switch (be) {
              case "selected":
                s.selected = A && typeof A != "function" && typeof A != "symbol";
                break;
              default:
                _a(s, f, be, A, v, null);
            }
        return;
      case "dialog":
        Sa("beforetoggle", s), Sa("toggle", s), Sa("cancel", s), Sa("close", s);
        break;
      case "iframe":
      case "object":
        Sa("load", s);
        break;
      case "video":
      case "audio":
        for (A = 0; A < Nr.length; A++)
          Sa(Nr[A], s);
        break;
      case "image":
        Sa("error", s), Sa("load", s);
        break;
      case "details":
        Sa("toggle", s);
        break;
      case "embed":
      case "source":
      case "link":
        Sa("error", s), Sa("load", s);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (et in v)
          if (v.hasOwnProperty(et) && (A = v[et], A != null))
            switch (et) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(a(137, f));
              default:
                _a(s, f, et, A, v, null);
            }
        return;
      default:
        if (Yu(f)) {
          for (Rt in v)
            v.hasOwnProperty(Rt) && (A = v[Rt], A !== void 0 && mt(
              s,
              f,
              Rt,
              A,
              v,
              void 0
            ));
          return;
        }
    }
    for (oe in v)
      v.hasOwnProperty(oe) && (A = v[oe], A != null && _a(s, f, oe, A, v, null));
  }
  function o_(s, f, v, A) {
    switch (f) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var U = null, H = null, W = null, oe = null, be = null, et = null, Rt = null;
        for (lt in v) {
          var zt = v[lt];
          if (v.hasOwnProperty(lt) && zt != null)
            switch (lt) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                be = zt;
              default:
                A.hasOwnProperty(lt) || _a(s, f, lt, null, A, zt);
            }
        }
        for (var at in A) {
          var lt = A[at];
          if (zt = v[at], A.hasOwnProperty(at) && (lt != null || zt != null))
            switch (at) {
              case "type":
                H = lt;
                break;
              case "name":
                U = lt;
                break;
              case "checked":
                et = lt;
                break;
              case "defaultChecked":
                Rt = lt;
                break;
              case "value":
                W = lt;
                break;
              case "defaultValue":
                oe = lt;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (lt != null)
                  throw Error(a(137, f));
                break;
              default:
                lt !== zt && _a(
                  s,
                  f,
                  at,
                  lt,
                  A,
                  zt
                );
            }
        }
        Ta(
          s,
          W,
          oe,
          be,
          et,
          Rt,
          H,
          U
        );
        return;
      case "select":
        lt = W = oe = at = null;
        for (H in v)
          if (be = v[H], v.hasOwnProperty(H) && be != null)
            switch (H) {
              case "value":
                break;
              case "multiple":
                lt = be;
              default:
                A.hasOwnProperty(H) || _a(
                  s,
                  f,
                  H,
                  null,
                  A,
                  be
                );
            }
        for (U in A)
          if (H = A[U], be = v[U], A.hasOwnProperty(U) && (H != null || be != null))
            switch (U) {
              case "value":
                at = H;
                break;
              case "defaultValue":
                oe = H;
                break;
              case "multiple":
                W = H;
              default:
                H !== be && _a(
                  s,
                  f,
                  U,
                  H,
                  A,
                  be
                );
            }
        f = oe, v = W, A = lt, at != null ? Ya(s, !!v, at, !1) : !!A != !!v && (f != null ? Ya(s, !!v, f, !0) : Ya(s, !!v, v ? [] : "", !1));
        return;
      case "textarea":
        lt = at = null;
        for (oe in v)
          if (U = v[oe], v.hasOwnProperty(oe) && U != null && !A.hasOwnProperty(oe))
            switch (oe) {
              case "value":
                break;
              case "children":
                break;
              default:
                _a(s, f, oe, null, A, U);
            }
        for (W in A)
          if (U = A[W], H = v[W], A.hasOwnProperty(W) && (U != null || H != null))
            switch (W) {
              case "value":
                at = U;
                break;
              case "defaultValue":
                lt = U;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (U != null) throw Error(a(91));
                break;
              default:
                U !== H && _a(s, f, W, U, A, H);
            }
        Ei(s, at, lt);
        return;
      case "option":
        for (var Yn in v)
          if (at = v[Yn], v.hasOwnProperty(Yn) && at != null && !A.hasOwnProperty(Yn))
            switch (Yn) {
              case "selected":
                s.selected = !1;
                break;
              default:
                _a(
                  s,
                  f,
                  Yn,
                  null,
                  A,
                  at
                );
            }
        for (be in A)
          if (at = A[be], lt = v[be], A.hasOwnProperty(be) && at !== lt && (at != null || lt != null))
            switch (be) {
              case "selected":
                s.selected = at && typeof at != "function" && typeof at != "symbol";
                break;
              default:
                _a(
                  s,
                  f,
                  be,
                  at,
                  A,
                  lt
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var In in v)
          at = v[In], v.hasOwnProperty(In) && at != null && !A.hasOwnProperty(In) && _a(s, f, In, null, A, at);
        for (et in A)
          if (at = A[et], lt = v[et], A.hasOwnProperty(et) && at !== lt && (at != null || lt != null))
            switch (et) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (at != null)
                  throw Error(a(137, f));
                break;
              default:
                _a(
                  s,
                  f,
                  et,
                  at,
                  A,
                  lt
                );
            }
        return;
      default:
        if (Yu(f)) {
          for (var ti in v)
            at = v[ti], v.hasOwnProperty(ti) && at !== void 0 && !A.hasOwnProperty(ti) && mt(
              s,
              f,
              ti,
              void 0,
              A,
              at
            );
          for (Rt in A)
            at = A[Rt], lt = v[Rt], !A.hasOwnProperty(Rt) || at === lt || at === void 0 && lt === void 0 || mt(
              s,
              f,
              Rt,
              at,
              A,
              lt
            );
          return;
        }
    }
    for (var Qe in v)
      at = v[Qe], v.hasOwnProperty(Qe) && at != null && !A.hasOwnProperty(Qe) && _a(s, f, Qe, null, A, at);
    for (zt in A)
      at = A[zt], lt = v[zt], !A.hasOwnProperty(zt) || at === lt || at == null && lt == null || _a(s, f, zt, at, A, lt);
  }
  var Ev = null, bv = null;
  function Pf(s) {
    return s.nodeType === 9 ? s : s.ownerDocument;
  }
  function cr(s) {
    switch (s) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function Oh(s, f) {
    if (s === 0)
      switch (f) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return s === 1 && f === "foreignObject" ? 0 : s;
  }
  function dc(s, f) {
    return s === "textarea" || s === "noscript" || typeof f.children == "string" || typeof f.children == "number" || typeof f.children == "bigint" || typeof f.dangerouslySetInnerHTML == "object" && f.dangerouslySetInnerHTML !== null && f.dangerouslySetInnerHTML.__html != null;
  }
  var wh = null;
  function Kc() {
    var s = window.event;
    return s && s.type === "popstate" ? s === wh ? !1 : (wh = s, !0) : (wh = null, !1);
  }
  var bm = typeof setTimeout == "function" ? setTimeout : void 0, ly = typeof clearTimeout == "function" ? clearTimeout : void 0, Mm = typeof Promise == "function" ? Promise : void 0, i0 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Mm < "u" ? function(s) {
    return Mm.resolve(null).then(s).catch(Nd);
  } : bm;
  function Nd(s) {
    setTimeout(function() {
      throw s;
    });
  }
  function zd(s) {
    return s === "head";
  }
  function Tg(s, f) {
    var v = f, A = 0, U = 0;
    do {
      var H = v.nextSibling;
      if (s.removeChild(v), H && H.nodeType === 8)
        if (v = H.data, v === "/$") {
          if (0 < A && 8 > A) {
            v = A;
            var W = s.ownerDocument;
            if (v & 1 && Bu(W.documentElement), v & 2 && Bu(W.body), v & 4)
              for (v = W.head, Bu(v), W = v.firstChild; W; ) {
                var oe = W.nextSibling, be = W.nodeName;
                W[un] || be === "SCRIPT" || be === "STYLE" || be === "LINK" && W.rel.toLowerCase() === "stylesheet" || v.removeChild(W), W = oe;
              }
          }
          if (U === 0) {
            s.removeChild(H), Gd(f);
            return;
          }
          U--;
        } else
          v === "$" || v === "$?" || v === "$!" ? U++ : A = v.charCodeAt(0) - 48;
      else A = 0;
      v = H;
    } while (v);
    Gd(f);
  }
  function xm(s) {
    var f = s.firstChild;
    for (f && f.nodeType === 10 && (f = f.nextSibling); f; ) {
      var v = f;
      switch (f = f.nextSibling, v.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          xm(v), li(v);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (v.rel.toLowerCase() === "stylesheet") continue;
      }
      s.removeChild(v);
    }
  }
  function Hd(s, f, v, A) {
    for (; s.nodeType === 1; ) {
      var U = v;
      if (s.nodeName.toLowerCase() !== f.toLowerCase()) {
        if (!A && (s.nodeName !== "INPUT" || s.type !== "hidden"))
          break;
      } else if (A) {
        if (!s[un])
          switch (f) {
            case "meta":
              if (!s.hasAttribute("itemprop")) break;
              return s;
            case "link":
              if (H = s.getAttribute("rel"), H === "stylesheet" && s.hasAttribute("data-precedence"))
                break;
              if (H !== U.rel || s.getAttribute("href") !== (U.href == null || U.href === "" ? null : U.href) || s.getAttribute("crossorigin") !== (U.crossOrigin == null ? null : U.crossOrigin) || s.getAttribute("title") !== (U.title == null ? null : U.title))
                break;
              return s;
            case "style":
              if (s.hasAttribute("data-precedence")) break;
              return s;
            case "script":
              if (H = s.getAttribute("src"), (H !== (U.src == null ? null : U.src) || s.getAttribute("type") !== (U.type == null ? null : U.type) || s.getAttribute("crossorigin") !== (U.crossOrigin == null ? null : U.crossOrigin)) && H && s.hasAttribute("async") && !s.hasAttribute("itemprop"))
                break;
              return s;
            default:
              return s;
          }
      } else if (f === "input" && s.type === "hidden") {
        var H = U.name == null ? null : "" + U.name;
        if (U.type === "hidden" && s.getAttribute("name") === H)
          return s;
      } else return s;
      if (s = Xf(s.nextSibling), s === null) break;
    }
    return null;
  }
  function l0(s, f, v) {
    if (f === "") return null;
    for (; s.nodeType !== 3; )
      if ((s.nodeType !== 1 || s.nodeName !== "INPUT" || s.type !== "hidden") && !v || (s = Xf(s.nextSibling), s === null)) return null;
    return s;
  }
  function Cg(s) {
    return s.data === "$!" || s.data === "$?" && s.ownerDocument.readyState === "complete";
  }
  function W0(s, f) {
    var v = s.ownerDocument;
    if (s.data !== "$?" || v.readyState === "complete")
      f();
    else {
      var A = function() {
        f(), v.removeEventListener("DOMContentLoaded", A);
      };
      v.addEventListener("DOMContentLoaded", A), s._reactRetry = A;
    }
  }
  function Xf(s) {
    for (; s != null; s = s.nextSibling) {
      var f = s.nodeType;
      if (f === 1 || f === 3) break;
      if (f === 8) {
        if (f = s.data, f === "$" || f === "$!" || f === "$?" || f === "F!" || f === "F")
          break;
        if (f === "/$") return null;
      }
    }
    return s;
  }
  var yp = null;
  function zr(s) {
    s = s.previousSibling;
    for (var f = 0; s; ) {
      if (s.nodeType === 8) {
        var v = s.data;
        if (v === "$" || v === "$!" || v === "$?") {
          if (f === 0) return s;
          f--;
        } else v === "/$" && f++;
      }
      s = s.previousSibling;
    }
    return null;
  }
  function vn(s, f, v) {
    switch (f = Pf(v), s) {
      case "html":
        if (s = f.documentElement, !s) throw Error(a(452));
        return s;
      case "head":
        if (s = f.head, !s) throw Error(a(453));
        return s;
      case "body":
        if (s = f.body, !s) throw Error(a(454));
        return s;
      default:
        throw Error(a(451));
    }
  }
  function Bu(s) {
    for (var f = s.attributes; f.length; )
      s.removeAttributeNode(f[0]);
    li(s);
  }
  var kl = /* @__PURE__ */ new Map(), po = /* @__PURE__ */ new Set();
  function s0(s) {
    return typeof s.getRootNode == "function" ? s.getRootNode() : s.nodeType === 9 ? s : s.ownerDocument;
  }
  var Nh = te.d;
  te.d = {
    f: sy,
    r: ry,
    D: Sp,
    C: oy,
    L: Uu,
    m: ws,
    X: oa,
    S: Hr,
    M: uy
  };
  function sy() {
    var s = Nh.f(), f = Kl();
    return s || f;
  }
  function ry(s) {
    var f = pe(s);
    f !== null && f.tag === 5 && f.type === "form" ? Ah(f) : Nh.r(s);
  }
  var mo = typeof document > "u" ? null : document;
  function Yf(s, f, v) {
    var A = mo;
    if (A && typeof f == "string" && f) {
      var U = Qn(f);
      U = 'link[rel="' + s + '"][href="' + U + '"]', typeof v == "string" && (U += '[crossorigin="' + v + '"]'), po.has(U) || (po.add(U), s = { rel: s, crossOrigin: v, href: f }, A.querySelector(U) === null && (f = A.createElement("link"), Kn(f, "link", s), nt(f), A.head.appendChild(f)));
    }
  }
  function Sp(s) {
    Nh.D(s), Yf("dns-prefetch", s, null);
  }
  function oy(s, f) {
    Nh.C(s, f), Yf("preconnect", s, f);
  }
  function Uu(s, f, v) {
    Nh.L(s, f, v);
    var A = mo;
    if (A && s && f) {
      var U = 'link[rel="preload"][as="' + Qn(f) + '"]';
      f === "image" && v && v.imageSrcSet ? (U += '[imagesrcset="' + Qn(
        v.imageSrcSet
      ) + '"]', typeof v.imageSizes == "string" && (U += '[imagesizes="' + Qn(
        v.imageSizes
      ) + '"]')) : U += '[href="' + Qn(s) + '"]';
      var H = U;
      switch (f) {
        case "style":
          H = Mv(s);
          break;
        case "script":
          H = kc(s);
      }
      kl.has(H) || (s = T(
        {
          rel: "preload",
          href: f === "image" && v && v.imageSrcSet ? void 0 : s,
          as: f
        },
        v
      ), kl.set(H, s), A.querySelector(U) !== null || f === "style" && A.querySelector(xv(H)) || f === "script" && A.querySelector(qf(H)) || (f = A.createElement("link"), Kn(f, "link", s), nt(f), A.head.appendChild(f)));
    }
  }
  function ws(s, f) {
    Nh.m(s, f);
    var v = mo;
    if (v && s) {
      var A = f && typeof f.as == "string" ? f.as : "script", U = 'link[rel="modulepreload"][as="' + Qn(A) + '"][href="' + Qn(s) + '"]', H = U;
      switch (A) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          H = kc(s);
      }
      if (!kl.has(H) && (s = T({ rel: "modulepreload", href: s }, f), kl.set(H, s), v.querySelector(U) === null)) {
        switch (A) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (v.querySelector(qf(H)))
              return;
        }
        A = v.createElement("link"), Kn(A, "link", s), nt(A), v.head.appendChild(A);
      }
    }
  }
  function Hr(s, f, v) {
    Nh.S(s, f, v);
    var A = mo;
    if (A && s) {
      var U = $e(A).hoistableStyles, H = Mv(s);
      f = f || "default";
      var W = U.get(H);
      if (!W) {
        var oe = { loading: 0, preload: null };
        if (W = A.querySelector(
          xv(H)
        ))
          oe.loading = 5;
        else {
          s = T(
            { rel: "stylesheet", href: s, "data-precedence": f },
            v
          ), (v = kl.get(H)) && Wc(s, v);
          var be = W = A.createElement("link");
          nt(be), Kn(be, "link", s), be._p = new Promise(function(et, Rt) {
            be.onload = et, be.onerror = Rt;
          }), be.addEventListener("load", function() {
            oe.loading |= 1;
          }), be.addEventListener("error", function() {
            oe.loading |= 2;
          }), oe.loading |= 4, Ou(W, f, A);
        }
        W = {
          type: "stylesheet",
          instance: W,
          count: 1,
          state: oe
        }, U.set(H, W);
      }
    }
  }
  function oa(s, f) {
    Nh.X(s, f);
    var v = mo;
    if (v && s) {
      var A = $e(v).hoistableScripts, U = kc(s), H = A.get(U);
      H || (H = v.querySelector(qf(U)), H || (s = T({ src: s, async: !0 }, f), (f = kl.get(U)) && _p(s, f), H = v.createElement("script"), nt(H), Kn(H, "link", s), v.head.appendChild(H)), H = {
        type: "script",
        instance: H,
        count: 1,
        state: null
      }, A.set(U, H));
    }
  }
  function uy(s, f) {
    Nh.M(s, f);
    var v = mo;
    if (v && s) {
      var A = $e(v).hoistableScripts, U = kc(s), H = A.get(U);
      H || (H = v.querySelector(qf(U)), H || (s = T({ src: s, async: !0, type: "module" }, f), (f = kl.get(U)) && _p(s, f), H = v.createElement("script"), nt(H), Kn(H, "link", s), v.head.appendChild(H)), H = {
        type: "script",
        instance: H,
        count: 1,
        state: null
      }, A.set(U, H));
    }
  }
  function $0(s, f, v, A) {
    var U = (U = ct.current) ? s0(U) : null;
    if (!U) throw Error(a(446));
    switch (s) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof v.precedence == "string" && typeof v.href == "string" ? (f = Mv(v.href), v = $e(
          U
        ).hoistableStyles, A = v.get(f), A || (A = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, v.set(f, A)), A) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (v.rel === "stylesheet" && typeof v.href == "string" && typeof v.precedence == "string") {
          s = Mv(v.href);
          var H = $e(
            U
          ).hoistableStyles, W = H.get(s);
          if (W || (U = U.ownerDocument || U, W = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, H.set(s, W), (H = U.querySelector(
            xv(s)
          )) && !H._p && (W.instance = H, W.state.loading = 5), kl.has(s) || (v = {
            rel: "preload",
            as: "style",
            href: v.href,
            crossOrigin: v.crossOrigin,
            integrity: v.integrity,
            media: v.media,
            hrefLang: v.hrefLang,
            referrerPolicy: v.referrerPolicy
          }, kl.set(s, v), H || Tm(
            U,
            s,
            v,
            W.state
          ))), f && A === null)
            throw Error(a(528, ""));
          return W;
        }
        if (f && A !== null)
          throw Error(a(529, ""));
        return null;
      case "script":
        return f = v.async, v = v.src, typeof v == "string" && f && typeof f != "function" && typeof f != "symbol" ? (f = kc(v), v = $e(
          U
        ).hoistableScripts, A = v.get(f), A || (A = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, v.set(f, A)), A) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(a(444, s));
    }
  }
  function Mv(s) {
    return 'href="' + Qn(s) + '"';
  }
  function xv(s) {
    return 'link[rel="stylesheet"][' + s + "]";
  }
  function Tv(s) {
    return T({}, s, {
      "data-precedence": s.precedence,
      precedence: null
    });
  }
  function Tm(s, f, v, A) {
    s.querySelector('link[rel="preload"][as="style"][' + f + "]") ? A.loading = 1 : (f = s.createElement("link"), A.preload = f, f.addEventListener("load", function() {
      return A.loading |= 1;
    }), f.addEventListener("error", function() {
      return A.loading |= 2;
    }), Kn(f, "link", v), nt(f), s.head.appendChild(f));
  }
  function kc(s) {
    return '[src="' + Qn(s) + '"]';
  }
  function qf(s) {
    return "script[async]" + s;
  }
  function cy(s, f, v) {
    if (f.count++, f.instance === null)
      switch (f.type) {
        case "style":
          var A = s.querySelector(
            'style[data-href~="' + Qn(v.href) + '"]'
          );
          if (A)
            return f.instance = A, nt(A), A;
          var U = T({}, v, {
            "data-href": v.href,
            "data-precedence": v.precedence,
            href: null,
            precedence: null
          });
          return A = (s.ownerDocument || s).createElement(
            "style"
          ), nt(A), Kn(A, "style", U), Ou(A, v.precedence, s), f.instance = A;
        case "stylesheet":
          U = Mv(v.href);
          var H = s.querySelector(
            xv(U)
          );
          if (H)
            return f.state.loading |= 4, f.instance = H, nt(H), H;
          A = Tv(v), (U = kl.get(U)) && Wc(A, U), H = (s.ownerDocument || s).createElement("link"), nt(H);
          var W = H;
          return W._p = new Promise(function(oe, be) {
            W.onload = oe, W.onerror = be;
          }), Kn(H, "link", A), f.state.loading |= 4, Ou(H, v.precedence, s), f.instance = H;
        case "script":
          return H = kc(v.src), (U = s.querySelector(
            qf(H)
          )) ? (f.instance = U, nt(U), U) : (A = v, (U = kl.get(H)) && (A = T({}, v), _p(A, U)), s = s.ownerDocument || s, U = s.createElement("script"), nt(U), Kn(U, "link", A), s.head.appendChild(U), f.instance = U);
        case "void":
          return null;
        default:
          throw Error(a(443, f.type));
      }
    else
      f.type === "stylesheet" && (f.state.loading & 4) === 0 && (A = f.instance, f.state.loading |= 4, Ou(A, v.precedence, s));
    return f.instance;
  }
  function Ou(s, f, v) {
    for (var A = v.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), U = A.length ? A[A.length - 1] : null, H = U, W = 0; W < A.length; W++) {
      var oe = A[W];
      if (oe.dataset.precedence === f) H = oe;
      else if (H !== U) break;
    }
    H ? H.parentNode.insertBefore(s, H.nextSibling) : (f = v.nodeType === 9 ? v.head : v, f.insertBefore(s, f.firstChild));
  }
  function Wc(s, f) {
    s.crossOrigin == null && (s.crossOrigin = f.crossOrigin), s.referrerPolicy == null && (s.referrerPolicy = f.referrerPolicy), s.title == null && (s.title = f.title);
  }
  function _p(s, f) {
    s.crossOrigin == null && (s.crossOrigin = f.crossOrigin), s.referrerPolicy == null && (s.referrerPolicy = f.referrerPolicy), s.integrity == null && (s.integrity = f.integrity);
  }
  var Zf = null;
  function Ns(s, f, v) {
    if (Zf === null) {
      var A = /* @__PURE__ */ new Map(), U = Zf = /* @__PURE__ */ new Map();
      U.set(v, A);
    } else
      U = Zf, A = U.get(v), A || (A = /* @__PURE__ */ new Map(), U.set(v, A));
    if (A.has(s)) return A;
    for (A.set(s, null), v = v.getElementsByTagName(s), U = 0; U < v.length; U++) {
      var H = v[U];
      if (!(H[un] || H[Ui] || s === "link" && H.getAttribute("rel") === "stylesheet") && H.namespaceURI !== "http://www.w3.org/2000/svg") {
        var W = H.getAttribute(f) || "";
        W = s + W;
        var oe = A.get(W);
        oe ? oe.push(H) : A.set(W, [H]);
      }
    }
    return A;
  }
  function hc(s, f, v) {
    s = s.ownerDocument || s, s.head.insertBefore(
      v,
      f === "title" ? s.querySelector("head > title") : null
    );
  }
  function $c(s, f, v) {
    if (v === 1 || f.itemProp != null) return !1;
    switch (s) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof f.precedence != "string" || typeof f.href != "string" || f.href === "")
          break;
        return !0;
      case "link":
        if (typeof f.rel != "string" || typeof f.href != "string" || f.href === "" || f.onLoad || f.onError)
          break;
        switch (f.rel) {
          case "stylesheet":
            return s = f.disabled, typeof f.precedence == "string" && s == null;
          default:
            return !0;
        }
      case "script":
        if (f.async && typeof f.async != "function" && typeof f.async != "symbol" && !f.onLoad && !f.onError && f.src && typeof f.src == "string")
          return !0;
    }
    return !1;
  }
  function vo(s) {
    return !(s.type === "stylesheet" && (s.state.loading & 3) === 0);
  }
  var fs = null;
  function js() {
  }
  function Cv(s, f, v) {
    if (fs === null) throw Error(a(475));
    var A = fs;
    if (f.type === "stylesheet" && (typeof v.media != "string" || matchMedia(v.media).matches !== !1) && (f.state.loading & 4) === 0) {
      if (f.instance === null) {
        var U = Mv(v.href), H = s.querySelector(
          xv(U)
        );
        if (H) {
          s = H._p, s !== null && typeof s == "object" && typeof s.then == "function" && (A.count++, A = Rg.bind(A), s.then(A, A)), f.state.loading |= 4, f.instance = H, nt(H);
          return;
        }
        H = s.ownerDocument || s, v = Tv(v), (U = kl.get(U)) && Wc(v, U), H = H.createElement("link"), nt(H);
        var W = H;
        W._p = new Promise(function(oe, be) {
          W.onload = oe, W.onerror = be;
        }), Kn(H, "link", v), f.instance = H;
      }
      A.stylesheets === null && (A.stylesheets = /* @__PURE__ */ new Map()), A.stylesheets.set(f, s), (s = f.state.preload) && (f.state.loading & 3) === 0 && (A.count++, f = Rg.bind(A), s.addEventListener("load", f), s.addEventListener("error", f));
    }
  }
  function r0() {
    if (fs === null) throw Error(a(475));
    var s = fs;
    return s.stylesheets && s.count === 0 && Dg(s, s.stylesheets), 0 < s.count ? function(f) {
      var v = setTimeout(function() {
        if (s.stylesheets && Dg(s, s.stylesheets), s.unsuspend) {
          var A = s.unsuspend;
          s.unsuspend = null, A();
        }
      }, 6e4);
      return s.unsuspend = f, function() {
        s.unsuspend = null, clearTimeout(v);
      };
    } : null;
  }
  function Rg() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) Dg(this, this.stylesheets);
      else if (this.unsuspend) {
        var s = this.unsuspend;
        this.unsuspend = null, s();
      }
    }
  }
  var Cm = null;
  function Dg(s, f) {
    s.stylesheets = null, s.unsuspend !== null && (s.count++, Cm = /* @__PURE__ */ new Map(), f.forEach(Js, s), Cm = null, Rg.call(s));
  }
  function Js(s, f) {
    if (!(f.state.loading & 4)) {
      var v = Cm.get(s);
      if (v) var A = v.get(null);
      else {
        v = /* @__PURE__ */ new Map(), Cm.set(s, v);
        for (var U = s.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), H = 0; H < U.length; H++) {
          var W = U[H];
          (W.nodeName === "LINK" || W.getAttribute("media") !== "not all") && (v.set(W.dataset.precedence, W), A = W);
        }
        A && v.set(null, A);
      }
      U = f.instance, W = U.getAttribute("data-precedence"), H = v.get(W) || A, H === A && v.set(null, U), v.set(W, U), this.count++, A = Rg.bind(this), U.addEventListener("load", A), U.addEventListener("error", A), H ? H.parentNode.insertBefore(U, H.nextSibling) : (s = s.nodeType === 9 ? s.head : s, s.insertBefore(U, s.firstChild)), f.state.loading |= 4;
    }
  }
  var Gn = {
    $$typeof: q,
    Provider: null,
    Consumer: null,
    _currentValue: ae,
    _currentValue2: ae,
    _threadCount: 0
  };
  function el(s, f, v, A, U, H, W, oe) {
    this.tag = 1, this.containerInfo = s, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = tt(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = tt(0), this.hiddenUpdates = tt(null), this.identifierPrefix = A, this.onUncaughtError = U, this.onCaughtError = H, this.onRecoverableError = W, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = oe, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function ds(s, f, v, A, U, H, W, oe, be, et, Rt, zt) {
    return s = new el(
      s,
      f,
      v,
      W,
      oe,
      be,
      et,
      zt
    ), f = 1, H === !0 && (f |= 24), H = tr(3, null, null, f), s.current = H, H.stateNode = s, f = ph(), f.refCount++, s.pooledCache = f, f.refCount++, H.memoizedState = {
      element: A,
      isDehydrated: v,
      cache: f
    }, ig(H), s;
  }
  function Bg(s) {
    return s ? (s = fd, s) : fd;
  }
  function Rm(s, f, v, A, U, H) {
    U = Bg(U), A.context === null ? A.context = U : A.pendingContext = U, A = xr(f), A.payload = { element: v }, H = H === void 0 ? null : H, H !== null && (A.callback = H), v = ml(s, A, f), v !== null && (fo(v, s, f), Tf(v, s, f));
  }
  function Ap(s, f) {
    if (s = s.memoizedState, s !== null && s.dehydrated !== null) {
      var v = s.retryLane;
      s.retryLane = v !== 0 && v < f ? v : f;
    }
  }
  function Rv(s, f) {
    Ap(s, f), (s = s.alternate) && Ap(s, f);
  }
  function Dv(s) {
    if (s.tag === 13) {
      var f = er(s, 67108864);
      f !== null && fo(f, s, 67108864), Rv(s, 67108864);
    }
  }
  var ef = !0;
  function u_(s, f, v, A) {
    var U = P.T;
    P.T = null;
    var H = te.p;
    try {
      te.p = 2, vt(s, f, v, A);
    } finally {
      te.p = H, P.T = U;
    }
  }
  function c_(s, f, v, A) {
    var U = P.T;
    P.T = null;
    var H = te.p;
    try {
      te.p = 8, vt(s, f, v, A);
    } finally {
      te.p = H, P.T = U;
    }
  }
  function vt(s, f, v, A) {
    if (ef) {
      var U = wu(A);
      if (U === null)
        Ru(
          s,
          f,
          A,
          Qf,
          v
        ), Dm(s, A);
      else if (eS(
        U,
        s,
        f,
        v,
        A
      ))
        A.stopPropagation();
      else if (Dm(s, A), f & 4 && -1 < Ep.indexOf(s)) {
        for (; U !== null; ) {
          var H = pe(U);
          if (H !== null)
            switch (H.tag) {
              case 3:
                if (H = H.stateNode, H.current.memoizedState.isDehydrated) {
                  var W = jt(H.pendingLanes);
                  if (W !== 0) {
                    var oe = H;
                    for (oe.pendingLanes |= 2, oe.entangledLanes |= 2; W; ) {
                      var be = 1 << 31 - Wt(W);
                      oe.entanglements[1] |= be, W &= ~be;
                    }
                    ho(H), (mi & 6) === 0 && (or = St() + 500, Eg(0));
                  }
                }
                break;
              case 13:
                oe = er(H, 2), oe !== null && fo(oe, H, 2), Kl(), Rv(H, 2);
            }
          if (H = wu(A), H === null && Ru(
            s,
            f,
            A,
            Qf,
            v
          ), H === U) break;
          U = H;
        }
        U !== null && A.stopPropagation();
      } else
        Ru(
          s,
          f,
          A,
          null,
          v
        );
    }
  }
  function wu(s) {
    return s = Vp(s), Bv(s);
  }
  var Qf = null;
  function Bv(s) {
    if (Qf = null, s = $(s), s !== null) {
      var f = d(s);
      if (f === null) s = null;
      else {
        var v = f.tag;
        if (v === 13) {
          if (s = p(f), s !== null) return s;
          s = null;
        } else if (v === 3) {
          if (f.stateNode.current.memoizedState.isDehydrated)
            return f.tag === 3 ? f.stateNode.containerInfo : null;
          s = null;
        } else f !== s && (s = null);
      }
    }
    return Qf = s, null;
  }
  function fy(s) {
    switch (s) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Mt()) {
          case kt:
            return 2;
          case At:
            return 8;
          case ce:
          case se:
            return 32;
          case Xe:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var Nu = !1, go = null, zu = null, Ko = null, Ld = /* @__PURE__ */ new Map(), Lr = /* @__PURE__ */ new Map(), hs = [], Ep = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function Dm(s, f) {
    switch (s) {
      case "focusin":
      case "focusout":
        go = null;
        break;
      case "dragenter":
      case "dragleave":
        zu = null;
        break;
      case "mouseover":
      case "mouseout":
        Ko = null;
        break;
      case "pointerover":
      case "pointerout":
        Ld.delete(f.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Lr.delete(f.pointerId);
    }
  }
  function Bm(s, f, v, A, U, H) {
    return s === null || s.nativeEvent !== H ? (s = {
      blockedOn: f,
      domEventName: v,
      eventSystemFlags: A,
      nativeEvent: H,
      targetContainers: [U]
    }, f !== null && (f = pe(f), f !== null && Dv(f)), s) : (s.eventSystemFlags |= A, f = s.targetContainers, U !== null && f.indexOf(U) === -1 && f.push(U), s);
  }
  function eS(s, f, v, A, U) {
    switch (f) {
      case "focusin":
        return go = Bm(
          go,
          s,
          f,
          v,
          A,
          U
        ), !0;
      case "dragenter":
        return zu = Bm(
          zu,
          s,
          f,
          v,
          A,
          U
        ), !0;
      case "mouseover":
        return Ko = Bm(
          Ko,
          s,
          f,
          v,
          A,
          U
        ), !0;
      case "pointerover":
        var H = U.pointerId;
        return Ld.set(
          H,
          Bm(
            Ld.get(H) || null,
            s,
            f,
            v,
            A,
            U
          )
        ), !0;
      case "gotpointercapture":
        return H = U.pointerId, Lr.set(
          H,
          Bm(
            Lr.get(H) || null,
            s,
            f,
            v,
            A,
            U
          )
        ), !0;
    }
    return !1;
  }
  function o0(s) {
    var f = $(s.target);
    if (f !== null) {
      var v = d(f);
      if (v !== null) {
        if (f = v.tag, f === 13) {
          if (f = p(v), f !== null) {
            s.blockedOn = f, ul(s.priority, function() {
              if (v.tag === 13) {
                var A = wl();
                A = Wn(A);
                var U = er(v, A);
                U !== null && fo(U, v, A), Rv(v, A);
              }
            });
            return;
          }
        } else if (f === 3 && v.stateNode.current.memoizedState.isDehydrated) {
          s.blockedOn = v.tag === 3 ? v.stateNode.containerInfo : null;
          return;
        }
      }
    }
    s.blockedOn = null;
  }
  function Ug(s) {
    if (s.blockedOn !== null) return !1;
    for (var f = s.targetContainers; 0 < f.length; ) {
      var v = wu(s.nativeEvent);
      if (v === null) {
        v = s.nativeEvent;
        var A = new v.constructor(
          v.type,
          v
        );
        Ec = A, v.target.dispatchEvent(A), Ec = null;
      } else
        return f = pe(v), f !== null && Dv(f), s.blockedOn = v, !1;
      f.shift();
    }
    return !0;
  }
  function Og(s, f, v) {
    Ug(s) && v.delete(f);
  }
  function Uv() {
    Nu = !1, go !== null && Ug(go) && (go = null), zu !== null && Ug(zu) && (zu = null), Ko !== null && Ug(Ko) && (Ko = null), Ld.forEach(Og), Lr.forEach(Og);
  }
  function dy(s, f) {
    s.blockedOn === f && (s.blockedOn = null, Nu || (Nu = !0, o.unstable_scheduleCallback(
      o.unstable_NormalPriority,
      Uv
    )));
  }
  var Um = null;
  function u0(s) {
    Um !== s && (Um = s, o.unstable_scheduleCallback(
      o.unstable_NormalPriority,
      function() {
        Um === s && (Um = null);
        for (var f = 0; f < s.length; f += 3) {
          var v = s[f], A = s[f + 1], U = s[f + 2];
          if (typeof A != "function") {
            if (Bv(A || v) === null)
              continue;
            break;
          }
          var H = pe(v);
          H !== null && (s.splice(f, 3), f -= 3, cm(
            H,
            {
              pending: !0,
              data: U,
              method: v.method,
              action: A
            },
            A,
            U
          ));
        }
      }
    ));
  }
  function Gd(s) {
    function f(be) {
      return dy(be, s);
    }
    go !== null && dy(go, s), zu !== null && dy(zu, s), Ko !== null && dy(Ko, s), Ld.forEach(f), Lr.forEach(f);
    for (var v = 0; v < hs.length; v++) {
      var A = hs[v];
      A.blockedOn === s && (A.blockedOn = null);
    }
    for (; 0 < hs.length && (v = hs[0], v.blockedOn === null); )
      o0(v), v.blockedOn === null && hs.shift();
    if (v = (s.ownerDocument || s).$$reactFormReplay, v != null)
      for (A = 0; A < v.length; A += 3) {
        var U = v[A], H = v[A + 1], W = U[cl] || null;
        if (typeof H == "function")
          W || u0(v);
        else if (W) {
          var oe = null;
          if (H && H.hasAttribute("formAction")) {
            if (U = H, W = H[cl] || null)
              oe = W.formAction;
            else if (Bv(U) !== null) continue;
          } else oe = W.action;
          typeof oe == "function" ? v[A + 1] = oe : (v.splice(A, 3), A -= 3), u0(v);
        }
      }
  }
  function hy(s) {
    this._internalRoot = s;
  }
  py.prototype.render = hy.prototype.render = function(s) {
    var f = this._internalRoot;
    if (f === null) throw Error(a(409));
    var v = f.current, A = wl();
    Rm(v, A, s, f, null, null);
  }, py.prototype.unmount = hy.prototype.unmount = function() {
    var s = this._internalRoot;
    if (s !== null) {
      this._internalRoot = null;
      var f = s.containerInfo;
      Rm(s.current, 2, null, s, null, null), Kl(), f[Xl] = null;
    }
  };
  function py(s) {
    this._internalRoot = s;
  }
  py.prototype.unstable_scheduleHydration = function(s) {
    if (s) {
      var f = sa();
      s = { blockedOn: null, target: s, priority: f };
      for (var v = 0; v < hs.length && f !== 0 && f < hs[v].priority; v++) ;
      hs.splice(v, 0, s), v === 0 && o0(s);
    }
  };
  var Om = e.version;
  if (Om !== "19.1.0")
    throw Error(
      a(
        527,
        Om,
        "19.1.0"
      )
    );
  te.findDOMNode = function(s) {
    var f = s._reactInternals;
    if (f === void 0)
      throw typeof s.render == "function" ? Error(a(188)) : (s = Object.keys(s).join(","), Error(a(268, s)));
    return s = _(f), s = s !== null ? E(s) : null, s = s === null ? null : s.stateNode, s;
  };
  var yo = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: P,
    reconcilerVersion: "19.1.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var wg = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!wg.isDisabled && wg.supportsFiber)
      try {
        yt = wg.inject(
          yo
        ), Jt = wg;
      } catch {
      }
  }
  return EA.createRoot = function(s, f) {
    if (!r(s)) throw Error(a(299));
    var v = !1, A = "", U = Of, H = mv, W = ft, oe = null;
    return f != null && (f.unstable_strictMode === !0 && (v = !0), f.identifierPrefix !== void 0 && (A = f.identifierPrefix), f.onUncaughtError !== void 0 && (U = f.onUncaughtError), f.onCaughtError !== void 0 && (H = f.onCaughtError), f.onRecoverableError !== void 0 && (W = f.onRecoverableError), f.unstable_transitionCallbacks !== void 0 && (oe = f.unstable_transitionCallbacks)), f = ds(
      s,
      1,
      !1,
      null,
      null,
      v,
      A,
      U,
      H,
      W,
      oe,
      null
    ), s[Xl] = f.current, ay(s), new hy(f);
  }, EA.hydrateRoot = function(s, f, v) {
    if (!r(s)) throw Error(a(299));
    var A = !1, U = "", H = Of, W = mv, oe = ft, be = null, et = null;
    return v != null && (v.unstable_strictMode === !0 && (A = !0), v.identifierPrefix !== void 0 && (U = v.identifierPrefix), v.onUncaughtError !== void 0 && (H = v.onUncaughtError), v.onCaughtError !== void 0 && (W = v.onCaughtError), v.onRecoverableError !== void 0 && (oe = v.onRecoverableError), v.unstable_transitionCallbacks !== void 0 && (be = v.unstable_transitionCallbacks), v.formState !== void 0 && (et = v.formState)), f = ds(
      s,
      1,
      !0,
      f,
      v ?? null,
      A,
      U,
      H,
      W,
      oe,
      be,
      et
    ), f.context = Bg(null), v = f.current, A = wl(), A = Wn(A), U = xr(A), U.callback = null, ml(v, U, A), v = A, f.current.lanes = v, Ct(f, v), ho(f), s[Xl] = f.current, ay(s), new py(f);
  }, EA.version = "19.1.0", EA;
}
var bA = {};
/**
 * @license React
 * react-dom-client.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oU;
function cI() {
  return oU || (oU = 1, process.env.NODE_ENV !== "production" && function() {
    function o(n, i) {
      for (n = n.memoizedState; n !== null && 0 < i; )
        n = n.next, i--;
      return n;
    }
    function e(n, i, c, g) {
      if (c >= i.length) return g;
      var b = i[c], R = _a(n) ? n.slice() : Da({}, n);
      return R[b] = e(n[b], i, c + 1, g), R;
    }
    function t(n, i, c) {
      if (i.length !== c.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var g = 0; g < c.length - 1; g++)
          if (i[g] !== c[g]) {
            console.warn(
              "copyWithRename() expects paths to be the same except for the deepest key"
            );
            return;
          }
        return a(n, i, c, 0);
      }
    }
    function a(n, i, c, g) {
      var b = i[g], R = _a(n) ? n.slice() : Da({}, n);
      return g + 1 === i.length ? (R[c[g]] = R[b], _a(R) ? R.splice(b, 1) : delete R[b]) : R[b] = a(
        n[b],
        i,
        c,
        g + 1
      ), R;
    }
    function r(n, i, c) {
      var g = i[c], b = _a(n) ? n.slice() : Da({}, n);
      return c + 1 === i.length ? (_a(b) ? b.splice(g, 1) : delete b[g], b) : (b[g] = r(n[g], i, c + 1), b);
    }
    function d() {
      return !1;
    }
    function p() {
      return null;
    }
    function y() {
    }
    function _() {
      console.error(
        "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
      );
    }
    function E() {
      console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      );
    }
    function T() {
    }
    function C(n) {
      var i = [];
      return n.forEach(function(c) {
        i.push(c);
      }), i.sort().join(", ");
    }
    function D(n, i, c, g) {
      return new nh(n, i, c, g);
    }
    function B(n, i) {
      n.context === zh && (Ge(n.current, 2, i, n, null, null), wf());
    }
    function z(n, i) {
      if (So !== null) {
        var c = i.staleFamilies;
        i = i.updatedFamilies, os(), th(
          n.current,
          i,
          c
        ), wf();
      }
    }
    function V(n) {
      So = n;
    }
    function G(n) {
      return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11);
    }
    function N(n) {
      var i = n, c = n;
      if (n.alternate) for (; i.return; ) i = i.return;
      else {
        n = i;
        do
          i = n, (i.flags & 4098) !== 0 && (c = i.return), n = i.return;
        while (n);
      }
      return i.tag === 3 ? c : null;
    }
    function F(n) {
      if (n.tag === 13) {
        var i = n.memoizedState;
        if (i === null && (n = n.alternate, n !== null && (i = n.memoizedState)), i !== null) return i.dehydrated;
      }
      return null;
    }
    function q(n) {
      if (N(n) !== n)
        throw Error("Unable to find node on an unmounted component.");
    }
    function Y(n) {
      var i = n.alternate;
      if (!i) {
        if (i = N(n), i === null)
          throw Error("Unable to find node on an unmounted component.");
        return i !== n ? null : n;
      }
      for (var c = n, g = i; ; ) {
        var b = c.return;
        if (b === null) break;
        var R = b.alternate;
        if (R === null) {
          if (g = b.return, g !== null) {
            c = g;
            continue;
          }
          break;
        }
        if (b.child === R.child) {
          for (R = b.child; R; ) {
            if (R === c) return q(b), n;
            if (R === g) return q(b), i;
            R = R.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (c.return !== g.return) c = b, g = R;
        else {
          for (var X = !1, K = b.child; K; ) {
            if (K === c) {
              X = !0, c = b, g = R;
              break;
            }
            if (K === g) {
              X = !0, g = b, c = R;
              break;
            }
            K = K.sibling;
          }
          if (!X) {
            for (K = R.child; K; ) {
              if (K === c) {
                X = !0, c = R, g = b;
                break;
              }
              if (K === g) {
                X = !0, g = R, c = b;
                break;
              }
              K = K.sibling;
            }
            if (!X)
              throw Error(
                "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
              );
          }
        }
        if (c.alternate !== g)
          throw Error(
            "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
          );
      }
      if (c.tag !== 3)
        throw Error("Unable to find node on an unmounted component.");
      return c.stateNode.current === c ? n : i;
    }
    function ie(n) {
      var i = n.tag;
      if (i === 5 || i === 26 || i === 27 || i === 6) return n;
      for (n = n.child; n !== null; ) {
        if (i = ie(n), i !== null) return i;
        n = n.sibling;
      }
      return null;
    }
    function k(n) {
      return n === null || typeof n != "object" ? null : (n = a0 && n[a0] || n["@@iterator"], typeof n == "function" ? n : null);
    }
    function le(n) {
      if (n == null) return null;
      if (typeof n == "function")
        return n.$$typeof === iy ? null : n.displayName || n.name || null;
      if (typeof n == "string") return n;
      switch (n) {
        case Sa:
          return "Fragment";
        case Ud:
          return "Profiler";
        case mp:
          return "StrictMode";
        case wd:
          return "Suspense";
        case Uh:
          return "SuspenseList";
        case gp:
          return "Activity";
      }
      if (typeof n == "object")
        switch (typeof n.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), n.$$typeof) {
          case Bh:
            return "Portal";
          case Ru:
            return (n.displayName || "Context") + ".Provider";
          case xg:
            return (n._context.displayName || "Context") + ".Consumer";
          case Od:
            var i = n.render;
            return n = n.displayName, n || (n = i.displayName || i.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n;
          case vp:
            return i = n.displayName || null, i !== null ? i : le(n.type) || "Memo";
          case Du:
            i = n._payload, n = n._init;
            try {
              return le(n(i));
            } catch {
            }
        }
      return null;
    }
    function ne(n) {
      return typeof n.tag == "number" ? Q(n) : typeof n.name == "string" ? n.name : null;
    }
    function Q(n) {
      var i = n.type;
      switch (n.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (i._context.displayName || "Context") + ".Consumer";
        case 10:
          return (i.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return n = i.render, n = n.displayName || n.name || "", i.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return i;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return le(i);
        case 8:
          return i === mp ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if (typeof i == "function")
            return i.displayName || i.name || null;
          if (typeof i == "string") return i;
          break;
        case 29:
          if (i = n._debugInfo, i != null) {
            for (var c = i.length - 1; 0 <= c; c--)
              if (typeof i[c].name == "string") return i[c].name;
          }
          if (n.return !== null)
            return Q(n.return);
      }
      return null;
    }
    function j(n) {
      return { current: n };
    }
    function re(n, i) {
      0 > Pf ? console.error("Unexpected pop.") : (i !== bv[Pf] && console.error("Unexpected Fiber popped."), n.current = Ev[Pf], Ev[Pf] = null, bv[Pf] = null, Pf--);
    }
    function _e(n, i, c) {
      Pf++, Ev[Pf] = n.current, bv[Pf] = c, n.current = i;
    }
    function me(n) {
      return n === null && console.error(
        "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
      ), n;
    }
    function Ae(n, i) {
      _e(dc, i, n), _e(Oh, n, n), _e(cr, null, n);
      var c = i.nodeType;
      switch (c) {
        case 9:
        case 11:
          c = c === 9 ? "#document" : "#fragment", i = (i = i.documentElement) && (i = i.namespaceURI) ? ba(i) : Dy;
          break;
        default:
          if (c = i.tagName, i = i.namespaceURI)
            i = ba(i), i = _l(
              i,
              c
            );
          else
            switch (c) {
              case "svg":
                i = G_;
                break;
              case "math":
                i = YE;
                break;
              default:
                i = Dy;
            }
      }
      c = c.toLowerCase(), c = Ei(null, c), c = {
        context: i,
        ancestorInfo: c
      }, re(cr, n), _e(cr, c, n);
    }
    function He(n) {
      re(cr, n), re(Oh, n), re(dc, n);
    }
    function P() {
      return me(cr.current);
    }
    function te(n) {
      n.memoizedState !== null && _e(wh, n, n);
      var i = me(cr.current), c = n.type, g = _l(i.context, c);
      c = Ei(i.ancestorInfo, c), g = { context: g, ancestorInfo: c }, i !== g && (_e(Oh, n, n), _e(cr, g, n));
    }
    function ae(n) {
      Oh.current === n && (re(cr, n), re(Oh, n)), wh.current === n && (re(wh, n), lA._currentValue = _S);
    }
    function Se(n) {
      return typeof Symbol == "function" && Symbol.toStringTag && n[Symbol.toStringTag] || n.constructor.name || "Object";
    }
    function ue(n) {
      try {
        return we(n), !1;
      } catch {
        return !0;
      }
    }
    function we(n) {
      return "" + n;
    }
    function De(n, i) {
      if (ue(n))
        return console.error(
          "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
          i,
          Se(n)
        ), we(n);
    }
    function We(n, i) {
      if (ue(n))
        return console.error(
          "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
          i,
          Se(n)
        ), we(n);
    }
    function Me(n) {
      if (ue(n))
        return console.error(
          "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
          Se(n)
        ), we(n);
    }
    function Ze(n) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") return !1;
      var i = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (i.isDisabled) return !0;
      if (!i.supportsFiber)
        return console.error(
          "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
        ), !0;
      try {
        yp = i.inject(n), zr = i;
      } catch (c) {
        console.error("React instrumentation encountered an error: %s.", c);
      }
      return !!i.checkDCE;
    }
    function ct(n) {
      if (typeof W0 == "function" && Xf(n), zr && typeof zr.setStrictMode == "function")
        try {
          zr.setStrictMode(yp, n);
        } catch (i) {
          Bu || (Bu = !0, console.error(
            "React instrumentation encountered an error: %s",
            i
          ));
        }
    }
    function Vt(n) {
      vn = n;
    }
    function Zt() {
      vn !== null && typeof vn.markCommitStopped == "function" && vn.markCommitStopped();
    }
    function Bn(n) {
      vn !== null && typeof vn.markComponentRenderStarted == "function" && vn.markComponentRenderStarted(n);
    }
    function rn() {
      vn !== null && typeof vn.markComponentRenderStopped == "function" && vn.markComponentRenderStopped();
    }
    function dn(n) {
      vn !== null && typeof vn.markRenderStarted == "function" && vn.markRenderStarted(n);
    }
    function Zn() {
      vn !== null && typeof vn.markRenderStopped == "function" && vn.markRenderStopped();
    }
    function Rn(n, i) {
      vn !== null && typeof vn.markStateUpdateScheduled == "function" && vn.markStateUpdateScheduled(n, i);
    }
    function Te(n) {
      return n >>>= 0, n === 0 ? 32 : 31 - (s0(n) / Nh | 0) | 0;
    }
    function Ha(n) {
      if (n & 1) return "SyncHydrationLane";
      if (n & 2) return "Sync";
      if (n & 4) return "InputContinuousHydration";
      if (n & 8) return "InputContinuous";
      if (n & 16) return "DefaultHydration";
      if (n & 32) return "Default";
      if (n & 128) return "TransitionHydration";
      if (n & 4194048) return "Transition";
      if (n & 62914560) return "Retry";
      if (n & 67108864) return "SelectiveHydration";
      if (n & 134217728) return "IdleHydration";
      if (n & 268435456) return "Idle";
      if (n & 536870912) return "Offscreen";
      if (n & 1073741824) return "Deferred";
    }
    function Tt(n) {
      var i = n & 42;
      if (i !== 0) return i;
      switch (n & -n) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return n & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return n & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), n;
      }
    }
    function St(n, i, c) {
      var g = n.pendingLanes;
      if (g === 0) return 0;
      var b = 0, R = n.suspendedLanes, X = n.pingedLanes;
      n = n.warmLanes;
      var K = g & 134217727;
      return K !== 0 ? (g = K & ~R, g !== 0 ? b = Tt(g) : (X &= K, X !== 0 ? b = Tt(X) : c || (c = K & ~n, c !== 0 && (b = Tt(c))))) : (K = g & ~R, K !== 0 ? b = Tt(K) : X !== 0 ? b = Tt(X) : c || (c = g & ~n, c !== 0 && (b = Tt(c)))), b === 0 ? 0 : i !== 0 && i !== b && (i & R) === 0 && (R = b & -b, c = i & -i, R >= c || R === 32 && (c & 4194048) !== 0) ? i : b;
    }
    function Mt(n, i) {
      return (n.pendingLanes & ~(n.suspendedLanes & ~n.pingedLanes) & i) === 0;
    }
    function kt(n, i) {
      switch (n) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return i + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return i + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error(
            "Should have found matching lanes. This is a bug in React."
          ), -1;
      }
    }
    function At() {
      var n = sy;
      return sy <<= 1, (sy & 4194048) === 0 && (sy = 256), n;
    }
    function ce() {
      var n = ry;
      return ry <<= 1, (ry & 62914560) === 0 && (ry = 4194304), n;
    }
    function se(n) {
      for (var i = [], c = 0; 31 > c; c++) i.push(n);
      return i;
    }
    function Xe(n, i) {
      n.pendingLanes |= i, i !== 268435456 && (n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0);
    }
    function dt(n, i, c, g, b, R) {
      var X = n.pendingLanes;
      n.pendingLanes = c, n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0, n.expiredLanes &= c, n.entangledLanes &= c, n.errorRecoveryDisabledLanes &= c, n.shellSuspendCounter = 0;
      var K = n.entanglements, de = n.expirationTimes, ge = n.hiddenUpdates;
      for (c = X & ~c; 0 < c; ) {
        var ut = 31 - po(c), xt = 1 << ut;
        K[ut] = 0, de[ut] = -1;
        var it = ge[ut];
        if (it !== null)
          for (ge[ut] = null, ut = 0; ut < it.length; ut++) {
            var Dt = it[ut];
            Dt !== null && (Dt.lane &= -536870913);
          }
        c &= ~xt;
      }
      g !== 0 && Et(n, g, 0), R !== 0 && b === 0 && n.tag !== 0 && (n.suspendedLanes |= R & ~(X & ~i));
    }
    function Et(n, i, c) {
      n.pendingLanes |= i, n.suspendedLanes &= ~i;
      var g = 31 - po(i);
      n.entangledLanes |= i, n.entanglements[g] = n.entanglements[g] | 1073741824 | c & 4194090;
    }
    function yt(n, i) {
      var c = n.entangledLanes |= i;
      for (n = n.entanglements; c; ) {
        var g = 31 - po(c), b = 1 << g;
        b & i | n[g] & i && (n[g] |= i), c &= ~b;
      }
    }
    function Jt(n) {
      switch (n) {
        case 2:
          n = 1;
          break;
        case 8:
          n = 4;
          break;
        case 32:
          n = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          n = 128;
          break;
        case 268435456:
          n = 134217728;
          break;
        default:
          n = 0;
      }
      return n;
    }
    function Xt(n, i, c) {
      if (kl)
        for (n = n.pendingUpdatersLaneMap; 0 < c; ) {
          var g = 31 - po(c), b = 1 << g;
          n[g].add(i), c &= ~b;
        }
    }
    function Wt(n, i) {
      if (kl)
        for (var c = n.pendingUpdatersLaneMap, g = n.memoizedUpdaters; 0 < i; ) {
          var b = 31 - po(i);
          n = 1 << b, b = c[b], 0 < b.size && (b.forEach(function(R) {
            var X = R.alternate;
            X !== null && g.has(X) || g.add(R);
          }), b.clear()), i &= ~n;
        }
    }
    function Vn(n) {
      return n &= -n, mo < n ? Yf < n ? (n & 134217727) !== 0 ? Sp : oy : Yf : mo;
    }
    function Pt() {
      var n = Kn.p;
      return n !== 0 ? n : (n = window.event, n === void 0 ? Sp : Em(n.type));
    }
    function pn(n, i) {
      var c = Kn.p;
      try {
        return Kn.p = n, i();
      } finally {
        Kn.p = c;
      }
    }
    function gn(n) {
      delete n[ws], delete n[Hr], delete n[uy], delete n[$0], delete n[Mv];
    }
    function nn(n) {
      var i = n[ws];
      if (i) return i;
      for (var c = n.parentNode; c; ) {
        if (i = c[oa] || c[ws]) {
          if (c = i.alternate, i.child !== null || c !== null && c.child !== null)
            for (n = Qc(n); n !== null; ) {
              if (c = n[ws])
                return c;
              n = Qc(n);
            }
          return i;
        }
        n = c, c = n.parentNode;
      }
      return null;
    }
    function jt(n) {
      if (n = n[ws] || n[oa]) {
        var i = n.tag;
        if (i === 5 || i === 6 || i === 13 || i === 26 || i === 27 || i === 3)
          return n;
      }
      return null;
    }
    function Ue(n) {
      var i = n.tag;
      if (i === 5 || i === 26 || i === 27 || i === 6)
        return n.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function ot(n) {
      var i = n[xv];
      return i || (i = n[xv] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), i;
    }
    function Ht(n) {
      n[Tv] = !0;
    }
    function xe(n, i) {
      Je(n, i), Je(n + "Capture", i);
    }
    function Je(n, i) {
      kc[n] && console.error(
        "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
        n
      ), kc[n] = i;
      var c = n.toLowerCase();
      for (qf[c] = n, n === "onDoubleClick" && (qf.ondblclick = n), n = 0; n < i.length; n++)
        Tm.add(i[n]);
    }
    function tt(n, i) {
      cy[i.type] || i.onChange || i.onInput || i.readOnly || i.disabled || i.value == null || console.error(
        n === "select" ? "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`." : "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
      ), i.onChange || i.readOnly || i.disabled || i.checked == null || console.error(
        "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
      );
    }
    function Ct(n) {
      return Kc.call(_p, n) ? !0 : Kc.call(Wc, n) ? !1 : Ou.test(n) ? _p[n] = !0 : (Wc[n] = !0, console.error("Invalid attribute name: `%s`", n), !1);
    }
    function $t(n, i, c) {
      if (Ct(i)) {
        if (!n.hasAttribute(i)) {
          switch (typeof c) {
            case "symbol":
            case "object":
              return c;
            case "function":
              return c;
            case "boolean":
              if (c === !1) return c;
          }
          return c === void 0 ? void 0 : null;
        }
        return n = n.getAttribute(i), n === "" && c === !0 ? !0 : (De(c, i), n === "" + c ? c : n);
      }
    }
    function tn(n, i, c) {
      if (Ct(i))
        if (c === null) n.removeAttribute(i);
        else {
          switch (typeof c) {
            case "undefined":
            case "function":
            case "symbol":
              n.removeAttribute(i);
              return;
            case "boolean":
              var g = i.toLowerCase().slice(0, 5);
              if (g !== "data-" && g !== "aria-") {
                n.removeAttribute(i);
                return;
              }
          }
          De(c, i), n.setAttribute(i, "" + c);
        }
    }
    function Mn(n, i, c) {
      if (c === null) n.removeAttribute(i);
      else {
        switch (typeof c) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            n.removeAttribute(i);
            return;
        }
        De(c, i), n.setAttribute(i, "" + c);
      }
    }
    function Wn(n, i, c, g) {
      if (g === null) n.removeAttribute(c);
      else {
        switch (typeof g) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            n.removeAttribute(c);
            return;
        }
        De(g, c), n.setAttributeNS(i, c, "" + g);
      }
    }
    function Xa() {
    }
    function sa() {
      if (Zf === 0) {
        Ns = console.log, hc = console.info, $c = console.warn, vo = console.error, fs = console.group, js = console.groupCollapsed, Cv = console.groupEnd;
        var n = {
          configurable: !0,
          enumerable: !0,
          value: Xa,
          writable: !0
        };
        Object.defineProperties(console, {
          info: n,
          log: n,
          warn: n,
          error: n,
          group: n,
          groupCollapsed: n,
          groupEnd: n
        });
      }
      Zf++;
    }
    function ul() {
      if (Zf--, Zf === 0) {
        var n = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: Da({}, n, { value: Ns }),
          info: Da({}, n, { value: hc }),
          warn: Da({}, n, { value: $c }),
          error: Da({}, n, { value: vo }),
          group: Da({}, n, { value: fs }),
          groupCollapsed: Da({}, n, { value: js }),
          groupEnd: Da({}, n, { value: Cv })
        });
      }
      0 > Zf && console.error(
        "disabledDepth fell below zero. This is a bug in React. Please file an issue."
      );
    }
    function xa(n) {
      if (r0 === void 0)
        try {
          throw Error();
        } catch (c) {
          var i = c.stack.trim().match(/\n( *(at )?)/);
          r0 = i && i[1] || "", Rg = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + r0 + n + Rg;
    }
    function Ui(n, i) {
      if (!n || Cm) return "";
      var c = Dg.get(n);
      if (c !== void 0) return c;
      Cm = !0, c = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
      var g = null;
      g = mt.H, mt.H = null, sa();
      try {
        var b = {
          DetermineComponentFrameRoot: function() {
            try {
              if (i) {
                var it = function() {
                  throw Error();
                };
                if (Object.defineProperty(it.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(it, []);
                  } catch (wn) {
                    var Dt = wn;
                  }
                  Reflect.construct(n, [], it);
                } else {
                  try {
                    it.call();
                  } catch (wn) {
                    Dt = wn;
                  }
                  n.call(it.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (wn) {
                  Dt = wn;
                }
                (it = n()) && typeof it.catch == "function" && it.catch(function() {
                });
              }
            } catch (wn) {
              if (wn && Dt && typeof wn.stack == "string")
                return [wn.stack, Dt.stack];
            }
            return [null, null];
          }
        };
        b.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var R = Object.getOwnPropertyDescriptor(
          b.DetermineComponentFrameRoot,
          "name"
        );
        R && R.configurable && Object.defineProperty(
          b.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var X = b.DetermineComponentFrameRoot(), K = X[0], de = X[1];
        if (K && de) {
          var ge = K.split(`
`), ut = de.split(`
`);
          for (X = R = 0; R < ge.length && !ge[R].includes(
            "DetermineComponentFrameRoot"
          ); )
            R++;
          for (; X < ut.length && !ut[X].includes(
            "DetermineComponentFrameRoot"
          ); )
            X++;
          if (R === ge.length || X === ut.length)
            for (R = ge.length - 1, X = ut.length - 1; 1 <= R && 0 <= X && ge[R] !== ut[X]; )
              X--;
          for (; 1 <= R && 0 <= X; R--, X--)
            if (ge[R] !== ut[X]) {
              if (R !== 1 || X !== 1)
                do
                  if (R--, X--, 0 > X || ge[R] !== ut[X]) {
                    var xt = `
` + ge[R].replace(
                      " at new ",
                      " at "
                    );
                    return n.displayName && xt.includes("<anonymous>") && (xt = xt.replace("<anonymous>", n.displayName)), typeof n == "function" && Dg.set(n, xt), xt;
                  }
                while (1 <= R && 0 <= X);
              break;
            }
        }
      } finally {
        Cm = !1, mt.H = g, ul(), Error.prepareStackTrace = c;
      }
      return ge = (ge = n ? n.displayName || n.name : "") ? xa(ge) : "", typeof n == "function" && Dg.set(n, ge), ge;
    }
    function cl(n) {
      var i = Error.prepareStackTrace;
      if (Error.prepareStackTrace = void 0, n = n.stack, Error.prepareStackTrace = i, n.startsWith(`Error: react-stack-top-frame
`) && (n = n.slice(29)), i = n.indexOf(`
`), i !== -1 && (n = n.slice(i + 1)), i = n.indexOf("react-stack-bottom-frame"), i !== -1 && (i = n.lastIndexOf(
        `
`,
        i
      )), i !== -1)
        n = n.slice(0, i);
      else return "";
      return n;
    }
    function Xl(n) {
      switch (n.tag) {
        case 26:
        case 27:
        case 5:
          return xa(n.type);
        case 16:
          return xa("Lazy");
        case 13:
          return xa("Suspense");
        case 19:
          return xa("SuspenseList");
        case 0:
        case 15:
          return Ui(n.type, !1);
        case 11:
          return Ui(n.type.render, !1);
        case 1:
          return Ui(n.type, !0);
        case 31:
          return xa("Activity");
        default:
          return "";
      }
    }
    function Ws(n) {
      try {
        var i = "";
        do {
          i += Xl(n);
          var c = n._debugInfo;
          if (c)
            for (var g = c.length - 1; 0 <= g; g--) {
              var b = c[g];
              if (typeof b.name == "string") {
                var R = i, X = b.env, K = xa(
                  b.name + (X ? " [" + X + "]" : "")
                );
                i = R + K;
              }
            }
          n = n.return;
        } while (n);
        return i;
      } catch (de) {
        return `
Error generating stack: ` + de.message + `
` + de.stack;
      }
    }
    function lu(n) {
      return (n = n ? n.displayName || n.name : "") ? xa(n) : "";
    }
    function zl() {
      if (Js === null) return null;
      var n = Js._debugOwner;
      return n != null ? ne(n) : null;
    }
    function Jn() {
      if (Js === null) return "";
      var n = Js;
      try {
        var i = "";
        switch (n.tag === 6 && (n = n.return), n.tag) {
          case 26:
          case 27:
          case 5:
            i += xa(n.type);
            break;
          case 13:
            i += xa("Suspense");
            break;
          case 19:
            i += xa("SuspenseList");
            break;
          case 31:
            i += xa("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            n._debugOwner || i !== "" || (i += lu(
              n.type
            ));
            break;
          case 11:
            n._debugOwner || i !== "" || (i += lu(
              n.type.render
            ));
        }
        for (; n; )
          if (typeof n.tag == "number") {
            var c = n;
            n = c._debugOwner;
            var g = c._debugStack;
            n && g && (typeof g != "string" && (c._debugStack = g = cl(g)), g !== "" && (i += `
` + g));
          } else if (n.debugStack != null) {
            var b = n.debugStack;
            (n = n.owner) && b && (i += `
` + cl(b));
          } else break;
        var R = i;
      } catch (X) {
        R = `
Error generating stack: ` + X.message + `
` + X.stack;
      }
      return R;
    }
    function un(n, i, c, g, b, R, X) {
      var K = Js;
      li(n);
      try {
        return n !== null && n._debugTask ? n._debugTask.run(
          i.bind(null, c, g, b, R, X)
        ) : i(c, g, b, R, X);
      } finally {
        li(K);
      }
      throw Error(
        "runWithFiberInDEV should never be called in production. This is a bug in React."
      );
    }
    function li(n) {
      mt.getCurrentStack = n === null ? null : Jn, Gn = !1, Js = n;
    }
    function $(n) {
      switch (typeof n) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return n;
        case "object":
          return Me(n), n;
        default:
          return "";
      }
    }
    function pe(n) {
      var i = n.type;
      return (n = n.nodeName) && n.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
    }
    function Ne(n) {
      var i = pe(n) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(
        n.constructor.prototype,
        i
      );
      Me(n[i]);
      var g = "" + n[i];
      if (!n.hasOwnProperty(i) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
        var b = c.get, R = c.set;
        return Object.defineProperty(n, i, {
          configurable: !0,
          get: function() {
            return b.call(this);
          },
          set: function(X) {
            Me(X), g = "" + X, R.call(this, X);
          }
        }), Object.defineProperty(n, i, {
          enumerable: c.enumerable
        }), {
          getValue: function() {
            return g;
          },
          setValue: function(X) {
            Me(X), g = "" + X;
          },
          stopTracking: function() {
            n._valueTracker = null, delete n[i];
          }
        };
      }
    }
    function $e(n) {
      n._valueTracker || (n._valueTracker = Ne(n));
    }
    function nt(n) {
      if (!n) return !1;
      var i = n._valueTracker;
      if (!i) return !0;
      var c = i.getValue(), g = "";
      return n && (g = pe(n) ? n.checked ? "true" : "false" : n.value), n = g, n !== c ? (i.setValue(n), !0) : !1;
    }
    function pt(n) {
      if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u") return null;
      try {
        return n.activeElement || n.body;
      } catch {
        return n.body;
      }
    }
    function Ft(n) {
      return n.replace(
        el,
        function(i) {
          return "\\" + i.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function Gt(n, i) {
      i.checked === void 0 || i.defaultChecked === void 0 || Bg || (console.error(
        "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        zl() || "A component",
        i.type
      ), Bg = !0), i.value === void 0 || i.defaultValue === void 0 || ds || (console.error(
        "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
        zl() || "A component",
        i.type
      ), ds = !0);
    }
    function ee(n, i, c, g, b, R, X, K) {
      n.name = "", X != null && typeof X != "function" && typeof X != "symbol" && typeof X != "boolean" ? (De(X, "type"), n.type = X) : n.removeAttribute("type"), i != null ? X === "number" ? (i === 0 && n.value === "" || n.value != i) && (n.value = "" + $(i)) : n.value !== "" + $(i) && (n.value = "" + $(i)) : X !== "submit" && X !== "reset" || n.removeAttribute("value"), i != null ? Ee(n, X, $(i)) : c != null ? Ee(n, X, $(c)) : g != null && n.removeAttribute("value"), b == null && R != null && (n.defaultChecked = !!R), b != null && (n.checked = b && typeof b != "function" && typeof b != "symbol"), K != null && typeof K != "function" && typeof K != "symbol" && typeof K != "boolean" ? (De(K, "name"), n.name = "" + $(K)) : n.removeAttribute("name");
    }
    function ye(n, i, c, g, b, R, X, K) {
      if (R != null && typeof R != "function" && typeof R != "symbol" && typeof R != "boolean" && (De(R, "type"), n.type = R), i != null || c != null) {
        if (!(R !== "submit" && R !== "reset" || i != null))
          return;
        c = c != null ? "" + $(c) : "", i = i != null ? "" + $(i) : c, K || i === n.value || (n.value = i), n.defaultValue = i;
      }
      g = g ?? b, g = typeof g != "function" && typeof g != "symbol" && !!g, n.checked = K ? n.checked : !!g, n.defaultChecked = !!g, X != null && typeof X != "function" && typeof X != "symbol" && typeof X != "boolean" && (De(X, "name"), n.name = X);
    }
    function Ee(n, i, c) {
      i === "number" && pt(n.ownerDocument) === n || n.defaultValue === "" + c || (n.defaultValue = "" + c);
    }
    function Re(n, i) {
      i.value == null && (typeof i.children == "object" && i.children !== null ? _v.Children.forEach(i.children, function(c) {
        c == null || typeof c == "string" || typeof c == "number" || typeof c == "bigint" || Ap || (Ap = !0, console.error(
          "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
        ));
      }) : i.dangerouslySetInnerHTML == null || Rv || (Rv = !0, console.error(
        "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
      ))), i.selected == null || Rm || (console.error(
        "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
      ), Rm = !0);
    }
    function Ie() {
      var n = zl();
      return n ? `

Check the render method of \`` + n + "`." : "";
    }
    function je(n, i, c, g) {
      if (n = n.options, i) {
        i = {};
        for (var b = 0; b < c.length; b++)
          i["$" + c[b]] = !0;
        for (c = 0; c < n.length; c++)
          b = i.hasOwnProperty("$" + n[c].value), n[c].selected !== b && (n[c].selected = b), b && g && (n[c].defaultSelected = !0);
      } else {
        for (c = "" + $(c), i = null, b = 0; b < n.length; b++) {
          if (n[b].value === c) {
            n[b].selected = !0, g && (n[b].defaultSelected = !0);
            return;
          }
          i !== null || n[b].disabled || (i = n[b]);
        }
        i !== null && (i.selected = !0);
      }
    }
    function _t(n, i) {
      for (n = 0; n < ef.length; n++) {
        var c = ef[n];
        if (i[c] != null) {
          var g = _a(i[c]);
          i.multiple && !g ? console.error(
            "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
            c,
            Ie()
          ) : !i.multiple && g && console.error(
            "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
            c,
            Ie()
          );
        }
      }
      i.value === void 0 || i.defaultValue === void 0 || Dv || (console.error(
        "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
      ), Dv = !0);
    }
    function Ut(n, i) {
      i.value === void 0 || i.defaultValue === void 0 || u_ || (console.error(
        "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
        zl() || "A component"
      ), u_ = !0), i.children != null && i.value == null && console.error(
        "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
      );
    }
    function It(n, i, c) {
      if (i != null && (i = "" + $(i), i !== n.value && (n.value = i), c == null)) {
        n.defaultValue !== i && (n.defaultValue = i);
        return;
      }
      n.defaultValue = c != null ? "" + $(c) : "";
    }
    function on(n, i, c, g) {
      if (i == null) {
        if (g != null) {
          if (c != null)
            throw Error(
              "If you supply `defaultValue` on a <textarea>, do not pass children."
            );
          if (_a(g)) {
            if (1 < g.length)
              throw Error("<textarea> can only have at most one child.");
            g = g[0];
          }
          c = g;
        }
        c == null && (c = ""), i = c;
      }
      c = $(i), n.defaultValue = c, g = n.textContent, g === c && g !== "" && g !== null && (n.value = g);
    }
    function sn(n, i) {
      return n.serverProps === void 0 && n.serverTail.length === 0 && n.children.length === 1 && 3 < n.distanceFromLeaf && n.distanceFromLeaf > 15 - i ? sn(n.children[0], i) : n;
    }
    function Qt(n) {
      return "  " + "  ".repeat(n);
    }
    function bn(n) {
      return "+ " + "  ".repeat(n);
    }
    function En(n) {
      return "- " + "  ".repeat(n);
    }
    function ca(n) {
      switch (n.tag) {
        case 26:
        case 27:
        case 5:
          return n.type;
        case 16:
          return "Lazy";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return n = n.type, n.displayName || n.name || null;
        case 11:
          return n = n.type.render, n.displayName || n.name || null;
        case 1:
          return n = n.type, n.displayName || n.name || null;
        default:
          return null;
      }
    }
    function yn(n, i) {
      return c_.test(n) ? (n = JSON.stringify(n), n.length > i - 2 ? 8 > i ? '{"..."}' : "{" + n.slice(0, i - 7) + '..."}' : "{" + n + "}") : n.length > i ? 5 > i ? '{"..."}' : n.slice(0, i - 3) + "..." : n;
    }
    function zn(n, i, c) {
      var g = 120 - 2 * c;
      if (i === null)
        return bn(c) + yn(n, g) + `
`;
      if (typeof i == "string") {
        for (var b = 0; b < i.length && b < n.length && i.charCodeAt(b) === n.charCodeAt(b); b++) ;
        return b > g - 8 && 10 < b && (n = "..." + n.slice(b - 8), i = "..." + i.slice(b - 8)), bn(c) + yn(n, g) + `
` + En(c) + yn(i, g) + `
`;
      }
      return Qt(c) + yn(n, g) + `
`;
    }
    function xn(n) {
      return Object.prototype.toString.call(n).replace(/^\[object (.*)\]$/, function(i, c) {
        return c;
      });
    }
    function si(n, i) {
      switch (typeof n) {
        case "string":
          return n = JSON.stringify(n), n.length > i ? 5 > i ? '"..."' : n.slice(0, i - 4) + '..."' : n;
        case "object":
          if (n === null) return "null";
          if (_a(n)) return "[...]";
          if (n.$$typeof === fc)
            return (i = le(n.type)) ? "<" + i + ">" : "<...>";
          var c = xn(n);
          if (c === "Object") {
            c = "", i -= 2;
            for (var g in n)
              if (n.hasOwnProperty(g)) {
                var b = JSON.stringify(g);
                if (b !== '"' + g + '"' && (g = b), i -= g.length - 2, b = si(
                  n[g],
                  15 > i ? i : 15
                ), i -= b.length, 0 > i) {
                  c += c === "" ? "..." : ", ...";
                  break;
                }
                c += (c === "" ? "" : ",") + g + ":" + b;
              }
            return "{" + c + "}";
          }
          return c;
        case "function":
          return (i = n.displayName || n.name) ? "function " + i : "function";
        default:
          return String(n);
      }
    }
    function jn(n, i) {
      return typeof n != "string" || c_.test(n) ? "{" + si(n, i - 2) + "}" : n.length > i - 2 ? 5 > i ? '"..."' : '"' + n.slice(0, i - 5) + '..."' : '"' + n + '"';
    }
    function ta(n, i, c) {
      var g = 120 - c.length - n.length, b = [], R;
      for (R in i)
        if (i.hasOwnProperty(R) && R !== "children") {
          var X = jn(
            i[R],
            120 - c.length - R.length - 1
          );
          g -= R.length + X.length + 2, b.push(R + "=" + X);
        }
      return b.length === 0 ? c + "<" + n + `>
` : 0 < g ? c + "<" + n + " " + b.join(" ") + `>
` : c + "<" + n + `
` + c + "  " + b.join(`
` + c + "  ") + `
` + c + `>
`;
    }
    function Li(n, i, c) {
      var g = "", b = Da({}, i), R;
      for (R in n)
        if (n.hasOwnProperty(R)) {
          delete b[R];
          var X = 120 - 2 * c - R.length - 2, K = si(n[R], X);
          i.hasOwnProperty(R) ? (X = si(i[R], X), g += bn(c) + R + ": " + K + `
`, g += En(c) + R + ": " + X + `
`) : g += bn(c) + R + ": " + K + `
`;
        }
      for (var de in b)
        b.hasOwnProperty(de) && (n = si(
          b[de],
          120 - 2 * c - de.length - 2
        ), g += En(c) + de + ": " + n + `
`);
      return g;
    }
    function Qn(n, i, c, g) {
      var b = "", R = /* @__PURE__ */ new Map();
      for (ge in c)
        c.hasOwnProperty(ge) && R.set(
          ge.toLowerCase(),
          ge
        );
      if (R.size === 1 && R.has("children"))
        b += ta(
          n,
          i,
          Qt(g)
        );
      else {
        for (var X in i)
          if (i.hasOwnProperty(X) && X !== "children") {
            var K = 120 - 2 * (g + 1) - X.length - 1, de = R.get(X.toLowerCase());
            if (de !== void 0) {
              R.delete(X.toLowerCase());
              var ge = i[X];
              de = c[de];
              var ut = jn(
                ge,
                K
              );
              K = jn(
                de,
                K
              ), typeof ge == "object" && ge !== null && typeof de == "object" && de !== null && xn(ge) === "Object" && xn(de) === "Object" && (2 < Object.keys(ge).length || 2 < Object.keys(de).length || -1 < ut.indexOf("...") || -1 < K.indexOf("...")) ? b += Qt(g + 1) + X + `={{
` + Li(
                ge,
                de,
                g + 2
              ) + Qt(g + 1) + `}}
` : (b += bn(g + 1) + X + "=" + ut + `
`, b += En(g + 1) + X + "=" + K + `
`);
            } else
              b += Qt(g + 1) + X + "=" + jn(i[X], K) + `
`;
          }
        R.forEach(function(xt) {
          if (xt !== "children") {
            var it = 120 - 2 * (g + 1) - xt.length - 1;
            b += En(g + 1) + xt + "=" + jn(c[xt], it) + `
`;
          }
        }), b = b === "" ? Qt(g) + "<" + n + `>
` : Qt(g) + "<" + n + `
` + b + Qt(g) + `>
`;
      }
      return n = c.children, i = i.children, typeof n == "string" || typeof n == "number" || typeof n == "bigint" ? (R = "", (typeof i == "string" || typeof i == "number" || typeof i == "bigint") && (R = "" + i), b += zn(R, "" + n, g + 1)) : (typeof i == "string" || typeof i == "number" || typeof i == "bigint") && (b = n == null ? b + zn("" + i, null, g + 1) : b + zn("" + i, void 0, g + 1)), b;
    }
    function Ta(n, i) {
      var c = ca(n);
      if (c === null) {
        for (c = "", n = n.child; n; )
          c += Ta(n, i), n = n.sibling;
        return c;
      }
      return Qt(i) + "<" + c + `>
`;
    }
    function da(n, i) {
      var c = sn(n, i);
      if (c !== n && (n.children.length !== 1 || n.children[0] !== c))
        return Qt(i) + `...
` + da(c, i + 1);
      c = "";
      var g = n.fiber._debugInfo;
      if (g)
        for (var b = 0; b < g.length; b++) {
          var R = g[b].name;
          typeof R == "string" && (c += Qt(i) + "<" + R + `>
`, i++);
        }
      if (g = "", b = n.fiber.pendingProps, n.fiber.tag === 6)
        g = zn(b, n.serverProps, i), i++;
      else if (R = ca(n.fiber), R !== null)
        if (n.serverProps === void 0) {
          g = i;
          var X = 120 - 2 * g - R.length - 2, K = "";
          for (ge in b)
            if (b.hasOwnProperty(ge) && ge !== "children") {
              var de = jn(b[ge], 15);
              if (X -= ge.length + de.length + 2, 0 > X) {
                K += " ...";
                break;
              }
              K += " " + ge + "=" + de;
            }
          g = Qt(g) + "<" + R + K + `>
`, i++;
        } else
          n.serverProps === null ? (g = ta(
            R,
            b,
            bn(i)
          ), i++) : typeof n.serverProps == "string" ? console.error(
            "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
          ) : (g = Qn(
            R,
            b,
            n.serverProps,
            i
          ), i++);
      var ge = "";
      for (b = n.fiber.child, R = 0; b && R < n.children.length; )
        X = n.children[R], X.fiber === b ? (ge += da(X, i), R++) : ge += Ta(b, i), b = b.sibling;
      for (b && 0 < n.children.length && (ge += Qt(i) + `...
`), b = n.serverTail, n.serverProps === null && i--, n = 0; n < b.length; n++)
        R = b[n], ge = typeof R == "string" ? ge + (En(i) + yn(R, 120 - 2 * i) + `
`) : ge + ta(
          R.type,
          R.props,
          En(i)
        );
      return c + g + ge;
    }
    function qi(n) {
      try {
        return `

` + da(n, 0);
      } catch {
        return "";
      }
    }
    function Ya(n, i, c) {
      for (var g = i, b = null, R = 0; g; )
        g === n && (R = 0), b = {
          fiber: g,
          children: b !== null ? [b] : [],
          serverProps: g === i ? c : g === n ? null : void 0,
          serverTail: [],
          distanceFromLeaf: R
        }, R++, g = g.return;
      return b !== null ? qi(b).replaceAll(/^[+-]/gm, ">") : "";
    }
    function Ei(n, i) {
      var c = Da({}, n || fy), g = { tag: i };
      return wu.indexOf(i) !== -1 && (c.aTagInScope = null, c.buttonTagInScope = null, c.nobrTagInScope = null), Qf.indexOf(i) !== -1 && (c.pTagInButtonScope = null), vt.indexOf(i) !== -1 && i !== "address" && i !== "div" && i !== "p" && (c.listItemTagAutoclosing = null, c.dlItemTagAutoclosing = null), c.current = g, i === "form" && (c.formTag = g), i === "a" && (c.aTagInScope = g), i === "button" && (c.buttonTagInScope = g), i === "nobr" && (c.nobrTagInScope = g), i === "p" && (c.pTagInButtonScope = g), i === "li" && (c.listItemTagAutoclosing = g), (i === "dd" || i === "dt") && (c.dlItemTagAutoclosing = g), i === "#document" || i === "html" ? c.containerTagInScope = null : c.containerTagInScope || (c.containerTagInScope = g), n !== null || i !== "#document" && i !== "html" && i !== "body" ? c.implicitRootScope === !0 && (c.implicitRootScope = !1) : c.implicitRootScope = !0, c;
    }
    function Wi(n, i, c) {
      switch (i) {
        case "select":
          return n === "hr" || n === "option" || n === "optgroup" || n === "script" || n === "template" || n === "#text";
        case "optgroup":
          return n === "option" || n === "#text";
        case "option":
          return n === "#text";
        case "tr":
          return n === "th" || n === "td" || n === "style" || n === "script" || n === "template";
        case "tbody":
        case "thead":
        case "tfoot":
          return n === "tr" || n === "style" || n === "script" || n === "template";
        case "colgroup":
          return n === "col" || n === "template";
        case "table":
          return n === "caption" || n === "colgroup" || n === "tbody" || n === "tfoot" || n === "thead" || n === "style" || n === "script" || n === "template";
        case "head":
          return n === "base" || n === "basefont" || n === "bgsound" || n === "link" || n === "meta" || n === "title" || n === "noscript" || n === "noframes" || n === "style" || n === "script" || n === "template";
        case "html":
          if (c) break;
          return n === "head" || n === "body" || n === "frameset";
        case "frameset":
          return n === "frame";
        case "#document":
          if (!c) return n === "html";
      }
      switch (n) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return i !== "h1" && i !== "h2" && i !== "h3" && i !== "h4" && i !== "h5" && i !== "h6";
        case "rp":
        case "rt":
          return Bv.indexOf(i) === -1;
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return i == null;
        case "head":
          return c || i === null;
        case "html":
          return c && i === "#document" || i === null;
        case "body":
          return c && (i === "#document" || i === "html") || i === null;
      }
      return !0;
    }
    function Hl(n, i) {
      switch (n) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return i.pTagInButtonScope;
        case "form":
          return i.formTag || i.pTagInButtonScope;
        case "li":
          return i.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return i.dlItemTagAutoclosing;
        case "button":
          return i.buttonTagInScope;
        case "a":
          return i.aTagInScope;
        case "nobr":
          return i.nobrTagInScope;
      }
      return null;
    }
    function Pr(n, i) {
      for (; n; ) {
        switch (n.tag) {
          case 5:
          case 26:
          case 27:
            if (n.type === i) return n;
        }
        n = n.return;
      }
      return null;
    }
    function ff(n, i) {
      i = i || fy;
      var c = i.current;
      if (i = (c = Wi(
        n,
        c && c.tag,
        i.implicitRootScope
      ) ? null : c) ? null : Hl(n, i), i = c || i, !i) return !0;
      var g = i.tag;
      if (i = String(!!c) + "|" + n + "|" + g, Nu[i]) return !1;
      Nu[i] = !0;
      var b = (i = Js) ? Pr(i.return, g) : null, R = i !== null && b !== null ? Ya(b, i, null) : "", X = "<" + n + ">";
      return c ? (c = "", g === "table" && n === "tr" && (c += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
        `In HTML, %s cannot be a child of <%s>.%s
This will cause a hydration error.%s`,
        X,
        g,
        c,
        R
      )) : console.error(
        `In HTML, %s cannot be a descendant of <%s>.
This will cause a hydration error.%s`,
        X,
        g,
        R
      ), i && (n = i.return, b === null || n === null || b === n && n._debugOwner === i._debugOwner || un(b, function() {
        console.error(
          `<%s> cannot contain a nested %s.
See this log for the ancestor stack trace.`,
          g,
          X
        );
      })), !1;
    }
    function Xu(n, i, c) {
      if (c || Wi("#text", i, !1))
        return !0;
      if (c = "#text|" + i, Nu[c]) return !1;
      Nu[c] = !0;
      var g = (c = Js) ? Pr(c, i) : null;
      return c = c !== null && g !== null ? Ya(
        g,
        c,
        c.tag !== 6 ? { children: null } : null
      ) : "", /\S/.test(n) ? console.error(
        `In HTML, text nodes cannot be a child of <%s>.
This will cause a hydration error.%s`,
        i,
        c
      ) : console.error(
        `In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.
This will cause a hydration error.%s`,
        i,
        c
      ), !1;
    }
    function Yu(n, i) {
      if (i) {
        var c = n.firstChild;
        if (c && c === n.lastChild && c.nodeType === 3) {
          c.nodeValue = i;
          return;
        }
      }
      n.textContent = i;
    }
    function $v(n) {
      return n.replace(hs, function(i, c) {
        return c.toUpperCase();
      });
    }
    function Kg(n, i, c) {
      var g = i.indexOf("--") === 0;
      g || (-1 < i.indexOf("-") ? Dm.hasOwnProperty(i) && Dm[i] || (Dm[i] = !0, console.error(
        "Unsupported style property %s. Did you mean %s?",
        i,
        $v(i.replace(Lr, "ms-"))
      )) : Ld.test(i) ? Dm.hasOwnProperty(i) && Dm[i] || (Dm[i] = !0, console.error(
        "Unsupported vendor-prefixed style property %s. Did you mean %s?",
        i,
        i.charAt(0).toUpperCase() + i.slice(1)
      )) : !Ep.test(c) || Bm.hasOwnProperty(c) && Bm[c] || (Bm[c] = !0, console.error(
        `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
        i,
        c.replace(Ep, "")
      )), typeof c == "number" && (isNaN(c) ? eS || (eS = !0, console.error(
        "`NaN` is an invalid value for the `%s` css style property.",
        i
      )) : isFinite(c) || o0 || (o0 = !0, console.error(
        "`Infinity` is an invalid value for the `%s` css style property.",
        i
      )))), c == null || typeof c == "boolean" || c === "" ? g ? n.setProperty(i, "") : i === "float" ? n.cssFloat = "" : n[i] = "" : g ? n.setProperty(i, c) : typeof c != "number" || c === 0 || Ug.has(i) ? i === "float" ? n.cssFloat = c : (We(c, i), n[i] = ("" + c).trim()) : n[i] = c + "px";
    }
    function Zh(n, i, c) {
      if (i != null && typeof i != "object")
        throw Error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      if (i && Object.freeze(i), n = n.style, c != null) {
        if (i) {
          var g = {};
          if (c) {
            for (var b in c)
              if (c.hasOwnProperty(b) && !i.hasOwnProperty(b))
                for (var R = go[b] || [b], X = 0; X < R.length; X++)
                  g[R[X]] = b;
          }
          for (var K in i)
            if (i.hasOwnProperty(K) && (!c || c[K] !== i[K]))
              for (b = go[K] || [K], R = 0; R < b.length; R++)
                g[b[R]] = K;
          K = {};
          for (var de in i)
            for (b = go[de] || [de], R = 0; R < b.length; R++)
              K[b[R]] = de;
          de = {};
          for (var ge in g)
            if (b = g[ge], (R = K[ge]) && b !== R && (X = b + "," + R, !de[X])) {
              de[X] = !0, X = console;
              var ut = i[b];
              X.error.call(
                X,
                "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                ut == null || typeof ut == "boolean" || ut === "" ? "Removing" : "Updating",
                b,
                R
              );
            }
        }
        for (var xt in c)
          !c.hasOwnProperty(xt) || i != null && i.hasOwnProperty(xt) || (xt.indexOf("--") === 0 ? n.setProperty(xt, "") : xt === "float" ? n.cssFloat = "" : n[xt] = "");
        for (var it in i)
          ge = i[it], i.hasOwnProperty(it) && c[it] !== ge && Kg(n, it, ge);
      } else
        for (g in i)
          i.hasOwnProperty(g) && Kg(n, g, i[g]);
    }
    function Ec(n) {
      if (n.indexOf("-") === -1) return !1;
      switch (n) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    function Vp(n) {
      return dy.get(n) || n;
    }
    function ad(n, i) {
      if (Kc.call(Gd, i) && Gd[i])
        return !0;
      if (py.test(i)) {
        if (n = "aria-" + i.slice(4).toLowerCase(), n = u0.hasOwnProperty(n) ? n : null, n == null)
          return console.error(
            "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
            i
          ), Gd[i] = !0;
        if (i !== n)
          return console.error(
            "Invalid ARIA attribute `%s`. Did you mean `%s`?",
            i,
            n
          ), Gd[i] = !0;
      }
      if (hy.test(i)) {
        if (n = i.toLowerCase(), n = u0.hasOwnProperty(n) ? n : null, n == null) return Gd[i] = !0, !1;
        i !== n && (console.error(
          "Unknown ARIA attribute `%s`. Did you mean `%s`?",
          i,
          n
        ), Gd[i] = !0);
      }
      return !0;
    }
    function df(n, i) {
      var c = [], g;
      for (g in i)
        ad(n, g) || c.push(g);
      i = c.map(function(b) {
        return "`" + b + "`";
      }).join(", "), c.length === 1 ? console.error(
        "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        i,
        n
      ) : 1 < c.length && console.error(
        "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
        i,
        n
      );
    }
    function eg(n, i, c, g) {
      if (Kc.call(yo, i) && yo[i])
        return !0;
      var b = i.toLowerCase();
      if (b === "onfocusin" || b === "onfocusout")
        return console.error(
          "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
        ), yo[i] = !0;
      if (typeof c == "function" && (n === "form" && i === "action" || n === "input" && i === "formAction" || n === "button" && i === "formAction"))
        return !0;
      if (g != null) {
        if (n = g.possibleRegistrationNames, g.registrationNameDependencies.hasOwnProperty(i))
          return !0;
        if (g = n.hasOwnProperty(b) ? n[b] : null, g != null)
          return console.error(
            "Invalid event handler property `%s`. Did you mean `%s`?",
            i,
            g
          ), yo[i] = !0;
        if (wg.test(i))
          return console.error(
            "Unknown event handler property `%s`. It will be ignored.",
            i
          ), yo[i] = !0;
      } else if (wg.test(i))
        return s.test(i) && console.error(
          "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
          i
        ), yo[i] = !0;
      if (f.test(i) || v.test(i)) return !0;
      if (b === "innerhtml")
        return console.error(
          "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
        ), yo[i] = !0;
      if (b === "aria")
        return console.error(
          "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
        ), yo[i] = !0;
      if (b === "is" && c !== null && c !== void 0 && typeof c != "string")
        return console.error(
          "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
          typeof c
        ), yo[i] = !0;
      if (typeof c == "number" && isNaN(c))
        return console.error(
          "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
          i
        ), yo[i] = !0;
      if (Um.hasOwnProperty(b)) {
        if (b = Um[b], b !== i)
          return console.error(
            "Invalid DOM property `%s`. Did you mean `%s`?",
            i,
            b
          ), yo[i] = !0;
      } else if (i !== b)
        return console.error(
          "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
          i,
          b
        ), yo[i] = !0;
      switch (i) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return !0;
        case "innerText":
        case "textContent":
          return !0;
      }
      switch (typeof c) {
        case "boolean":
          switch (i) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return !0;
            default:
              return b = i.toLowerCase().slice(0, 5), b === "data-" || b === "aria-" ? !0 : (c ? console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                c,
                i,
                i,
                c,
                i
              ) : console.error(
                'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                c,
                i,
                i,
                c,
                i,
                i,
                i
              ), yo[i] = !0);
          }
        case "function":
        case "symbol":
          return yo[i] = !0, !1;
        case "string":
          if (c === "false" || c === "true") {
            switch (i) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return !0;
            }
            console.error(
              "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
              c,
              i,
              c === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
              i,
              c
            ), yo[i] = !0;
          }
      }
      return !0;
    }
    function Fp(n, i, c) {
      var g = [], b;
      for (b in i)
        eg(n, b, i[b], c) || g.push(b);
      i = g.map(function(R) {
        return "`" + R + "`";
      }).join(", "), g.length === 1 ? console.error(
        "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        i,
        n
      ) : 1 < g.length && console.error(
        "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
        i,
        n
      );
    }
    function Kd(n) {
      return A.test("" + n) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : n;
    }
    function fl(n) {
      return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n;
    }
    function To(n) {
      var i = jt(n);
      if (i && (n = i.stateNode)) {
        var c = n[Hr] || null;
        e: switch (n = i.stateNode, i.type) {
          case "input":
            if (ee(
              n,
              c.value,
              c.defaultValue,
              c.defaultValue,
              c.checked,
              c.defaultChecked,
              c.type,
              c.name
            ), i = c.name, c.type === "radio" && i != null) {
              for (c = n; c.parentNode; ) c = c.parentNode;
              for (De(i, "name"), c = c.querySelectorAll(
                'input[name="' + Ft(
                  "" + i
                ) + '"][type="radio"]'
              ), i = 0; i < c.length; i++) {
                var g = c[i];
                if (g !== n && g.form === n.form) {
                  var b = g[Hr] || null;
                  if (!b)
                    throw Error(
                      "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                    );
                  ee(
                    g,
                    b.value,
                    b.defaultValue,
                    b.defaultValue,
                    b.checked,
                    b.defaultChecked,
                    b.type,
                    b.name
                  );
                }
              }
              for (i = 0; i < c.length; i++)
                g = c[i], g.form === n.form && nt(g);
            }
            break e;
          case "textarea":
            It(n, c.value, c.defaultValue);
            break e;
          case "select":
            i = c.value, i != null && je(n, !!c.multiple, i, !1);
        }
      }
    }
    function id(n, i, c) {
      if (oe) return n(i, c);
      oe = !0;
      try {
        var g = n(i);
        return g;
      } finally {
        if (oe = !1, (H !== null || W !== null) && (wf(), H && (i = H, n = W, W = H = null, To(i), n)))
          for (i = 0; i < n.length; i++) To(n[i]);
      }
    }
    function Co(n, i) {
      var c = n.stateNode;
      if (c === null) return null;
      var g = c[Hr] || null;
      if (g === null) return null;
      c = g[i];
      e: switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (g = !g.disabled) || (n = n.type, g = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !g;
          break e;
        default:
          n = !1;
      }
      if (n) return null;
      if (c && typeof c != "function")
        throw Error(
          "Expected `" + i + "` listener to be a function, instead got a value of `" + typeof c + "` type."
        );
      return c;
    }
    function su() {
      if (lt) return lt;
      var n, i = at, c = i.length, g, b = "value" in zt ? zt.value : zt.textContent, R = b.length;
      for (n = 0; n < c && i[n] === b[n]; n++) ;
      var X = c - n;
      for (g = 1; g <= X && i[c - g] === b[R - g]; g++) ;
      return lt = b.slice(n, 1 < g ? 1 - g : void 0);
    }
    function ld(n) {
      var i = n.keyCode;
      return "charCode" in n ? (n = n.charCode, n === 0 && i === 13 && (n = 13)) : n = i, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0;
    }
    function hf() {
      return !0;
    }
    function Km() {
      return !1;
    }
    function Ll(n) {
      function i(c, g, b, R, X) {
        this._reactName = c, this._targetInst = b, this.type = g, this.nativeEvent = R, this.target = X, this.currentTarget = null;
        for (var K in n)
          n.hasOwnProperty(K) && (c = n[K], this[K] = c ? c(R) : R[K]);
        return this.isDefaultPrevented = (R.defaultPrevented != null ? R.defaultPrevented : R.returnValue === !1) ? hf : Km, this.isPropagationStopped = Km, this;
      }
      return Da(i.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var c = this.nativeEvent;
          c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = hf);
        },
        stopPropagation: function() {
          var c = this.nativeEvent;
          c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = hf);
        },
        persist: function() {
        },
        isPersistent: hf
      }), i;
    }
    function kd(n) {
      var i = this.nativeEvent;
      return i.getModifierState ? i.getModifierState(n) : (n = Fx[n]) ? !!i[n] : !1;
    }
    function sd() {
      return kd;
    }
    function xl(n, i) {
      switch (n) {
        case "keyup":
          return aS.indexOf(i.keyCode) !== -1;
        case "keydown":
          return i.keyCode !== my;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function pf(n) {
      return n = n.detail, typeof n == "object" && "data" in n ? n.data : null;
    }
    function ru(n, i) {
      switch (n) {
        case "compositionend":
          return pf(i);
        case "keypress":
          return i.which !== ki ? null : (ka = !0, El);
        case "textInput":
          return n = i.data, n === El && ka ? null : n;
        default:
          return null;
      }
    }
    function Ro(n, i) {
      if (wa)
        return n === "compositionend" || !iS && xl(n, i) ? (n = su(), lt = at = zt = null, wa = !1, n) : null;
      switch (n) {
        case "paste":
          return null;
        case "keypress":
          if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
            if (i.char && 1 < i.char.length)
              return i.char;
            if (i.which)
              return String.fromCharCode(i.which);
          }
          return null;
        case "compositionend":
          return lS && i.locale !== "ko" ? null : i.data;
        default:
          return null;
      }
    }
    function Pp(n) {
      var i = n && n.nodeName && n.nodeName.toLowerCase();
      return i === "input" ? !!jf[n.type] : i === "textarea";
    }
    function ra(n) {
      if (!be) return !1;
      n = "on" + n;
      var i = n in document;
      return i || (i = document.createElement("div"), i.setAttribute(n, "return;"), i = typeof i[n] == "function"), i;
    }
    function Yt(n, i, c, g) {
      H ? W ? W.push(g) : W = [g] : H = g, i = pp(i, "onChange"), 0 < i.length && (c = new In(
        "onChange",
        "change",
        null,
        c,
        g
      ), n.push({ event: c, listeners: i }));
    }
    function bc(n) {
      Eu(n, 0);
    }
    function qu(n) {
      var i = Ue(n);
      if (nt(i)) return n;
    }
    function dl(n, i) {
      if (n === "change") return i;
    }
    function km() {
      wv && (wv.detachEvent("onpropertychange", tg), Tp = wv = null);
    }
    function tg(n) {
      if (n.propertyName === "value" && qu(Tp)) {
        var i = [];
        Yt(
          i,
          Tp,
          n,
          fl(n)
        ), id(bc, i);
      }
    }
    function Is(n, i, c) {
      n === "focusin" ? (km(), wv = i, Tp = c, wv.attachEvent("onpropertychange", tg)) : n === "focusout" && km();
    }
    function Xp(n) {
      if (n === "selectionchange" || n === "keyup" || n === "keydown")
        return qu(Tp);
    }
    function ky(n, i) {
      if (n === "click") return qu(i);
    }
    function ng(n, i) {
      if (n === "input" || n === "change")
        return qu(i);
    }
    function ag(n, i) {
      return n === i && (n !== 0 || 1 / n === 1 / i) || n !== n && i !== i;
    }
    function Wd(n, i) {
      if (mc(n, i)) return !0;
      if (typeof n != "object" || n === null || typeof i != "object" || i === null)
        return !1;
      var c = Object.keys(n), g = Object.keys(i);
      if (c.length !== g.length) return !1;
      for (g = 0; g < c.length; g++) {
        var b = c[g];
        if (!Kc.call(i, b) || !mc(n[b], i[b]))
          return !1;
      }
      return !0;
    }
    function ms(n) {
      for (; n && n.firstChild; ) n = n.firstChild;
      return n;
    }
    function fi(n, i) {
      var c = ms(n);
      n = 0;
      for (var g; c; ) {
        if (c.nodeType === 3) {
          if (g = n + c.textContent.length, n <= i && g >= i)
            return { node: c, offset: i - n };
          n = g;
        }
        e: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break e;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = ms(c);
      }
    }
    function Qh(n, i) {
      return n && i ? n === i ? !0 : n && n.nodeType === 3 ? !1 : i && i.nodeType === 3 ? Qh(n, i.parentNode) : "contains" in n ? n.contains(i) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(i) & 16) : !1 : !1;
    }
    function mf(n) {
      n = n != null && n.ownerDocument != null && n.ownerDocument.defaultView != null ? n.ownerDocument.defaultView : window;
      for (var i = pt(n.document); i instanceof n.HTMLIFrameElement; ) {
        try {
          var c = typeof i.contentWindow.location.href == "string";
        } catch {
          c = !1;
        }
        if (c) n = i.contentWindow;
        else break;
        i = pt(n.document);
      }
      return i;
    }
    function vf(n) {
      var i = n && n.nodeName && n.nodeName.toLowerCase();
      return i && (i === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || i === "textarea" || n.contentEditable === "true");
    }
    function Do(n, i, c) {
      var g = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
      sl || Cp == null || Cp !== pt(g) || (g = Cp, "selectionStart" in g && vf(g) ? g = { start: g.selectionStart, end: g.selectionEnd } : (g = (g.ownerDocument && g.ownerDocument.defaultView || window).getSelection(), g = {
        anchorNode: g.anchorNode,
        anchorOffset: g.anchorOffset,
        focusNode: g.focusNode,
        focusOffset: g.focusOffset
      }), gy && Wd(gy, g) || (gy = g, g = pp(vy, "onSelect"), 0 < g.length && (i = new In(
        "onSelect",
        "select",
        null,
        i,
        c
      ), n.push({ event: i, listeners: g }), i.target = Cp)));
    }
    function ou(n, i) {
      var c = {};
      return c[n.toLowerCase()] = i.toLowerCase(), c["Webkit" + n] = "webkit" + i, c["Moz" + n] = "moz" + i, c;
    }
    function uu(n) {
      if (Rp[n]) return Rp[n];
      if (!ko[n]) return n;
      var i = ko[n], c;
      for (c in i)
        if (i.hasOwnProperty(c) && c in yy)
          return Rp[n] = i[c];
      return n;
    }
    function Xr(n, i) {
      Hg.set(n, i), xe(i, [n]);
    }
    function vs(n, i) {
      if (typeof n == "object" && n !== null) {
        var c = Vd.get(n);
        return c !== void 0 ? c : (i = {
          value: n,
          source: i,
          stack: Ws(i)
        }, Vd.set(n, i), i);
      }
      return {
        value: n,
        source: i,
        stack: Ws(i)
      };
    }
    function rd() {
      for (var n = Nm, i = sS = Nm = 0; i < n; ) {
        var c = Fd[i];
        Fd[i++] = null;
        var g = Fd[i];
        Fd[i++] = null;
        var b = Fd[i];
        Fd[i++] = null;
        var R = Fd[i];
        if (Fd[i++] = null, g !== null && b !== null) {
          var X = g.pending;
          X === null ? b.next = b : (b.next = X.next, X.next = b), g.pending = b;
        }
        R !== 0 && Mc(c, b, R);
      }
    }
    function $d(n, i, c, g) {
      Fd[Nm++] = n, Fd[Nm++] = i, Fd[Nm++] = c, Fd[Nm++] = g, sS |= g, n.lanes |= g, n = n.alternate, n !== null && (n.lanes |= g);
    }
    function Yp(n, i, c, g) {
      return $d(n, i, c, g), jh(n);
    }
    function mr(n, i) {
      return $d(n, null, null, i), jh(n);
    }
    function Mc(n, i, c) {
      n.lanes |= c;
      var g = n.alternate;
      g !== null && (g.lanes |= c);
      for (var b = !1, R = n.return; R !== null; )
        R.childLanes |= c, g = R.alternate, g !== null && (g.childLanes |= c), R.tag === 22 && (n = R.stateNode, n === null || n._visibility & p0 || (b = !0)), n = R, R = R.return;
      return n.tag === 3 ? (R = n.stateNode, b && i !== null && (b = 31 - po(c), n = R.hiddenUpdates, g = n[b], g === null ? n[b] = [i] : g.push(i), i.lane = c | 536870912), R) : null;
    }
    function jh(n) {
      if ($1 > yN)
        throw mS = $1 = 0, eA = hT = null, Error(
          "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
        );
      mS > SN && (mS = 0, eA = null, console.error(
        "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
      )), n.alternate === null && (n.flags & 4098) !== 0 && Xc(n);
      for (var i = n, c = i.return; c !== null; )
        i.alternate === null && (i.flags & 4098) !== 0 && Xc(n), i = c, c = i.return;
      return i.tag === 3 ? i.stateNode : null;
    }
    function eh(n) {
      if (So === null) return n;
      var i = So(n);
      return i === void 0 ? n : i.current;
    }
    function qp(n) {
      if (So === null) return n;
      var i = So(n);
      return i === void 0 ? n != null && typeof n.render == "function" && (i = eh(n.render), n.render !== i) ? (i = { $$typeof: Od, render: i }, n.displayName !== void 0 && (i.displayName = n.displayName), i) : n : i.current;
    }
    function xc(n, i) {
      if (So === null) return !1;
      var c = n.elementType;
      i = i.type;
      var g = !1, b = typeof i == "object" && i !== null ? i.$$typeof : null;
      switch (n.tag) {
        case 1:
          typeof i == "function" && (g = !0);
          break;
        case 0:
          (typeof i == "function" || b === Du) && (g = !0);
          break;
        case 11:
          (b === Od || b === Du) && (g = !0);
          break;
        case 14:
        case 15:
          (b === vp || b === Du) && (g = !0);
          break;
        default:
          return !1;
      }
      return !!(g && (n = So(c), n !== void 0 && n === So(i)));
    }
    function Zu(n) {
      So !== null && typeof WeakSet == "function" && (zv === null && (zv = /* @__PURE__ */ new WeakSet()), zv.add(n));
    }
    function th(n, i, c) {
      var g = n.alternate, b = n.child, R = n.sibling, X = n.tag, K = n.type, de = null;
      switch (X) {
        case 0:
        case 15:
        case 1:
          de = K;
          break;
        case 11:
          de = K.render;
      }
      if (So === null)
        throw Error("Expected resolveFamily to be set during hot reload.");
      var ge = !1;
      K = !1, de !== null && (de = So(de), de !== void 0 && (c.has(de) ? K = !0 : i.has(de) && (X === 1 ? K = !0 : ge = !0))), zv !== null && (zv.has(n) || g !== null && zv.has(g)) && (K = !0), K && (n._debugNeedsRemount = !0), (K || ge) && (g = mr(n, 2), g !== null && Cl(g, n, 2)), b === null || K || th(
        b,
        i,
        c
      ), R !== null && th(
        R,
        i,
        c
      );
    }
    function nh(n, i, c, g) {
      this.tag = n, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = g, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null, this.actualDuration = -0, this.actualStartTime = -1.1, this.treeBaseDuration = this.selfBaseDuration = -0, this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, g_ || typeof Object.preventExtensions != "function" || Object.preventExtensions(this);
    }
    function ah(n) {
      return n = n.prototype, !(!n || !n.isReactComponent);
    }
    function cu(n, i) {
      var c = n.alternate;
      switch (c === null ? (c = D(
        n.tag,
        i,
        n.key,
        n.mode
      ), c.elementType = n.elementType, c.type = n.type, c.stateNode = n.stateNode, c._debugOwner = n._debugOwner, c._debugStack = n._debugStack, c._debugTask = n._debugTask, c._debugHookTypes = n._debugHookTypes, c.alternate = n, n.alternate = c) : (c.pendingProps = i, c.type = n.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null, c.actualDuration = -0, c.actualStartTime = -1.1), c.flags = n.flags & 65011712, c.childLanes = n.childLanes, c.lanes = n.lanes, c.child = n.child, c.memoizedProps = n.memoizedProps, c.memoizedState = n.memoizedState, c.updateQueue = n.updateQueue, i = n.dependencies, c.dependencies = i === null ? null : {
        lanes: i.lanes,
        firstContext: i.firstContext,
        _debugThenableState: i._debugThenableState
      }, c.sibling = n.sibling, c.index = n.index, c.ref = n.ref, c.refCleanup = n.refCleanup, c.selfBaseDuration = n.selfBaseDuration, c.treeBaseDuration = n.treeBaseDuration, c._debugInfo = n._debugInfo, c._debugNeedsRemount = n._debugNeedsRemount, c.tag) {
        case 0:
        case 15:
          c.type = eh(n.type);
          break;
        case 1:
          c.type = eh(n.type);
          break;
        case 11:
          c.type = qp(n.type);
      }
      return c;
    }
    function gf(n, i) {
      n.flags &= 65011714;
      var c = n.alternate;
      return c === null ? (n.childLanes = 0, n.lanes = i, n.child = null, n.subtreeFlags = 0, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null, n.selfBaseDuration = 0, n.treeBaseDuration = 0) : (n.childLanes = c.childLanes, n.lanes = c.lanes, n.child = c.child, n.subtreeFlags = 0, n.deletions = null, n.memoizedProps = c.memoizedProps, n.memoizedState = c.memoizedState, n.updateQueue = c.updateQueue, n.type = c.type, i = c.dependencies, n.dependencies = i === null ? null : {
        lanes: i.lanes,
        firstContext: i.firstContext,
        _debugThenableState: i._debugThenableState
      }, n.selfBaseDuration = c.selfBaseDuration, n.treeBaseDuration = c.treeBaseDuration), n;
    }
    function ts(n, i, c, g, b, R) {
      var X = 0, K = n;
      if (typeof n == "function")
        ah(n) && (X = 1), K = eh(K);
      else if (typeof n == "string")
        X = P(), X = Be(n, c, X) ? 26 : n === "html" || n === "head" || n === "body" ? 27 : 5;
      else
        e: switch (n) {
          case gp:
            return i = D(31, c, i, b), i.elementType = gp, i.lanes = R, i;
          case Sa:
            return Tc(
              c.children,
              b,
              R,
              i
            );
          case mp:
            X = 8, b |= Wo, b |= Bp;
            break;
          case Ud:
            return n = c, g = b, typeof n.id != "string" && console.error(
              'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
              typeof n.id
            ), i = D(12, n, i, g | _o), i.elementType = Ud, i.lanes = R, i.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, i;
          case wd:
            return i = D(13, c, i, b), i.elementType = wd, i.lanes = R, i;
          case Uh:
            return i = D(19, c, i, b), i.elementType = Uh, i.lanes = R, i;
          default:
            if (typeof n == "object" && n !== null)
              switch (n.$$typeof) {
                case ay:
                case Ru:
                  X = 10;
                  break e;
                case xg:
                  X = 9;
                  break e;
                case Od:
                  X = 11, K = qp(K);
                  break e;
                case vp:
                  X = 14;
                  break e;
                case Du:
                  X = 16, K = null;
                  break e;
              }
            K = "", (n === void 0 || typeof n == "object" && n !== null && Object.keys(n).length === 0) && (K += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), n === null ? c = "null" : _a(n) ? c = "array" : n !== void 0 && n.$$typeof === fc ? (c = "<" + (le(n.type) || "Unknown") + " />", K = " Did you accidentally export a JSX literal instead of a component?") : c = typeof n, (X = g ? ne(g) : null) && (K += `

Check the render method of \`` + X + "`."), X = 29, c = Error(
              "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (c + "." + K)
            ), K = null;
        }
      return i = D(X, c, i, b), i.elementType = n, i.type = K, i.lanes = R, i._debugOwner = g, i;
    }
    function od(n, i, c) {
      return i = ts(
        n.type,
        n.key,
        n.props,
        n._owner,
        i,
        c
      ), i._debugOwner = n._owner, i._debugStack = n._debugStack, i._debugTask = n._debugTask, i;
    }
    function Tc(n, i, c, g) {
      return n = D(7, n, g, i), n.lanes = c, n;
    }
    function Cc(n, i, c) {
      return n = D(6, n, null, i), n.lanes = c, n;
    }
    function ih(n, i, c) {
      return i = D(
        4,
        n.children !== null ? n.children : [],
        n.key,
        i
      ), i.lanes = c, i.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation
      }, i;
    }
    function Bo(n, i) {
      Yr(), Hv[v0++] = Lg, Hv[v0++] = zm, zm = n, Lg = i;
    }
    function lh(n, i, c) {
      Yr(), Hu[Pd++] = Lv, Hu[Pd++] = Hh, Hu[Pd++] = _y, _y = n;
      var g = Lv;
      n = Hh;
      var b = 32 - po(g) - 1;
      g &= ~(1 << b), c += 1;
      var R = 32 - po(i) + b;
      if (30 < R) {
        var X = b - b % 5;
        R = (g & (1 << X) - 1).toString(32), g >>= X, b -= X, Lv = 1 << 32 - po(i) + b | c << b | g, Hh = R + n;
      } else
        Lv = 1 << R | c << b | g, Hh = n;
    }
    function Zp(n) {
      Yr(), n.return !== null && (Bo(n, 1), lh(n, 1, 0));
    }
    function vr(n) {
      for (; n === zm; )
        zm = Hv[--v0], Hv[v0] = null, Lg = Hv[--v0], Hv[v0] = null;
      for (; n === _y; )
        _y = Hu[--Pd], Hu[Pd] = null, Hh = Hu[--Pd], Hu[Pd] = null, Lv = Hu[--Pd], Hu[Pd] = null;
    }
    function Yr() {
      Di || console.error(
        "Expected to be hydrating. This is a bug in React. Please file an issue."
      );
    }
    function Vs(n, i) {
      if (n.return === null) {
        if (Lu === null)
          Lu = {
            fiber: n,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf: i
          };
        else {
          if (Lu.fiber !== n)
            throw Error(
              "Saw multiple hydration diff roots in a pass. This is a bug in React."
            );
          Lu.distanceFromLeaf > i && (Lu.distanceFromLeaf = i);
        }
        return Lu;
      }
      var c = Vs(
        n.return,
        i + 1
      ).children;
      return 0 < c.length && c[c.length - 1].fiber === n ? (c = c[c.length - 1], c.distanceFromLeaf > i && (c.distanceFromLeaf = i), c) : (i = {
        fiber: n,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: i
      }, c.push(i), i);
    }
    function Qp(n, i) {
      Ir || (n = Vs(n, 0), n.serverProps = null, i !== null && (i = If(i), n.serverTail.push(i)));
    }
    function $s(n) {
      var i = "", c = Lu;
      throw c !== null && (Lu = null, i = qi(c)), yi(
        vs(
          Error(
            `Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + i
          ),
          n
        )
      ), S_;
    }
    function Fs(n) {
      var i = n.stateNode, c = n.type, g = n.memoizedProps;
      switch (i[ws] = n, i[Hr] = g, sr(c, g), c) {
        case "dialog":
          ga("cancel", i), ga("close", i);
          break;
        case "iframe":
        case "object":
        case "embed":
          ga("load", i);
          break;
        case "video":
        case "audio":
          for (c = 0; c < tA.length; c++)
            ga(tA[c], i);
          break;
        case "source":
          ga("error", i);
          break;
        case "img":
        case "image":
        case "link":
          ga("error", i), ga("load", i);
          break;
        case "details":
          ga("toggle", i);
          break;
        case "input":
          tt("input", g), ga("invalid", i), Gt(i, g), ye(
            i,
            g.value,
            g.defaultValue,
            g.checked,
            g.defaultChecked,
            g.type,
            g.name,
            !0
          ), $e(i);
          break;
        case "option":
          Re(i, g);
          break;
        case "select":
          tt("select", g), ga("invalid", i), _t(i, g);
          break;
        case "textarea":
          tt("textarea", g), ga("invalid", i), Ut(i, g), on(
            i,
            g.value,
            g.defaultValue,
            g.children
          ), $e(i);
      }
      c = g.children, typeof c != "string" && typeof c != "number" && typeof c != "bigint" || i.textContent === "" + c || g.suppressHydrationWarning === !0 || gm(i.textContent, c) ? (g.popover != null && (ga("beforetoggle", i), ga("toggle", i)), g.onScroll != null && ga("scroll", i), g.onScrollEnd != null && ga("scrollend", i), g.onClick != null && (i.onclick = bu), i = !0) : i = !1, i || $s(n);
    }
    function sh(n) {
      for (vc = n.return; vc; )
        switch (vc.tag) {
          case 5:
          case 13:
            Up = !1;
            return;
          case 27:
          case 3:
            Up = !0;
            return;
          default:
            vc = vc.return;
        }
    }
    function yf(n) {
      if (n !== vc) return !1;
      if (!Di)
        return sh(n), Di = !0, !1;
      var i = n.tag, c;
      if ((c = i !== 3 && i !== 27) && ((c = i === 5) && (c = n.type, c = !(c !== "form" && c !== "button") || wr(n.type, n.memoizedProps)), c = !c), c && Hs) {
        for (c = Hs; c; ) {
          var g = Vs(n, 0), b = If(c);
          g.serverTail.push(b), c = b.type === "Suspense" ? co(c) : Al(c.nextSibling);
        }
        $s(n);
      }
      if (sh(n), i === 13) {
        if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n)
          throw Error(
            "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
          );
        Hs = co(n);
      } else
        i === 27 ? (i = Hs, oo(n.type) ? (n = xT, xT = null, Hs = n) : Hs = i) : Hs = vc ? Al(n.stateNode.nextSibling) : null;
      return !0;
    }
    function Rc() {
      Hs = vc = null, Ir = Di = !1;
    }
    function ud() {
      var n = Gg;
      return n !== null && (qd === null ? qd = n : qd.push.apply(
        qd,
        n
      ), Gg = null), n;
    }
    function yi(n) {
      Gg === null ? Gg = [n] : Gg.push(n);
    }
    function Wm() {
      var n = Lu;
      if (n !== null) {
        Lu = null;
        for (var i = qi(n); 0 < n.children.length; )
          n = n.children[0];
        un(n.fiber, function() {
          console.error(
            `A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`,
            "https://react.dev/link/hydration-mismatch",
            i
          );
        });
      }
    }
    function Jh() {
      Ay = oS = null, Ey = !1;
    }
    function Dc(n, i, c) {
      _e(__, i._currentValue, n), i._currentValue = c, _e(A_, i._currentRenderer, n), i._currentRenderer !== void 0 && i._currentRenderer !== null && i._currentRenderer !== G1 && console.error(
        "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
      ), i._currentRenderer = G1;
    }
    function gr(n, i) {
      n._currentValue = __.current;
      var c = A_.current;
      re(A_, i), n._currentRenderer = c, re(__, i);
    }
    function Qu(n, i, c) {
      for (; n !== null; ) {
        var g = n.alternate;
        if ((n.childLanes & i) !== i ? (n.childLanes |= i, g !== null && (g.childLanes |= i)) : g !== null && (g.childLanes & i) !== i && (g.childLanes |= i), n === c) break;
        n = n.return;
      }
      n !== c && console.error(
        "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function $m(n, i, c, g) {
      var b = n.child;
      for (b !== null && (b.return = n); b !== null; ) {
        var R = b.dependencies;
        if (R !== null) {
          var X = b.child;
          R = R.firstContext;
          e: for (; R !== null; ) {
            var K = R;
            R = b;
            for (var de = 0; de < i.length; de++)
              if (K.context === i[de]) {
                R.lanes |= c, K = R.alternate, K !== null && (K.lanes |= c), Qu(
                  R.return,
                  c,
                  n
                ), g || (X = null);
                break e;
              }
            R = K.next;
          }
        } else if (b.tag === 18) {
          if (X = b.return, X === null)
            throw Error(
              "We just came from a parent so we must have had a parent. This is a bug in React."
            );
          X.lanes |= c, R = X.alternate, R !== null && (R.lanes |= c), Qu(
            X,
            c,
            n
          ), X = null;
        } else X = b.child;
        if (X !== null) X.return = b;
        else
          for (X = b; X !== null; ) {
            if (X === n) {
              X = null;
              break;
            }
            if (b = X.sibling, b !== null) {
              b.return = X.return, X = b;
              break;
            }
            X = X.return;
          }
        b = X;
      }
    }
    function gs(n, i, c, g) {
      n = null;
      for (var b = i, R = !1; b !== null; ) {
        if (!R) {
          if ((b.flags & 524288) !== 0) R = !0;
          else if ((b.flags & 262144) !== 0) break;
        }
        if (b.tag === 10) {
          var X = b.alternate;
          if (X === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          if (X = X.memoizedProps, X !== null) {
            var K = b.type;
            mc(b.pendingProps.value, X.value) || (n !== null ? n.push(K) : n = [K]);
          }
        } else if (b === wh.current) {
          if (X = b.alternate, X === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          X.memoizedState.memoizedState !== b.memoizedState.memoizedState && (n !== null ? n.push(lA) : n = [lA]);
        }
        b = b.return;
      }
      n !== null && $m(
        i,
        n,
        c,
        g
      ), i.flags |= 262144;
    }
    function yr(n) {
      for (n = n.firstContext; n !== null; ) {
        if (!mc(
          n.context._currentValue,
          n.memoizedValue
        ))
          return !0;
        n = n.next;
      }
      return !1;
    }
    function Yl(n) {
      oS = n, Ay = null, n = n.dependencies, n !== null && (n.firstContext = null);
    }
    function Zi(n) {
      return Ey && console.error(
        "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
      ), jp(oS, n);
    }
    function Kh(n, i) {
      return oS === null && Yl(n), jp(n, i);
    }
    function jp(n, i) {
      var c = i._currentValue;
      if (i = { context: i, memoizedValue: c, next: null }, Ay === null) {
        if (n === null)
          throw Error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        Ay = i, n.dependencies = {
          lanes: 0,
          firstContext: i,
          _debugThenableState: null
        }, n.flags |= 524288;
      } else Ay = Ay.next = i;
      return c;
    }
    function rh() {
      return {
        controller: new l(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function Sf(n) {
      n.controller.signal.aborted && console.warn(
        "A cache instance was retained after it was already freed. This likely indicates a bug in React."
      ), n.refCount++;
    }
    function ys(n) {
      n.refCount--, 0 > n.refCount && console.warn(
        "A cache instance was released after it was already freed. This likely indicates a bug in React."
      ), n.refCount === 0 && u(S, function() {
        n.controller.abort();
      });
    }
    function Uo() {
      var n = Pe;
      return Pe = 0, n;
    }
    function _f(n) {
      var i = Pe;
      return Pe = n, i;
    }
    function oh(n) {
      var i = Pe;
      return Pe += n, i;
    }
    function ev(n) {
      he = O(), 0 > n.actualStartTime && (n.actualStartTime = he);
    }
    function ns(n) {
      if (0 <= he) {
        var i = O() - he;
        n.actualDuration += i, n.selfBaseDuration = i, he = -1;
      }
    }
    function fu(n) {
      if (0 <= he) {
        var i = O() - he;
        n.actualDuration += i, he = -1;
      }
    }
    function qr() {
      if (0 <= he) {
        var n = O() - he;
        he = -1, Pe += n;
      }
    }
    function Oo() {
      he = O();
    }
    function du(n) {
      for (var i = n.child; i; )
        n.actualDuration += i.actualDuration, i = i.sibling;
    }
    function Sr(n, i) {
      if (ln === null) {
        var c = ln = [];
        Sn = 0, Na = Jl(), vi = {
          status: "pending",
          value: void 0,
          then: function(g) {
            c.push(g);
          }
        };
      }
      return Sn++, i.then(Jp, Jp), i;
    }
    function Jp() {
      if (--Sn === 0 && ln !== null) {
        vi !== null && (vi.status = "fulfilled");
        var n = ln;
        ln = null, Na = 0, vi = null;
        for (var i = 0; i < n.length; i++) (0, n[i])();
      }
    }
    function _r(n, i) {
      var c = [], g = {
        status: "pending",
        value: null,
        reason: null,
        then: function(b) {
          c.push(b);
        }
      };
      return n.then(
        function() {
          g.status = "fulfilled", g.value = i;
          for (var b = 0; b < c.length; b++) (0, c[b])(i);
        },
        function(b) {
          for (g.status = "rejected", g.reason = b, b = 0; b < c.length; b++)
            (0, c[b])(void 0);
        }
      ), g;
    }
    function tv() {
      var n = Lh.current;
      return n !== null ? n : Wl.pooledCache;
    }
    function hu(n, i) {
      i === null ? _e(Lh, Lh.current, n) : _e(Lh, i.pool, n);
    }
    function pu() {
      var n = tv();
      return n === null ? null : { parent: x._currentValue, pool: n };
    }
    function mu() {
      return { didWarnAboutUncachedPromise: !1, thenables: [] };
    }
    function Kp(n) {
      return n = n.status, n === "fulfilled" || n === "rejected";
    }
    function Af() {
    }
    function ql(n, i, c) {
      mt.actQueue !== null && (mt.didUsePromise = !0);
      var g = n.thenables;
      switch (c = g[c], c === void 0 ? g.push(i) : c !== i && (n.didWarnAboutUncachedPromise || (n.didWarnAboutUncachedPromise = !0, console.error(
        "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
      )), i.then(Af, Af), i = c), i.status) {
        case "fulfilled":
          return i.value;
        case "rejected":
          throw n = i.reason, Ps(n), n;
        default:
          if (typeof i.status == "string")
            i.then(Af, Af);
          else {
            if (n = Wl, n !== null && 100 < n.shellSuspendCounter)
              throw Error(
                "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
              );
            n = i, n.status = "pending", n.then(
              function(b) {
                if (i.status === "pending") {
                  var R = i;
                  R.status = "fulfilled", R.value = b;
                }
              },
              function(b) {
                if (i.status === "pending") {
                  var R = i;
                  R.status = "rejected", R.reason = b;
                }
              }
            );
          }
          switch (i.status) {
            case "fulfilled":
              return i.value;
            case "rejected":
              throw n = i.reason, Ps(n), n;
          }
          throw V1 = i, ME = !0, rl;
      }
    }
    function kp() {
      if (V1 === null)
        throw Error(
          "Expected a suspended thenable. This is a bug in React. Please file an issue."
        );
      var n = V1;
      return V1 = null, ME = !1, n;
    }
    function Ps(n) {
      if (n === rl || n === Gh)
        throw Error(
          "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
        );
    }
    function ri(n) {
      n.updateQueue = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function Zr(n, i) {
      n = n.updateQueue, i.updateQueue === n && (i.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        callbacks: null
      });
    }
    function ju(n) {
      return {
        lane: n,
        tag: SR,
        payload: null,
        callback: null,
        next: null
      };
    }
    function vu(n, i, c) {
      var g = n.updateQueue;
      if (g === null) return null;
      if (g = g.shared, Yx === g && !ER) {
        var b = Q(n);
        console.error(
          `An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`,
          b
        ), ER = !0;
      }
      return (ol & Yd) !== Op ? (b = g.pending, b === null ? i.next = i : (i.next = b.next, b.next = i), g.pending = i, i = jh(n), Mc(n, null, c), i) : ($d(n, g, i, c), jh(n));
    }
    function gu(n, i, c) {
      if (i = i.updateQueue, i !== null && (i = i.shared, (c & 4194048) !== 0)) {
        var g = i.lanes;
        g &= n.pendingLanes, c |= g, i.lanes = c, yt(n, c);
      }
    }
    function uh(n, i) {
      var c = n.updateQueue, g = n.alternate;
      if (g !== null && (g = g.updateQueue, c === g)) {
        var b = null, R = null;
        if (c = c.firstBaseUpdate, c !== null) {
          do {
            var X = {
              lane: c.lane,
              tag: c.tag,
              payload: c.payload,
              callback: null,
              next: null
            };
            R === null ? b = R = X : R = R.next = X, c = c.next;
          } while (c !== null);
          R === null ? b = R = i : R = R.next = i;
        } else b = R = i;
        c = {
          baseState: g.baseState,
          firstBaseUpdate: b,
          lastBaseUpdate: R,
          shared: g.shared,
          callbacks: g.callbacks
        }, n.updateQueue = c;
        return;
      }
      n = c.lastBaseUpdate, n === null ? c.firstBaseUpdate = i : n.next = i, c.lastBaseUpdate = i;
    }
    function er() {
      if (qx) {
        var n = vi;
        if (n !== null) throw n;
      }
    }
    function cd(n, i, c, g) {
      qx = !1;
      var b = n.updateQueue;
      g0 = !1, Yx = b.shared;
      var R = b.firstBaseUpdate, X = b.lastBaseUpdate, K = b.shared.pending;
      if (K !== null) {
        b.shared.pending = null;
        var de = K, ge = de.next;
        de.next = null, X === null ? R = ge : X.next = ge, X = de;
        var ut = n.alternate;
        ut !== null && (ut = ut.updateQueue, K = ut.lastBaseUpdate, K !== X && (K === null ? ut.firstBaseUpdate = ge : K.next = ge, ut.lastBaseUpdate = de));
      }
      if (R !== null) {
        var xt = b.baseState;
        X = 0, ut = ge = de = null, K = R;
        do {
          var it = K.lane & -536870913, Dt = it !== K.lane;
          if (Dt ? (gi & it) === it : (g & it) === it) {
            it !== 0 && it === Na && (qx = !0), ut !== null && (ut = ut.next = {
              lane: 0,
              tag: K.tag,
              payload: K.payload,
              callback: null,
              next: null
            });
            e: {
              it = n;
              var wn = K, Ea = i, $l = c;
              switch (wn.tag) {
                case _R:
                  if (wn = wn.payload, typeof wn == "function") {
                    Ey = !0;
                    var _i = wn.call(
                      $l,
                      xt,
                      Ea
                    );
                    if (it.mode & Wo) {
                      ct(!0);
                      try {
                        wn.call($l, xt, Ea);
                      } finally {
                        ct(!1);
                      }
                    }
                    Ey = !1, xt = _i;
                    break e;
                  }
                  xt = wn;
                  break e;
                case Xx:
                  it.flags = it.flags & -65537 | 128;
                case SR:
                  if (_i = wn.payload, typeof _i == "function") {
                    if (Ey = !0, wn = _i.call(
                      $l,
                      xt,
                      Ea
                    ), it.mode & Wo) {
                      ct(!0);
                      try {
                        _i.call($l, xt, Ea);
                      } finally {
                        ct(!1);
                      }
                    }
                    Ey = !1;
                  } else wn = _i;
                  if (wn == null) break e;
                  xt = Da({}, xt, wn);
                  break e;
                case AR:
                  g0 = !0;
              }
            }
            it = K.callback, it !== null && (n.flags |= 64, Dt && (n.flags |= 8192), Dt = b.callbacks, Dt === null ? b.callbacks = [it] : Dt.push(it));
          } else
            Dt = {
              lane: it,
              tag: K.tag,
              payload: K.payload,
              callback: K.callback,
              next: null
            }, ut === null ? (ge = ut = Dt, de = xt) : ut = ut.next = Dt, X |= it;
          if (K = K.next, K === null) {
            if (K = b.shared.pending, K === null)
              break;
            Dt = K, K = Dt.next, Dt.next = null, b.lastBaseUpdate = Dt, b.shared.pending = null;
          }
        } while (!0);
        ut === null && (de = xt), b.baseState = de, b.firstBaseUpdate = ge, b.lastBaseUpdate = ut, R === null && (b.shared.lanes = 0), A0 |= X, n.lanes = X, n.memoizedState = xt;
      }
      Yx = null;
    }
    function ch(n, i) {
      if (typeof n != "function")
        throw Error(
          "Invalid argument passed as callback. Expected a function. Instead received: " + n
        );
      n.call(i);
    }
    function fd(n, i) {
      var c = n.shared.hiddenCallbacks;
      if (c !== null)
        for (n.shared.hiddenCallbacks = null, n = 0; n < c.length; n++)
          ch(c[n], i);
    }
    function nv(n, i) {
      var c = n.callbacks;
      if (c !== null)
        for (n.callbacks = null, n = 0; n < c.length; n++)
          ch(c[n], i);
    }
    function tr(n, i) {
      var c = Fg;
      _e(xE, c, n), _e(E_, i, n), Fg = c | i.baseLanes;
    }
    function dd(n) {
      _e(xE, Fg, n), _e(
        E_,
        E_.current,
        n
      );
    }
    function tl(n) {
      Fg = xE.current, re(E_, n), re(xE, n);
    }
    function Ca() {
      var n = bt;
      Gm === null ? Gm = [n] : Gm.push(n);
    }
    function Lt() {
      var n = bt;
      if (Gm !== null && (xy++, Gm[xy] !== n)) {
        var i = Q(Ba);
        if (!bR.has(i) && (bR.add(i), Gm !== null)) {
          for (var c = "", g = 0; g <= xy; g++) {
            var b = Gm[g], R = g === xy ? n : b;
            for (b = g + 1 + ". " + b; 30 > b.length; )
              b += " ";
            b += R + `
`, c += b;
          }
          console.error(
            `React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,
            i,
            c
          );
        }
      }
    }
    function Qr(n) {
      n == null || _a(n) || console.error(
        "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
        bt,
        typeof n
      );
    }
    function Ef() {
      var n = Q(Ba);
      xR.has(n) || (xR.add(n), console.error(
        "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
        n
      ));
    }
    function nl() {
      throw Error(
        `Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`
      );
    }
    function hd(n, i) {
      if (P1) return !1;
      if (i === null)
        return console.error(
          "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
          bt
        ), !1;
      n.length !== i.length && console.error(
        `The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,
        bt,
        "[" + i.join(", ") + "]",
        "[" + n.join(", ") + "]"
      );
      for (var c = 0; c < i.length && c < n.length; c++)
        if (!mc(n[c], i[c])) return !1;
      return !0;
    }
    function Xs(n, i, c, g, b, R) {
      y0 = R, Ba = i, Gm = n !== null ? n._debugHookTypes : null, xy = -1, P1 = n !== null && n.type !== i.type, (Object.prototype.toString.call(c) === "[object AsyncFunction]" || Object.prototype.toString.call(c) === "[object AsyncGeneratorFunction]") && (R = Q(Ba), Zx.has(R) || (Zx.add(R), console.error(
        "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
        R === null ? "An unknown Component" : "<" + R + ">"
      ))), i.memoizedState = null, i.updateQueue = null, i.lanes = 0, mt.H = n !== null && n.memoizedState !== null ? jx : Gm !== null ? TR : Qx, uS = R = (i.mode & Wo) !== Xi;
      var X = Jx(c, g, b);
      if (uS = !1, M_ && (X = Ar(
        i,
        c,
        g,
        b
      )), R) {
        ct(!0);
        try {
          X = Ar(
            i,
            c,
            g,
            b
          );
        } finally {
          ct(!1);
        }
      }
      return kh(n, i), X;
    }
    function kh(n, i) {
      i._debugHookTypes = Gm, i.dependencies === null ? My !== null && (i.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: My
      }) : i.dependencies._debugThenableState = My, mt.H = RE;
      var c = Pl !== null && Pl.next !== null;
      if (y0 = 0, Gm = bt = $o = Pl = Ba = null, xy = -1, n !== null && (n.flags & 65011712) !== (i.flags & 65011712) && console.error(
        "Internal React error: Expected static flag was missing. Please notify the React team."
      ), TE = !1, F1 = 0, My = null, c)
        throw Error(
          "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
        );
      n === null || gc || (n = n.dependencies, n !== null && yr(n) && (gc = !0)), ME ? (ME = !1, n = !0) : n = !1, n && (i = Q(i) || "Unknown", MR.has(i) || Zx.has(i) || (MR.add(i), console.error(
        "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
      )));
    }
    function Ar(n, i, c, g) {
      Ba = n;
      var b = 0;
      do {
        if (M_ && (My = null), F1 = 0, M_ = !1, b >= rN)
          throw Error(
            "Too many re-renders. React limits the number of renders to prevent an infinite loop."
          );
        if (b += 1, P1 = !1, $o = Pl = null, n.updateQueue != null) {
          var R = n.updateQueue;
          R.lastEffect = null, R.events = null, R.stores = null, R.memoCache != null && (R.memoCache.index = 0);
        }
        xy = -1, mt.H = CR, R = Jx(i, c, g);
      } while (M_);
      return R;
    }
    function Ss() {
      var n = mt.H, i = n.useState()[0];
      return i = typeof i.then == "function" ? pd(i) : i, n = n.useState()[0], (Pl !== null ? Pl.memoizedState : null) !== n && (Ba.flags |= 1024), i;
    }
    function jr() {
      var n = CE !== 0;
      return CE = 0, n;
    }
    function Ju(n, i, c) {
      i.updateQueue = n.updateQueue, i.flags = (i.mode & Bp) !== Xi ? i.flags & -402655237 : i.flags & -2053, n.lanes &= ~c;
    }
    function Jr(n) {
      if (TE) {
        for (n = n.memoizedState; n !== null; ) {
          var i = n.queue;
          i !== null && (i.pending = null), n = n.next;
        }
        TE = !1;
      }
      y0 = 0, Gm = $o = Pl = Ba = null, xy = -1, bt = null, M_ = !1, F1 = CE = 0, My = null;
    }
    function bi() {
      var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return $o === null ? Ba.memoizedState = $o = n : $o = $o.next = n, $o;
    }
    function fa() {
      if (Pl === null) {
        var n = Ba.alternate;
        n = n !== null ? n.memoizedState : null;
      } else n = Pl.next;
      var i = $o === null ? Ba.memoizedState : $o.next;
      if (i !== null)
        $o = i, Pl = n;
      else {
        if (n === null)
          throw Ba.alternate === null ? Error(
            "Update hook called on initial render. This is likely a bug in React. Please file an issue."
          ) : Error("Rendered more hooks than during the previous render.");
        Pl = n, n = {
          memoizedState: Pl.memoizedState,
          baseState: Pl.baseState,
          baseQueue: Pl.baseQueue,
          queue: Pl.queue,
          next: null
        }, $o === null ? Ba.memoizedState = $o = n : $o = $o.next = n;
      }
      return $o;
    }
    function fh() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function pd(n) {
      var i = F1;
      return F1 += 1, My === null && (My = mu()), n = ql(My, n, i), i = Ba, ($o === null ? i.memoizedState : $o.next) === null && (i = i.alternate, mt.H = i !== null && i.memoizedState !== null ? jx : Qx), n;
    }
    function wo(n) {
      if (n !== null && typeof n == "object") {
        if (typeof n.then == "function") return pd(n);
        if (n.$$typeof === Ru) return Zi(n);
      }
      throw Error("An unsupported type was passed to use(): " + String(n));
    }
    function hl(n) {
      var i = null, c = Ba.updateQueue;
      if (c !== null && (i = c.memoCache), i == null) {
        var g = Ba.alternate;
        g !== null && (g = g.updateQueue, g !== null && (g = g.memoCache, g != null && (i = {
          data: g.data.map(function(b) {
            return b.slice();
          }),
          index: 0
        })));
      }
      if (i == null && (i = { data: [], index: 0 }), c === null && (c = fh(), Ba.updateQueue = c), c.memoCache = i, c = i.data[i.index], c === void 0 || P1)
        for (c = i.data[i.index] = Array(n), g = 0; g < n; g++)
          c[g] = Av;
      else
        c.length !== n && console.error(
          "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
          c.length,
          n
        );
      return i.index++, c;
    }
    function Ua(n, i) {
      return typeof i == "function" ? i(n) : i;
    }
    function Ln(n, i, c) {
      var g = bi();
      if (c !== void 0) {
        var b = c(i);
        if (uS) {
          ct(!0);
          try {
            c(i);
          } finally {
            ct(!1);
          }
        }
      } else b = i;
      return g.memoizedState = g.baseState = b, n = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: n,
        lastRenderedState: b
      }, g.queue = n, n = n.dispatch = lg.bind(
        null,
        Ba,
        n
      ), [g.memoizedState, n];
    }
    function as(n) {
      var i = fa();
      return Er(i, Pl, n);
    }
    function Er(n, i, c) {
      var g = n.queue;
      if (g === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      g.lastRenderedReducer = c;
      var b = n.baseQueue, R = g.pending;
      if (R !== null) {
        if (b !== null) {
          var X = b.next;
          b.next = R.next, R.next = X;
        }
        i.baseQueue !== b && console.error(
          "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
        ), i.baseQueue = b = R, g.pending = null;
      }
      if (R = n.baseState, b === null) n.memoizedState = R;
      else {
        i = b.next;
        var K = X = null, de = null, ge = i, ut = !1;
        do {
          var xt = ge.lane & -536870913;
          if (xt !== ge.lane ? (gi & xt) === xt : (y0 & xt) === xt) {
            var it = ge.revertLane;
            if (it === 0)
              de !== null && (de = de.next = {
                lane: 0,
                revertLane: 0,
                action: ge.action,
                hasEagerState: ge.hasEagerState,
                eagerState: ge.eagerState,
                next: null
              }), xt === Na && (ut = !0);
            else if ((y0 & it) === it) {
              ge = ge.next, it === Na && (ut = !0);
              continue;
            } else
              xt = {
                lane: 0,
                revertLane: ge.revertLane,
                action: ge.action,
                hasEagerState: ge.hasEagerState,
                eagerState: ge.eagerState,
                next: null
              }, de === null ? (K = de = xt, X = R) : de = de.next = xt, Ba.lanes |= it, A0 |= it;
            xt = ge.action, uS && c(R, xt), R = ge.hasEagerState ? ge.eagerState : c(R, xt);
          } else
            it = {
              lane: xt,
              revertLane: ge.revertLane,
              action: ge.action,
              hasEagerState: ge.hasEagerState,
              eagerState: ge.eagerState,
              next: null
            }, de === null ? (K = de = it, X = R) : de = de.next = it, Ba.lanes |= xt, A0 |= xt;
          ge = ge.next;
        } while (ge !== null && ge !== i);
        if (de === null ? X = R : de.next = K, !mc(R, n.memoizedState) && (gc = !0, ut && (c = vi, c !== null)))
          throw c;
        n.memoizedState = R, n.baseState = X, n.baseQueue = de, g.lastRenderedState = R;
      }
      return b === null && (g.lanes = 0), [n.memoizedState, g.dispatch];
    }
    function bf(n) {
      var i = fa(), c = i.queue;
      if (c === null)
        throw Error(
          "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
        );
      c.lastRenderedReducer = n;
      var g = c.dispatch, b = c.pending, R = i.memoizedState;
      if (b !== null) {
        c.pending = null;
        var X = b = b.next;
        do
          R = n(R, X.action), X = X.next;
        while (X !== b);
        mc(R, i.memoizedState) || (gc = !0), i.memoizedState = R, i.baseQueue === null && (i.baseState = R), c.lastRenderedState = R;
      }
      return [R, g];
    }
    function br(n, i, c) {
      var g = Ba, b = bi();
      if (Di) {
        if (c === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        var R = c();
        b_ || R === c() || (console.error(
          "The result of getServerSnapshot should be cached to avoid an infinite loop"
        ), b_ = !0);
      } else {
        if (R = i(), b_ || (c = i(), mc(R, c) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), b_ = !0)), Wl === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        (gi & 124) !== 0 || Wp(g, i, R);
      }
      return b.memoizedState = R, c = { value: R, getSnapshot: i }, b.queue = c, Mr(
        dh.bind(null, g, c, n),
        [n]
      ), g.flags |= 2048, yu(
        Lm | Gu,
        Mf(),
        Kr.bind(
          null,
          g,
          c,
          R,
          i
        ),
        null
      ), R;
    }
    function md(n, i, c) {
      var g = Ba, b = fa(), R = Di;
      if (R) {
        if (c === void 0)
          throw Error(
            "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
          );
        c = c();
      } else if (c = i(), !b_) {
        var X = i();
        mc(c, X) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), b_ = !0);
      }
      (X = !mc(
        (Pl || b).memoizedState,
        c
      )) && (b.memoizedState = c, gc = !0), b = b.queue;
      var K = dh.bind(null, g, b, n);
      if (is(2048, Gu, K, [n]), b.getSnapshot !== i || X || $o !== null && $o.memoizedState.tag & Lm) {
        if (g.flags |= 2048, yu(
          Lm | Gu,
          Mf(),
          Kr.bind(
            null,
            g,
            b,
            c,
            i
          ),
          null
        ), Wl === null)
          throw Error(
            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
          );
        R || (y0 & 124) !== 0 || Wp(g, i, c);
      }
      return c;
    }
    function Wp(n, i, c) {
      n.flags |= 16384, n = { getSnapshot: i, value: c }, i = Ba.updateQueue, i === null ? (i = fh(), Ba.updateQueue = i, i.stores = [n]) : (c = i.stores, c === null ? i.stores = [n] : c.push(n));
    }
    function Kr(n, i, c, g) {
      i.value = c, i.getSnapshot = g, va(i) && vd(n);
    }
    function dh(n, i, c) {
      return c(function() {
        va(i) && vd(n);
      });
    }
    function va(n) {
      var i = n.getSnapshot;
      n = n.value;
      try {
        var c = i();
        return !mc(n, c);
      } catch {
        return !0;
      }
    }
    function vd(n) {
      var i = mr(n, 2);
      i !== null && Cl(i, n, 2);
    }
    function Wh(n) {
      var i = bi();
      if (typeof n == "function") {
        var c = n;
        if (n = c(), uS) {
          ct(!0);
          try {
            c();
          } finally {
            ct(!1);
          }
        }
      }
      return i.memoizedState = i.baseState = n, i.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ua,
        lastRenderedState: n
      }, i;
    }
    function Bc(n) {
      n = Wh(n);
      var i = n.queue, c = nm.bind(null, Ba, i);
      return i.dispatch = c, [n.memoizedState, c];
    }
    function Ku(n) {
      var i = bi();
      i.memoizedState = i.baseState = n;
      var c = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return i.queue = c, i = Sd.bind(
        null,
        Ba,
        !0,
        c
      ), c.dispatch = i, [n, i];
    }
    function Uc(n, i) {
      var c = fa();
      return ku(c, Pl, n, i);
    }
    function ku(n, i, c, g) {
      return n.baseState = c, Er(
        n,
        Pl,
        typeof g == "function" ? g : Ua
      );
    }
    function av(n, i) {
      var c = fa();
      return Pl !== null ? ku(c, Pl, n, i) : (c.baseState = n, [n, c.queue.dispatch]);
    }
    function hh(n, i, c, g, b) {
      if (Cf(n))
        throw Error("Cannot update form state while rendering.");
      if (n = i.action, n !== null) {
        var R = {
          payload: b,
          action: n,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(X) {
            R.listeners.push(X);
          }
        };
        mt.T !== null ? c(!0) : R.isTransition = !1, g(R), c = i.pending, c === null ? (R.next = i.pending = R, nr(i, R)) : (R.next = c.next, i.pending = c.next = R);
      }
    }
    function nr(n, i) {
      var c = i.action, g = i.payload, b = n.state;
      if (i.isTransition) {
        var R = mt.T, X = {};
        mt.T = X, mt.T._updatedFibers = /* @__PURE__ */ new Set();
        try {
          var K = c(b, g), de = mt.S;
          de !== null && de(X, K), Oi(n, i, K);
        } catch (ge) {
          pl(n, i, ge);
        } finally {
          mt.T = R, R === null && X._updatedFibers && (n = X._updatedFibers.size, X._updatedFibers.clear(), 10 < n && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          ));
        }
      } else
        try {
          X = c(b, g), Oi(n, i, X);
        } catch (ge) {
          pl(n, i, ge);
        }
    }
    function Oi(n, i, c) {
      c !== null && typeof c == "object" && typeof c.then == "function" ? (c.then(
        function(g) {
          Oc(n, i, g);
        },
        function(g) {
          return pl(n, i, g);
        }
      ), i.isTransition || console.error(
        "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
      )) : Oc(n, i, c);
    }
    function Oc(n, i, c) {
      i.status = "fulfilled", i.value = c, $h(i), n.state = c, i = n.pending, i !== null && (c = i.next, c === i ? n.pending = null : (c = c.next, i.next = c, nr(n, c)));
    }
    function pl(n, i, c) {
      var g = n.pending;
      if (n.pending = null, g !== null) {
        g = g.next;
        do
          i.status = "rejected", i.reason = c, $h(i), i = i.next;
        while (i !== g);
      }
      n.action = null;
    }
    function $h(n) {
      n = n.listeners;
      for (var i = 0; i < n.length; i++) (0, n[i])();
    }
    function No(n, i) {
      return i;
    }
    function gd(n, i) {
      if (Di) {
        var c = Wl.formState;
        if (c !== null) {
          e: {
            var g = Ba;
            if (Di) {
              if (Hs) {
                t: {
                  for (var b = Hs, R = Up; b.nodeType !== 8; ) {
                    if (!R) {
                      b = null;
                      break t;
                    }
                    if (b = Al(
                      b.nextSibling
                    ), b === null) {
                      b = null;
                      break t;
                    }
                  }
                  R = b.data, b = R === AT || R === xD ? b : null;
                }
                if (b) {
                  Hs = Al(
                    b.nextSibling
                  ), g = b.data === AT;
                  break e;
                }
              }
              $s(g);
            }
            g = !1;
          }
          g && (i = c[0]);
        }
      }
      return c = bi(), c.memoizedState = c.baseState = i, g = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: No,
        lastRenderedState: i
      }, c.queue = g, c = nm.bind(
        null,
        Ba,
        g
      ), g.dispatch = c, g = Wh(!1), R = Sd.bind(
        null,
        Ba,
        !1,
        g.queue
      ), g = bi(), b = {
        state: i,
        dispatch: null,
        action: n,
        pending: null
      }, g.queue = b, c = hh.bind(
        null,
        Ba,
        b,
        R,
        c
      ), b.dispatch = c, g.memoizedState = n, [i, c, !1];
    }
    function $p(n) {
      var i = fa();
      return ep(i, Pl, n);
    }
    function ep(n, i, c) {
      if (i = Er(
        n,
        i,
        No
      )[0], n = as(Ua)[0], typeof i == "object" && i !== null && typeof i.then == "function")
        try {
          var g = pd(i);
        } catch (X) {
          throw X === rl ? Gh : X;
        }
      else g = i;
      i = fa();
      var b = i.queue, R = b.dispatch;
      return c !== i.memoizedState && (Ba.flags |= 2048, yu(
        Lm | Gu,
        Mf(),
        al.bind(null, b, c),
        null
      )), [g, R, n];
    }
    function al(n, i) {
      n.action = i;
    }
    function ph(n) {
      var i = fa(), c = Pl;
      if (c !== null)
        return ep(i, c, n);
      fa(), i = i.memoizedState, c = fa();
      var g = c.queue.dispatch;
      return c.memoizedState = n, [i, g, !1];
    }
    function yu(n, i, c, g) {
      return n = {
        tag: n,
        create: c,
        deps: g,
        inst: i,
        next: null
      }, i = Ba.updateQueue, i === null && (i = fh(), Ba.updateQueue = i), c = i.lastEffect, c === null ? i.lastEffect = n.next = n : (g = c.next, c.next = n, n.next = g, i.lastEffect = n), n;
    }
    function Mf() {
      return { destroy: void 0, resource: void 0 };
    }
    function tp(n) {
      var i = bi();
      return n = { current: n }, i.memoizedState = n;
    }
    function na(n, i, c, g) {
      var b = bi();
      g = g === void 0 ? null : g, Ba.flags |= n, b.memoizedState = yu(
        Lm | i,
        Mf(),
        c,
        g
      );
    }
    function is(n, i, c, g) {
      var b = fa();
      g = g === void 0 ? null : g;
      var R = b.memoizedState.inst;
      Pl !== null && g !== null && hd(g, Pl.memoizedState.deps) ? b.memoizedState = yu(i, R, c, g) : (Ba.flags |= n, b.memoizedState = yu(
        Lm | i,
        R,
        c,
        g
      ));
    }
    function Mr(n, i) {
      (Ba.mode & Bp) !== Xi && (Ba.mode & m0) === Xi ? na(276826112, Gu, n, i) : na(8390656, Gu, n, i);
    }
    function Wu(n, i) {
      var c = 4194308;
      return (Ba.mode & Bp) !== Xi && (c |= 134217728), na(c, nf, n, i);
    }
    function zo(n, i) {
      if (typeof i == "function") {
        n = n();
        var c = i(n);
        return function() {
          typeof c == "function" ? c() : i(null);
        };
      }
      if (i != null)
        return i.hasOwnProperty("current") || console.error(
          "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
          "an object with keys {" + Object.keys(i).join(", ") + "}"
        ), n = n(), i.current = n, function() {
          i.current = null;
        };
    }
    function mh(n, i, c) {
      typeof i != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        i !== null ? typeof i : "null"
      ), c = c != null ? c.concat([n]) : null;
      var g = 4194308;
      (Ba.mode & Bp) !== Xi && (g |= 134217728), na(
        g,
        nf,
        zo.bind(null, i, n),
        c
      );
    }
    function kr(n, i, c) {
      typeof i != "function" && console.error(
        "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
        i !== null ? typeof i : "null"
      ), c = c != null ? c.concat([n]) : null, is(
        4,
        nf,
        zo.bind(null, i, n),
        c
      );
    }
    function wc(n, i) {
      return bi().memoizedState = [
        n,
        i === void 0 ? null : i
      ], n;
    }
    function yd(n, i) {
      var c = fa();
      i = i === void 0 ? null : i;
      var g = c.memoizedState;
      return i !== null && hd(i, g[1]) ? g[0] : (c.memoizedState = [n, i], n);
    }
    function np(n, i) {
      var c = bi();
      i = i === void 0 ? null : i;
      var g = n();
      if (uS) {
        ct(!0);
        try {
          n();
        } finally {
          ct(!1);
        }
      }
      return c.memoizedState = [g, i], g;
    }
    function xf(n, i) {
      var c = fa();
      i = i === void 0 ? null : i;
      var g = c.memoizedState;
      if (i !== null && hd(i, g[1]))
        return g[0];
      if (g = n(), uS) {
        ct(!0);
        try {
          n();
        } finally {
          ct(!1);
        }
      }
      return c.memoizedState = [g, i], g;
    }
    function ap(n, i) {
      var c = bi();
      return ip(c, n, i);
    }
    function Wr(n, i) {
      var c = fa();
      return lp(
        c,
        Pl.memoizedState,
        n,
        i
      );
    }
    function em(n, i) {
      var c = fa();
      return Pl === null ? ip(c, n, i) : lp(
        c,
        Pl.memoizedState,
        n,
        i
      );
    }
    function ip(n, i, c) {
      return c === void 0 || (y0 & 1073741824) !== 0 ? n.memoizedState = i : (n.memoizedState = c, n = ty(), Ba.lanes |= n, A0 |= n, c);
    }
    function lp(n, i, c, g) {
      return mc(c, i) ? c : E_.current !== null ? (n = ip(n, c, g), mc(n, i) || (gc = !0), n) : (y0 & 42) === 0 ? (gc = !0, n.memoizedState = c) : (n = ty(), Ba.lanes |= n, A0 |= n, i);
    }
    function tm(n, i, c, g, b) {
      var R = Kn.p;
      Kn.p = R !== 0 && R < Yf ? R : Yf;
      var X = mt.T, K = {};
      mt.T = K, Sd(n, !1, i, c), K._updatedFibers = /* @__PURE__ */ new Set();
      try {
        var de = b(), ge = mt.S;
        if (ge !== null && ge(K, de), de !== null && typeof de == "object" && typeof de.then == "function") {
          var ut = _r(
            de,
            g
          );
          _s(
            n,
            i,
            ut,
            ir(n)
          );
        } else
          _s(
            n,
            i,
            g,
            ir(n)
          );
      } catch (xt) {
        _s(
          n,
          i,
          { then: function() {
          }, status: "rejected", reason: xt },
          ir(n)
        );
      } finally {
        Kn.p = R, mt.T = X, X === null && K._updatedFibers && (n = K._updatedFibers.size, K._updatedFibers.clear(), 10 < n && console.warn(
          "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
        ));
      }
    }
    function $r(n, i, c, g) {
      if (n.tag !== 5)
        throw Error(
          "Expected the form instance to be a HostComponent. This is a bug in React."
        );
      var b = Ho(n).queue;
      tm(
        n,
        b,
        i,
        _S,
        c === null ? T : function() {
          return iv(n), c(g);
        }
      );
    }
    function Ho(n) {
      var i = n.memoizedState;
      if (i !== null) return i;
      i = {
        memoizedState: _S,
        baseState: _S,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Ua,
          lastRenderedState: _S
        },
        next: null
      };
      var c = {};
      return i.next = {
        memoizedState: c,
        baseState: c,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Ua,
          lastRenderedState: c
        },
        next: null
      }, n.memoizedState = i, n = n.alternate, n !== null && (n.memoizedState = i), i;
    }
    function iv(n) {
      mt.T === null && console.error(
        "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
      );
      var i = Ho(n).next.queue;
      _s(
        n,
        i,
        {},
        ir(n)
      );
    }
    function $u() {
      var n = Wh(!1);
      return n = tm.bind(
        null,
        Ba,
        n.queue,
        !0,
        !1
      ), bi().memoizedState = n, [!1, n];
    }
    function ig() {
      var n = as(Ua)[0], i = fa().memoizedState;
      return [
        typeof n == "boolean" ? n : pd(n),
        i
      ];
    }
    function $n() {
      var n = bf(Ua)[0], i = fa().memoizedState;
      return [
        typeof n == "boolean" ? n : pd(n),
        i
      ];
    }
    function xr() {
      return Zi(lA);
    }
    function ml() {
      var n = bi(), i = Wl.identifierPrefix;
      if (Di) {
        var c = Hh, g = Lv;
        c = (g & ~(1 << 32 - po(g) - 1)).toString(32) + c, i = "" + i + "R" + c, c = CE++, 0 < c && (i += "H" + c.toString(32)), i += "";
      } else
        c = sN++, i = "" + i + "r" + c.toString(32) + "";
      return n.memoizedState = i;
    }
    function Tf() {
      return bi().memoizedState = Ys.bind(
        null,
        Ba
      );
    }
    function Ys(n, i) {
      for (var c = n.return; c !== null; ) {
        switch (c.tag) {
          case 24:
          case 3:
            var g = ir(c);
            n = ju(g);
            var b = vu(c, n, g);
            b !== null && (Cl(b, c, g), gu(b, c, g)), c = rh(), i != null && b !== null && console.error(
              "The seed argument is not enabled outside experimental channels."
            ), n.payload = { cache: c };
            return;
        }
        c = c.return;
      }
    }
    function lg(n, i, c) {
      var g = arguments;
      typeof g[3] == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), g = ir(n);
      var b = {
        lane: g,
        revertLane: 0,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      Cf(n) ? vh(i, b) : (b = Yp(n, i, b, g), b !== null && (Cl(b, n, g), Su(b, i, g))), Rn(n, g);
    }
    function nm(n, i, c) {
      var g = arguments;
      typeof g[3] == "function" && console.error(
        "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
      ), g = ir(n), _s(n, i, c, g), Rn(n, g);
    }
    function _s(n, i, c, g) {
      var b = {
        lane: g,
        revertLane: 0,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Cf(n)) vh(i, b);
      else {
        var R = n.alternate;
        if (n.lanes === 0 && (R === null || R.lanes === 0) && (R = i.lastRenderedReducer, R !== null)) {
          var X = mt.H;
          mt.H = Gv;
          try {
            var K = i.lastRenderedState, de = R(K, c);
            if (b.hasEagerState = !0, b.eagerState = de, mc(de, K))
              return $d(n, i, b, 0), Wl === null && rd(), !1;
          } catch {
          } finally {
            mt.H = X;
          }
        }
        if (c = Yp(n, i, b, g), c !== null)
          return Cl(c, n, g), Su(c, i, g), !0;
      }
      return !1;
    }
    function Sd(n, i, c, g) {
      if (mt.T === null && Na === 0 && console.error(
        "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
      ), g = {
        lane: 2,
        revertLane: Jl(),
        action: g,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, Cf(n)) {
        if (i)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        i = Yp(
          n,
          c,
          g,
          2
        ), i !== null && Cl(i, n, 2);
      Rn(n, 2);
    }
    function Cf(n) {
      var i = n.alternate;
      return n === Ba || i !== null && i === Ba;
    }
    function vh(n, i) {
      M_ = TE = !0;
      var c = n.pending;
      c === null ? i.next = i : (i.next = c.next, c.next = i), n.pending = i;
    }
    function Su(n, i, c) {
      if ((c & 4194048) !== 0) {
        var g = i.lanes;
        g &= n.pendingLanes, c |= g, i.lanes = c, yt(n, c);
      }
    }
    function ls(n) {
      var i = ai;
      return n != null && (ai = i === null ? n : i.concat(n)), i;
    }
    function gh(n, i, c) {
      for (var g = Object.keys(n.props), b = 0; b < g.length; b++) {
        var R = g[b];
        if (R !== "children" && R !== "key") {
          i === null && (i = od(n, c.mode, 0), i._debugInfo = ai, i.return = c), un(
            i,
            function(X) {
              console.error(
                "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                X
              );
            },
            R
          );
          break;
        }
      }
    }
    function eo(n) {
      var i = X1;
      return X1 += 1, x_ === null && (x_ = mu()), ql(x_, n, i);
    }
    function Lo(n, i) {
      i = i.props.ref, n.ref = i !== void 0 ? i : null;
    }
    function ea(n, i) {
      throw i.$$typeof === Nr ? Error(
        `A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`
      ) : (n = Object.prototype.toString.call(i), Error(
        "Objects are not valid as a React child (found: " + (n === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : n) + "). If you meant to render a collection of children, use an array instead."
      ));
    }
    function di(n, i) {
      var c = Q(n) || "Component";
      PR[c] || (PR[c] = !0, i = i.displayName || i.name || "Component", n.tag === 3 ? console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`,
        i,
        i,
        i
      ) : console.error(
        `Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`,
        i,
        i,
        c,
        i,
        c
      ));
    }
    function Qi(n, i) {
      var c = Q(n) || "Component";
      XR[c] || (XR[c] = !0, i = String(i), n.tag === 3 ? console.error(
        `Symbols are not valid as a React child.
  root.render(%s)`,
        i
      ) : console.error(
        `Symbols are not valid as a React child.
  <%s>%s</%s>`,
        c,
        i,
        c
      ));
    }
    function Nc(n) {
      function i(Ce, Oe) {
        if (n) {
          var Fe = Ce.deletions;
          Fe === null ? (Ce.deletions = [Oe], Ce.flags |= 16) : Fe.push(Oe);
        }
      }
      function c(Ce, Oe) {
        if (!n) return null;
        for (; Oe !== null; )
          i(Ce, Oe), Oe = Oe.sibling;
        return null;
      }
      function g(Ce) {
        for (var Oe = /* @__PURE__ */ new Map(); Ce !== null; )
          Ce.key !== null ? Oe.set(Ce.key, Ce) : Oe.set(Ce.index, Ce), Ce = Ce.sibling;
        return Oe;
      }
      function b(Ce, Oe) {
        return Ce = cu(Ce, Oe), Ce.index = 0, Ce.sibling = null, Ce;
      }
      function R(Ce, Oe, Fe) {
        return Ce.index = Fe, n ? (Fe = Ce.alternate, Fe !== null ? (Fe = Fe.index, Fe < Oe ? (Ce.flags |= 67108866, Oe) : Fe) : (Ce.flags |= 67108866, Oe)) : (Ce.flags |= 1048576, Oe);
      }
      function X(Ce) {
        return n && Ce.alternate === null && (Ce.flags |= 67108866), Ce;
      }
      function K(Ce, Oe, Fe, Bt) {
        return Oe === null || Oe.tag !== 6 ? (Oe = Cc(
          Fe,
          Ce.mode,
          Bt
        ), Oe.return = Ce, Oe._debugOwner = Ce, Oe._debugTask = Ce._debugTask, Oe._debugInfo = ai, Oe) : (Oe = b(Oe, Fe), Oe.return = Ce, Oe._debugInfo = ai, Oe);
      }
      function de(Ce, Oe, Fe, Bt) {
        var fn = Fe.type;
        return fn === Sa ? (Oe = ut(
          Ce,
          Oe,
          Fe.props.children,
          Bt,
          Fe.key
        ), gh(Fe, Oe, Ce), Oe) : Oe !== null && (Oe.elementType === fn || xc(Oe, Fe) || typeof fn == "object" && fn !== null && fn.$$typeof === Du && S0(fn) === Oe.type) ? (Oe = b(Oe, Fe.props), Lo(Oe, Fe), Oe.return = Ce, Oe._debugOwner = Fe._owner, Oe._debugInfo = ai, Oe) : (Oe = od(Fe, Ce.mode, Bt), Lo(Oe, Fe), Oe.return = Ce, Oe._debugInfo = ai, Oe);
      }
      function ge(Ce, Oe, Fe, Bt) {
        return Oe === null || Oe.tag !== 4 || Oe.stateNode.containerInfo !== Fe.containerInfo || Oe.stateNode.implementation !== Fe.implementation ? (Oe = ih(Fe, Ce.mode, Bt), Oe.return = Ce, Oe._debugInfo = ai, Oe) : (Oe = b(Oe, Fe.children || []), Oe.return = Ce, Oe._debugInfo = ai, Oe);
      }
      function ut(Ce, Oe, Fe, Bt, fn) {
        return Oe === null || Oe.tag !== 7 ? (Oe = Tc(
          Fe,
          Ce.mode,
          Bt,
          fn
        ), Oe.return = Ce, Oe._debugOwner = Ce, Oe._debugTask = Ce._debugTask, Oe._debugInfo = ai, Oe) : (Oe = b(Oe, Fe), Oe.return = Ce, Oe._debugInfo = ai, Oe);
      }
      function xt(Ce, Oe, Fe) {
        if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number" || typeof Oe == "bigint")
          return Oe = Cc(
            "" + Oe,
            Ce.mode,
            Fe
          ), Oe.return = Ce, Oe._debugOwner = Ce, Oe._debugTask = Ce._debugTask, Oe._debugInfo = ai, Oe;
        if (typeof Oe == "object" && Oe !== null) {
          switch (Oe.$$typeof) {
            case fc:
              return Fe = od(
                Oe,
                Ce.mode,
                Fe
              ), Lo(Fe, Oe), Fe.return = Ce, Ce = ls(Oe._debugInfo), Fe._debugInfo = ai, ai = Ce, Fe;
            case Bh:
              return Oe = ih(
                Oe,
                Ce.mode,
                Fe
              ), Oe.return = Ce, Oe._debugInfo = ai, Oe;
            case Du:
              var Bt = ls(Oe._debugInfo);
              return Oe = S0(Oe), Ce = xt(Ce, Oe, Fe), ai = Bt, Ce;
          }
          if (_a(Oe) || k(Oe))
            return Fe = Tc(
              Oe,
              Ce.mode,
              Fe,
              null
            ), Fe.return = Ce, Fe._debugOwner = Ce, Fe._debugTask = Ce._debugTask, Ce = ls(Oe._debugInfo), Fe._debugInfo = ai, ai = Ce, Fe;
          if (typeof Oe.then == "function")
            return Bt = ls(Oe._debugInfo), Ce = xt(
              Ce,
              eo(Oe),
              Fe
            ), ai = Bt, Ce;
          if (Oe.$$typeof === Ru)
            return xt(
              Ce,
              Kh(Ce, Oe),
              Fe
            );
          ea(Ce, Oe);
        }
        return typeof Oe == "function" && di(Ce, Oe), typeof Oe == "symbol" && Qi(Ce, Oe), null;
      }
      function it(Ce, Oe, Fe, Bt) {
        var fn = Oe !== null ? Oe.key : null;
        if (typeof Fe == "string" && Fe !== "" || typeof Fe == "number" || typeof Fe == "bigint")
          return fn !== null ? null : K(Ce, Oe, "" + Fe, Bt);
        if (typeof Fe == "object" && Fe !== null) {
          switch (Fe.$$typeof) {
            case fc:
              return Fe.key === fn ? (fn = ls(Fe._debugInfo), Ce = de(
                Ce,
                Oe,
                Fe,
                Bt
              ), ai = fn, Ce) : null;
            case Bh:
              return Fe.key === fn ? ge(Ce, Oe, Fe, Bt) : null;
            case Du:
              return fn = ls(Fe._debugInfo), Fe = S0(Fe), Ce = it(
                Ce,
                Oe,
                Fe,
                Bt
              ), ai = fn, Ce;
          }
          if (_a(Fe) || k(Fe))
            return fn !== null ? null : (fn = ls(Fe._debugInfo), Ce = ut(
              Ce,
              Oe,
              Fe,
              Bt,
              null
            ), ai = fn, Ce);
          if (typeof Fe.then == "function")
            return fn = ls(Fe._debugInfo), Ce = it(
              Ce,
              Oe,
              eo(Fe),
              Bt
            ), ai = fn, Ce;
          if (Fe.$$typeof === Ru)
            return it(
              Ce,
              Oe,
              Kh(Ce, Fe),
              Bt
            );
          ea(Ce, Fe);
        }
        return typeof Fe == "function" && di(Ce, Fe), typeof Fe == "symbol" && Qi(Ce, Fe), null;
      }
      function Dt(Ce, Oe, Fe, Bt, fn) {
        if (typeof Bt == "string" && Bt !== "" || typeof Bt == "number" || typeof Bt == "bigint")
          return Ce = Ce.get(Fe) || null, K(Oe, Ce, "" + Bt, fn);
        if (typeof Bt == "object" && Bt !== null) {
          switch (Bt.$$typeof) {
            case fc:
              return Fe = Ce.get(
                Bt.key === null ? Fe : Bt.key
              ) || null, Ce = ls(Bt._debugInfo), Oe = de(
                Oe,
                Fe,
                Bt,
                fn
              ), ai = Ce, Oe;
            case Bh:
              return Ce = Ce.get(
                Bt.key === null ? Fe : Bt.key
              ) || null, ge(Oe, Ce, Bt, fn);
            case Du:
              var Ia = ls(Bt._debugInfo);
              return Bt = S0(Bt), Oe = Dt(
                Ce,
                Oe,
                Fe,
                Bt,
                fn
              ), ai = Ia, Oe;
          }
          if (_a(Bt) || k(Bt))
            return Fe = Ce.get(Fe) || null, Ce = ls(Bt._debugInfo), Oe = ut(
              Oe,
              Fe,
              Bt,
              fn,
              null
            ), ai = Ce, Oe;
          if (typeof Bt.then == "function")
            return Ia = ls(Bt._debugInfo), Oe = Dt(
              Ce,
              Oe,
              Fe,
              eo(Bt),
              fn
            ), ai = Ia, Oe;
          if (Bt.$$typeof === Ru)
            return Dt(
              Ce,
              Oe,
              Fe,
              Kh(Oe, Bt),
              fn
            );
          ea(Oe, Bt);
        }
        return typeof Bt == "function" && di(Oe, Bt), typeof Bt == "symbol" && Qi(Oe, Bt), null;
      }
      function wn(Ce, Oe, Fe, Bt) {
        if (typeof Fe != "object" || Fe === null) return Bt;
        switch (Fe.$$typeof) {
          case fc:
          case Bh:
            y(Ce, Oe, Fe);
            var fn = Fe.key;
            if (typeof fn != "string") break;
            if (Bt === null) {
              Bt = /* @__PURE__ */ new Set(), Bt.add(fn);
              break;
            }
            if (!Bt.has(fn)) {
              Bt.add(fn);
              break;
            }
            un(Oe, function() {
              console.error(
                "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.",
                fn
              );
            });
            break;
          case Du:
            Fe = S0(Fe), wn(Ce, Oe, Fe, Bt);
        }
        return Bt;
      }
      function Ea(Ce, Oe, Fe, Bt) {
        for (var fn = null, Ia = null, Nn = null, Va = Oe, Qa = Oe = 0, ps = null; Va !== null && Qa < Fe.length; Qa++) {
          Va.index > Qa ? (ps = Va, Va = null) : ps = Va.sibling;
          var Eo = it(
            Ce,
            Va,
            Fe[Qa],
            Bt
          );
          if (Eo === null) {
            Va === null && (Va = ps);
            break;
          }
          fn = wn(
            Ce,
            Eo,
            Fe[Qa],
            fn
          ), n && Va && Eo.alternate === null && i(Ce, Va), Oe = R(Eo, Oe, Qa), Nn === null ? Ia = Eo : Nn.sibling = Eo, Nn = Eo, Va = ps;
        }
        if (Qa === Fe.length)
          return c(Ce, Va), Di && Bo(Ce, Qa), Ia;
        if (Va === null) {
          for (; Qa < Fe.length; Qa++)
            Va = xt(Ce, Fe[Qa], Bt), Va !== null && (fn = wn(
              Ce,
              Va,
              Fe[Qa],
              fn
            ), Oe = R(
              Va,
              Oe,
              Qa
            ), Nn === null ? Ia = Va : Nn.sibling = Va, Nn = Va);
          return Di && Bo(Ce, Qa), Ia;
        }
        for (Va = g(Va); Qa < Fe.length; Qa++)
          ps = Dt(
            Va,
            Ce,
            Qa,
            Fe[Qa],
            Bt
          ), ps !== null && (fn = wn(
            Ce,
            ps,
            Fe[Qa],
            fn
          ), n && ps.alternate !== null && Va.delete(
            ps.key === null ? Qa : ps.key
          ), Oe = R(
            ps,
            Oe,
            Qa
          ), Nn === null ? Ia = ps : Nn.sibling = ps, Nn = ps);
        return n && Va.forEach(function(Uy) {
          return i(Ce, Uy);
        }), Di && Bo(Ce, Qa), Ia;
      }
      function $l(Ce, Oe, Fe, Bt) {
        if (Fe == null)
          throw Error("An iterable object provided no iterator.");
        for (var fn = null, Ia = null, Nn = Oe, Va = Oe = 0, Qa = null, ps = null, Eo = Fe.next(); Nn !== null && !Eo.done; Va++, Eo = Fe.next()) {
          Nn.index > Va ? (Qa = Nn, Nn = null) : Qa = Nn.sibling;
          var Uy = it(Ce, Nn, Eo.value, Bt);
          if (Uy === null) {
            Nn === null && (Nn = Qa);
            break;
          }
          ps = wn(
            Ce,
            Uy,
            Eo.value,
            ps
          ), n && Nn && Uy.alternate === null && i(Ce, Nn), Oe = R(Uy, Oe, Va), Ia === null ? fn = Uy : Ia.sibling = Uy, Ia = Uy, Nn = Qa;
        }
        if (Eo.done)
          return c(Ce, Nn), Di && Bo(Ce, Va), fn;
        if (Nn === null) {
          for (; !Eo.done; Va++, Eo = Fe.next())
            Nn = xt(Ce, Eo.value, Bt), Nn !== null && (ps = wn(
              Ce,
              Nn,
              Eo.value,
              ps
            ), Oe = R(
              Nn,
              Oe,
              Va
            ), Ia === null ? fn = Nn : Ia.sibling = Nn, Ia = Nn);
          return Di && Bo(Ce, Va), fn;
        }
        for (Nn = g(Nn); !Eo.done; Va++, Eo = Fe.next())
          Qa = Dt(
            Nn,
            Ce,
            Va,
            Eo.value,
            Bt
          ), Qa !== null && (ps = wn(
            Ce,
            Qa,
            Eo.value,
            ps
          ), n && Qa.alternate !== null && Nn.delete(
            Qa.key === null ? Va : Qa.key
          ), Oe = R(
            Qa,
            Oe,
            Va
          ), Ia === null ? fn = Qa : Ia.sibling = Qa, Ia = Qa);
        return n && Nn.forEach(function(wN) {
          return i(Ce, wN);
        }), Di && Bo(Ce, Va), fn;
      }
      function _i(Ce, Oe, Fe, Bt) {
        if (typeof Fe == "object" && Fe !== null && Fe.type === Sa && Fe.key === null && (gh(Fe, null, Ce), Fe = Fe.props.children), typeof Fe == "object" && Fe !== null) {
          switch (Fe.$$typeof) {
            case fc:
              var fn = ls(Fe._debugInfo);
              e: {
                for (var Ia = Fe.key; Oe !== null; ) {
                  if (Oe.key === Ia) {
                    if (Ia = Fe.type, Ia === Sa) {
                      if (Oe.tag === 7) {
                        c(
                          Ce,
                          Oe.sibling
                        ), Bt = b(
                          Oe,
                          Fe.props.children
                        ), Bt.return = Ce, Bt._debugOwner = Fe._owner, Bt._debugInfo = ai, gh(Fe, Bt, Ce), Ce = Bt;
                        break e;
                      }
                    } else if (Oe.elementType === Ia || xc(
                      Oe,
                      Fe
                    ) || typeof Ia == "object" && Ia !== null && Ia.$$typeof === Du && S0(Ia) === Oe.type) {
                      c(
                        Ce,
                        Oe.sibling
                      ), Bt = b(Oe, Fe.props), Lo(Bt, Fe), Bt.return = Ce, Bt._debugOwner = Fe._owner, Bt._debugInfo = ai, Ce = Bt;
                      break e;
                    }
                    c(Ce, Oe);
                    break;
                  } else i(Ce, Oe);
                  Oe = Oe.sibling;
                }
                Fe.type === Sa ? (Bt = Tc(
                  Fe.props.children,
                  Ce.mode,
                  Bt,
                  Fe.key
                ), Bt.return = Ce, Bt._debugOwner = Ce, Bt._debugTask = Ce._debugTask, Bt._debugInfo = ai, gh(Fe, Bt, Ce), Ce = Bt) : (Bt = od(
                  Fe,
                  Ce.mode,
                  Bt
                ), Lo(Bt, Fe), Bt.return = Ce, Bt._debugInfo = ai, Ce = Bt);
              }
              return Ce = X(Ce), ai = fn, Ce;
            case Bh:
              e: {
                for (fn = Fe, Fe = fn.key; Oe !== null; ) {
                  if (Oe.key === Fe)
                    if (Oe.tag === 4 && Oe.stateNode.containerInfo === fn.containerInfo && Oe.stateNode.implementation === fn.implementation) {
                      c(
                        Ce,
                        Oe.sibling
                      ), Bt = b(
                        Oe,
                        fn.children || []
                      ), Bt.return = Ce, Ce = Bt;
                      break e;
                    } else {
                      c(Ce, Oe);
                      break;
                    }
                  else i(Ce, Oe);
                  Oe = Oe.sibling;
                }
                Bt = ih(
                  fn,
                  Ce.mode,
                  Bt
                ), Bt.return = Ce, Ce = Bt;
              }
              return X(Ce);
            case Du:
              return fn = ls(Fe._debugInfo), Fe = S0(Fe), Ce = _i(
                Ce,
                Oe,
                Fe,
                Bt
              ), ai = fn, Ce;
          }
          if (_a(Fe))
            return fn = ls(Fe._debugInfo), Ce = Ea(
              Ce,
              Oe,
              Fe,
              Bt
            ), ai = fn, Ce;
          if (k(Fe)) {
            if (fn = ls(Fe._debugInfo), Ia = k(Fe), typeof Ia != "function")
              throw Error(
                "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
              );
            var Nn = Ia.call(Fe);
            return Nn === Fe ? (Ce.tag !== 0 || Object.prototype.toString.call(Ce.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(Nn) !== "[object Generator]") && (VR || console.error(
              "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
            ), VR = !0) : Fe.entries !== Ia || kx || (console.error(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), kx = !0), Ce = $l(
              Ce,
              Oe,
              Nn,
              Bt
            ), ai = fn, Ce;
          }
          if (typeof Fe.then == "function")
            return fn = ls(Fe._debugInfo), Ce = _i(
              Ce,
              Oe,
              eo(Fe),
              Bt
            ), ai = fn, Ce;
          if (Fe.$$typeof === Ru)
            return _i(
              Ce,
              Oe,
              Kh(Ce, Fe),
              Bt
            );
          ea(Ce, Fe);
        }
        return typeof Fe == "string" && Fe !== "" || typeof Fe == "number" || typeof Fe == "bigint" ? (fn = "" + Fe, Oe !== null && Oe.tag === 6 ? (c(
          Ce,
          Oe.sibling
        ), Bt = b(Oe, fn), Bt.return = Ce, Ce = Bt) : (c(Ce, Oe), Bt = Cc(
          fn,
          Ce.mode,
          Bt
        ), Bt.return = Ce, Bt._debugOwner = Ce, Bt._debugTask = Ce._debugTask, Bt._debugInfo = ai, Ce = Bt), X(Ce)) : (typeof Fe == "function" && di(Ce, Fe), typeof Fe == "symbol" && Qi(Ce, Fe), c(Ce, Oe));
      }
      return function(Ce, Oe, Fe, Bt) {
        var fn = ai;
        ai = null;
        try {
          X1 = 0;
          var Ia = _i(
            Ce,
            Oe,
            Fe,
            Bt
          );
          return x_ = null, Ia;
        } catch (ps) {
          if (ps === rl || ps === Gh) throw ps;
          var Nn = D(29, ps, null, Ce.mode);
          Nn.lanes = Bt, Nn.return = Ce;
          var Va = Nn._debugInfo = ai;
          if (Nn._debugOwner = Ce._debugOwner, Nn._debugTask = Ce._debugTask, Va != null) {
            for (var Qa = Va.length - 1; 0 <= Qa; Qa--)
              if (typeof Va[Qa].stack == "string") {
                Nn._debugOwner = Va[Qa], Nn._debugTask = Va[Qa].debugTask;
                break;
              }
          }
          return Nn;
        } finally {
          ai = fn;
        }
      };
    }
    function Tr(n) {
      var i = n.alternate;
      _e(
        Iu,
        Iu.current & C_,
        n
      ), _e(Im, n, n), Vg === null && (i === null || E_.current !== null || i.memoizedState !== null) && (Vg = n);
    }
    function ar(n) {
      if (n.tag === 22) {
        if (_e(Iu, Iu.current, n), _e(Im, n, n), Vg === null) {
          var i = n.alternate;
          i !== null && i.memoizedState !== null && (Vg = n);
        }
      } else Mi(n);
    }
    function Mi(n) {
      _e(Iu, Iu.current, n), _e(
        Im,
        Im.current,
        n
      );
    }
    function Zl(n) {
      re(Im, n), Vg === n && (Vg = null), re(Iu, n);
    }
    function Tl(n) {
      for (var i = n; i !== null; ) {
        if (i.tag === 13) {
          var c = i.memoizedState;
          if (c !== null && (c = c.dehydrated, c === null || c.data === Ry || Ds(c)))
            return i;
        } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
          if ((i.flags & 128) !== 0) return i;
        } else if (i.child !== null) {
          i.child.return = i, i = i.child;
          continue;
        }
        if (i === n) break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === n) return null;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
      return null;
    }
    function lv(n) {
      if (n !== null && typeof n != "function") {
        var i = String(n);
        tD.has(i) || (tD.add(i), console.error(
          "Expected the last optional `callback` argument to be a function. Instead received: %s.",
          n
        ));
      }
    }
    function vl(n, i, c, g) {
      var b = n.memoizedState, R = c(g, b);
      if (n.mode & Wo) {
        ct(!0);
        try {
          R = c(g, b);
        } finally {
          ct(!1);
        }
      }
      R === void 0 && (i = le(i) || "Component", kR.has(i) || (kR.add(i), console.error(
        "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
        i
      ))), b = R == null ? b : Da({}, b, R), n.memoizedState = b, n.lanes === 0 && (n.updateQueue.baseState = b);
    }
    function As(n, i, c, g, b, R, X) {
      var K = n.stateNode;
      if (typeof K.shouldComponentUpdate == "function") {
        if (c = K.shouldComponentUpdate(
          g,
          R,
          X
        ), n.mode & Wo) {
          ct(!0);
          try {
            c = K.shouldComponentUpdate(
              g,
              R,
              X
            );
          } finally {
            ct(!1);
          }
        }
        return c === void 0 && console.error(
          "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
          le(i) || "Component"
        ), c;
      }
      return i.prototype && i.prototype.isPureReactComponent ? !Wd(c, g) || !Wd(b, R) : !0;
    }
    function ec(n, i, c, g) {
      var b = i.state;
      typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(c, g), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(c, g), i.state !== b && (n = Q(n) || "Component", ZR.has(n) || (ZR.add(n), console.error(
        "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
        n
      )), Wx.enqueueReplaceState(
        i,
        i.state,
        null
      ));
    }
    function Rf(n, i) {
      var c = i;
      if ("ref" in i) {
        c = {};
        for (var g in i)
          g !== "ref" && (c[g] = i[g]);
      }
      if (n = n.defaultProps) {
        c === i && (c = Da({}, c));
        for (var b in n)
          c[b] === void 0 && (c[b] = n[b]);
      }
      return c;
    }
    function sg(n) {
      $x(n), console.warn(
        `%s

%s
`,
        R_ ? "An error occurred in the <" + R_ + "> component." : "An error occurred in one of your React components.",
        `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`
      );
    }
    function sv(n) {
      var i = R_ ? "The above error occurred in the <" + R_ + "> component." : "The above error occurred in one of your React components.", c = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((eT || "Anonymous") + ".");
      if (typeof n == "object" && n !== null && typeof n.environmentName == "string") {
        var g = n.environmentName;
        n = [
          `%o

%s

%s
`,
          n,
          i,
          c
        ].slice(0), typeof n[0] == "string" ? n.splice(
          0,
          1,
          wD + n[0],
          ND,
          QE + g + QE,
          zD
        ) : n.splice(
          0,
          0,
          wD,
          ND,
          QE + g + QE,
          zD
        ), n.unshift(console), g = UN.apply(console.error, n), g();
      } else
        console.error(
          `%o

%s

%s
`,
          n,
          i,
          c
        );
    }
    function rg(n) {
      $x(n);
    }
    function yh(n, i) {
      try {
        R_ = i.source ? Q(i.source) : null, eT = null;
        var c = i.value;
        if (mt.actQueue !== null)
          mt.thrownErrors.push(c);
        else {
          var g = n.onUncaughtError;
          g(c, { componentStack: i.stack });
        }
      } catch (b) {
        setTimeout(function() {
          throw b;
        });
      }
    }
    function Cr(n, i, c) {
      try {
        R_ = c.source ? Q(c.source) : null, eT = Q(i);
        var g = n.onCaughtError;
        g(c.value, {
          componentStack: c.stack,
          errorBoundary: i.tag === 1 ? i.stateNode : null
        });
      } catch (b) {
        setTimeout(function() {
          throw b;
        });
      }
    }
    function qs(n, i, c) {
      return c = ju(c), c.tag = Xx, c.payload = { element: null }, c.callback = function() {
        un(i.source, yh, n, i);
      }, c;
    }
    function ha(n) {
      return n = ju(n), n.tag = Xx, n;
    }
    function zc(n, i, c, g) {
      var b = c.type.getDerivedStateFromError;
      if (typeof b == "function") {
        var R = g.value;
        n.payload = function() {
          return b(R);
        }, n.callback = function() {
          Zu(c), un(
            g.source,
            Cr,
            i,
            c,
            g
          );
        };
      }
      var X = c.stateNode;
      X !== null && typeof X.componentDidCatch == "function" && (n.callback = function() {
        Zu(c), un(
          g.source,
          Cr,
          i,
          c,
          g
        ), typeof b != "function" && (b0 === null ? b0 = /* @__PURE__ */ new Set([this]) : b0.add(this)), oN(this, g), typeof b == "function" || (c.lanes & 2) === 0 && console.error(
          "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
          Q(c) || "Unknown"
        );
      });
    }
    function _u(n, i, c, g, b) {
      if (c.flags |= 32768, kl && so(n, b), g !== null && typeof g == "object" && typeof g.then == "function") {
        if (i = c.alternate, i !== null && gs(
          i,
          c,
          b,
          !0
        ), Di && (Ir = !0), c = Im.current, c !== null) {
          switch (c.tag) {
            case 13:
              return Vg === null ? Ur() : c.alternate === null && Vr === Cy && (Vr = iT), c.flags &= -257, c.flags |= 65536, c.lanes = b, g === I1 ? c.flags |= 16384 : (i = c.updateQueue, i === null ? c.updateQueue = /* @__PURE__ */ new Set([g]) : i.add(g), Pc(n, g, b)), !1;
            case 22:
              return c.flags |= 65536, g === I1 ? c.flags |= 16384 : (i = c.updateQueue, i === null ? (i = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([g])
              }, c.updateQueue = i) : (c = i.retryQueue, c === null ? i.retryQueue = /* @__PURE__ */ new Set([g]) : c.add(g)), Pc(n, g, b)), !1;
          }
          throw Error(
            "Unexpected Suspense handler tag (" + c.tag + "). This is a bug in React."
          );
        }
        return Pc(n, g, b), Ur(), !1;
      }
      if (Di)
        return Ir = !0, i = Im.current, i !== null ? ((i.flags & 65536) === 0 && (i.flags |= 256), i.flags |= 65536, i.lanes = b, g !== S_ && yi(
          vs(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
              { cause: g }
            ),
            c
          )
        )) : (g !== S_ && yi(
          vs(
            Error(
              "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
              { cause: g }
            ),
            c
          )
        ), n = n.current.alternate, n.flags |= 65536, b &= -b, n.lanes |= b, g = vs(g, c), b = qs(
          n.stateNode,
          g,
          b
        ), uh(n, b), Vr !== cS && (Vr = O_)), !1;
      var R = vs(
        Error(
          "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
          { cause: g }
        ),
        c
      );
      if (k1 === null ? k1 = [R] : k1.push(R), Vr !== cS && (Vr = O_), i === null) return !0;
      g = vs(g, c), c = i;
      do {
        switch (c.tag) {
          case 3:
            return c.flags |= 65536, n = b & -b, c.lanes |= n, n = qs(
              c.stateNode,
              g,
              n
            ), uh(c, n), !1;
          case 1:
            if (i = c.type, R = c.stateNode, (c.flags & 128) === 0 && (typeof i.getDerivedStateFromError == "function" || R !== null && typeof R.componentDidCatch == "function" && (b0 === null || !b0.has(R))))
              return c.flags |= 65536, b &= -b, c.lanes |= b, b = ha(b), zc(
                b,
                n,
                c,
                g
              ), uh(c, b), !1;
        }
        c = c.return;
      } while (c !== null);
      return !1;
    }
    function Ql(n, i, c, g) {
      i.child = n === null ? YR(i, null, c, g) : T_(
        i,
        n.child,
        c,
        g
      );
    }
    function og(n, i, c, g, b) {
      c = c.render;
      var R = i.ref;
      if ("ref" in g) {
        var X = {};
        for (var K in g)
          K !== "ref" && (X[K] = g[K]);
      } else X = g;
      return Yl(i), Bn(i), g = Xs(
        n,
        i,
        c,
        X,
        R,
        b
      ), K = jr(), rn(), n !== null && !gc ? (Ju(n, i, b), Df(n, i, b)) : (Di && K && Zp(i), i.flags |= 1, Ql(n, i, g, b), i.child);
    }
    function Zs(n, i, c, g, b) {
      if (n === null) {
        var R = c.type;
        return typeof R == "function" && !ah(R) && R.defaultProps === void 0 && c.compare === null ? (c = eh(R), i.tag = 15, i.type = c, lm(i, R), tc(
          n,
          i,
          c,
          g,
          b
        )) : (n = ts(
          c.type,
          null,
          g,
          i,
          i.mode,
          b
        ), n.ref = i.ref, n.return = i, i.child = n);
      }
      if (R = n.child, !hg(n, b)) {
        var X = R.memoizedProps;
        if (c = c.compare, c = c !== null ? c : Wd, c(X, g) && n.ref === i.ref)
          return Df(
            n,
            i,
            b
          );
      }
      return i.flags |= 1, n = cu(R, g), n.ref = i.ref, n.return = i, i.child = n;
    }
    function tc(n, i, c, g, b) {
      if (n !== null) {
        var R = n.memoizedProps;
        if (Wd(R, g) && n.ref === i.ref && i.type === n.type)
          if (gc = !1, i.pendingProps = g = R, hg(n, b))
            (n.flags & 131072) !== 0 && (gc = !0);
          else
            return i.lanes = n.lanes, Df(n, i, b);
      }
      return Ad(
        n,
        i,
        c,
        g,
        b
      );
    }
    function am(n, i, c) {
      var g = i.pendingProps, b = g.children, R = n !== null ? n.memoizedState : null;
      if (g.mode === "hidden") {
        if ((i.flags & 128) !== 0) {
          if (g = R !== null ? R.baseLanes | c : c, n !== null) {
            for (b = i.child = n.child, R = 0; b !== null; )
              R = R | b.lanes | b.childLanes, b = b.sibling;
            i.childLanes = R & ~g;
          } else i.childLanes = 0, i.child = null;
          return _d(
            n,
            i,
            g,
            c
          );
        }
        if ((c & 536870912) !== 0)
          i.memoizedState = { baseLanes: 0, cachePool: null }, n !== null && hu(
            i,
            R !== null ? R.cachePool : null
          ), R !== null ? tr(i, R) : dd(i), ar(i);
        else
          return i.lanes = i.childLanes = 536870912, _d(
            n,
            i,
            R !== null ? R.baseLanes | c : c,
            c
          );
      } else
        R !== null ? (hu(i, R.cachePool), tr(i, R), Mi(i), i.memoizedState = null) : (n !== null && hu(i, null), dd(i), Mi(i));
      return Ql(n, i, b, c), i.child;
    }
    function _d(n, i, c, g) {
      var b = tv();
      return b = b === null ? null : {
        parent: x._currentValue,
        pool: b
      }, i.memoizedState = {
        baseLanes: c,
        cachePool: b
      }, n !== null && hu(i, null), dd(i), ar(i), n !== null && gs(n, i, g, !0), null;
    }
    function im(n, i) {
      var c = i.ref;
      if (c === null)
        n !== null && n.ref !== null && (i.flags |= 4194816);
      else {
        if (typeof c != "function" && typeof c != "object")
          throw Error(
            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
          );
        (n === null || n.ref !== c) && (i.flags |= 4194816);
      }
    }
    function Ad(n, i, c, g, b) {
      if (c.prototype && typeof c.prototype.render == "function") {
        var R = le(c) || "Unknown";
        aD[R] || (console.error(
          "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
          R,
          R
        ), aD[R] = !0);
      }
      return i.mode & Wo && dr.recordLegacyContextWarning(
        i,
        null
      ), n === null && (lm(i, i.type), c.contextTypes && (R = le(c) || "Unknown", lD[R] || (lD[R] = !0, console.error(
        "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
        R
      )))), Yl(i), Bn(i), c = Xs(
        n,
        i,
        c,
        g,
        void 0,
        b
      ), g = jr(), rn(), n !== null && !gc ? (Ju(n, i, b), Df(n, i, b)) : (Di && g && Zp(i), i.flags |= 1, Ql(n, i, c, b), i.child);
    }
    function ug(n, i, c, g, b, R) {
      return Yl(i), Bn(i), xy = -1, P1 = n !== null && n.type !== i.type, i.updateQueue = null, c = Ar(
        i,
        g,
        c,
        b
      ), kh(n, i), g = jr(), rn(), n !== null && !gc ? (Ju(n, i, R), Df(n, i, R)) : (Di && g && Zp(i), i.flags |= 1, Ql(n, i, c, R), i.child);
    }
    function cg(n, i, c, g, b) {
      switch (p(i)) {
        case !1:
          var R = i.stateNode, X = new i.type(
            i.memoizedProps,
            R.context
          ).state;
          R.updater.enqueueSetState(R, X, null);
          break;
        case !0:
          i.flags |= 128, i.flags |= 65536, R = Error("Simulated error coming from DevTools");
          var K = b & -b;
          if (i.lanes |= K, X = Wl, X === null)
            throw Error(
              "Expected a work-in-progress root. This is a bug in React. Please file an issue."
            );
          K = ha(K), zc(
            K,
            X,
            i,
            vs(R, i)
          ), uh(i, K);
      }
      if (Yl(i), i.stateNode === null) {
        if (X = zh, R = c.contextType, "contextType" in c && R !== null && (R === void 0 || R.$$typeof !== Ru) && !eD.has(c) && (eD.add(c), K = R === void 0 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof R != "object" ? " However, it is set to a " + typeof R + "." : R.$$typeof === xg ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(R).join(", ") + "}.", console.error(
          "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
          le(c) || "Component",
          K
        )), typeof R == "object" && R !== null && (X = Zi(R)), R = new c(g, X), i.mode & Wo) {
          ct(!0);
          try {
            R = new c(g, X);
          } finally {
            ct(!1);
          }
        }
        if (X = i.memoizedState = R.state !== null && R.state !== void 0 ? R.state : null, R.updater = Wx, i.stateNode = R, R._reactInternals = i, R._reactInternalInstance = qR, typeof c.getDerivedStateFromProps == "function" && X === null && (X = le(c) || "Component", QR.has(X) || (QR.add(X), console.error(
          "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
          X,
          R.state === null ? "null" : "undefined",
          X
        ))), typeof c.getDerivedStateFromProps == "function" || typeof R.getSnapshotBeforeUpdate == "function") {
          var de = K = X = null;
          if (typeof R.componentWillMount == "function" && R.componentWillMount.__suppressDeprecationWarning !== !0 ? X = "componentWillMount" : typeof R.UNSAFE_componentWillMount == "function" && (X = "UNSAFE_componentWillMount"), typeof R.componentWillReceiveProps == "function" && R.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? K = "componentWillReceiveProps" : typeof R.UNSAFE_componentWillReceiveProps == "function" && (K = "UNSAFE_componentWillReceiveProps"), typeof R.componentWillUpdate == "function" && R.componentWillUpdate.__suppressDeprecationWarning !== !0 ? de = "componentWillUpdate" : typeof R.UNSAFE_componentWillUpdate == "function" && (de = "UNSAFE_componentWillUpdate"), X !== null || K !== null || de !== null) {
            R = le(c) || "Component";
            var ge = typeof c.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            JR.has(R) || (JR.add(R), console.error(
              `Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`,
              R,
              ge,
              X !== null ? `
  ` + X : "",
              K !== null ? `
  ` + K : "",
              de !== null ? `
  ` + de : ""
            ));
          }
        }
        R = i.stateNode, X = le(c) || "Component", R.render || (c.prototype && typeof c.prototype.render == "function" ? console.error(
          "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
          X
        ) : console.error(
          "No `render` method found on the %s instance: you may have forgotten to define `render`.",
          X
        )), !R.getInitialState || R.getInitialState.isReactClassApproved || R.state || console.error(
          "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
          X
        ), R.getDefaultProps && !R.getDefaultProps.isReactClassApproved && console.error(
          "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
          X
        ), R.contextType && console.error(
          "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
          X
        ), c.childContextTypes && !$R.has(c) && ($R.add(c), console.error(
          "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
          X
        )), c.contextTypes && !WR.has(c) && (WR.add(c), console.error(
          "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
          X
        )), typeof R.componentShouldUpdate == "function" && console.error(
          "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
          X
        ), c.prototype && c.prototype.isPureReactComponent && typeof R.shouldComponentUpdate < "u" && console.error(
          "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
          le(c) || "A pure component"
        ), typeof R.componentDidUnmount == "function" && console.error(
          "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
          X
        ), typeof R.componentDidReceiveProps == "function" && console.error(
          "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
          X
        ), typeof R.componentWillRecieveProps == "function" && console.error(
          "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
          X
        ), typeof R.UNSAFE_componentWillRecieveProps == "function" && console.error(
          "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
          X
        ), K = R.props !== g, R.props !== void 0 && K && console.error(
          "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
          X
        ), R.defaultProps && console.error(
          "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
          X,
          X
        ), typeof R.getSnapshotBeforeUpdate != "function" || typeof R.componentDidUpdate == "function" || jR.has(c) || (jR.add(c), console.error(
          "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
          le(c)
        )), typeof R.getDerivedStateFromProps == "function" && console.error(
          "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          X
        ), typeof R.getDerivedStateFromError == "function" && console.error(
          "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
          X
        ), typeof c.getSnapshotBeforeUpdate == "function" && console.error(
          "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
          X
        ), (K = R.state) && (typeof K != "object" || _a(K)) && console.error("%s.state: must be set to an object or null", X), typeof R.getChildContext == "function" && typeof c.childContextTypes != "object" && console.error(
          "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
          X
        ), R = i.stateNode, R.props = g, R.state = i.memoizedState, R.refs = {}, ri(i), X = c.contextType, R.context = typeof X == "object" && X !== null ? Zi(X) : zh, R.state === g && (X = le(c) || "Component", KR.has(X) || (KR.add(X), console.error(
          "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
          X
        ))), i.mode & Wo && dr.recordLegacyContextWarning(
          i,
          R
        ), dr.recordUnsafeLifecycleWarnings(
          i,
          R
        ), R.state = i.memoizedState, X = c.getDerivedStateFromProps, typeof X == "function" && (vl(
          i,
          c,
          X,
          g
        ), R.state = i.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof R.getSnapshotBeforeUpdate == "function" || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (X = R.state, typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount(), X !== R.state && (console.error(
          "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
          Q(i) || "Component"
        ), Wx.enqueueReplaceState(
          R,
          R.state,
          null
        )), cd(i, g, R, b), er(), R.state = i.memoizedState), typeof R.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & Bp) !== Xi && (i.flags |= 134217728), R = !0;
      } else if (n === null) {
        R = i.stateNode;
        var ut = i.memoizedProps;
        K = Rf(c, ut), R.props = K;
        var xt = R.context;
        de = c.contextType, X = zh, typeof de == "object" && de !== null && (X = Zi(de)), ge = c.getDerivedStateFromProps, de = typeof ge == "function" || typeof R.getSnapshotBeforeUpdate == "function", ut = i.pendingProps !== ut, de || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (ut || xt !== X) && ec(
          i,
          R,
          g,
          X
        ), g0 = !1;
        var it = i.memoizedState;
        R.state = it, cd(i, g, R, b), er(), xt = i.memoizedState, ut || it !== xt || g0 ? (typeof ge == "function" && (vl(
          i,
          c,
          ge,
          g
        ), xt = i.memoizedState), (K = g0 || As(
          i,
          c,
          K,
          g,
          it,
          xt,
          X
        )) ? (de || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount()), typeof R.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & Bp) !== Xi && (i.flags |= 134217728)) : (typeof R.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & Bp) !== Xi && (i.flags |= 134217728), i.memoizedProps = g, i.memoizedState = xt), R.props = g, R.state = xt, R.context = X, R = K) : (typeof R.componentDidMount == "function" && (i.flags |= 4194308), (i.mode & Bp) !== Xi && (i.flags |= 134217728), R = !1);
      } else {
        R = i.stateNode, Zr(n, i), X = i.memoizedProps, de = Rf(c, X), R.props = de, ge = i.pendingProps, it = R.context, xt = c.contextType, K = zh, typeof xt == "object" && xt !== null && (K = Zi(xt)), ut = c.getDerivedStateFromProps, (xt = typeof ut == "function" || typeof R.getSnapshotBeforeUpdate == "function") || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (X !== ge || it !== K) && ec(
          i,
          R,
          g,
          K
        ), g0 = !1, it = i.memoizedState, R.state = it, cd(i, g, R, b), er();
        var Dt = i.memoizedState;
        X !== ge || it !== Dt || g0 || n !== null && n.dependencies !== null && yr(n.dependencies) ? (typeof ut == "function" && (vl(
          i,
          c,
          ut,
          g
        ), Dt = i.memoizedState), (de = g0 || As(
          i,
          c,
          de,
          g,
          it,
          Dt,
          K
        ) || n !== null && n.dependencies !== null && yr(n.dependencies)) ? (xt || typeof R.UNSAFE_componentWillUpdate != "function" && typeof R.componentWillUpdate != "function" || (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(g, Dt, K), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(
          g,
          Dt,
          K
        )), typeof R.componentDidUpdate == "function" && (i.flags |= 4), typeof R.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof R.componentDidUpdate != "function" || X === n.memoizedProps && it === n.memoizedState || (i.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || X === n.memoizedProps && it === n.memoizedState || (i.flags |= 1024), i.memoizedProps = g, i.memoizedState = Dt), R.props = g, R.state = Dt, R.context = K, R = de) : (typeof R.componentDidUpdate != "function" || X === n.memoizedProps && it === n.memoizedState || (i.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || X === n.memoizedProps && it === n.memoizedState || (i.flags |= 1024), R = !1);
      }
      if (K = R, im(n, i), X = (i.flags & 128) !== 0, K || X) {
        if (K = i.stateNode, li(i), X && typeof c.getDerivedStateFromError != "function")
          c = null, he = -1;
        else {
          if (Bn(i), c = BR(K), i.mode & Wo) {
            ct(!0);
            try {
              BR(K);
            } finally {
              ct(!1);
            }
          }
          rn();
        }
        i.flags |= 1, n !== null && X ? (i.child = T_(
          i,
          n.child,
          null,
          b
        ), i.child = T_(
          i,
          null,
          c,
          b
        )) : Ql(n, i, c, b), i.memoizedState = K.state, n = i.child;
      } else
        n = Df(
          n,
          i,
          b
        );
      return b = i.stateNode, R && b.props !== g && (D_ || console.error(
        "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
        Q(i) || "a component"
      ), D_ = !0), n;
    }
    function rv(n, i, c, g) {
      return Rc(), i.flags |= 256, Ql(n, i, c, g), i.child;
    }
    function lm(n, i) {
      i && i.childContextTypes && console.error(
        `childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`,
        i.displayName || i.name || "Component"
      ), typeof i.getDerivedStateFromProps == "function" && (n = le(i) || "Unknown", sD[n] || (console.error(
        "%s: Function components do not support getDerivedStateFromProps.",
        n
      ), sD[n] = !0)), typeof i.contextType == "object" && i.contextType !== null && (i = le(i) || "Unknown", iD[i] || (console.error(
        "%s: Function components do not support contextType.",
        i
      ), iD[i] = !0));
    }
    function sm(n) {
      return { baseLanes: n, cachePool: pu() };
    }
    function fg(n, i, c) {
      return n = n !== null ? n.childLanes & ~c : 0, i && (n |= Np), n;
    }
    function Wy(n, i, c) {
      var g, b = i.pendingProps;
      d(i) && (i.flags |= 128);
      var R = !1, X = (i.flags & 128) !== 0;
      if ((g = X) || (g = n !== null && n.memoizedState === null ? !1 : (Iu.current & Y1) !== 0), g && (R = !0, i.flags &= -129), g = (i.flags & 32) !== 0, i.flags &= -33, n === null) {
        if (Di) {
          if (R ? Tr(i) : Mi(i), Di) {
            var K = Hs, de;
            if (!(de = !K)) {
              e: {
                var ge = K;
                for (de = Up; ge.nodeType !== 8; ) {
                  if (!de) {
                    de = null;
                    break e;
                  }
                  if (ge = Al(ge.nextSibling), ge === null) {
                    de = null;
                    break e;
                  }
                }
                de = ge;
              }
              de !== null ? (Yr(), i.memoizedState = {
                dehydrated: de,
                treeContext: _y !== null ? { id: Lv, overflow: Hh } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, ge = D(18, null, null, Xi), ge.stateNode = de, ge.return = i, i.child = ge, vc = i, Hs = null, de = !0) : de = !1, de = !de;
            }
            de && (Qp(
              i,
              K
            ), $s(i));
          }
          if (K = i.memoizedState, K !== null && (K = K.dehydrated, K !== null))
            return Ds(K) ? i.lanes = 32 : i.lanes = 536870912, null;
          Zl(i);
        }
        return K = b.children, b = b.fallback, R ? (Mi(i), R = i.mode, K = rm(
          {
            mode: "hidden",
            children: K
          },
          R
        ), b = Tc(
          b,
          R,
          c,
          null
        ), K.return = i, b.return = i, K.sibling = b, i.child = K, R = i.child, R.memoizedState = sm(c), R.childLanes = fg(
          n,
          g,
          c
        ), i.memoizedState = nT, b) : (Tr(i), ov(
          i,
          K
        ));
      }
      var ut = n.memoizedState;
      if (ut !== null && (K = ut.dehydrated, K !== null)) {
        if (X)
          i.flags & 256 ? (Tr(i), i.flags &= -257, i = dg(
            n,
            i,
            c
          )) : i.memoizedState !== null ? (Mi(i), i.child = n.child, i.flags |= 128, i = null) : (Mi(i), R = b.fallback, K = i.mode, b = rm(
            {
              mode: "visible",
              children: b.children
            },
            K
          ), R = Tc(
            R,
            K,
            c,
            null
          ), R.flags |= 2, b.return = i, R.return = i, b.sibling = R, i.child = b, T_(
            i,
            n.child,
            null,
            c
          ), b = i.child, b.memoizedState = sm(c), b.childLanes = fg(
            n,
            g,
            c
          ), i.memoizedState = nT, i = R);
        else if (Tr(i), Di && console.error(
          "We should not be hydrating here. This is a bug in React. Please file a bug."
        ), Ds(K)) {
          if (g = K.nextSibling && K.nextSibling.dataset, g) {
            de = g.dgst;
            var xt = g.msg;
            ge = g.stck;
            var it = g.cstck;
          }
          K = xt, g = de, b = ge, de = R = it, R = Error(K || "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."), R.stack = b || "", R.digest = g, g = de === void 0 ? null : de, b = {
            value: R,
            source: null,
            stack: g
          }, typeof g == "string" && Vd.set(
            R,
            b
          ), yi(b), i = dg(
            n,
            i,
            c
          );
        } else if (gc || gs(
          n,
          i,
          c,
          !1
        ), g = (c & n.childLanes) !== 0, gc || g) {
          if (g = Wl, g !== null && (b = c & -c, b = (b & 42) !== 0 ? 1 : Jt(
            b
          ), b = (b & (g.suspendedLanes | c)) !== 0 ? 0 : b, b !== 0 && b !== ut.retryLane))
            throw ut.retryLane = b, mr(
              n,
              b
            ), Cl(
              g,
              n,
              b
            ), nD;
          K.data === Ry || Ur(), i = dg(
            n,
            i,
            c
          );
        } else
          K.data === Ry ? (i.flags |= 192, i.child = n.child, i = null) : (n = ut.treeContext, Hs = Al(
            K.nextSibling
          ), vc = i, Di = !0, Gg = null, Ir = !1, Lu = null, Up = !1, n !== null && (Yr(), Hu[Pd++] = Lv, Hu[Pd++] = Hh, Hu[Pd++] = _y, Lv = n.id, Hh = n.overflow, _y = i), i = ov(
            i,
            b.children
          ), i.flags |= 4096);
        return i;
      }
      return R ? (Mi(i), R = b.fallback, K = i.mode, de = n.child, ge = de.sibling, b = cu(
        de,
        {
          mode: "hidden",
          children: b.children
        }
      ), b.subtreeFlags = de.subtreeFlags & 65011712, ge !== null ? R = cu(
        ge,
        R
      ) : (R = Tc(
        R,
        K,
        c,
        null
      ), R.flags |= 2), R.return = i, b.return = i, b.sibling = R, i.child = b, b = R, R = i.child, K = n.child.memoizedState, K === null ? K = sm(c) : (de = K.cachePool, de !== null ? (ge = x._currentValue, de = de.parent !== ge ? { parent: ge, pool: ge } : de) : de = pu(), K = {
        baseLanes: K.baseLanes | c,
        cachePool: de
      }), R.memoizedState = K, R.childLanes = fg(
        n,
        g,
        c
      ), i.memoizedState = nT, b) : (Tr(i), c = n.child, n = c.sibling, c = cu(c, {
        mode: "visible",
        children: b.children
      }), c.return = i, c.sibling = null, n !== null && (g = i.deletions, g === null ? (i.deletions = [n], i.flags |= 16) : g.push(n)), i.child = c, i.memoizedState = null, c);
    }
    function ov(n, i) {
      return i = rm(
        { mode: "visible", children: i },
        n.mode
      ), i.return = n, n.child = i;
    }
    function rm(n, i) {
      return n = D(22, n, null, i), n.lanes = 0, n.stateNode = {
        _visibility: p0,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }, n;
    }
    function dg(n, i, c) {
      return T_(i, n.child, null, c), n = ov(
        i,
        i.pendingProps.children
      ), n.flags |= 2, i.memoizedState = null, n;
    }
    function Ed(n, i, c) {
      n.lanes |= i;
      var g = n.alternate;
      g !== null && (g.lanes |= i), Qu(
        n.return,
        i,
        c
      );
    }
    function om(n, i) {
      var c = _a(n);
      return n = !c && typeof k(n) == "function", c || n ? (c = c ? "array" : "iterable", console.error(
        "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
        c,
        i,
        c
      ), !1) : !0;
    }
    function um(n, i, c, g, b) {
      var R = n.memoizedState;
      R === null ? n.memoizedState = {
        isBackwards: i,
        rendering: null,
        renderingStartTime: 0,
        last: g,
        tail: c,
        tailMode: b
      } : (R.isBackwards = i, R.rendering = null, R.renderingStartTime = 0, R.last = g, R.tail = c, R.tailMode = b);
    }
    function uv(n, i, c) {
      var g = i.pendingProps, b = g.revealOrder, R = g.tail;
      if (g = g.children, b !== void 0 && b !== "forwards" && b !== "backwards" && b !== "together" && !rD[b])
        if (rD[b] = !0, typeof b == "string")
          switch (b.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                b,
                b.toLowerCase()
              );
              break;
            case "forward":
            case "backward":
              console.error(
                '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                b,
                b.toLowerCase()
              );
              break;
            default:
              console.error(
                '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                b
              );
          }
        else
          console.error(
            '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
            b
          );
      R === void 0 || tT[R] || (R !== "collapsed" && R !== "hidden" ? (tT[R] = !0, console.error(
        '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
        R
      )) : b !== "forwards" && b !== "backwards" && (tT[R] = !0, console.error(
        '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
        R
      )));
      e: if ((b === "forwards" || b === "backwards") && g !== void 0 && g !== null && g !== !1)
        if (_a(g)) {
          for (var X = 0; X < g.length; X++)
            if (!om(g[X], X)) break e;
        } else if (X = k(g), typeof X == "function") {
          if (X = X.call(g))
            for (var K = X.next(), de = 0; !K.done; K = X.next()) {
              if (!om(K.value, de)) break e;
              de++;
            }
        } else
          console.error(
            'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
            b
          );
      if (Ql(n, i, g, c), g = Iu.current, (g & Y1) !== 0)
        g = g & C_ | Y1, i.flags |= 128;
      else {
        if (n !== null && (n.flags & 128) !== 0)
          e: for (n = i.child; n !== null; ) {
            if (n.tag === 13)
              n.memoizedState !== null && Ed(
                n,
                c,
                i
              );
            else if (n.tag === 19)
              Ed(n, c, i);
            else if (n.child !== null) {
              n.child.return = n, n = n.child;
              continue;
            }
            if (n === i) break e;
            for (; n.sibling === null; ) {
              if (n.return === null || n.return === i)
                break e;
              n = n.return;
            }
            n.sibling.return = n.return, n = n.sibling;
          }
        g &= C_;
      }
      switch (_e(Iu, g, i), b) {
        case "forwards":
          for (c = i.child, b = null; c !== null; )
            n = c.alternate, n !== null && Tl(n) === null && (b = c), c = c.sibling;
          c = b, c === null ? (b = i.child, i.child = null) : (b = c.sibling, c.sibling = null), um(
            i,
            !1,
            b,
            c,
            R
          );
          break;
        case "backwards":
          for (c = null, b = i.child, i.child = null; b !== null; ) {
            if (n = b.alternate, n !== null && Tl(n) === null) {
              i.child = b;
              break;
            }
            n = b.sibling, b.sibling = c, c = b, b = n;
          }
          um(
            i,
            !0,
            c,
            null,
            R
          );
          break;
        case "together":
          um(i, !1, null, null, void 0);
          break;
        default:
          i.memoizedState = null;
      }
      return i.child;
    }
    function Df(n, i, c) {
      if (n !== null && (i.dependencies = n.dependencies), he = -1, A0 |= i.lanes, (c & i.childLanes) === 0)
        if (n !== null) {
          if (gs(
            n,
            i,
            c,
            !1
          ), (c & i.childLanes) === 0)
            return null;
        } else return null;
      if (n !== null && i.child !== n.child)
        throw Error("Resuming work not yet implemented.");
      if (i.child !== null) {
        for (n = i.child, c = cu(n, n.pendingProps), i.child = c, c.return = i; n.sibling !== null; )
          n = n.sibling, c = c.sibling = cu(n, n.pendingProps), c.return = i;
        c.sibling = null;
      }
      return i.child;
    }
    function hg(n, i) {
      return (n.lanes & i) !== 0 ? !0 : (n = n.dependencies, !!(n !== null && yr(n)));
    }
    function $y(n, i, c) {
      switch (i.tag) {
        case 3:
          Ae(
            i,
            i.stateNode.containerInfo
          ), Dc(
            i,
            x,
            n.memoizedState.cache
          ), Rc();
          break;
        case 27:
        case 5:
          te(i);
          break;
        case 4:
          Ae(
            i,
            i.stateNode.containerInfo
          );
          break;
        case 10:
          Dc(
            i,
            i.type,
            i.memoizedProps.value
          );
          break;
        case 12:
          (c & i.childLanes) !== 0 && (i.flags |= 4), i.flags |= 2048;
          var g = i.stateNode;
          g.effectDuration = -0, g.passiveEffectDuration = -0;
          break;
        case 13:
          if (g = i.memoizedState, g !== null)
            return g.dehydrated !== null ? (Tr(i), i.flags |= 128, null) : (c & i.child.childLanes) !== 0 ? Wy(
              n,
              i,
              c
            ) : (Tr(i), n = Df(
              n,
              i,
              c
            ), n !== null ? n.sibling : null);
          Tr(i);
          break;
        case 19:
          var b = (n.flags & 128) !== 0;
          if (g = (c & i.childLanes) !== 0, g || (gs(
            n,
            i,
            c,
            !1
          ), g = (c & i.childLanes) !== 0), b) {
            if (g)
              return uv(
                n,
                i,
                c
              );
            i.flags |= 128;
          }
          if (b = i.memoizedState, b !== null && (b.rendering = null, b.tail = null, b.lastEffect = null), _e(
            Iu,
            Iu.current,
            i
          ), g) break;
          return null;
        case 22:
        case 23:
          return i.lanes = 0, am(n, i, c);
        case 24:
          Dc(
            i,
            x,
            n.memoizedState.cache
          );
      }
      return Df(n, i, c);
    }
    function Hc(n, i, c) {
      if (i._debugNeedsRemount && n !== null) {
        c = ts(
          i.type,
          i.key,
          i.pendingProps,
          i._debugOwner || null,
          i.mode,
          i.lanes
        ), c._debugStack = i._debugStack, c._debugTask = i._debugTask;
        var g = i.return;
        if (g === null) throw Error("Cannot swap the root fiber.");
        if (n.alternate = null, i.alternate = null, c.index = i.index, c.sibling = i.sibling, c.return = i.return, c.ref = i.ref, c._debugInfo = i._debugInfo, i === g.child)
          g.child = c;
        else {
          var b = g.child;
          if (b === null)
            throw Error("Expected parent to have a child.");
          for (; b.sibling !== i; )
            if (b = b.sibling, b === null)
              throw Error("Expected to find the previous sibling.");
          b.sibling = c;
        }
        return i = g.deletions, i === null ? (g.deletions = [n], g.flags |= 16) : i.push(n), c.flags |= 2, c;
      }
      if (n !== null)
        if (n.memoizedProps !== i.pendingProps || i.type !== n.type)
          gc = !0;
        else {
          if (!hg(n, c) && (i.flags & 128) === 0)
            return gc = !1, $y(
              n,
              i,
              c
            );
          gc = (n.flags & 131072) !== 0;
        }
      else
        gc = !1, (g = Di) && (Yr(), g = (i.flags & 1048576) !== 0), g && (g = i.index, Yr(), lh(i, Lg, g));
      switch (i.lanes = 0, i.tag) {
        case 16:
          e: if (g = i.pendingProps, n = S0(i.elementType), i.type = n, typeof n == "function")
            ah(n) ? (g = Rf(
              n,
              g
            ), i.tag = 1, i.type = n = eh(n), i = cg(
              null,
              i,
              n,
              g,
              c
            )) : (i.tag = 0, lm(i, n), i.type = n = eh(n), i = Ad(
              null,
              i,
              n,
              g,
              c
            ));
          else {
            if (n != null) {
              if (b = n.$$typeof, b === Od) {
                i.tag = 11, i.type = n = qp(n), i = og(
                  null,
                  i,
                  n,
                  g,
                  c
                );
                break e;
              } else if (b === vp) {
                i.tag = 14, i = Zs(
                  null,
                  i,
                  n,
                  g,
                  c
                );
                break e;
              }
            }
            throw i = "", n !== null && typeof n == "object" && n.$$typeof === Du && (i = " Did you wrap a component in React.lazy() more than once?"), n = le(n) || n, Error(
              "Element type is invalid. Received a promise that resolves to: " + n + ". Lazy element type must resolve to a class or function." + i
            );
          }
          return i;
        case 0:
          return Ad(
            n,
            i,
            i.type,
            i.pendingProps,
            c
          );
        case 1:
          return g = i.type, b = Rf(
            g,
            i.pendingProps
          ), cg(
            n,
            i,
            g,
            b,
            c
          );
        case 3:
          e: {
            if (Ae(
              i,
              i.stateNode.containerInfo
            ), n === null)
              throw Error(
                "Should have a current fiber. This is a bug in React."
              );
            g = i.pendingProps;
            var R = i.memoizedState;
            b = R.element, Zr(n, i), cd(i, g, null, c);
            var X = i.memoizedState;
            if (g = X.cache, Dc(i, x, g), g !== R.cache && $m(
              i,
              [x],
              c,
              !0
            ), er(), g = X.element, R.isDehydrated)
              if (R = {
                element: g,
                isDehydrated: !1,
                cache: X.cache
              }, i.updateQueue.baseState = R, i.memoizedState = R, i.flags & 256) {
                i = rv(
                  n,
                  i,
                  g,
                  c
                );
                break e;
              } else if (g !== b) {
                b = vs(
                  Error(
                    "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                  ),
                  i
                ), yi(b), i = rv(
                  n,
                  i,
                  g,
                  c
                );
                break e;
              } else {
                switch (n = i.stateNode.containerInfo, n.nodeType) {
                  case 9:
                    n = n.body;
                    break;
                  default:
                    n = n.nodeName === "HTML" ? n.ownerDocument.body : n;
                }
                for (Hs = Al(n.firstChild), vc = i, Di = !0, Gg = null, Ir = !1, Lu = null, Up = !0, n = YR(
                  i,
                  null,
                  g,
                  c
                ), i.child = n; n; )
                  n.flags = n.flags & -3 | 4096, n = n.sibling;
              }
            else {
              if (Rc(), g === b) {
                i = Df(
                  n,
                  i,
                  c
                );
                break e;
              }
              Ql(
                n,
                i,
                g,
                c
              );
            }
            i = i.child;
          }
          return i;
        case 26:
          return im(n, i), n === null ? (n = Zo(
            i.type,
            null,
            i.pendingProps,
            null
          )) ? i.memoizedState = n : Di || (n = i.type, c = i.pendingProps, g = me(
            dc.current
          ), g = Fn(
            g
          ).createElement(n), g[ws] = i, g[Hr] = c, yl(g, n, c), Ht(g), i.stateNode = g) : i.memoizedState = Zo(
            i.type,
            n.memoizedProps,
            i.pendingProps,
            n.memoizedState
          ), null;
        case 27:
          return te(i), n === null && Di && (g = me(dc.current), b = P(), g = i.stateNode = yv(
            i.type,
            i.pendingProps,
            g,
            b,
            !1
          ), Ir || (b = ma(
            g,
            i.type,
            i.pendingProps,
            b
          ), b !== null && (Vs(i, 0).serverProps = b)), vc = i, Up = !0, b = Hs, oo(i.type) ? (xT = b, Hs = Al(
            g.firstChild
          )) : Hs = b), Ql(
            n,
            i,
            i.pendingProps.children,
            c
          ), im(n, i), n === null && (i.flags |= 4194304), i.child;
        case 5:
          return n === null && Di && (R = P(), g = ff(
            i.type,
            R.ancestorInfo
          ), b = Hs, (X = !b) || (X = qo(
            b,
            i.type,
            i.pendingProps,
            Up
          ), X !== null ? (i.stateNode = X, Ir || (R = ma(
            X,
            i.type,
            i.pendingProps,
            R
          ), R !== null && (Vs(i, 0).serverProps = R)), vc = i, Hs = Al(
            X.firstChild
          ), Up = !1, R = !0) : R = !1, X = !R), X && (g && Qp(i, b), $s(i))), te(i), b = i.type, R = i.pendingProps, X = n !== null ? n.memoizedProps : null, g = R.children, wr(b, R) ? g = null : X !== null && wr(b, X) && (i.flags |= 32), i.memoizedState !== null && (b = Xs(
            n,
            i,
            Ss,
            null,
            null,
            c
          ), lA._currentValue = b), im(n, i), Ql(
            n,
            i,
            g,
            c
          ), i.child;
        case 6:
          return n === null && Di && (n = i.pendingProps, c = P(), g = c.ancestorInfo.current, n = g != null ? Xu(
            n,
            g.tag,
            c.ancestorInfo.implicitRootScope
          ) : !0, c = Hs, (g = !c) || (g = Rs(
            c,
            i.pendingProps,
            Up
          ), g !== null ? (i.stateNode = g, vc = i, Hs = null, g = !0) : g = !1, g = !g), g && (n && Qp(i, c), $s(i))), null;
        case 13:
          return Wy(n, i, c);
        case 4:
          return Ae(
            i,
            i.stateNode.containerInfo
          ), g = i.pendingProps, n === null ? i.child = T_(
            i,
            null,
            g,
            c
          ) : Ql(
            n,
            i,
            g,
            c
          ), i.child;
        case 11:
          return og(
            n,
            i,
            i.type,
            i.pendingProps,
            c
          );
        case 7:
          return Ql(
            n,
            i,
            i.pendingProps,
            c
          ), i.child;
        case 8:
          return Ql(
            n,
            i,
            i.pendingProps.children,
            c
          ), i.child;
        case 12:
          return i.flags |= 4, i.flags |= 2048, g = i.stateNode, g.effectDuration = -0, g.passiveEffectDuration = -0, Ql(
            n,
            i,
            i.pendingProps.children,
            c
          ), i.child;
        case 10:
          return g = i.type, b = i.pendingProps, R = b.value, "value" in b || oD || (oD = !0, console.error(
            "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
          )), Dc(i, g, R), Ql(
            n,
            i,
            b.children,
            c
          ), i.child;
        case 9:
          return b = i.type._context, g = i.pendingProps.children, typeof g != "function" && console.error(
            "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
          ), Yl(i), b = Zi(b), Bn(i), g = Jx(
            g,
            b,
            void 0
          ), rn(), i.flags |= 1, Ql(
            n,
            i,
            g,
            c
          ), i.child;
        case 14:
          return Zs(
            n,
            i,
            i.type,
            i.pendingProps,
            c
          );
        case 15:
          return tc(
            n,
            i,
            i.type,
            i.pendingProps,
            c
          );
        case 19:
          return uv(
            n,
            i,
            c
          );
        case 31:
          return g = i.pendingProps, c = i.mode, g = {
            mode: g.mode,
            children: g.children
          }, n === null ? (n = rm(
            g,
            c
          ), n.ref = i.ref, i.child = n, n.return = i, i = n) : (n = cu(n.child, g), n.ref = i.ref, i.child = n, n.return = i, i = n), i;
        case 22:
          return am(n, i, c);
        case 24:
          return Yl(i), g = Zi(x), n === null ? (b = tv(), b === null && (b = Wl, R = rh(), b.pooledCache = R, Sf(R), R !== null && (b.pooledCacheLanes |= c), b = R), i.memoizedState = {
            parent: g,
            cache: b
          }, ri(i), Dc(i, x, b)) : ((n.lanes & c) !== 0 && (Zr(n, i), cd(i, null, null, c), er()), b = n.memoizedState, R = i.memoizedState, b.parent !== g ? (b = {
            parent: g,
            cache: g
          }, i.memoizedState = b, i.lanes === 0 && (i.memoizedState = i.updateQueue.baseState = b), Dc(i, x, g)) : (g = R.cache, Dc(i, x, g), g !== b.cache && $m(
            i,
            [x],
            c,
            !0
          ))), Ql(
            n,
            i,
            i.pendingProps.children,
            c
          ), i.child;
        case 29:
          throw i.pendingProps;
      }
      throw Error(
        "Unknown unit of work tag (" + i.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function to(n) {
      n.flags |= 4;
    }
    function $a(n, i) {
      if (i.type !== "stylesheet" || (i.state.loading & Vm) !== SS)
        n.flags &= -16777217;
      else if (n.flags |= 16777216, !qe(i)) {
        if (i = Im.current, i !== null && ((gi & 4194048) === gi ? Vg !== null : (gi & 62914560) !== gi && (gi & 536870912) === 0 || i !== Vg))
          throw V1 = I1, Ks;
        n.flags |= 8192;
      }
    }
    function Sh(n, i) {
      i !== null && (n.flags |= 4), n.flags & 16384 && (i = n.tag !== 22 ? ce() : 536870912, n.lanes |= i, hS |= i);
    }
    function _h(n, i) {
      if (!Di)
        switch (n.tailMode) {
          case "hidden":
            i = n.tail;
            for (var c = null; i !== null; )
              i.alternate !== null && (c = i), i = i.sibling;
            c === null ? n.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = n.tail;
            for (var g = null; c !== null; )
              c.alternate !== null && (g = c), c = c.sibling;
            g === null ? i || n.tail === null ? n.tail = null : n.tail.sibling = null : g.sibling = null;
        }
    }
    function xi(n) {
      var i = n.alternate !== null && n.alternate.child === n.child, c = 0, g = 0;
      if (i)
        if ((n.mode & _o) !== Xi) {
          for (var b = n.selfBaseDuration, R = n.child; R !== null; )
            c |= R.lanes | R.childLanes, g |= R.subtreeFlags & 65011712, g |= R.flags & 65011712, b += R.treeBaseDuration, R = R.sibling;
          n.treeBaseDuration = b;
        } else
          for (b = n.child; b !== null; )
            c |= b.lanes | b.childLanes, g |= b.subtreeFlags & 65011712, g |= b.flags & 65011712, b.return = n, b = b.sibling;
      else if ((n.mode & _o) !== Xi) {
        b = n.actualDuration, R = n.selfBaseDuration;
        for (var X = n.child; X !== null; )
          c |= X.lanes | X.childLanes, g |= X.subtreeFlags, g |= X.flags, b += X.actualDuration, R += X.treeBaseDuration, X = X.sibling;
        n.actualDuration = b, n.treeBaseDuration = R;
      } else
        for (b = n.child; b !== null; )
          c |= b.lanes | b.childLanes, g |= b.subtreeFlags, g |= b.flags, b.return = n, b = b.sibling;
      return n.subtreeFlags |= g, n.childLanes = c, i;
    }
    function kg(n, i, c) {
      var g = i.pendingProps;
      switch (vr(i), i.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return xi(i), null;
        case 1:
          return xi(i), null;
        case 3:
          return c = i.stateNode, g = null, n !== null && (g = n.memoizedState.cache), i.memoizedState.cache !== g && (i.flags |= 2048), gr(x, i), He(i), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (n === null || n.child === null) && (yf(i) ? (Wm(), to(i)) : n === null || n.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024, ud())), xi(i), null;
        case 26:
          return c = i.memoizedState, n === null ? (to(i), c !== null ? (xi(i), $a(
            i,
            c
          )) : (xi(i), i.flags &= -16777217)) : c ? c !== n.memoizedState ? (to(i), xi(i), $a(
            i,
            c
          )) : (xi(i), i.flags &= -16777217) : (n.memoizedProps !== g && to(i), xi(i), i.flags &= -16777217), null;
        case 27:
          ae(i), c = me(dc.current);
          var b = i.type;
          if (n !== null && i.stateNode != null)
            n.memoizedProps !== g && to(i);
          else {
            if (!g) {
              if (i.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return xi(i), null;
            }
            n = P(), yf(i) ? Fs(i) : (n = yv(
              b,
              g,
              c,
              n,
              !0
            ), i.stateNode = n, to(i));
          }
          return xi(i), null;
        case 5:
          if (ae(i), c = i.type, n !== null && i.stateNode != null)
            n.memoizedProps !== g && to(i);
          else {
            if (!g) {
              if (i.stateNode === null)
                throw Error(
                  "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                );
              return xi(i), null;
            }
            if (b = P(), yf(i))
              Fs(i);
            else {
              switch (n = me(dc.current), ff(c, b.ancestorInfo), b = b.context, n = Fn(n), b) {
                case G_:
                  n = n.createElementNS(Uv, c);
                  break;
                case YE:
                  n = n.createElementNS(
                    Og,
                    c
                  );
                  break;
                default:
                  switch (c) {
                    case "svg":
                      n = n.createElementNS(
                        Uv,
                        c
                      );
                      break;
                    case "math":
                      n = n.createElementNS(
                        Og,
                        c
                      );
                      break;
                    case "script":
                      n = n.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild);
                      break;
                    case "select":
                      n = typeof g.is == "string" ? n.createElement("select", { is: g.is }) : n.createElement("select"), g.multiple ? n.multiple = !0 : g.size && (n.size = g.size);
                      break;
                    default:
                      n = typeof g.is == "string" ? n.createElement(c, {
                        is: g.is
                      }) : n.createElement(c), c.indexOf("-") === -1 && (c !== c.toLowerCase() && console.error(
                        "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                        c
                      ), Object.prototype.toString.call(n) !== "[object HTMLUnknownElement]" || Kc.call(
                        CD,
                        c
                      ) || (CD[c] = !0, console.error(
                        "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                        c
                      )));
                  }
              }
              n[ws] = i, n[Hr] = g;
              e: for (b = i.child; b !== null; ) {
                if (b.tag === 5 || b.tag === 6)
                  n.appendChild(b.stateNode);
                else if (b.tag !== 4 && b.tag !== 27 && b.child !== null) {
                  b.child.return = b, b = b.child;
                  continue;
                }
                if (b === i) break e;
                for (; b.sibling === null; ) {
                  if (b.return === null || b.return === i)
                    break e;
                  b = b.return;
                }
                b.sibling.return = b.return, b = b.sibling;
              }
              i.stateNode = n;
              e: switch (yl(n, c, g), c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  n = !!g.autoFocus;
                  break e;
                case "img":
                  n = !0;
                  break e;
                default:
                  n = !1;
              }
              n && to(i);
            }
          }
          return xi(i), i.flags &= -16777217, null;
        case 6:
          if (n && i.stateNode != null)
            n.memoizedProps !== g && to(i);
          else {
            if (typeof g != "string" && i.stateNode === null)
              throw Error(
                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
              );
            if (n = me(dc.current), c = P(), yf(i)) {
              n = i.stateNode, c = i.memoizedProps, b = !Ir, g = null;
              var R = vc;
              if (R !== null)
                switch (R.tag) {
                  case 3:
                    b && (b = _m(
                      n,
                      c,
                      g
                    ), b !== null && (Vs(i, 0).serverProps = b));
                    break;
                  case 27:
                  case 5:
                    g = R.memoizedProps, b && (b = _m(
                      n,
                      c,
                      g
                    ), b !== null && (Vs(
                      i,
                      0
                    ).serverProps = b));
                }
              n[ws] = i, n = !!(n.nodeValue === c || g !== null && g.suppressHydrationWarning === !0 || gm(n.nodeValue, c)), n || $s(i);
            } else
              b = c.ancestorInfo.current, b != null && Xu(
                g,
                b.tag,
                c.ancestorInfo.implicitRootScope
              ), n = Fn(n).createTextNode(
                g
              ), n[ws] = i, i.stateNode = n;
          }
          return xi(i), null;
        case 13:
          if (g = i.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
            if (b = yf(i), g !== null && g.dehydrated !== null) {
              if (n === null) {
                if (!b)
                  throw Error(
                    "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                  );
                if (b = i.memoizedState, b = b !== null ? b.dehydrated : null, !b)
                  throw Error(
                    "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                  );
                b[ws] = i, xi(i), (i.mode & _o) !== Xi && g !== null && (b = i.child, b !== null && (i.treeBaseDuration -= b.treeBaseDuration));
              } else
                Wm(), Rc(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4, xi(i), (i.mode & _o) !== Xi && g !== null && (b = i.child, b !== null && (i.treeBaseDuration -= b.treeBaseDuration));
              b = !1;
            } else
              b = ud(), n !== null && n.memoizedState !== null && (n.memoizedState.hydrationErrors = b), b = !0;
            if (!b)
              return i.flags & 256 ? (Zl(i), i) : (Zl(i), null);
          }
          return Zl(i), (i.flags & 128) !== 0 ? (i.lanes = c, (i.mode & _o) !== Xi && du(i), i) : (c = g !== null, n = n !== null && n.memoizedState !== null, c && (g = i.child, b = null, g.alternate !== null && g.alternate.memoizedState !== null && g.alternate.memoizedState.cachePool !== null && (b = g.alternate.memoizedState.cachePool.pool), R = null, g.memoizedState !== null && g.memoizedState.cachePool !== null && (R = g.memoizedState.cachePool.pool), R !== b && (g.flags |= 2048)), c !== n && c && (i.child.flags |= 8192), Sh(i, i.updateQueue), xi(i), (i.mode & _o) !== Xi && c && (n = i.child, n !== null && (i.treeBaseDuration -= n.treeBaseDuration)), null);
        case 4:
          return He(i), n === null && mm(
            i.stateNode.containerInfo
          ), xi(i), null;
        case 10:
          return gr(i.type, i), xi(i), null;
        case 19:
          if (re(Iu, i), b = i.memoizedState, b === null) return xi(i), null;
          if (g = (i.flags & 128) !== 0, R = b.rendering, R === null)
            if (g) _h(b, !1);
            else {
              if (Vr !== Cy || n !== null && (n.flags & 128) !== 0)
                for (n = i.child; n !== null; ) {
                  if (R = Tl(n), R !== null) {
                    for (i.flags |= 128, _h(b, !1), n = R.updateQueue, i.updateQueue = n, Sh(i, n), i.subtreeFlags = 0, n = c, c = i.child; c !== null; )
                      gf(c, n), c = c.sibling;
                    return _e(
                      Iu,
                      Iu.current & C_ | Y1,
                      i
                    ), i.child;
                  }
                  n = n.sibling;
                }
              b.tail !== null && Nd() > OE && (i.flags |= 128, g = !0, _h(b, !1), i.lanes = 4194304);
            }
          else {
            if (!g)
              if (n = Tl(R), n !== null) {
                if (i.flags |= 128, g = !0, n = n.updateQueue, i.updateQueue = n, Sh(i, n), _h(b, !0), b.tail === null && b.tailMode === "hidden" && !R.alternate && !Di)
                  return xi(i), null;
              } else
                2 * Nd() - b.renderingStartTime > OE && c !== 536870912 && (i.flags |= 128, g = !0, _h(b, !1), i.lanes = 4194304);
            b.isBackwards ? (R.sibling = i.child, i.child = R) : (n = b.last, n !== null ? n.sibling = R : i.child = R, b.last = R);
          }
          return b.tail !== null ? (n = b.tail, b.rendering = n, b.tail = n.sibling, b.renderingStartTime = Nd(), n.sibling = null, c = Iu.current, c = g ? c & C_ | Y1 : c & C_, _e(Iu, c, i), n) : (xi(i), null);
        case 22:
        case 23:
          return Zl(i), tl(i), g = i.memoizedState !== null, n !== null ? n.memoizedState !== null !== g && (i.flags |= 8192) : g && (i.flags |= 8192), g ? (c & 536870912) !== 0 && (i.flags & 128) === 0 && (xi(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : xi(i), c = i.updateQueue, c !== null && Sh(i, c.retryQueue), c = null, n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (c = n.memoizedState.cachePool.pool), g = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (g = i.memoizedState.cachePool.pool), g !== c && (i.flags |= 2048), n !== null && re(Lh, i), null;
        case 24:
          return c = null, n !== null && (c = n.memoizedState.cache), i.memoizedState.cache !== c && (i.flags |= 2048), gr(x, i), xi(i), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(
        "Unknown unit of work tag (" + i.tag + "). This error is likely caused by a bug in React. Please file an issue."
      );
    }
    function Wg(n, i) {
      switch (vr(i), i.tag) {
        case 1:
          return n = i.flags, n & 65536 ? (i.flags = n & -65537 | 128, (i.mode & _o) !== Xi && du(i), i) : null;
        case 3:
          return gr(x, i), He(i), n = i.flags, (n & 65536) !== 0 && (n & 128) === 0 ? (i.flags = n & -65537 | 128, i) : null;
        case 26:
        case 27:
        case 5:
          return ae(i), null;
        case 13:
          if (Zl(i), n = i.memoizedState, n !== null && n.dehydrated !== null) {
            if (i.alternate === null)
              throw Error(
                "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
              );
            Rc();
          }
          return n = i.flags, n & 65536 ? (i.flags = n & -65537 | 128, (i.mode & _o) !== Xi && du(i), i) : null;
        case 19:
          return re(Iu, i), null;
        case 4:
          return He(i), null;
        case 10:
          return gr(i.type, i), null;
        case 22:
        case 23:
          return Zl(i), tl(i), n !== null && re(Lh, i), n = i.flags, n & 65536 ? (i.flags = n & -65537 | 128, (i.mode & _o) !== Xi && du(i), i) : null;
        case 24:
          return gr(x, i), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function sp(n, i) {
      switch (vr(i), i.tag) {
        case 3:
          gr(x, i), He(i);
          break;
        case 26:
        case 27:
        case 5:
          ae(i);
          break;
        case 4:
          He(i);
          break;
        case 13:
          Zl(i);
          break;
        case 19:
          re(Iu, i);
          break;
        case 10:
          gr(i.type, i);
          break;
        case 22:
        case 23:
          Zl(i), tl(i), n !== null && re(Lh, i);
          break;
        case 24:
          gr(x, i);
      }
    }
    function Go(n) {
      return (n.mode & _o) !== Xi;
    }
    function pg(n, i) {
      Go(n) ? (Oo(), Lc(i, n), qr()) : Lc(i, n);
    }
    function cv(n, i, c) {
      Go(n) ? (Oo(), rp(
        c,
        n,
        i
      ), qr()) : rp(
        c,
        n,
        i
      );
    }
    function Lc(n, i) {
      try {
        var c = i.updateQueue, g = c !== null ? c.lastEffect : null;
        if (g !== null) {
          var b = g.next;
          c = b;
          do {
            if ((c.tag & n) === n && ((n & Gu) !== Hm ? vn !== null && typeof vn.markComponentPassiveEffectMountStarted == "function" && vn.markComponentPassiveEffectMountStarted(
              i
            ) : (n & nf) !== Hm && vn !== null && typeof vn.markComponentLayoutEffectMountStarted == "function" && vn.markComponentLayoutEffectMountStarted(
              i
            ), g = void 0, (n & Xd) !== Hm && (H_ = !0), g = un(
              i,
              uN,
              c
            ), (n & Xd) !== Hm && (H_ = !1), (n & Gu) !== Hm ? vn !== null && typeof vn.markComponentPassiveEffectMountStopped == "function" && vn.markComponentPassiveEffectMountStopped() : (n & nf) !== Hm && vn !== null && typeof vn.markComponentLayoutEffectMountStopped == "function" && vn.markComponentLayoutEffectMountStopped(), g !== void 0 && typeof g != "function")) {
              var R = void 0;
              R = (c.tag & nf) !== 0 ? "useLayoutEffect" : (c.tag & Xd) !== 0 ? "useInsertionEffect" : "useEffect";
              var X = void 0;
              X = g === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof g.then == "function" ? `

It looks like you wrote ` + R + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + R + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching` : " You returned: " + g, un(
                i,
                function(K, de) {
                  console.error(
                    "%s must not return anything besides a function, which is used for clean-up.%s",
                    K,
                    de
                  );
                },
                R,
                X
              );
            }
            c = c.next;
          } while (c !== b);
        }
      } catch (K) {
        Tn(i, i.return, K);
      }
    }
    function rp(n, i, c) {
      try {
        var g = i.updateQueue, b = g !== null ? g.lastEffect : null;
        if (b !== null) {
          var R = b.next;
          g = R;
          do {
            if ((g.tag & n) === n) {
              var X = g.inst, K = X.destroy;
              K !== void 0 && (X.destroy = void 0, (n & Gu) !== Hm ? vn !== null && typeof vn.markComponentPassiveEffectUnmountStarted == "function" && vn.markComponentPassiveEffectUnmountStarted(
                i
              ) : (n & nf) !== Hm && vn !== null && typeof vn.markComponentLayoutEffectUnmountStarted == "function" && vn.markComponentLayoutEffectUnmountStarted(
                i
              ), (n & Xd) !== Hm && (H_ = !0), b = i, un(
                b,
                cN,
                b,
                c,
                K
              ), (n & Xd) !== Hm && (H_ = !1), (n & Gu) !== Hm ? vn !== null && typeof vn.markComponentPassiveEffectUnmountStopped == "function" && vn.markComponentPassiveEffectUnmountStopped() : (n & nf) !== Hm && vn !== null && typeof vn.markComponentLayoutEffectUnmountStopped == "function" && vn.markComponentLayoutEffectUnmountStopped());
            }
            g = g.next;
          } while (g !== R);
        }
      } catch (de) {
        Tn(i, i.return, de);
      }
    }
    function mg(n, i) {
      Go(n) ? (Oo(), Lc(i, n), qr()) : Lc(i, n);
    }
    function nc(n, i, c) {
      Go(n) ? (Oo(), rp(
        c,
        n,
        i
      ), qr()) : rp(
        c,
        n,
        i
      );
    }
    function fv(n) {
      var i = n.updateQueue;
      if (i !== null) {
        var c = n.stateNode;
        n.type.defaultProps || "ref" in n.memoizedProps || D_ || (c.props !== n.memoizedProps && console.error(
          "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
          Q(n) || "instance"
        ), c.state !== n.memoizedState && console.error(
          "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
          Q(n) || "instance"
        ));
        try {
          un(
            n,
            nv,
            i,
            c
          );
        } catch (g) {
          Tn(n, n.return, g);
        }
      }
    }
    function $g(n, i, c) {
      return n.getSnapshotBeforeUpdate(i, c);
    }
    function e0(n, i) {
      var c = i.memoizedProps, g = i.memoizedState;
      i = n.stateNode, n.type.defaultProps || "ref" in n.memoizedProps || D_ || (i.props !== n.memoizedProps && console.error(
        "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
        Q(n) || "instance"
      ), i.state !== n.memoizedState && console.error(
        "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
        Q(n) || "instance"
      ));
      try {
        var b = Rf(
          n.type,
          c,
          n.elementType === n.type
        ), R = un(
          n,
          $g,
          i,
          b,
          g
        );
        c = uD, R !== void 0 || c.has(n.type) || (c.add(n.type), un(n, function() {
          console.error(
            "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
            Q(n)
          );
        })), i.__reactInternalSnapshotBeforeUpdate = R;
      } catch (X) {
        Tn(n, n.return, X);
      }
    }
    function cm(n, i, c) {
      c.props = Rf(
        n.type,
        n.memoizedProps
      ), c.state = n.memoizedState, Go(n) ? (Oo(), un(
        n,
        HR,
        n,
        i,
        c
      ), qr()) : un(
        n,
        HR,
        n,
        i,
        c
      );
    }
    function t0(n) {
      var i = n.ref;
      if (i !== null) {
        switch (n.tag) {
          case 26:
          case 27:
          case 5:
            var c = n.stateNode;
            break;
          case 30:
            c = n.stateNode;
            break;
          default:
            c = n.stateNode;
        }
        if (typeof i == "function")
          if (Go(n))
            try {
              Oo(), n.refCleanup = i(c);
            } finally {
              qr();
            }
          else n.refCleanup = i(c);
        else
          typeof i == "string" ? console.error("String refs are no longer supported.") : i.hasOwnProperty("current") || console.error(
            "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
            Q(n)
          ), i.current = c;
      }
    }
    function Ah(n, i) {
      try {
        un(n, t0, n);
      } catch (c) {
        Tn(n, i, c);
      }
    }
    function Es(n, i) {
      var c = n.ref, g = n.refCleanup;
      if (c !== null)
        if (typeof g == "function")
          try {
            if (Go(n))
              try {
                Oo(), un(n, g);
              } finally {
                qr(n);
              }
            else un(n, g);
          } catch (b) {
            Tn(n, i, b);
          } finally {
            n.refCleanup = null, n = n.alternate, n != null && (n.refCleanup = null);
          }
        else if (typeof c == "function")
          try {
            if (Go(n))
              try {
                Oo(), un(n, c, null);
              } finally {
                qr(n);
              }
            else un(n, c, null);
          } catch (b) {
            Tn(n, i, b);
          }
        else c.current = null;
    }
    function vg(n, i, c, g) {
      var b = n.memoizedProps, R = b.id, X = b.onCommit;
      b = b.onRender, i = i === null ? "mount" : "update", ht && (i = "nested-update"), typeof b == "function" && b(
        R,
        i,
        n.actualDuration,
        n.treeBaseDuration,
        n.actualStartTime,
        c
      ), typeof X == "function" && X(
        n.memoizedProps.id,
        i,
        g,
        c
      );
    }
    function gg(n, i, c, g) {
      var b = n.memoizedProps;
      n = b.id, b = b.onPostCommit, i = i === null ? "mount" : "update", ht && (i = "nested-update"), typeof b == "function" && b(
        n,
        i,
        g,
        c
      );
    }
    function dv(n) {
      var i = n.type, c = n.memoizedProps, g = n.stateNode;
      try {
        un(
          n,
          uc,
          g,
          i,
          c,
          n
        );
      } catch (b) {
        Tn(n, n.return, b);
      }
    }
    function bd(n, i, c) {
      try {
        un(
          n,
          il,
          n.stateNode,
          n.type,
          c,
          i,
          n
        );
      } catch (g) {
        Tn(n, n.return, g);
      }
    }
    function yg(n) {
      return n.tag === 5 || n.tag === 3 || n.tag === 26 || n.tag === 27 && oo(n.type) || n.tag === 4;
    }
    function Md(n) {
      e: for (; ; ) {
        for (; n.sibling === null; ) {
          if (n.return === null || yg(n.return)) return null;
          n = n.return;
        }
        for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
          if (n.tag === 27 && oo(n.type) || n.flags & 2 || n.child === null || n.tag === 4) continue e;
          n.child.return = n, n = n.child;
        }
        if (!(n.flags & 2)) return n.stateNode;
      }
    }
    function Eh(n, i, c) {
      var g = n.tag;
      if (g === 5 || g === 6)
        n = n.stateNode, i ? (c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c).insertBefore(n, i) : (i = c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, i.appendChild(n), c = c._reactRootContainer, c != null || i.onclick !== null || (i.onclick = bu));
      else if (g !== 4 && (g === 27 && oo(n.type) && (c = n.stateNode, i = null), n = n.child, n !== null))
        for (Eh(n, i, c), n = n.sibling; n !== null; )
          Eh(n, i, c), n = n.sibling;
    }
    function op(n, i, c) {
      var g = n.tag;
      if (g === 5 || g === 6)
        n = n.stateNode, i ? c.insertBefore(n, i) : c.appendChild(n);
      else if (g !== 4 && (g === 27 && oo(n.type) && (c = n.stateNode), n = n.child, n !== null))
        for (op(n, i, c), n = n.sibling; n !== null; )
          op(n, i, c), n = n.sibling;
    }
    function ey(n) {
      for (var i, c = n.return; c !== null; ) {
        if (yg(c)) {
          i = c;
          break;
        }
        c = c.return;
      }
      if (i == null)
        throw Error(
          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
        );
      switch (i.tag) {
        case 27:
          i = i.stateNode, c = Md(n), op(
            n,
            c,
            i
          );
          break;
        case 5:
          c = i.stateNode, i.flags & 32 && (Mu(c), i.flags &= -33), i = Md(n), op(
            n,
            i,
            c
          );
          break;
        case 3:
        case 4:
          i = i.stateNode.containerInfo, c = Md(n), Eh(
            n,
            c,
            i
          );
          break;
        default:
          throw Error(
            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
          );
      }
    }
    function no(n) {
      var i = n.stateNode, c = n.memoizedProps;
      try {
        un(
          n,
          fo,
          n.type,
          c,
          i,
          n
        );
      } catch (g) {
        Tn(n, n.return, g);
      }
    }
    function fm(n, i) {
      if (n = n.containerInfo, ET = jE, n = mf(n), vf(n)) {
        if ("selectionStart" in n)
          var c = {
            start: n.selectionStart,
            end: n.selectionEnd
          };
        else
          e: {
            c = (c = n.ownerDocument) && c.defaultView || window;
            var g = c.getSelection && c.getSelection();
            if (g && g.rangeCount !== 0) {
              c = g.anchorNode;
              var b = g.anchorOffset, R = g.focusNode;
              g = g.focusOffset;
              try {
                c.nodeType, R.nodeType;
              } catch {
                c = null;
                break e;
              }
              var X = 0, K = -1, de = -1, ge = 0, ut = 0, xt = n, it = null;
              t: for (; ; ) {
                for (var Dt; xt !== c || b !== 0 && xt.nodeType !== 3 || (K = X + b), xt !== R || g !== 0 && xt.nodeType !== 3 || (de = X + g), xt.nodeType === 3 && (X += xt.nodeValue.length), (Dt = xt.firstChild) !== null; )
                  it = xt, xt = Dt;
                for (; ; ) {
                  if (xt === n) break t;
                  if (it === c && ++ge === b && (K = X), it === R && ++ut === g && (de = X), (Dt = xt.nextSibling) !== null) break;
                  xt = it, it = xt.parentNode;
                }
                xt = Dt;
              }
              c = K === -1 || de === -1 ? null : { start: K, end: de };
            } else c = null;
          }
        c = c || { start: 0, end: 0 };
      } else c = null;
      for (bT = {
        focusedElem: n,
        selectionRange: c
      }, jE = !1, yc = i; yc !== null; )
        if (i = yc, n = i.child, (i.subtreeFlags & 1024) !== 0 && n !== null)
          n.return = i, yc = n;
        else
          for (; yc !== null; ) {
            switch (n = i = yc, c = n.alternate, b = n.flags, n.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                (b & 1024) !== 0 && c !== null && e0(n, c);
                break;
              case 3:
                if ((b & 1024) !== 0) {
                  if (n = n.stateNode.containerInfo, c = n.nodeType, c === 9)
                    uo(n);
                  else if (c === 1)
                    switch (n.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        uo(n);
                        break;
                      default:
                        n.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((b & 1024) !== 0)
                  throw Error(
                    "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                  );
            }
            if (n = i.sibling, n !== null) {
              n.return = i.return, yc = n;
              break;
            }
            yc = i.return;
          }
    }
    function dm(n, i, c) {
      var g = c.flags;
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
          Br(n, c), g & 4 && pg(c, nf | Lm);
          break;
        case 1:
          if (Br(n, c), g & 4)
            if (n = c.stateNode, i === null)
              c.type.defaultProps || "ref" in c.memoizedProps || D_ || (n.props !== c.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                Q(c) || "instance"
              ), n.state !== c.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                Q(c) || "instance"
              )), Go(c) ? (Oo(), un(
                c,
                Kx,
                c,
                n
              ), qr()) : un(
                c,
                Kx,
                c,
                n
              );
            else {
              var b = Rf(
                c.type,
                i.memoizedProps
              );
              i = i.memoizedState, c.type.defaultProps || "ref" in c.memoizedProps || D_ || (n.props !== c.memoizedProps && console.error(
                "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                Q(c) || "instance"
              ), n.state !== c.memoizedState && console.error(
                "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                Q(c) || "instance"
              )), Go(c) ? (Oo(), un(
                c,
                wR,
                c,
                n,
                b,
                i,
                n.__reactInternalSnapshotBeforeUpdate
              ), qr()) : un(
                c,
                wR,
                c,
                n,
                b,
                i,
                n.__reactInternalSnapshotBeforeUpdate
              );
            }
          g & 64 && fv(c), g & 512 && Ah(c, c.return);
          break;
        case 3:
          if (i = Uo(), Br(n, c), g & 64 && (g = c.updateQueue, g !== null)) {
            if (b = null, c.child !== null)
              switch (c.child.tag) {
                case 27:
                case 5:
                  b = c.child.stateNode;
                  break;
                case 1:
                  b = c.child.stateNode;
              }
            try {
              un(
                c,
                nv,
                g,
                b
              );
            } catch (X) {
              Tn(c, c.return, X);
            }
          }
          n.effectDuration += _f(i);
          break;
        case 27:
          i === null && g & 4 && no(c);
        case 26:
        case 5:
          Br(n, c), i === null && g & 4 && dv(c), g & 512 && Ah(c, c.return);
          break;
        case 12:
          if (g & 4) {
            g = Uo(), Br(n, c), n = c.stateNode, n.effectDuration += oh(g);
            try {
              un(
                c,
                vg,
                c,
                i,
                J,
                n.effectDuration
              );
            } catch (X) {
              Tn(c, c.return, X);
            }
          } else Br(n, c);
          break;
        case 13:
          Br(n, c), g & 4 && hm(n, c), g & 64 && (n = c.memoizedState, n !== null && (n = n.dehydrated, n !== null && (c = dp.bind(
            null,
            c
          ), Vi(n, c))));
          break;
        case 22:
          if (g = c.memoizedState !== null || Ty, !g) {
            i = i !== null && i.memoizedState !== null || Ao, b = Ty;
            var R = Ao;
            Ty = g, (Ao = i) && !R ? ic(
              n,
              c,
              (c.subtreeFlags & 8772) !== 0
            ) : Br(n, c), Ty = b, Ao = R;
          }
          break;
        case 30:
          break;
        default:
          Br(n, c);
      }
    }
    function hv(n) {
      var i = n.alternate;
      i !== null && (n.alternate = null, hv(i)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (i = n.stateNode, i !== null && gn(i)), n.stateNode = null, n._debugOwner = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
    }
    function Gc(n, i, c) {
      for (c = c.child; c !== null; )
        Bf(
          n,
          i,
          c
        ), c = c.sibling;
    }
    function Bf(n, i, c) {
      if (zr && typeof zr.onCommitFiberUnmount == "function")
        try {
          zr.onCommitFiberUnmount(yp, c);
        } catch (R) {
          Bu || (Bu = !0, console.error(
            "React instrumentation encountered an error: %s",
            R
          ));
        }
      switch (c.tag) {
        case 26:
          Ao || Es(c, i), Gc(
            n,
            i,
            c
          ), c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode, c.parentNode.removeChild(c));
          break;
        case 27:
          Ao || Es(c, i);
          var g = eu, b = Ih;
          oo(c.type) && (eu = c.stateNode, Ih = !1), Gc(
            n,
            i,
            c
          ), un(
            c,
            Vf,
            c.stateNode
          ), eu = g, Ih = b;
          break;
        case 5:
          Ao || Es(c, i);
        case 6:
          if (g = eu, b = Ih, eu = null, Gc(
            n,
            i,
            c
          ), eu = g, Ih = b, eu !== null)
            if (Ih)
              try {
                un(
                  c,
                  hi,
                  eu,
                  c.stateNode
                );
              } catch (R) {
                Tn(
                  c,
                  i,
                  R
                );
              }
            else
              try {
                un(
                  c,
                  xu,
                  eu,
                  c.stateNode
                );
              } catch (R) {
                Tn(
                  c,
                  i,
                  R
                );
              }
          break;
        case 18:
          eu !== null && (Ih ? (n = eu, Si(
            n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n,
            c.stateNode
          ), Jo(n)) : Si(eu, c.stateNode));
          break;
        case 4:
          g = eu, b = Ih, eu = c.stateNode.containerInfo, Ih = !0, Gc(
            n,
            i,
            c
          ), eu = g, Ih = b;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          Ao || rp(
            Xd,
            c,
            i
          ), Ao || cv(
            c,
            i,
            nf
          ), Gc(
            n,
            i,
            c
          );
          break;
        case 1:
          Ao || (Es(c, i), g = c.stateNode, typeof g.componentWillUnmount == "function" && cm(
            c,
            i,
            g
          )), Gc(
            n,
            i,
            c
          );
          break;
        case 21:
          Gc(
            n,
            i,
            c
          );
          break;
        case 22:
          Ao = (g = Ao) || c.memoizedState !== null, Gc(
            n,
            i,
            c
          ), Ao = g;
          break;
        default:
          Gc(
            n,
            i,
            c
          );
      }
    }
    function hm(n, i) {
      if (i.memoizedState === null && (n = i.alternate, n !== null && (n = n.memoizedState, n !== null && (n = n.dehydrated, n !== null))))
        try {
          un(
            i,
            wl,
            n
          );
        } catch (c) {
          Tn(i, i.return, c);
        }
    }
    function pv(n) {
      switch (n.tag) {
        case 13:
        case 19:
          var i = n.stateNode;
          return i === null && (i = n.stateNode = new cD()), i;
        case 22:
          return n = n.stateNode, i = n._retryCache, i === null && (i = n._retryCache = new cD()), i;
        default:
          throw Error(
            "Unexpected Suspense handler tag (" + n.tag + "). This is a bug in React."
          );
      }
    }
    function pa(n, i) {
      var c = pv(n);
      i.forEach(function(g) {
        var b = Au.bind(null, n, g);
        if (!c.has(g)) {
          if (c.add(g), kl)
            if (B_ !== null && U_ !== null)
              so(U_, B_);
            else
              throw Error(
                "Expected finished root and lanes to be set. This is a bug in React."
              );
          g.then(b, b);
        }
      });
    }
    function Rr(n, i) {
      var c = i.deletions;
      if (c !== null)
        for (var g = 0; g < c.length; g++) {
          var b = n, R = i, X = c[g], K = R;
          e: for (; K !== null; ) {
            switch (K.tag) {
              case 27:
                if (oo(K.type)) {
                  eu = K.stateNode, Ih = !1;
                  break e;
                }
                break;
              case 5:
                eu = K.stateNode, Ih = !1;
                break e;
              case 3:
              case 4:
                eu = K.stateNode.containerInfo, Ih = !0;
                break e;
            }
            K = K.return;
          }
          if (eu === null)
            throw Error(
              "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
            );
          Bf(b, R, X), eu = null, Ih = !1, b = X, R = b.alternate, R !== null && (R.return = null), b.return = null;
        }
      if (i.subtreeFlags & 13878)
        for (i = i.child; i !== null; )
          Dr(i, n), i = i.sibling;
    }
    function Dr(n, i) {
      var c = n.alternate, g = n.flags;
      switch (n.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Rr(i, n), Ti(n), g & 4 && (rp(
            Xd | Lm,
            n,
            n.return
          ), Lc(Xd | Lm, n), cv(
            n,
            n.return,
            nf | Lm
          ));
          break;
        case 1:
          Rr(i, n), Ti(n), g & 512 && (Ao || c === null || Es(c, c.return)), g & 64 && Ty && (n = n.updateQueue, n !== null && (g = n.callbacks, g !== null && (c = n.shared.hiddenCallbacks, n.shared.hiddenCallbacks = c === null ? g : c.concat(g))));
          break;
        case 26:
          var b = Iv;
          if (Rr(i, n), Ti(n), g & 512 && (Ao || c === null || Es(c, c.return)), g & 4)
            if (i = c !== null ? c.memoizedState : null, g = n.memoizedState, c === null)
              if (g === null)
                if (n.stateNode === null) {
                  e: {
                    g = n.type, c = n.memoizedProps, i = b.ownerDocument || b;
                    t: switch (g) {
                      case "title":
                        b = i.getElementsByTagName("title")[0], (!b || b[Tv] || b[ws] || b.namespaceURI === Uv || b.hasAttribute("itemprop")) && (b = i.createElement(g), i.head.insertBefore(
                          b,
                          i.querySelector("head > title")
                        )), yl(b, g, c), b[ws] = n, Ht(b), g = b;
                        break e;
                      case "link":
                        var R = Z(
                          "link",
                          "href",
                          i
                        ).get(g + (c.href || ""));
                        if (R) {
                          for (var X = 0; X < R.length; X++)
                            if (b = R[X], b.getAttribute("href") === (c.href == null || c.href === "" ? null : c.href) && b.getAttribute("rel") === (c.rel == null ? null : c.rel) && b.getAttribute("title") === (c.title == null ? null : c.title) && b.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                              R.splice(X, 1);
                              break t;
                            }
                        }
                        b = i.createElement(g), yl(b, g, c), i.head.appendChild(b);
                        break;
                      case "meta":
                        if (R = Z(
                          "meta",
                          "content",
                          i
                        ).get(g + (c.content || ""))) {
                          for (X = 0; X < R.length; X++)
                            if (b = R[X], De(
                              c.content,
                              "content"
                            ), b.getAttribute("content") === (c.content == null ? null : "" + c.content) && b.getAttribute("name") === (c.name == null ? null : c.name) && b.getAttribute("property") === (c.property == null ? null : c.property) && b.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && b.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                              R.splice(X, 1);
                              break t;
                            }
                        }
                        b = i.createElement(g), yl(b, g, c), i.head.appendChild(b);
                        break;
                      default:
                        throw Error(
                          'getNodesForType encountered a type it did not expect: "' + g + '". This is a bug in React.'
                        );
                    }
                    b[ws] = n, Ht(b), g = b;
                  }
                  n.stateNode = g;
                } else
                  fe(
                    b,
                    n.type,
                    n.stateNode
                  );
              else
                n.stateNode = m(
                  b,
                  g,
                  n.memoizedProps
                );
            else
              i !== g ? (i === null ? c.stateNode !== null && (c = c.stateNode, c.parentNode.removeChild(c)) : i.count--, g === null ? fe(
                b,
                n.type,
                n.stateNode
              ) : m(
                b,
                g,
                n.memoizedProps
              )) : g === null && n.stateNode !== null && bd(
                n,
                n.memoizedProps,
                c.memoizedProps
              );
          break;
        case 27:
          Rr(i, n), Ti(n), g & 512 && (Ao || c === null || Es(c, c.return)), c !== null && g & 4 && bd(
            n,
            n.memoizedProps,
            c.memoizedProps
          );
          break;
        case 5:
          if (Rr(i, n), Ti(n), g & 512 && (Ao || c === null || Es(c, c.return)), n.flags & 32) {
            i = n.stateNode;
            try {
              un(n, Mu, i);
            } catch (ut) {
              Tn(n, n.return, ut);
            }
          }
          g & 4 && n.stateNode != null && (i = n.memoizedProps, bd(
            n,
            i,
            c !== null ? c.memoizedProps : i
          )), g & 1024 && (aT = !0, n.type !== "form" && console.error(
            "Unexpected host component type. Expected a form. This is a bug in React."
          ));
          break;
        case 6:
          if (Rr(i, n), Ti(n), g & 4) {
            if (n.stateNode === null)
              throw Error(
                "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
              );
            g = n.memoizedProps, c = c !== null ? c.memoizedProps : g, i = n.stateNode;
            try {
              un(
                n,
                Zc,
                i,
                c,
                g
              );
            } catch (ut) {
              Tn(n, n.return, ut);
            }
          }
          break;
        case 3:
          if (b = Uo(), qE = null, R = Iv, Iv = Bd(i.containerInfo), Rr(i, n), Iv = R, Ti(n), g & 4 && c !== null && c.memoizedState.isDehydrated)
            try {
              un(
                n,
                Fl,
                i.containerInfo
              );
            } catch (ut) {
              Tn(n, n.return, ut);
            }
          aT && (aT = !1, bh(n)), i.effectDuration += _f(b);
          break;
        case 4:
          g = Iv, Iv = Bd(
            n.stateNode.containerInfo
          ), Rr(i, n), Ti(n), Iv = g;
          break;
        case 12:
          g = Uo(), Rr(i, n), Ti(n), n.stateNode.effectDuration += oh(g);
          break;
        case 13:
          Rr(i, n), Ti(n), n.child.flags & 8192 && n.memoizedState !== null != (c !== null && c.memoizedState !== null) && (uT = Nd()), g & 4 && (g = n.updateQueue, g !== null && (n.updateQueue = null, pa(n, g)));
          break;
        case 22:
          b = n.memoizedState !== null;
          var K = c !== null && c.memoizedState !== null, de = Ty, ge = Ao;
          if (Ty = de || b, Ao = ge || K, Rr(i, n), Ao = ge, Ty = de, Ti(n), g & 8192)
            e: for (i = n.stateNode, i._visibility = b ? i._visibility & -2 : i._visibility | p0, b && (c === null || K || Ty || Ao || Gl(n)), c = null, i = n; ; ) {
              if (i.tag === 5 || i.tag === 26) {
                if (c === null) {
                  K = c = i;
                  try {
                    R = K.stateNode, b ? un(K, Dn, R) : un(
                      K,
                      Ri,
                      K.stateNode,
                      K.memoizedProps
                    );
                  } catch (ut) {
                    Tn(K, K.return, ut);
                  }
                }
              } else if (i.tag === 6) {
                if (c === null) {
                  K = i;
                  try {
                    X = K.stateNode, b ? un(K, qa, X) : un(
                      K,
                      or,
                      X,
                      K.memoizedProps
                    );
                  } catch (ut) {
                    Tn(K, K.return, ut);
                  }
                }
              } else if ((i.tag !== 22 && i.tag !== 23 || i.memoizedState === null || i === n) && i.child !== null) {
                i.child.return = i, i = i.child;
                continue;
              }
              if (i === n) break e;
              for (; i.sibling === null; ) {
                if (i.return === null || i.return === n)
                  break e;
                c === i && (c = null), i = i.return;
              }
              c === i && (c = null), i.sibling.return = i.return, i = i.sibling;
            }
          g & 4 && (g = n.updateQueue, g !== null && (c = g.retryQueue, c !== null && (g.retryQueue = null, pa(n, c))));
          break;
        case 19:
          Rr(i, n), Ti(n), g & 4 && (g = n.updateQueue, g !== null && (n.updateQueue = null, pa(n, g)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          Rr(i, n), Ti(n);
      }
    }
    function Ti(n) {
      var i = n.flags;
      if (i & 2) {
        try {
          un(n, ey, n);
        } catch (c) {
          Tn(n, n.return, c);
        }
        n.flags &= -3;
      }
      i & 4096 && (n.flags &= -4097);
    }
    function bh(n) {
      if (n.subtreeFlags & 1024)
        for (n = n.child; n !== null; ) {
          var i = n;
          bh(i), i.tag === 5 && i.flags & 1024 && i.stateNode.reset(), n = n.sibling;
        }
    }
    function Br(n, i) {
      if (i.subtreeFlags & 8772)
        for (i = i.child; i !== null; )
          dm(n, i.alternate, i), i = i.sibling;
    }
    function oi(n) {
      switch (n.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          cv(
            n,
            n.return,
            nf
          ), Gl(n);
          break;
        case 1:
          Es(n, n.return);
          var i = n.stateNode;
          typeof i.componentWillUnmount == "function" && cm(
            n,
            n.return,
            i
          ), Gl(n);
          break;
        case 27:
          un(
            n,
            Vf,
            n.stateNode
          );
        case 26:
        case 5:
          Es(n, n.return), Gl(n);
          break;
        case 22:
          n.memoizedState === null && Gl(n);
          break;
        case 30:
          Gl(n);
          break;
        default:
          Gl(n);
      }
    }
    function Gl(n) {
      for (n = n.child; n !== null; )
        oi(n), n = n.sibling;
    }
    function ac(n, i, c, g) {
      var b = c.flags;
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
          ic(
            n,
            c,
            g
          ), pg(c, nf);
          break;
        case 1:
          if (ic(
            n,
            c,
            g
          ), i = c.stateNode, typeof i.componentDidMount == "function" && un(
            c,
            Kx,
            c,
            i
          ), i = c.updateQueue, i !== null) {
            n = c.stateNode;
            try {
              un(
                c,
                fd,
                i,
                n
              );
            } catch (R) {
              Tn(c, c.return, R);
            }
          }
          g && b & 64 && fv(c), Ah(c, c.return);
          break;
        case 27:
          no(c);
        case 26:
        case 5:
          ic(
            n,
            c,
            g
          ), g && i === null && b & 4 && dv(c), Ah(c, c.return);
          break;
        case 12:
          if (g && b & 4) {
            b = Uo(), ic(
              n,
              c,
              g
            ), g = c.stateNode, g.effectDuration += oh(b);
            try {
              un(
                c,
                vg,
                c,
                i,
                J,
                g.effectDuration
              );
            } catch (R) {
              Tn(c, c.return, R);
            }
          } else
            ic(
              n,
              c,
              g
            );
          break;
        case 13:
          ic(
            n,
            c,
            g
          ), g && b & 4 && hm(n, c);
          break;
        case 22:
          c.memoizedState === null && ic(
            n,
            c,
            g
          ), Ah(c, c.return);
          break;
        case 30:
          break;
        default:
          ic(
            n,
            c,
            g
          );
      }
    }
    function ic(n, i, c) {
      for (c = c && (i.subtreeFlags & 8772) !== 0, i = i.child; i !== null; )
        ac(
          n,
          i.alternate,
          i,
          c
        ), i = i.sibling;
    }
    function Uf(n, i) {
      var c = null;
      n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (c = n.memoizedState.cachePool.pool), n = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (n = i.memoizedState.cachePool.pool), n !== c && (n != null && Sf(n), c != null && ys(c));
    }
    function Io(n, i) {
      n = null, i.alternate !== null && (n = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== n && (Sf(i), n != null && ys(n));
    }
    function La(n, i, c, g) {
      if (i.subtreeFlags & 10256)
        for (i = i.child; i !== null; )
          Vo(
            n,
            i,
            c,
            g
          ), i = i.sibling;
    }
    function Vo(n, i, c, g) {
      var b = i.flags;
      switch (i.tag) {
        case 0:
        case 11:
        case 15:
          La(
            n,
            i,
            c,
            g
          ), b & 2048 && mg(i, Gu | Lm);
          break;
        case 1:
          La(
            n,
            i,
            c,
            g
          );
          break;
        case 3:
          var R = Uo();
          La(
            n,
            i,
            c,
            g
          ), b & 2048 && (c = null, i.alternate !== null && (c = i.alternate.memoizedState.cache), i = i.memoizedState.cache, i !== c && (Sf(i), c != null && ys(c))), n.passiveEffectDuration += _f(R);
          break;
        case 12:
          if (b & 2048) {
            b = Uo(), La(
              n,
              i,
              c,
              g
            ), n = i.stateNode, n.passiveEffectDuration += oh(b);
            try {
              un(
                i,
                gg,
                i,
                i.alternate,
                J,
                n.passiveEffectDuration
              );
            } catch (K) {
              Tn(i, i.return, K);
            }
          } else
            La(
              n,
              i,
              c,
              g
            );
          break;
        case 13:
          La(
            n,
            i,
            c,
            g
          );
          break;
        case 23:
          break;
        case 22:
          R = i.stateNode;
          var X = i.alternate;
          i.memoizedState !== null ? R._visibility & Nv ? La(
            n,
            i,
            c,
            g
          ) : xd(
            n,
            i
          ) : R._visibility & Nv ? La(
            n,
            i,
            c,
            g
          ) : (R._visibility |= Nv, ao(
            n,
            i,
            c,
            g,
            (i.subtreeFlags & 10256) !== 0
          )), b & 2048 && Uf(X, i);
          break;
        case 24:
          La(
            n,
            i,
            c,
            g
          ), b & 2048 && Io(i.alternate, i);
          break;
        default:
          La(
            n,
            i,
            c,
            g
          );
      }
    }
    function ao(n, i, c, g, b) {
      for (b = b && (i.subtreeFlags & 10256) !== 0, i = i.child; i !== null; )
        Qs(
          n,
          i,
          c,
          g,
          b
        ), i = i.sibling;
    }
    function Qs(n, i, c, g, b) {
      var R = i.flags;
      switch (i.tag) {
        case 0:
        case 11:
        case 15:
          ao(
            n,
            i,
            c,
            g,
            b
          ), mg(i, Gu);
          break;
        case 23:
          break;
        case 22:
          var X = i.stateNode;
          i.memoizedState !== null ? X._visibility & Nv ? ao(
            n,
            i,
            c,
            g,
            b
          ) : xd(
            n,
            i
          ) : (X._visibility |= Nv, ao(
            n,
            i,
            c,
            g,
            b
          )), b && R & 2048 && Uf(
            i.alternate,
            i
          );
          break;
        case 24:
          ao(
            n,
            i,
            c,
            g,
            b
          ), b && R & 2048 && Io(i.alternate, i);
          break;
        default:
          ao(
            n,
            i,
            c,
            g,
            b
          );
      }
    }
    function xd(n, i) {
      if (i.subtreeFlags & 10256)
        for (i = i.child; i !== null; ) {
          var c = n, g = i, b = g.flags;
          switch (g.tag) {
            case 22:
              xd(
                c,
                g
              ), b & 2048 && Uf(
                g.alternate,
                g
              );
              break;
            case 24:
              xd(
                c,
                g
              ), b & 2048 && Io(
                g.alternate,
                g
              );
              break;
            default:
              xd(
                c,
                g
              );
          }
          i = i.sibling;
        }
    }
    function bs(n) {
      if (n.subtreeFlags & q1)
        for (n = n.child; n !== null; )
          lc(n), n = n.sibling;
    }
    function lc(n) {
      switch (n.tag) {
        case 26:
          bs(n), n.flags & q1 && n.memoizedState !== null && en(
            Iv,
            n.memoizedState,
            n.memoizedProps
          );
          break;
        case 5:
          bs(n);
          break;
        case 3:
        case 4:
          var i = Iv;
          Iv = Bd(
            n.stateNode.containerInfo
          ), bs(n), Iv = i;
          break;
        case 22:
          n.memoizedState === null && (i = n.alternate, i !== null && i.memoizedState !== null ? (i = q1, q1 = 16777216, bs(n), q1 = i) : bs(n));
          break;
        default:
          bs(n);
      }
    }
    function Mh(n) {
      var i = n.alternate;
      if (i !== null && (n = i.child, n !== null)) {
        i.child = null;
        do
          i = n.sibling, n.sibling = null, n = i;
        while (n !== null);
      }
    }
    function Of(n) {
      var i = n.deletions;
      if ((n.flags & 16) !== 0) {
        if (i !== null)
          for (var c = 0; c < i.length; c++) {
            var g = i[c];
            yc = g, Fo(
              g,
              n
            );
          }
        Mh(n);
      }
      if (n.subtreeFlags & 10256)
        for (n = n.child; n !== null; )
          mv(n), n = n.sibling;
    }
    function mv(n) {
      switch (n.tag) {
        case 0:
        case 11:
        case 15:
          Of(n), n.flags & 2048 && nc(
            n,
            n.return,
            Gu | Lm
          );
          break;
        case 3:
          var i = Uo();
          Of(n), n.stateNode.passiveEffectDuration += _f(i);
          break;
        case 12:
          i = Uo(), Of(n), n.stateNode.passiveEffectDuration += oh(i);
          break;
        case 22:
          i = n.stateNode, n.memoizedState !== null && i._visibility & Nv && (n.return === null || n.return.tag !== 13) ? (i._visibility &= -3, ft(n)) : Of(n);
          break;
        default:
          Of(n);
      }
    }
    function ft(n) {
      var i = n.deletions;
      if ((n.flags & 16) !== 0) {
        if (i !== null)
          for (var c = 0; c < i.length; c++) {
            var g = i[c];
            yc = g, Fo(
              g,
              n
            );
          }
        Mh(n);
      }
      for (n = n.child; n !== null; )
        Td(n), n = n.sibling;
    }
    function Td(n) {
      switch (n.tag) {
        case 0:
        case 11:
        case 15:
          nc(
            n,
            n.return,
            Gu
          ), ft(n);
          break;
        case 22:
          var i = n.stateNode;
          i._visibility & Nv && (i._visibility &= -3, ft(n));
          break;
        default:
          ft(n);
      }
    }
    function Fo(n, i) {
      for (; yc !== null; ) {
        var c = yc, g = c;
        switch (g.tag) {
          case 0:
          case 11:
          case 15:
            nc(
              g,
              i,
              Gu
            );
            break;
          case 23:
          case 22:
            g.memoizedState !== null && g.memoizedState.cachePool !== null && (g = g.memoizedState.cachePool.pool, g != null && Sf(g));
            break;
          case 24:
            ys(g.memoizedState.cache);
        }
        if (g = c.child, g !== null) g.return = c, yc = g;
        else
          e: for (c = n; yc !== null; ) {
            g = yc;
            var b = g.sibling, R = g.return;
            if (hv(g), g === c) {
              yc = null;
              break e;
            }
            if (b !== null) {
              b.return = R, yc = b;
              break e;
            }
            yc = R;
          }
      }
    }
    function vv() {
      dN.forEach(function(n) {
        return n();
      });
    }
    function Sg() {
      var n = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
      return n || mt.actQueue === null || console.error(
        "The current testing environment is not configured to support act(...)"
      ), n;
    }
    function ir(n) {
      if ((ol & Yd) !== Op && gi !== 0)
        return gi & -gi;
      var i = mt.T;
      return i !== null ? (i._updatedFibers || (i._updatedFibers = /* @__PURE__ */ new Set()), i._updatedFibers.add(n), n = Na, n !== 0 ? n : Jl()) : Pt();
    }
    function ty() {
      Np === 0 && (Np = (gi & 536870912) === 0 || Di ? At() : 536870912);
      var n = Im.current;
      return n !== null && (n.flags |= 32), Np;
    }
    function Cl(n, i, c) {
      if (H_ && console.error("useInsertionEffect must not schedule updates."), pT && (wE = !0), (n === Wl && (bl === fS || bl === dS) || n.cancelPendingCommit !== null) && (Dl(n, 0), Rl(
        n,
        gi,
        Np,
        !1
      )), Xe(n, c), (ol & Yd) !== 0 && n === Wl) {
        if (Gn)
          switch (i.tag) {
            case 0:
            case 11:
            case 15:
              n = pi && Q(pi) || "Unknown", _D.has(n) || (_D.add(n), i = Q(i) || "Unknown", console.error(
                "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                i,
                n,
                n
              ));
              break;
            case 1:
              SD || (console.error(
                "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
              ), SD = !0);
          }
      } else
        kl && Xt(n, i, c), gv(i), n === Wl && ((ol & Yd) === Op && (E0 |= c), Vr === cS && Rl(
          n,
          gi,
          Np,
          !1
        )), lr(n);
    }
    function ss(n, i, c) {
      if ((ol & (Yd | Vv)) !== Op)
        throw Error("Should not already be working.");
      var g = !c && (i & 124) === 0 && (i & n.expiredLanes) === 0 || Mt(n, i), b = g ? Ic(n, i) : lo(n, i, !0), R = g;
      do {
        if (b === Cy) {
          N_ && !g && Rl(n, i, 0, !1);
          break;
        } else {
          if (c = n.current.alternate, R && !io(c)) {
            b = lo(n, i, !1), R = !1;
            continue;
          }
          if (b === O_) {
            if (R = i, n.errorRecoveryDisabledLanes & R)
              var X = 0;
            else
              X = n.pendingLanes & -536870913, X = X !== 0 ? X : X & 536870912 ? 536870912 : 0;
            if (X !== 0) {
              i = X;
              e: {
                b = n;
                var K = X;
                X = k1;
                var de = b.current.memoizedState.isDehydrated;
                if (de && (Dl(
                  b,
                  K
                ).flags |= 256), K = lo(
                  b,
                  K,
                  !1
                ), K !== O_) {
                  if (rT && !de) {
                    b.errorRecoveryDisabledLanes |= R, E0 |= R, b = cS;
                    break e;
                  }
                  b = qd, qd = X, b !== null && (qd === null ? qd = b : qd.push.apply(
                    qd,
                    b
                  ));
                }
                b = K;
              }
              if (R = !1, b !== O_) continue;
            }
          }
          if (b === Q1) {
            Dl(n, 0), Rl(n, i, 0, !0);
            break;
          }
          e: {
            switch (g = n, b) {
              case Cy:
              case Q1:
                throw Error("Root did not complete. This is a bug in React.");
              case cS:
                if ((i & 4194048) !== i) break;
              case BE:
                Rl(
                  g,
                  i,
                  Np,
                  !_0
                );
                break e;
              case O_:
                qd = null;
                break;
              case iT:
              case fD:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (mt.actQueue !== null)
              Xo(
                g,
                c,
                i,
                qd,
                W1,
                UE,
                Np,
                E0,
                hS
              );
            else {
              if ((i & 62914560) === i && (R = uT + hD - Nd(), 10 < R)) {
                if (Rl(
                  g,
                  i,
                  Np,
                  !_0
                ), St(g, 0, !0) !== 0) break e;
                g.timeoutHandle = RD(
                  gl.bind(
                    null,
                    g,
                    c,
                    qd,
                    W1,
                    UE,
                    i,
                    Np,
                    E0,
                    hS,
                    _0,
                    b,
                    vN,
                    L,
                    0
                  ),
                  R
                );
                break e;
              }
              gl(
                g,
                c,
                qd,
                W1,
                UE,
                i,
                Np,
                E0,
                hS,
                _0,
                b,
                pN,
                L,
                0
              );
            }
          }
        }
        break;
      } while (!0);
      lr(n);
    }
    function gl(n, i, c, g, b, R, X, K, de, ge, ut, xt, it, Dt) {
      if (n.timeoutHandle = yS, xt = i.subtreeFlags, (xt & 8192 || (xt & 16785408) === 16785408) && (iA = { stylesheets: null, count: 0, unsuspend: wt }, lc(i), xt = mn(), xt !== null)) {
        n.cancelPendingCommit = xt(
          Xo.bind(
            null,
            n,
            i,
            R,
            c,
            g,
            b,
            X,
            K,
            de,
            ut,
            mN,
            it,
            Dt
          )
        ), Rl(
          n,
          R,
          X,
          !ge
        );
        return;
      }
      Xo(
        n,
        i,
        R,
        c,
        g,
        b,
        X,
        K,
        de
      );
    }
    function io(n) {
      for (var i = n; ; ) {
        var c = i.tag;
        if ((c === 0 || c === 11 || c === 15) && i.flags & 16384 && (c = i.updateQueue, c !== null && (c = c.stores, c !== null)))
          for (var g = 0; g < c.length; g++) {
            var b = c[g], R = b.getSnapshot;
            b = b.value;
            try {
              if (!mc(R(), b)) return !1;
            } catch {
              return !1;
            }
          }
        if (c = i.child, i.subtreeFlags & 16384 && c !== null)
          c.return = i, i = c;
        else {
          if (i === n) break;
          for (; i.sibling === null; ) {
            if (i.return === null || i.return === n) return !0;
            i = i.return;
          }
          i.sibling.return = i.return, i = i.sibling;
        }
      }
      return !0;
    }
    function Rl(n, i, c, g) {
      i &= ~oT, i &= ~E0, n.suspendedLanes |= i, n.pingedLanes &= ~i, g && (n.warmLanes |= i), g = n.expirationTimes;
      for (var b = i; 0 < b; ) {
        var R = 31 - po(b), X = 1 << R;
        g[R] = -1, b &= ~X;
      }
      c !== 0 && Et(n, c, i);
    }
    function wf() {
      return (ol & (Yd | Vv)) === Op ? (rc(0), !1) : !0;
    }
    function rs() {
      if (pi !== null) {
        if (bl === Vh)
          var n = pi.return;
        else
          n = pi, Jh(), Jr(n), x_ = null, X1 = 0, n = pi;
        for (; n !== null; )
          sp(n.alternate, n), n = n.return;
        pi = null;
      }
    }
    function Dl(n, i) {
      var c = n.timeoutHandle;
      c !== yS && (n.timeoutHandle = yS, DN(c)), c = n.cancelPendingCommit, c !== null && (n.cancelPendingCommit = null, c()), rs(), Wl = n, pi = c = cu(n.current, null), gi = i, bl = Vh, wp = null, _0 = !1, N_ = Mt(n, i), rT = !1, Vr = Cy, hS = Np = oT = E0 = A0 = 0, qd = k1 = null, UE = !1, (i & 8) !== 0 && (i |= i & 32);
      var g = n.entangledLanes;
      if (g !== 0)
        for (n = n.entanglements, g &= i; 0 < g; ) {
          var b = 31 - po(g), R = 1 << b;
          i |= n[b], g &= ~R;
        }
      return Fg = i, rd(), i = L1(), 1e3 < i - H1 && (mt.recentlyCreatedOwnerStacks = 0, H1 = i), dr.discardPendingWarnings(), c;
    }
    function Il(n, i) {
      Ba = null, mt.H = RE, mt.getCurrentStack = null, Gn = !1, Js = null, i === rl || i === Gh ? (i = kp(), bl = J1) : i === Ks ? (i = kp(), bl = dD) : bl = i === nD ? sT : i !== null && typeof i == "object" && typeof i.then == "function" ? w_ : j1, wp = i;
      var c = pi;
      if (c === null)
        Vr = Q1, yh(
          n,
          vs(i, n.current)
        );
      else
        switch (c.mode & _o && ns(c), rn(), bl) {
          case j1:
            vn !== null && typeof vn.markComponentErrored == "function" && vn.markComponentErrored(
              c,
              i,
              gi
            );
            break;
          case fS:
          case dS:
          case J1:
          case w_:
          case K1:
            vn !== null && typeof vn.markComponentSuspended == "function" && vn.markComponentSuspended(
              c,
              i,
              gi
            );
        }
    }
    function up() {
      var n = mt.H;
      return mt.H = RE, n === null ? RE : n;
    }
    function Po() {
      var n = mt.A;
      return mt.A = fN, n;
    }
    function Ur() {
      Vr = cS, _0 || (gi & 4194048) !== gi && Im.current !== null || (N_ = !0), (A0 & 134217727) === 0 && (E0 & 134217727) === 0 || Wl === null || Rl(
        Wl,
        gi,
        Np,
        !1
      );
    }
    function lo(n, i, c) {
      var g = ol;
      ol |= Yd;
      var b = up(), R = Po();
      if (Wl !== n || gi !== i) {
        if (kl) {
          var X = n.memoizedUpdaters;
          0 < X.size && (so(n, gi), X.clear()), Wt(n, i);
        }
        W1 = null, Dl(n, i);
      }
      dn(i), i = !1, X = Vr;
      e: do
        try {
          if (bl !== Vh && pi !== null) {
            var K = pi, de = wp;
            switch (bl) {
              case sT:
                rs(), X = BE;
                break e;
              case J1:
              case fS:
              case dS:
              case w_:
                Im.current === null && (i = !0);
                var ge = bl;
                if (bl = Vh, wp = null, Bl(n, K, de, ge), c && N_) {
                  X = Cy;
                  break e;
                }
                break;
              default:
                ge = bl, bl = Vh, wp = null, Bl(n, K, de, ge);
            }
          }
          sc(), X = Vr;
          break;
        } catch (ut) {
          Il(n, ut);
        }
      while (!0);
      return i && n.shellSuspendCounter++, Jh(), ol = g, mt.H = b, mt.A = R, Zn(), pi === null && (Wl = null, gi = 0, rd()), X;
    }
    function sc() {
      for (; pi !== null; ) cp(pi);
    }
    function Ic(n, i) {
      var c = ol;
      ol |= Yd;
      var g = up(), b = Po();
      if (Wl !== n || gi !== i) {
        if (kl) {
          var R = n.memoizedUpdaters;
          0 < R.size && (so(n, gi), R.clear()), Wt(n, i);
        }
        W1 = null, OE = Nd() + pD, Dl(n, i);
      } else
        N_ = Mt(
          n,
          i
        );
      dn(i);
      e: do
        try {
          if (bl !== Vh && pi !== null)
            t: switch (i = pi, R = wp, bl) {
              case j1:
                bl = Vh, wp = null, Bl(
                  n,
                  i,
                  R,
                  j1
                );
                break;
              case fS:
              case dS:
                if (Kp(R)) {
                  bl = Vh, wp = null, Vc(i);
                  break;
                }
                i = function() {
                  bl !== fS && bl !== dS || Wl !== n || (bl = K1), lr(n);
                }, R.then(i, i);
                break e;
              case J1:
                bl = K1;
                break e;
              case dD:
                bl = lT;
                break e;
              case K1:
                Kp(R) ? (bl = Vh, wp = null, Vc(i)) : (bl = Vh, wp = null, Bl(
                  n,
                  i,
                  R,
                  K1
                ));
                break;
              case lT:
                var X = null;
                switch (pi.tag) {
                  case 26:
                    X = pi.memoizedState;
                  case 5:
                  case 27:
                    var K = pi;
                    if (!X || qe(X)) {
                      bl = Vh, wp = null;
                      var de = K.sibling;
                      if (de !== null) pi = de;
                      else {
                        var ge = K.return;
                        ge !== null ? (pi = ge, Ul(ge)) : pi = null;
                      }
                      break t;
                    }
                    break;
                  default:
                    console.error(
                      "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                    );
                }
                bl = Vh, wp = null, Bl(
                  n,
                  i,
                  R,
                  lT
                );
                break;
              case w_:
                bl = Vh, wp = null, Bl(
                  n,
                  i,
                  R,
                  w_
                );
                break;
              case sT:
                rs(), Vr = BE;
                break e;
              default:
                throw Error(
                  "Unexpected SuspendedReason. This is a bug in React."
                );
            }
          mt.actQueue !== null ? sc() : Ms();
          break;
        } catch (ut) {
          Il(n, ut);
        }
      while (!0);
      return Jh(), mt.H = g, mt.A = b, ol = c, pi !== null ? (vn !== null && typeof vn.markRenderYielded == "function" && vn.markRenderYielded(), Cy) : (Zn(), Wl = null, gi = 0, rd(), Vr);
    }
    function Ms() {
      for (; pi !== null && !Mm(); )
        cp(pi);
    }
    function cp(n) {
      var i = n.alternate;
      (n.mode & _o) !== Xi ? (ev(n), i = un(
        n,
        Hc,
        i,
        n,
        Fg
      ), ns(n)) : i = un(
        n,
        Hc,
        i,
        n,
        Fg
      ), n.memoizedProps = n.pendingProps, i === null ? Ul(n) : pi = i;
    }
    function Vc(n) {
      var i = un(n, Cd, n);
      n.memoizedProps = n.pendingProps, i === null ? Ul(n) : pi = i;
    }
    function Cd(n) {
      var i = n.alternate, c = (n.mode & _o) !== Xi;
      switch (c && ev(n), n.tag) {
        case 15:
        case 0:
          i = ug(
            i,
            n,
            n.pendingProps,
            n.type,
            void 0,
            gi
          );
          break;
        case 11:
          i = ug(
            i,
            n,
            n.pendingProps,
            n.type.render,
            n.ref,
            gi
          );
          break;
        case 5:
          Jr(n);
        default:
          sp(i, n), n = pi = gf(n, Fg), i = Hc(i, n, Fg);
      }
      return c && ns(n), i;
    }
    function Bl(n, i, c, g) {
      Jh(), Jr(i), x_ = null, X1 = 0;
      var b = i.return;
      try {
        if (_u(
          n,
          b,
          i,
          c,
          gi
        )) {
          Vr = Q1, yh(
            n,
            vs(c, n.current)
          ), pi = null;
          return;
        }
      } catch (R) {
        if (b !== null) throw pi = b, R;
        Vr = Q1, yh(
          n,
          vs(c, n.current)
        ), pi = null;
        return;
      }
      i.flags & 32768 ? (Di || g === j1 ? n = !0 : N_ || (gi & 536870912) !== 0 ? n = !1 : (_0 = n = !0, (g === fS || g === dS || g === J1 || g === w_) && (g = Im.current, g !== null && g.tag === 13 && (g.flags |= 16384))), Ja(i, n)) : Ul(i);
    }
    function Ul(n) {
      var i = n;
      do {
        if ((i.flags & 32768) !== 0) {
          Ja(
            i,
            _0
          );
          return;
        }
        var c = i.alternate;
        if (n = i.return, ev(i), c = un(
          i,
          kg,
          c,
          i,
          Fg
        ), (i.mode & _o) !== Xi && fu(i), c !== null) {
          pi = c;
          return;
        }
        if (i = i.sibling, i !== null) {
          pi = i;
          return;
        }
        pi = i = n;
      } while (i !== null);
      Vr === Cy && (Vr = fD);
    }
    function Ja(n, i) {
      do {
        var c = Wg(n.alternate, n);
        if (c !== null) {
          c.flags &= 32767, pi = c;
          return;
        }
        if ((n.mode & _o) !== Xi) {
          fu(n), c = n.actualDuration;
          for (var g = n.child; g !== null; )
            c += g.actualDuration, g = g.sibling;
          n.actualDuration = c;
        }
        if (c = n.return, c !== null && (c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null), !i && (n = n.sibling, n !== null)) {
          pi = n;
          return;
        }
        pi = n = c;
      } while (n !== null);
      Vr = BE, pi = null;
    }
    function Xo(n, i, c, g, b, R, X, K, de) {
      n.cancelPendingCommit = null;
      do
        os();
      while (af !== pS);
      if (dr.flushLegacyContextWarning(), dr.flushPendingUnsafeLifecycleWarnings(), (ol & (Yd | Vv)) !== Op)
        throw Error("Should not already be working.");
      if (vn !== null && typeof vn.markCommitStarted == "function" && vn.markCommitStarted(c), i === null) Zt();
      else {
        if (c === 0 && console.error(
          "finishedLanes should not be empty during a commit. This is a bug in React."
        ), i === n.current)
          throw Error(
            "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
          );
        if (R = i.lanes | i.childLanes, R |= sS, dt(
          n,
          c,
          R,
          X,
          K,
          de
        ), n === Wl && (pi = Wl = null, gi = 0), z_ = i, M0 = n, x0 = c, fT = R, dT = b, yD = g, (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0 ? (n.callbackNode = null, n.callbackPriority = 0, Yc(Hd, function() {
          return Fc(), null;
        })) : (n.callbackNode = null, n.callbackPriority = 0), J = O(), g = (i.flags & 13878) !== 0, (i.subtreeFlags & 13878) !== 0 || g) {
          g = mt.T, mt.T = null, b = Kn.p, Kn.p = mo, X = ol, ol |= Vv;
          try {
            fm(n, i, c);
          } finally {
            ol = X, Kn.p = b, mt.T = g;
          }
        }
        af = mD, xs(), xh(), jl();
      }
    }
    function xs() {
      if (af === mD) {
        af = pS;
        var n = M0, i = z_, c = x0, g = (i.flags & 13878) !== 0;
        if ((i.subtreeFlags & 13878) !== 0 || g) {
          g = mt.T, mt.T = null;
          var b = Kn.p;
          Kn.p = mo;
          var R = ol;
          ol |= Vv;
          try {
            B_ = c, U_ = n, Dr(i, n), U_ = B_ = null, c = bT;
            var X = mf(n.containerInfo), K = c.focusedElem, de = c.selectionRange;
            if (X !== K && K && K.ownerDocument && Qh(
              K.ownerDocument.documentElement,
              K
            )) {
              if (de !== null && vf(K)) {
                var ge = de.start, ut = de.end;
                if (ut === void 0 && (ut = ge), "selectionStart" in K)
                  K.selectionStart = ge, K.selectionEnd = Math.min(
                    ut,
                    K.value.length
                  );
                else {
                  var xt = K.ownerDocument || document, it = xt && xt.defaultView || window;
                  if (it.getSelection) {
                    var Dt = it.getSelection(), wn = K.textContent.length, Ea = Math.min(
                      de.start,
                      wn
                    ), $l = de.end === void 0 ? Ea : Math.min(de.end, wn);
                    !Dt.extend && Ea > $l && (X = $l, $l = Ea, Ea = X);
                    var _i = fi(
                      K,
                      Ea
                    ), Ce = fi(
                      K,
                      $l
                    );
                    if (_i && Ce && (Dt.rangeCount !== 1 || Dt.anchorNode !== _i.node || Dt.anchorOffset !== _i.offset || Dt.focusNode !== Ce.node || Dt.focusOffset !== Ce.offset)) {
                      var Oe = xt.createRange();
                      Oe.setStart(_i.node, _i.offset), Dt.removeAllRanges(), Ea > $l ? (Dt.addRange(Oe), Dt.extend(Ce.node, Ce.offset)) : (Oe.setEnd(Ce.node, Ce.offset), Dt.addRange(Oe));
                    }
                  }
                }
              }
              for (xt = [], Dt = K; Dt = Dt.parentNode; )
                Dt.nodeType === 1 && xt.push({
                  element: Dt,
                  left: Dt.scrollLeft,
                  top: Dt.scrollTop
                });
              for (typeof K.focus == "function" && K.focus(), K = 0; K < xt.length; K++) {
                var Fe = xt[K];
                Fe.element.scrollLeft = Fe.left, Fe.element.scrollTop = Fe.top;
              }
            }
            jE = !!ET, bT = ET = null;
          } finally {
            ol = R, Kn.p = b, mt.T = g;
          }
        }
        n.current = i, af = vD;
      }
    }
    function xh() {
      if (af === vD) {
        af = pS;
        var n = M0, i = z_, c = x0, g = (i.flags & 8772) !== 0;
        if ((i.subtreeFlags & 8772) !== 0 || g) {
          g = mt.T, mt.T = null;
          var b = Kn.p;
          Kn.p = mo;
          var R = ol;
          ol |= Vv;
          try {
            vn !== null && typeof vn.markLayoutEffectsStarted == "function" && vn.markLayoutEffectsStarted(c), B_ = c, U_ = n, dm(
              n,
              i.alternate,
              i
            ), U_ = B_ = null, vn !== null && typeof vn.markLayoutEffectsStopped == "function" && vn.markLayoutEffectsStopped();
          } finally {
            ol = R, Kn.p = b, mt.T = g;
          }
        }
        af = gD;
      }
    }
    function jl() {
      if (af === gN || af === gD) {
        af = pS, i0();
        var n = M0, i = z_, c = x0, g = yD, b = (i.subtreeFlags & 10256) !== 0 || (i.flags & 10256) !== 0;
        b ? af = cT : (af = pS, z_ = M0 = null, Ts(n, n.pendingLanes), mS = 0, eA = null);
        var R = n.pendingLanes;
        if (R === 0 && (b0 = null), b || Rd(n), b = Vn(c), i = i.stateNode, zr && typeof zr.onCommitFiberRoot == "function")
          try {
            var X = (i.current.flags & 128) === 128;
            switch (b) {
              case mo:
                var K = Tg;
                break;
              case Yf:
                K = xm;
                break;
              case Sp:
                K = Hd;
                break;
              case oy:
                K = Cg;
                break;
              default:
                K = Hd;
            }
            zr.onCommitFiberRoot(
              yp,
              i,
              K,
              X
            );
          } catch (xt) {
            Bu || (Bu = !0, console.error(
              "React instrumentation encountered an error: %s",
              xt
            ));
          }
        if (kl && n.memoizedUpdaters.clear(), vv(), g !== null) {
          X = mt.T, K = Kn.p, Kn.p = mo, mt.T = null;
          try {
            var de = n.onRecoverableError;
            for (i = 0; i < g.length; i++) {
              var ge = g[i], ut = Vl(ge.stack);
              un(
                ge.source,
                de,
                ge.value,
                ut
              );
            }
          } finally {
            mt.T = X, Kn.p = K;
          }
        }
        (x0 & 3) !== 0 && os(), lr(n), R = n.pendingLanes, (c & 4194090) !== 0 && (R & 42) !== 0 ? (Kt = !0, n === hT ? $1++ : ($1 = 0, hT = n)) : $1 = 0, rc(0), Zt();
      }
    }
    function Vl(n) {
      return n = { componentStack: n }, Object.defineProperty(n, "digest", {
        get: function() {
          console.error(
            'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
          );
        }
      }), n;
    }
    function Ts(n, i) {
      (n.pooledCacheLanes &= i) === 0 && (i = n.pooledCache, i != null && (n.pooledCache = null, ys(i)));
    }
    function os(n) {
      return xs(), xh(), jl(), Fc();
    }
    function Fc() {
      if (af !== cT) return !1;
      var n = M0, i = fT;
      fT = 0;
      var c = Vn(x0), g = Sp > c ? Sp : c;
      c = mt.T;
      var b = Kn.p;
      try {
        Kn.p = g, mt.T = null, g = dT, dT = null;
        var R = M0, X = x0;
        if (af = pS, z_ = M0 = null, x0 = 0, (ol & (Yd | Vv)) !== Op)
          throw Error("Cannot flush passive effects while already rendering.");
        pT = !0, wE = !1, vn !== null && typeof vn.markPassiveEffectsStarted == "function" && vn.markPassiveEffectsStarted(X);
        var K = ol;
        if (ol |= Vv, mv(R.current), Vo(
          R,
          R.current,
          X,
          g
        ), vn !== null && typeof vn.markPassiveEffectsStopped == "function" && vn.markPassiveEffectsStopped(), Rd(R), ol = K, rc(0, !1), wE ? R === eA ? mS++ : (mS = 0, eA = R) : mS = 0, wE = pT = !1, zr && typeof zr.onPostCommitFiberRoot == "function")
          try {
            zr.onPostCommitFiberRoot(yp, R);
          } catch (ge) {
            Bu || (Bu = !0, console.error(
              "React instrumentation encountered an error: %s",
              ge
            ));
          }
        var de = R.current.stateNode;
        return de.effectDuration = 0, de.passiveEffectDuration = 0, !0;
      } finally {
        Kn.p = b, mt.T = c, Ts(n, i);
      }
    }
    function Th(n, i, c) {
      i = vs(c, i), i = qs(n.stateNode, i, 2), n = vu(n, i, 2), n !== null && (Xe(n, 2), lr(n));
    }
    function Tn(n, i, c) {
      if (H_ = !1, n.tag === 3)
        Th(n, n, c);
      else {
        for (; i !== null; ) {
          if (i.tag === 3) {
            Th(
              i,
              n,
              c
            );
            return;
          }
          if (i.tag === 1) {
            var g = i.stateNode;
            if (typeof i.type.getDerivedStateFromError == "function" || typeof g.componentDidCatch == "function" && (b0 === null || !b0.has(g))) {
              n = vs(c, n), c = ha(2), g = vu(i, c, 2), g !== null && (zc(
                c,
                g,
                i,
                n
              ), Xe(g, 2), lr(g));
              return;
            }
          }
          i = i.return;
        }
        console.error(
          `Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,
          c
        );
      }
    }
    function Pc(n, i, c) {
      var g = n.pingCache;
      if (g === null) {
        g = n.pingCache = new hN();
        var b = /* @__PURE__ */ new Set();
        g.set(i, b);
      } else
        b = g.get(i), b === void 0 && (b = /* @__PURE__ */ new Set(), g.set(i, b));
      b.has(c) || (rT = !0, b.add(c), g = pm.bind(null, n, i, c), kl && so(n, c), i.then(g, g));
    }
    function pm(n, i, c) {
      var g = n.pingCache;
      g !== null && g.delete(i), n.pingedLanes |= n.suspendedLanes & c, n.warmLanes &= ~c, Sg() && mt.actQueue === null && console.error(
        `A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`
      ), Wl === n && (gi & c) === c && (Vr === cS || Vr === iT && (gi & 62914560) === gi && Nd() - uT < hD ? (ol & Yd) === Op && Dl(n, 0) : oT |= c, hS === gi && (hS = 0)), lr(n);
    }
    function fp(n, i) {
      i === 0 && (i = ce()), n = mr(n, i), n !== null && (Xe(n, i), lr(n));
    }
    function dp(n) {
      var i = n.memoizedState, c = 0;
      i !== null && (c = i.retryLane), fp(n, c);
    }
    function Au(n, i) {
      var c = 0;
      switch (n.tag) {
        case 13:
          var g = n.stateNode, b = n.memoizedState;
          b !== null && (c = b.retryLane);
          break;
        case 19:
          g = n.stateNode;
          break;
        case 22:
          g = n.stateNode._retryCache;
          break;
        default:
          throw Error(
            "Pinged unknown suspense boundary type. This is probably a bug in React."
          );
      }
      g !== null && g.delete(i), fp(n, c);
    }
    function Nf(n, i, c) {
      if ((i.subtreeFlags & 67117056) !== 0)
        for (i = i.child; i !== null; ) {
          var g = n, b = i, R = b.type === mp;
          R = c || R, b.tag !== 22 ? b.flags & 67108864 ? R && un(
            b,
            zf,
            g,
            b,
            (b.mode & m0) === Xi
          ) : Nf(
            g,
            b,
            R
          ) : b.memoizedState === null && (R && b.flags & 8192 ? un(
            b,
            zf,
            g,
            b
          ) : b.subtreeFlags & 67108864 && un(
            b,
            Nf,
            g,
            b,
            R
          )), i = i.sibling;
        }
    }
    function zf(n, i) {
      var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : !0;
      ct(!0);
      try {
        oi(i), c && Td(i), ac(n, i.alternate, i, !1), c && Qs(n, i, 0, null, !1, 0);
      } finally {
        ct(!1);
      }
    }
    function Rd(n) {
      var i = !0;
      n.current.mode & (Wo | Bp) || (i = !1), Nf(
        n,
        n.current,
        i
      );
    }
    function Xc(n) {
      if ((ol & Yd) === Op) {
        var i = n.tag;
        if (i === 3 || i === 1 || i === 0 || i === 11 || i === 14 || i === 15) {
          if (i = Q(n) || "ReactComponent", NE !== null) {
            if (NE.has(i)) return;
            NE.add(i);
          } else NE = /* @__PURE__ */ new Set([i]);
          un(n, function() {
            console.error(
              "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
            );
          });
        }
      }
    }
    function so(n, i) {
      kl && n.memoizedUpdaters.forEach(function(c) {
        Xt(n, c, i);
      });
    }
    function Yc(n, i) {
      var c = mt.actQueue;
      return c !== null ? (c.push(i), _N) : bm(n, i);
    }
    function gv(n) {
      Sg() && mt.actQueue === null && un(n, function() {
        console.error(
          `An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`,
          Q(n)
        );
      });
    }
    function lr(n) {
      n !== L_ && n.next === null && (L_ === null ? zE = L_ = n : L_ = L_.next = n), HE = !0, mt.actQueue !== null ? vT || (vT = !0, Gi()) : mT || (mT = !0, Gi());
    }
    function rc(n, i) {
      if (!gT && HE) {
        gT = !0;
        do
          for (var c = !1, g = zE; g !== null; ) {
            if (n !== 0) {
              var b = g.pendingLanes;
              if (b === 0) var R = 0;
              else {
                var X = g.suspendedLanes, K = g.pingedLanes;
                R = (1 << 31 - po(42 | n) + 1) - 1, R &= b & ~(X & ~K), R = R & 201326741 ? R & 201326741 | 1 : R ? R | 2 : 0;
              }
              R !== 0 && (c = !0, hp(g, R));
            } else
              R = gi, R = St(
                g,
                g === Wl ? R : 0,
                g.cancelPendingCommit !== null || g.timeoutHandle !== yS
              ), (R & 3) === 0 || Mt(g, R) || (c = !0, hp(g, R));
            g = g.next;
          }
        while (c);
        gT = !1;
      }
    }
    function Ch() {
      ro();
    }
    function ro() {
      HE = vT = mT = !1;
      var n = 0;
      vS !== 0 && (ym() && (n = vS), vS = 0);
      for (var i = Nd(), c = null, g = zE; g !== null; ) {
        var b = g.next, R = qc(g, i);
        R === 0 ? (g.next = null, c === null ? zE = b : c.next = b, b === null && (L_ = c)) : (c = g, (n !== 0 || (R & 3) !== 0) && (HE = !0)), g = b;
      }
      rc(n);
    }
    function qc(n, i) {
      for (var c = n.suspendedLanes, g = n.pingedLanes, b = n.expirationTimes, R = n.pendingLanes & -62914561; 0 < R; ) {
        var X = 31 - po(R), K = 1 << X, de = b[X];
        de === -1 ? ((K & c) === 0 || (K & g) !== 0) && (b[X] = kt(K, i)) : de <= i && (n.expiredLanes |= K), R &= ~K;
      }
      if (i = Wl, c = gi, c = St(
        n,
        n === i ? c : 0,
        n.cancelPendingCommit !== null || n.timeoutHandle !== yS
      ), g = n.callbackNode, c === 0 || n === i && (bl === fS || bl === dS) || n.cancelPendingCommit !== null)
        return g !== null && Cs(g), n.callbackNode = null, n.callbackPriority = 0;
      if ((c & 3) === 0 || Mt(n, c)) {
        if (i = c & -c, i !== n.callbackPriority || mt.actQueue !== null && g !== yT)
          Cs(g);
        else return i;
        switch (Vn(c)) {
          case mo:
          case Yf:
            c = xm;
            break;
          case Sp:
            c = Hd;
            break;
          case oy:
            c = Cg;
            break;
          default:
            c = Hd;
        }
        return g = ji.bind(null, n), mt.actQueue !== null ? (mt.actQueue.push(g), c = yT) : c = bm(c, g), n.callbackPriority = i, n.callbackNode = c, i;
      }
      return g !== null && Cs(g), n.callbackPriority = 2, n.callbackNode = null, 2;
    }
    function ji(n, i) {
      if (Kt = ht = !1, af !== pS && af !== cT)
        return n.callbackNode = null, n.callbackPriority = 0, null;
      var c = n.callbackNode;
      if (os() && n.callbackNode !== c)
        return null;
      var g = gi;
      return g = St(
        n,
        n === Wl ? g : 0,
        n.cancelPendingCommit !== null || n.timeoutHandle !== yS
      ), g === 0 ? null : (ss(
        n,
        g,
        i
      ), qc(n, Nd()), n.callbackNode != null && n.callbackNode === c ? ji.bind(null, n) : null);
    }
    function hp(n, i) {
      if (os()) return null;
      ht = Kt, Kt = !1, ss(n, i, !0);
    }
    function Cs(n) {
      n !== yT && n !== null && ly(n);
    }
    function Gi() {
      mt.actQueue !== null && mt.actQueue.push(function() {
        return ro(), null;
      }), BN(function() {
        (ol & (Yd | Vv)) !== Op ? bm(
          Tg,
          Ch
        ) : ro();
      });
    }
    function Jl() {
      return vS === 0 && (vS = At()), vS;
    }
    function Hf(n) {
      return n == null || typeof n == "symbol" || typeof n == "boolean" ? null : typeof n == "function" ? n : (De(n, "action"), Kd("" + n));
    }
    function Ra(n, i) {
      var c = i.ownerDocument.createElement("input");
      return c.name = i.name, c.value = i.value, n.id && c.setAttribute("form", n.id), i.parentNode.insertBefore(c, i), n = new FormData(n), c.parentNode.removeChild(c), n;
    }
    function kn(n, i, c, g, b) {
      if (i === "submit" && c && c.stateNode === b) {
        var R = Hf(
          (b[Hr] || null).action
        ), X = g.submitter;
        X && (i = (i = X[Hr] || null) ? Hf(i.formAction) : X.getAttribute("formAction"), i !== null && (R = i, X = null));
        var K = new In(
          "action",
          "action",
          null,
          g,
          b
        );
        n.push({
          event: K,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (g.defaultPrevented) {
                  if (vS !== 0) {
                    var de = X ? Ra(
                      b,
                      X
                    ) : new FormData(b), ge = {
                      pending: !0,
                      data: de,
                      method: b.method,
                      action: R
                    };
                    Object.freeze(ge), $r(
                      c,
                      ge,
                      null,
                      de
                    );
                  }
                } else
                  typeof R == "function" && (K.preventDefault(), de = X ? Ra(
                    b,
                    X
                  ) : new FormData(b), ge = {
                    pending: !0,
                    data: de,
                    method: b.method,
                    action: R
                  }, Object.freeze(ge), $r(
                    c,
                    ge,
                    R,
                    de
                  ));
              },
              currentTarget: b
            }
          ]
        });
      }
    }
    function Ka(n, i, c) {
      n.currentTarget = c;
      try {
        i(n);
      } catch (g) {
        $x(g);
      }
      n.currentTarget = null;
    }
    function Eu(n, i) {
      i = (i & 4) !== 0;
      for (var c = 0; c < n.length; c++) {
        var g = n[c];
        e: {
          var b = void 0, R = g.event;
          if (g = g.listeners, i)
            for (var X = g.length - 1; 0 <= X; X--) {
              var K = g[X], de = K.instance, ge = K.currentTarget;
              if (K = K.listener, de !== b && R.isPropagationStopped())
                break e;
              de !== null ? un(
                de,
                Ka,
                R,
                K,
                ge
              ) : Ka(R, K, ge), b = de;
            }
          else
            for (X = 0; X < g.length; X++) {
              if (K = g[X], de = K.instance, ge = K.currentTarget, K = K.listener, de !== b && R.isPropagationStopped())
                break e;
              de !== null ? un(
                de,
                Ka,
                R,
                K,
                ge
              ) : Ka(R, K, ge), b = de;
            }
        }
      }
    }
    function ga(n, i) {
      ST.has(n) || console.error(
        'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
        n
      );
      var c = i[uy];
      c === void 0 && (c = i[uy] = /* @__PURE__ */ new Set());
      var g = n + "__bubble";
      c.has(g) || (Rh(i, n, 2, !1), c.add(g));
    }
    function Lf(n, i, c) {
      ST.has(n) && !i && console.error(
        'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
        n
      );
      var g = 0;
      i && (g |= 4), Rh(
        c,
        n,
        g,
        i
      );
    }
    function mm(n) {
      if (!n[LE]) {
        n[LE] = !0, Tm.forEach(function(c) {
          c !== "selectionchange" && (ST.has(c) || Lf(c, !1, n), Lf(c, !0, n));
        });
        var i = n.nodeType === 9 ? n : n.ownerDocument;
        i === null || i[LE] || (i[LE] = !0, Lf("selectionchange", !1, i));
      }
    }
    function Rh(n, i, c, g) {
      switch (Em(i)) {
        case mo:
          var b = ya;
          break;
        case Yf:
          b = Ki;
          break;
        default:
          b = la;
      }
      c = b.bind(
        null,
        i,
        c,
        n
      ), b = void 0, !et || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (b = !0), g ? b !== void 0 ? n.addEventListener(i, c, {
        capture: !0,
        passive: b
      }) : n.addEventListener(i, c, !0) : b !== void 0 ? n.addEventListener(i, c, {
        passive: b
      }) : n.addEventListener(
        i,
        c,
        !1
      );
    }
    function us(n, i, c, g, b) {
      var R = g;
      if ((i & 1) === 0 && (i & 2) === 0 && g !== null)
        e: for (; ; ) {
          if (g === null) return;
          var X = g.tag;
          if (X === 3 || X === 4) {
            var K = g.stateNode.containerInfo;
            if (K === b) break;
            if (X === 4)
              for (X = g.return; X !== null; ) {
                var de = X.tag;
                if ((de === 3 || de === 4) && X.stateNode.containerInfo === b)
                  return;
                X = X.return;
              }
            for (; K !== null; ) {
              if (X = nn(K), X === null) return;
              if (de = X.tag, de === 5 || de === 6 || de === 26 || de === 27) {
                g = R = X;
                continue e;
              }
              K = K.parentNode;
            }
          }
          g = g.return;
        }
      id(function() {
        var ge = R, ut = fl(c), xt = [];
        e: {
          var it = Hg.get(n);
          if (it !== void 0) {
            var Dt = In, wn = n;
            switch (n) {
              case "keypress":
                if (ld(c) === 0) break e;
              case "keydown":
              case "keyup":
                Dt = d_;
                break;
              case "focusin":
                wn = "focus", Dt = ci;
                break;
              case "focusout":
                wn = "blur", Dt = ci;
                break;
              case "beforeblur":
              case "afterblur":
                Dt = ci;
                break;
              case "click":
                if (c.button === 2) break e;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                Dt = Aa;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                Dt = Xn;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                Dt = nS;
                break;
              case v_:
              case Dp:
              case zs:
                Dt = Gr;
                break;
              case Jf:
                Dt = Px;
                break;
              case "scroll":
              case "scrollend":
                Dt = Qe;
                break;
              case "wheel":
                Dt = pc;
                break;
              case "copy":
              case "cut":
              case "paste":
                Dt = f0;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                Dt = tS;
                break;
              case "toggle":
              case "beforetoggle":
                Dt = Ov;
            }
            var Ea = (i & 4) !== 0, $l = !Ea && (n === "scroll" || n === "scrollend"), _i = Ea ? it !== null ? it + "Capture" : null : it;
            Ea = [];
            for (var Ce = ge, Oe; Ce !== null; ) {
              var Fe = Ce;
              if (Oe = Fe.stateNode, Fe = Fe.tag, Fe !== 5 && Fe !== 26 && Fe !== 27 || Oe === null || _i === null || (Fe = Co(Ce, _i), Fe != null && Ea.push(
                Or(
                  Ce,
                  Fe,
                  Oe
                )
              )), $l) break;
              Ce = Ce.return;
            }
            0 < Ea.length && (it = new Dt(
              it,
              wn,
              null,
              c,
              ut
            ), xt.push({
              event: it,
              listeners: Ea
            }));
          }
        }
        if ((i & 7) === 0) {
          e: {
            if (it = n === "mouseover" || n === "pointerover", Dt = n === "mouseout" || n === "pointerout", it && c !== U && (wn = c.relatedTarget || c.fromElement) && (nn(wn) || wn[oa]))
              break e;
            if ((Dt || it) && (it = ut.window === ut ? ut : (it = ut.ownerDocument) ? it.defaultView || it.parentWindow : window, Dt ? (wn = c.relatedTarget || c.toElement, Dt = ge, wn = wn ? nn(wn) : null, wn !== null && ($l = N(wn), Ea = wn.tag, wn !== $l || Ea !== 5 && Ea !== 27 && Ea !== 6) && (wn = null)) : (Dt = null, wn = ge), Dt !== wn)) {
              if (Ea = Aa, Fe = "onMouseLeave", _i = "onMouseEnter", Ce = "mouse", (n === "pointerout" || n === "pointerover") && (Ea = tS, Fe = "onPointerLeave", _i = "onPointerEnter", Ce = "pointer"), $l = Dt == null ? it : Ue(Dt), Oe = wn == null ? it : Ue(wn), it = new Ea(
                Fe,
                Ce + "leave",
                Dt,
                c,
                ut
              ), it.target = $l, it.relatedTarget = Oe, Fe = null, nn(ut) === ge && (Ea = new Ea(
                _i,
                Ce + "enter",
                wn,
                c,
                ut
              ), Ea.target = Oe, Ea.relatedTarget = $l, Fe = Ea), $l = Fe, Dt && wn)
                t: {
                  for (Ea = Dt, _i = wn, Ce = 0, Oe = Ea; Oe; Oe = Ji(Oe))
                    Ce++;
                  for (Oe = 0, Fe = _i; Fe; Fe = Ji(Fe))
                    Oe++;
                  for (; 0 < Ce - Oe; )
                    Ea = Ji(Ea), Ce--;
                  for (; 0 < Oe - Ce; )
                    _i = Ji(_i), Oe--;
                  for (; Ce--; ) {
                    if (Ea === _i || _i !== null && Ea === _i.alternate)
                      break t;
                    Ea = Ji(Ea), _i = Ji(_i);
                  }
                  Ea = null;
                }
              else Ea = null;
              Dt !== null && Dd(
                xt,
                it,
                Dt,
                Ea,
                !1
              ), wn !== null && $l !== null && Dd(
                xt,
                $l,
                wn,
                Ea,
                !0
              );
            }
          }
          e: {
            if (it = ge ? Ue(ge) : window, Dt = it.nodeName && it.nodeName.toLowerCase(), Dt === "select" || Dt === "input" && it.type === "file")
              var Bt = dl;
            else if (Pp(it))
              if (h0)
                Bt = ng;
              else {
                Bt = Xp;
                var fn = Is;
              }
            else
              Dt = it.nodeName, !Dt || Dt.toLowerCase() !== "input" || it.type !== "checkbox" && it.type !== "radio" ? ge && Ec(ge.elementType) && (Bt = dl) : Bt = ky;
            if (Bt && (Bt = Bt(n, ge))) {
              Yt(
                xt,
                Bt,
                c,
                ut
              );
              break e;
            }
            fn && fn(n, it, ge), n === "focusout" && ge && it.type === "number" && ge.memoizedProps.value != null && Ee(it, "number", it.value);
          }
          switch (fn = ge ? Ue(ge) : window, n) {
            case "focusin":
              (Pp(fn) || fn.contentEditable === "true") && (Cp = fn, vy = ge, gy = null);
              break;
            case "focusout":
              gy = vy = Cp = null;
              break;
            case "mousedown":
              sl = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              sl = !1, Do(
                xt,
                c,
                ut
              );
              break;
            case "selectionchange":
              if (N1) break;
            case "keydown":
            case "keyup":
              Do(
                xt,
                c,
                ut
              );
          }
          var Ia;
          if (iS)
            e: {
              switch (n) {
                case "compositionstart":
                  var Nn = "onCompositionStart";
                  break e;
                case "compositionend":
                  Nn = "onCompositionEnd";
                  break e;
                case "compositionupdate":
                  Nn = "onCompositionUpdate";
                  break e;
              }
              Nn = void 0;
            }
          else
            wa ? xl(n, c) && (Nn = "onCompositionEnd") : n === "keydown" && c.keyCode === my && (Nn = "onCompositionStart");
          Nn && (lS && c.locale !== "ko" && (wa || Nn !== "onCompositionStart" ? Nn === "onCompositionEnd" && wa && (Ia = su()) : (zt = ut, at = "value" in zt ? zt.value : zt.textContent, wa = !0)), fn = pp(
            ge,
            Nn
          ), 0 < fn.length && (Nn = new fr(
            Nn,
            n,
            null,
            c,
            ut
          ), xt.push({
            event: Nn,
            listeners: fn
          }), Ia ? Nn.data = Ia : (Ia = pf(c), Ia !== null && (Nn.data = Ia)))), (Ia = AE ? ru(n, c) : Ro(n, c)) && (Nn = pp(
            ge,
            "onBeforeInput"
          ), 0 < Nn.length && (fn = new Id(
            "onBeforeInput",
            "beforeinput",
            null,
            c,
            ut
          ), xt.push({
            event: fn,
            listeners: Nn
          }), fn.data = Ia)), kn(
            xt,
            n,
            ge,
            c,
            ut
          );
        }
        Eu(xt, i);
      });
    }
    function Or(n, i, c) {
      return {
        instance: n,
        listener: i,
        currentTarget: c
      };
    }
    function pp(n, i) {
      for (var c = i + "Capture", g = []; n !== null; ) {
        var b = n, R = b.stateNode;
        if (b = b.tag, b !== 5 && b !== 26 && b !== 27 || R === null || (b = Co(n, c), b != null && g.unshift(
          Or(n, b, R)
        ), b = Co(n, i), b != null && g.push(
          Or(n, b, R)
        )), n.tag === 3) return g;
        n = n.return;
      }
      return [];
    }
    function Ji(n) {
      if (n === null) return null;
      do
        n = n.return;
      while (n && n.tag !== 5 && n.tag !== 27);
      return n || null;
    }
    function Dd(n, i, c, g, b) {
      for (var R = i._reactName, X = []; c !== null && c !== g; ) {
        var K = c, de = K.alternate, ge = K.stateNode;
        if (K = K.tag, de !== null && de === g) break;
        K !== 5 && K !== 26 && K !== 27 || ge === null || (de = ge, b ? (ge = Co(c, R), ge != null && X.unshift(
          Or(c, ge, de)
        )) : b || (ge = Co(c, R), ge != null && X.push(
          Or(c, ge, de)
        ))), c = c.return;
      }
      X.length !== 0 && n.push({ event: i, listeners: X });
    }
    function sr(n, i) {
      df(n, i), n !== "input" && n !== "textarea" && n !== "select" || i == null || i.value !== null || Om || (Om = !0, n === "select" && i.multiple ? console.error(
        "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
        n
      ) : console.error(
        "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
        n
      ));
      var c = {
        registrationNameDependencies: kc,
        possibleRegistrationNames: qf
      };
      Ec(n) || typeof i.is == "string" || Fp(n, i, c), i.contentEditable && !i.suppressContentEditableWarning && i.children != null && console.error(
        "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
      );
    }
    function Ci(n, i, c, g) {
      i !== c && (c = ui(c), ui(i) !== c && (g[n] = i));
    }
    function Gf(n, i, c) {
      i.forEach(function(g) {
        c[ny(g)] = g === "style" ? Ii(n) : n.getAttribute(g);
      });
    }
    function Yo(n, i) {
      i === !1 ? console.error(
        "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
        n,
        n,
        n
      ) : console.error(
        "Expected `%s` listener to be a function, instead got a value of `%s` type.",
        n,
        typeof i
      );
    }
    function vm(n, i) {
      return n = n.namespaceURI === Og || n.namespaceURI === Uv ? n.ownerDocument.createElementNS(
        n.namespaceURI,
        n.tagName
      ) : n.ownerDocument.createElement(n.tagName), n.innerHTML = i, n.innerHTML;
    }
    function ui(n) {
      return ue(n) && (console.error(
        "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
        Se(n)
      ), we(n)), (typeof n == "string" ? n : "" + n).replace(AN, `
`).replace(EN, "");
    }
    function gm(n, i) {
      return i = ui(i), ui(n) === i;
    }
    function bu() {
    }
    function Oa(n, i, c, g, b, R) {
      switch (c) {
        case "children":
          typeof g == "string" ? (Xu(g, i, !1), i === "body" || i === "textarea" && g === "" || Yu(n, g)) : (typeof g == "number" || typeof g == "bigint") && (Xu("" + g, i, !1), i !== "body" && Yu(n, "" + g));
          break;
        case "className":
          Mn(n, "class", g);
          break;
        case "tabIndex":
          Mn(n, "tabindex", g);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          Mn(n, c, g);
          break;
        case "style":
          Zh(n, g, R);
          break;
        case "data":
          if (i !== "object") {
            Mn(n, "data", g);
            break;
          }
        case "src":
        case "href":
          if (g === "" && (i !== "a" || c !== "href")) {
            console.error(
              c === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
              c,
              c
            ), n.removeAttribute(c);
            break;
          }
          if (g == null || typeof g == "function" || typeof g == "symbol" || typeof g == "boolean") {
            n.removeAttribute(c);
            break;
          }
          De(g, c), g = Kd("" + g), n.setAttribute(c, g);
          break;
        case "action":
        case "formAction":
          if (g != null && (i === "form" ? c === "formAction" ? console.error(
            "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
          ) : typeof g == "function" && (b.encType == null && b.method == null || VE || (VE = !0, console.error(
            "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
          )), b.target == null || IE || (IE = !0, console.error(
            "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
          ))) : i === "input" || i === "button" ? c === "action" ? console.error(
            "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
          ) : i !== "input" || b.type === "submit" || b.type === "image" || GE ? i !== "button" || b.type == null || b.type === "submit" || GE ? typeof g == "function" && (b.name == null || bD || (bD = !0, console.error(
            'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
          )), b.formEncType == null && b.formMethod == null || VE || (VE = !0, console.error(
            "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
          )), b.formTarget == null || IE || (IE = !0, console.error(
            "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
          ))) : (GE = !0, console.error(
            'A button can only specify a formAction along with type="submit" or no type.'
          )) : (GE = !0, console.error(
            'An input can only specify a formAction along with type="submit" or type="image".'
          )) : console.error(
            c === "action" ? "You can only pass the action prop to <form>." : "You can only pass the formAction prop to <input> or <button>."
          )), typeof g == "function") {
            n.setAttribute(
              c,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            typeof R == "function" && (c === "formAction" ? (i !== "input" && Oa(n, i, "name", b.name, b, null), Oa(
              n,
              i,
              "formEncType",
              b.formEncType,
              b,
              null
            ), Oa(
              n,
              i,
              "formMethod",
              b.formMethod,
              b,
              null
            ), Oa(
              n,
              i,
              "formTarget",
              b.formTarget,
              b,
              null
            )) : (Oa(
              n,
              i,
              "encType",
              b.encType,
              b,
              null
            ), Oa(n, i, "method", b.method, b, null), Oa(
              n,
              i,
              "target",
              b.target,
              b,
              null
            )));
          if (g == null || typeof g == "symbol" || typeof g == "boolean") {
            n.removeAttribute(c);
            break;
          }
          De(g, c), g = Kd("" + g), n.setAttribute(c, g);
          break;
        case "onClick":
          g != null && (typeof g != "function" && Yo(c, g), n.onclick = bu);
          break;
        case "onScroll":
          g != null && (typeof g != "function" && Yo(c, g), ga("scroll", n));
          break;
        case "onScrollEnd":
          g != null && (typeof g != "function" && Yo(c, g), ga("scrollend", n));
          break;
        case "dangerouslySetInnerHTML":
          if (g != null) {
            if (typeof g != "object" || !("__html" in g))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (c = g.__html, c != null) {
              if (b.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              n.innerHTML = c;
            }
          }
          break;
        case "multiple":
          n.multiple = g && typeof g != "function" && typeof g != "symbol";
          break;
        case "muted":
          n.muted = g && typeof g != "function" && typeof g != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (g == null || typeof g == "function" || typeof g == "boolean" || typeof g == "symbol") {
            n.removeAttribute("xlink:href");
            break;
          }
          De(g, c), c = Kd("" + g), n.setAttributeNS(gS, "xlink:href", c);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          g != null && typeof g != "function" && typeof g != "symbol" ? (De(g, c), n.setAttribute(c, "" + g)) : n.removeAttribute(c);
          break;
        case "inert":
          g !== "" || FE[c] || (FE[c] = !0, console.error(
            "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
            c
          ));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          g && typeof g != "function" && typeof g != "symbol" ? n.setAttribute(c, "") : n.removeAttribute(c);
          break;
        case "capture":
        case "download":
          g === !0 ? n.setAttribute(c, "") : g !== !1 && g != null && typeof g != "function" && typeof g != "symbol" ? (De(g, c), n.setAttribute(c, g)) : n.removeAttribute(c);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          g != null && typeof g != "function" && typeof g != "symbol" && !isNaN(g) && 1 <= g ? (De(g, c), n.setAttribute(c, g)) : n.removeAttribute(c);
          break;
        case "rowSpan":
        case "start":
          g == null || typeof g == "function" || typeof g == "symbol" || isNaN(g) ? n.removeAttribute(c) : (De(g, c), n.setAttribute(c, g));
          break;
        case "popover":
          ga("beforetoggle", n), ga("toggle", n), tn(n, "popover", g);
          break;
        case "xlinkActuate":
          Wn(
            n,
            gS,
            "xlink:actuate",
            g
          );
          break;
        case "xlinkArcrole":
          Wn(
            n,
            gS,
            "xlink:arcrole",
            g
          );
          break;
        case "xlinkRole":
          Wn(
            n,
            gS,
            "xlink:role",
            g
          );
          break;
        case "xlinkShow":
          Wn(
            n,
            gS,
            "xlink:show",
            g
          );
          break;
        case "xlinkTitle":
          Wn(
            n,
            gS,
            "xlink:title",
            g
          );
          break;
        case "xlinkType":
          Wn(
            n,
            gS,
            "xlink:type",
            g
          );
          break;
        case "xmlBase":
          Wn(
            n,
            _T,
            "xml:base",
            g
          );
          break;
        case "xmlLang":
          Wn(
            n,
            _T,
            "xml:lang",
            g
          );
          break;
        case "xmlSpace":
          Wn(
            n,
            _T,
            "xml:space",
            g
          );
          break;
        case "is":
          R != null && console.error(
            'Cannot update the "is" prop after it has been initialized.'
          ), tn(n, "is", g);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          MD || g == null || typeof g != "object" || (MD = !0, console.error(
            "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
            g
          ));
        default:
          !(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N" ? (c = Vp(c), tn(n, c, g)) : kc.hasOwnProperty(c) && g != null && typeof g != "function" && Yo(c, g);
      }
    }
    function rr(n, i, c, g, b, R) {
      switch (c) {
        case "style":
          Zh(n, g, R);
          break;
        case "dangerouslySetInnerHTML":
          if (g != null) {
            if (typeof g != "object" || !("__html" in g))
              throw Error(
                "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
              );
            if (c = g.__html, c != null) {
              if (b.children != null)
                throw Error(
                  "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                );
              n.innerHTML = c;
            }
          }
          break;
        case "children":
          typeof g == "string" ? Yu(n, g) : (typeof g == "number" || typeof g == "bigint") && Yu(n, "" + g);
          break;
        case "onScroll":
          g != null && (typeof g != "function" && Yo(c, g), ga("scroll", n));
          break;
        case "onScrollEnd":
          g != null && (typeof g != "function" && Yo(c, g), ga("scrollend", n));
          break;
        case "onClick":
          g != null && (typeof g != "function" && Yo(c, g), n.onclick = bu);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (kc.hasOwnProperty(c))
            g != null && typeof g != "function" && Yo(c, g);
          else
            e: {
              if (c[0] === "o" && c[1] === "n" && (b = c.endsWith("Capture"), i = c.slice(2, b ? c.length - 7 : void 0), R = n[Hr] || null, R = R != null ? R[c] : null, typeof R == "function" && n.removeEventListener(i, R, b), typeof g == "function")) {
                typeof R != "function" && R !== null && (c in n ? n[c] = null : n.hasAttribute(c) && n.removeAttribute(c)), n.addEventListener(i, g, b);
                break e;
              }
              c in n ? n[c] = g : g === !0 ? n.setAttribute(c, "") : tn(n, c, g);
            }
      }
    }
    function yl(n, i, c) {
      switch (sr(i, c), i) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          ga("error", n), ga("load", n);
          var g = !1, b = !1, R;
          for (R in c)
            if (c.hasOwnProperty(R)) {
              var X = c[R];
              if (X != null)
                switch (R) {
                  case "src":
                    g = !0;
                    break;
                  case "srcSet":
                    b = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(
                      i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  default:
                    Oa(n, i, R, X, c, null);
                }
            }
          b && Oa(n, i, "srcSet", c.srcSet, c, null), g && Oa(n, i, "src", c.src, c, null);
          return;
        case "input":
          tt("input", c), ga("invalid", n);
          var K = R = X = b = null, de = null, ge = null;
          for (g in c)
            if (c.hasOwnProperty(g)) {
              var ut = c[g];
              if (ut != null)
                switch (g) {
                  case "name":
                    b = ut;
                    break;
                  case "type":
                    X = ut;
                    break;
                  case "checked":
                    de = ut;
                    break;
                  case "defaultChecked":
                    ge = ut;
                    break;
                  case "value":
                    R = ut;
                    break;
                  case "defaultValue":
                    K = ut;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (ut != null)
                      throw Error(
                        i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    break;
                  default:
                    Oa(n, i, g, ut, c, null);
                }
            }
          Gt(n, c), ye(
            n,
            R,
            K,
            de,
            ge,
            X,
            b,
            !1
          ), $e(n);
          return;
        case "select":
          tt("select", c), ga("invalid", n), g = X = R = null;
          for (b in c)
            if (c.hasOwnProperty(b) && (K = c[b], K != null))
              switch (b) {
                case "value":
                  R = K;
                  break;
                case "defaultValue":
                  X = K;
                  break;
                case "multiple":
                  g = K;
                default:
                  Oa(
                    n,
                    i,
                    b,
                    K,
                    c,
                    null
                  );
              }
          _t(n, c), i = R, c = X, n.multiple = !!g, i != null ? je(n, !!g, i, !1) : c != null && je(n, !!g, c, !0);
          return;
        case "textarea":
          tt("textarea", c), ga("invalid", n), R = b = g = null;
          for (X in c)
            if (c.hasOwnProperty(X) && (K = c[X], K != null))
              switch (X) {
                case "value":
                  g = K;
                  break;
                case "defaultValue":
                  b = K;
                  break;
                case "children":
                  R = K;
                  break;
                case "dangerouslySetInnerHTML":
                  if (K != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  Oa(
                    n,
                    i,
                    X,
                    K,
                    c,
                    null
                  );
              }
          Ut(n, c), on(n, g, b, R), $e(n);
          return;
        case "option":
          Re(n, c);
          for (de in c)
            if (c.hasOwnProperty(de) && (g = c[de], g != null))
              switch (de) {
                case "selected":
                  n.selected = g && typeof g != "function" && typeof g != "symbol";
                  break;
                default:
                  Oa(n, i, de, g, c, null);
              }
          return;
        case "dialog":
          ga("beforetoggle", n), ga("toggle", n), ga("cancel", n), ga("close", n);
          break;
        case "iframe":
        case "object":
          ga("load", n);
          break;
        case "video":
        case "audio":
          for (g = 0; g < tA.length; g++)
            ga(tA[g], n);
          break;
        case "image":
          ga("error", n), ga("load", n);
          break;
        case "details":
          ga("toggle", n);
          break;
        case "embed":
        case "source":
        case "link":
          ga("error", n), ga("load", n);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (ge in c)
            if (c.hasOwnProperty(ge) && (g = c[ge], g != null))
              switch (ge) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(
                    i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                  );
                default:
                  Oa(n, i, ge, g, c, null);
              }
          return;
        default:
          if (Ec(i)) {
            for (ut in c)
              c.hasOwnProperty(ut) && (g = c[ut], g !== void 0 && rr(
                n,
                i,
                ut,
                g,
                c,
                void 0
              ));
            return;
          }
      }
      for (K in c)
        c.hasOwnProperty(K) && (g = c[K], g != null && Oa(n, i, K, g, c, null));
    }
    function n0(n, i, c, g) {
      switch (sr(i, g), i) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var b = null, R = null, X = null, K = null, de = null, ge = null, ut = null;
          for (Dt in c) {
            var xt = c[Dt];
            if (c.hasOwnProperty(Dt) && xt != null)
              switch (Dt) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  de = xt;
                default:
                  g.hasOwnProperty(Dt) || Oa(
                    n,
                    i,
                    Dt,
                    null,
                    g,
                    xt
                  );
              }
          }
          for (var it in g) {
            var Dt = g[it];
            if (xt = c[it], g.hasOwnProperty(it) && (Dt != null || xt != null))
              switch (it) {
                case "type":
                  R = Dt;
                  break;
                case "name":
                  b = Dt;
                  break;
                case "checked":
                  ge = Dt;
                  break;
                case "defaultChecked":
                  ut = Dt;
                  break;
                case "value":
                  X = Dt;
                  break;
                case "defaultValue":
                  K = Dt;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Dt != null)
                    throw Error(
                      i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  Dt !== xt && Oa(
                    n,
                    i,
                    it,
                    Dt,
                    g,
                    xt
                  );
              }
          }
          i = c.type === "checkbox" || c.type === "radio" ? c.checked != null : c.value != null, g = g.type === "checkbox" || g.type === "radio" ? g.checked != null : g.value != null, i || !g || ED || (console.error(
            "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), ED = !0), !i || g || AD || (console.error(
            "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
          ), AD = !0), ee(
            n,
            X,
            K,
            de,
            ge,
            ut,
            R,
            b
          );
          return;
        case "select":
          Dt = X = K = it = null;
          for (R in c)
            if (de = c[R], c.hasOwnProperty(R) && de != null)
              switch (R) {
                case "value":
                  break;
                case "multiple":
                  Dt = de;
                default:
                  g.hasOwnProperty(R) || Oa(
                    n,
                    i,
                    R,
                    null,
                    g,
                    de
                  );
              }
          for (b in g)
            if (R = g[b], de = c[b], g.hasOwnProperty(b) && (R != null || de != null))
              switch (b) {
                case "value":
                  it = R;
                  break;
                case "defaultValue":
                  K = R;
                  break;
                case "multiple":
                  X = R;
                default:
                  R !== de && Oa(
                    n,
                    i,
                    b,
                    R,
                    g,
                    de
                  );
              }
          g = K, i = X, c = Dt, it != null ? je(n, !!i, it, !1) : !!c != !!i && (g != null ? je(n, !!i, g, !0) : je(n, !!i, i ? [] : "", !1));
          return;
        case "textarea":
          Dt = it = null;
          for (K in c)
            if (b = c[K], c.hasOwnProperty(K) && b != null && !g.hasOwnProperty(K))
              switch (K) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  Oa(n, i, K, null, g, b);
              }
          for (X in g)
            if (b = g[X], R = c[X], g.hasOwnProperty(X) && (b != null || R != null))
              switch (X) {
                case "value":
                  it = b;
                  break;
                case "defaultValue":
                  Dt = b;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (b != null)
                    throw Error(
                      "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                    );
                  break;
                default:
                  b !== R && Oa(n, i, X, b, g, R);
              }
          It(n, it, Dt);
          return;
        case "option":
          for (var wn in c)
            if (it = c[wn], c.hasOwnProperty(wn) && it != null && !g.hasOwnProperty(wn))
              switch (wn) {
                case "selected":
                  n.selected = !1;
                  break;
                default:
                  Oa(
                    n,
                    i,
                    wn,
                    null,
                    g,
                    it
                  );
              }
          for (de in g)
            if (it = g[de], Dt = c[de], g.hasOwnProperty(de) && it !== Dt && (it != null || Dt != null))
              switch (de) {
                case "selected":
                  n.selected = it && typeof it != "function" && typeof it != "symbol";
                  break;
                default:
                  Oa(
                    n,
                    i,
                    de,
                    it,
                    g,
                    Dt
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var Ea in c)
            it = c[Ea], c.hasOwnProperty(Ea) && it != null && !g.hasOwnProperty(Ea) && Oa(
              n,
              i,
              Ea,
              null,
              g,
              it
            );
          for (ge in g)
            if (it = g[ge], Dt = c[ge], g.hasOwnProperty(ge) && it !== Dt && (it != null || Dt != null))
              switch (ge) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (it != null)
                    throw Error(
                      i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                    );
                  break;
                default:
                  Oa(
                    n,
                    i,
                    ge,
                    it,
                    g,
                    Dt
                  );
              }
          return;
        default:
          if (Ec(i)) {
            for (var $l in c)
              it = c[$l], c.hasOwnProperty($l) && it !== void 0 && !g.hasOwnProperty($l) && rr(
                n,
                i,
                $l,
                void 0,
                g,
                it
              );
            for (ut in g)
              it = g[ut], Dt = c[ut], !g.hasOwnProperty(ut) || it === Dt || it === void 0 && Dt === void 0 || rr(
                n,
                i,
                ut,
                it,
                g,
                Dt
              );
            return;
          }
      }
      for (var _i in c)
        it = c[_i], c.hasOwnProperty(_i) && it != null && !g.hasOwnProperty(_i) && Oa(n, i, _i, null, g, it);
      for (xt in g)
        it = g[xt], Dt = c[xt], !g.hasOwnProperty(xt) || it === Dt || it == null && Dt == null || Oa(n, i, xt, it, g, Dt);
    }
    function ny(n) {
      switch (n) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return n;
      }
    }
    function Ii(n) {
      var i = {};
      n = n.style;
      for (var c = 0; c < n.length; c++) {
        var g = n[c];
        i[g] = n.getPropertyValue(g);
      }
      return i;
    }
    function _g(n, i, c) {
      if (i != null && typeof i != "object")
        console.error(
          "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
        );
      else {
        var g, b = g = "", R;
        for (R in i)
          if (i.hasOwnProperty(R)) {
            var X = i[R];
            X != null && typeof X != "boolean" && X !== "" && (R.indexOf("--") === 0 ? (We(X, R), g += b + R + ":" + ("" + X).trim()) : typeof X != "number" || X === 0 || Ug.has(R) ? (We(X, R), g += b + R.replace(zu, "-$1").toLowerCase().replace(Ko, "-ms-") + ":" + ("" + X).trim()) : g += b + R.replace(zu, "-$1").toLowerCase().replace(Ko, "-ms-") + ":" + X + "px", b = ";");
          }
        g = g || null, i = n.getAttribute("style"), i !== g && (g = ui(g), ui(i) !== g && (c.style = Ii(n)));
      }
    }
    function Ol(n, i, c, g, b, R) {
      if (b.delete(c), n = n.getAttribute(c), n === null)
        switch (typeof g) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (g != null)
        switch (typeof g) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (De(g, i), n === "" + g)
              return;
        }
      Ci(i, n, g, R);
    }
    function oc(n, i, c, g, b, R) {
      if (b.delete(c), n = n.getAttribute(c), n === null) {
        switch (typeof g) {
          case "function":
          case "symbol":
            return;
        }
        if (!g) return;
      } else
        switch (typeof g) {
          case "function":
          case "symbol":
            break;
          default:
            if (g) return;
        }
      Ci(i, n, g, R);
    }
    function Sl(n, i, c, g, b, R) {
      if (b.delete(c), n = n.getAttribute(c), n === null)
        switch (typeof g) {
          case "undefined":
          case "function":
          case "symbol":
            return;
        }
      else if (g != null)
        switch (typeof g) {
          case "function":
          case "symbol":
            break;
          default:
            if (De(g, c), n === "" + g)
              return;
        }
      Ci(i, n, g, R);
    }
    function Ag(n, i, c, g, b, R) {
      if (b.delete(c), n = n.getAttribute(c), n === null)
        switch (typeof g) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
          default:
            if (isNaN(g)) return;
        }
      else if (g != null)
        switch (typeof g) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (!isNaN(g) && (De(g, i), n === "" + g))
              return;
        }
      Ci(i, n, g, R);
    }
    function mi(n, i, c, g, b, R) {
      if (b.delete(c), n = n.getAttribute(c), n === null)
        switch (typeof g) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (g != null)
        switch (typeof g) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (De(g, i), c = Kd("" + g), n === c)
              return;
        }
      Ci(i, n, g, R);
    }
    function ma(n, i, c, g) {
      for (var b = {}, R = /* @__PURE__ */ new Set(), X = n.attributes, K = 0; K < X.length; K++)
        switch (X[K].name.toLowerCase()) {
          case "value":
            break;
          case "checked":
            break;
          case "selected":
            break;
          default:
            R.add(X[K].name);
        }
      if (Ec(i)) {
        for (var de in c)
          if (c.hasOwnProperty(de)) {
            var ge = c[de];
            if (ge != null) {
              if (kc.hasOwnProperty(de))
                typeof ge != "function" && Yo(de, ge);
              else if (c.suppressHydrationWarning !== !0)
                switch (de) {
                  case "children":
                    typeof ge != "string" && typeof ge != "number" || Ci(
                      "children",
                      n.textContent,
                      ge,
                      b
                    );
                    continue;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref":
                    continue;
                  case "dangerouslySetInnerHTML":
                    X = n.innerHTML, ge = ge ? ge.__html : void 0, ge != null && (ge = vm(n, ge), Ci(
                      de,
                      X,
                      ge,
                      b
                    ));
                    continue;
                  case "style":
                    R.delete(de), _g(n, ge, b);
                    continue;
                  case "offsetParent":
                  case "offsetTop":
                  case "offsetLeft":
                  case "offsetWidth":
                  case "offsetHeight":
                  case "isContentEditable":
                  case "outerText":
                  case "outerHTML":
                    R.delete(de.toLowerCase()), console.error(
                      "Assignment to read-only property will result in a no-op: `%s`",
                      de
                    );
                    continue;
                  case "className":
                    R.delete("class"), X = $t(
                      n,
                      "class",
                      ge
                    ), Ci(
                      "className",
                      X,
                      ge,
                      b
                    );
                    continue;
                  default:
                    g.context === Dy && i !== "svg" && i !== "math" ? R.delete(de.toLowerCase()) : R.delete(de), X = $t(
                      n,
                      de,
                      ge
                    ), Ci(
                      de,
                      X,
                      ge,
                      b
                    );
                }
            }
          }
      } else
        for (ge in c)
          if (c.hasOwnProperty(ge) && (de = c[ge], de != null)) {
            if (kc.hasOwnProperty(ge))
              typeof de != "function" && Yo(ge, de);
            else if (c.suppressHydrationWarning !== !0)
              switch (ge) {
                case "children":
                  typeof de != "string" && typeof de != "number" || Ci(
                    "children",
                    n.textContent,
                    de,
                    b
                  );
                  continue;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                  continue;
                case "dangerouslySetInnerHTML":
                  X = n.innerHTML, de = de ? de.__html : void 0, de != null && (de = vm(n, de), X !== de && (b[ge] = { __html: X }));
                  continue;
                case "className":
                  Ol(
                    n,
                    ge,
                    "class",
                    de,
                    R,
                    b
                  );
                  continue;
                case "tabIndex":
                  Ol(
                    n,
                    ge,
                    "tabindex",
                    de,
                    R,
                    b
                  );
                  continue;
                case "style":
                  R.delete(ge), _g(n, de, b);
                  continue;
                case "multiple":
                  R.delete(ge), Ci(
                    ge,
                    n.multiple,
                    de,
                    b
                  );
                  continue;
                case "muted":
                  R.delete(ge), Ci(
                    ge,
                    n.muted,
                    de,
                    b
                  );
                  continue;
                case "autoFocus":
                  R.delete("autofocus"), Ci(
                    ge,
                    n.autofocus,
                    de,
                    b
                  );
                  continue;
                case "data":
                  if (i !== "object") {
                    R.delete(ge), X = n.getAttribute("data"), Ci(
                      ge,
                      X,
                      de,
                      b
                    );
                    continue;
                  }
                case "src":
                case "href":
                  if (!(de !== "" || i === "a" && ge === "href" || i === "object" && ge === "data")) {
                    console.error(
                      ge === "src" ? 'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.' : 'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                      ge,
                      ge
                    );
                    continue;
                  }
                  mi(
                    n,
                    ge,
                    ge,
                    de,
                    R,
                    b
                  );
                  continue;
                case "action":
                case "formAction":
                  if (X = n.getAttribute(ge), typeof de == "function") {
                    R.delete(ge.toLowerCase()), ge === "formAction" ? (R.delete("name"), R.delete("formenctype"), R.delete("formmethod"), R.delete("formtarget")) : (R.delete("enctype"), R.delete("method"), R.delete("target"));
                    continue;
                  } else if (X === bN) {
                    R.delete(ge.toLowerCase()), Ci(
                      ge,
                      "function",
                      de,
                      b
                    );
                    continue;
                  }
                  mi(
                    n,
                    ge,
                    ge.toLowerCase(),
                    de,
                    R,
                    b
                  );
                  continue;
                case "xlinkHref":
                  mi(
                    n,
                    ge,
                    "xlink:href",
                    de,
                    R,
                    b
                  );
                  continue;
                case "contentEditable":
                  Sl(
                    n,
                    ge,
                    "contenteditable",
                    de,
                    R,
                    b
                  );
                  continue;
                case "spellCheck":
                  Sl(
                    n,
                    ge,
                    "spellcheck",
                    de,
                    R,
                    b
                  );
                  continue;
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                  Sl(
                    n,
                    ge,
                    ge,
                    de,
                    R,
                    b
                  );
                  continue;
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                  oc(
                    n,
                    ge,
                    ge.toLowerCase(),
                    de,
                    R,
                    b
                  );
                  continue;
                case "capture":
                case "download":
                  e: {
                    K = n;
                    var ut = X = ge, xt = b;
                    if (R.delete(ut), K = K.getAttribute(ut), K === null)
                      switch (typeof de) {
                        case "undefined":
                        case "function":
                        case "symbol":
                          break e;
                        default:
                          if (de === !1) break e;
                      }
                    else if (de != null)
                      switch (typeof de) {
                        case "function":
                        case "symbol":
                          break;
                        case "boolean":
                          if (de === !0 && K === "") break e;
                          break;
                        default:
                          if (De(de, X), K === "" + de)
                            break e;
                      }
                    Ci(
                      X,
                      K,
                      de,
                      xt
                    );
                  }
                  continue;
                case "cols":
                case "rows":
                case "size":
                case "span":
                  e: {
                    if (K = n, ut = X = ge, xt = b, R.delete(ut), K = K.getAttribute(ut), K === null)
                      switch (typeof de) {
                        case "undefined":
                        case "function":
                        case "symbol":
                        case "boolean":
                          break e;
                        default:
                          if (isNaN(de) || 1 > de) break e;
                      }
                    else if (de != null)
                      switch (typeof de) {
                        case "function":
                        case "symbol":
                        case "boolean":
                          break;
                        default:
                          if (!(isNaN(de) || 1 > de) && (De(de, X), K === "" + de))
                            break e;
                      }
                    Ci(
                      X,
                      K,
                      de,
                      xt
                    );
                  }
                  continue;
                case "rowSpan":
                  Ag(
                    n,
                    ge,
                    "rowspan",
                    de,
                    R,
                    b
                  );
                  continue;
                case "start":
                  Ag(
                    n,
                    ge,
                    ge,
                    de,
                    R,
                    b
                  );
                  continue;
                case "xHeight":
                  Ol(
                    n,
                    ge,
                    "x-height",
                    de,
                    R,
                    b
                  );
                  continue;
                case "xlinkActuate":
                  Ol(
                    n,
                    ge,
                    "xlink:actuate",
                    de,
                    R,
                    b
                  );
                  continue;
                case "xlinkArcrole":
                  Ol(
                    n,
                    ge,
                    "xlink:arcrole",
                    de,
                    R,
                    b
                  );
                  continue;
                case "xlinkRole":
                  Ol(
                    n,
                    ge,
                    "xlink:role",
                    de,
                    R,
                    b
                  );
                  continue;
                case "xlinkShow":
                  Ol(
                    n,
                    ge,
                    "xlink:show",
                    de,
                    R,
                    b
                  );
                  continue;
                case "xlinkTitle":
                  Ol(
                    n,
                    ge,
                    "xlink:title",
                    de,
                    R,
                    b
                  );
                  continue;
                case "xlinkType":
                  Ol(
                    n,
                    ge,
                    "xlink:type",
                    de,
                    R,
                    b
                  );
                  continue;
                case "xmlBase":
                  Ol(
                    n,
                    ge,
                    "xml:base",
                    de,
                    R,
                    b
                  );
                  continue;
                case "xmlLang":
                  Ol(
                    n,
                    ge,
                    "xml:lang",
                    de,
                    R,
                    b
                  );
                  continue;
                case "xmlSpace":
                  Ol(
                    n,
                    ge,
                    "xml:space",
                    de,
                    R,
                    b
                  );
                  continue;
                case "inert":
                  de !== "" || FE[ge] || (FE[ge] = !0, console.error(
                    "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                    ge
                  )), oc(
                    n,
                    ge,
                    ge,
                    de,
                    R,
                    b
                  );
                  continue;
                default:
                  if (!(2 < ge.length) || ge[0] !== "o" && ge[0] !== "O" || ge[1] !== "n" && ge[1] !== "N") {
                    K = Vp(ge), X = !1, g.context === Dy && i !== "svg" && i !== "math" ? R.delete(K.toLowerCase()) : (ut = ge.toLowerCase(), ut = Um.hasOwnProperty(
                      ut
                    ) && Um[ut] || null, ut !== null && ut !== ge && (X = !0, R.delete(ut)), R.delete(K));
                    e: if (ut = n, xt = K, K = de, Ct(xt))
                      if (ut.hasAttribute(xt))
                        ut = ut.getAttribute(
                          xt
                        ), De(
                          K,
                          xt
                        ), K = ut === "" + K ? K : ut;
                      else {
                        switch (typeof K) {
                          case "function":
                          case "symbol":
                            break e;
                          case "boolean":
                            if (ut = xt.toLowerCase().slice(0, 5), ut !== "data-" && ut !== "aria-")
                              break e;
                        }
                        K = K === void 0 ? void 0 : null;
                      }
                    else K = void 0;
                    X || Ci(
                      ge,
                      K,
                      de,
                      b
                    );
                  }
              }
          }
      return 0 < R.size && c.suppressHydrationWarning !== !0 && Gf(n, R, b), Object.keys(b).length === 0 ? null : b;
    }
    function Ga(n, i) {
      switch (n.length) {
        case 0:
          return "";
        case 1:
          return n[0];
        case 2:
          return n[0] + " " + i + " " + n[1];
        default:
          return n.slice(0, -1).join(", ") + ", " + i + " " + n[n.length - 1];
      }
    }
    function Fn(n) {
      return n.nodeType === 9 ? n : n.ownerDocument;
    }
    function ba(n) {
      switch (n) {
        case Uv:
          return G_;
        case Og:
          return YE;
        default:
          return Dy;
      }
    }
    function _l(n, i) {
      if (n === Dy)
        switch (i) {
          case "svg":
            return G_;
          case "math":
            return YE;
          default:
            return Dy;
        }
      return n === G_ && i === "foreignObject" ? Dy : n;
    }
    function wr(n, i) {
      return n === "textarea" || n === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.children == "bigint" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
    }
    function ym() {
      var n = window.event;
      return n && n.type === "popstate" ? n === MT ? !1 : (MT = n, !0) : (MT = null, !1);
    }
    function Sm(n) {
      setTimeout(function() {
        throw n;
      });
    }
    function uc(n, i, c) {
      switch (i) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && n.focus();
          break;
        case "img":
          c.src ? n.src = c.src : c.srcSet && (n.srcset = c.srcSet);
      }
    }
    function il(n, i, c, g) {
      n0(n, i, c, g), n[Hr] = g;
    }
    function Mu(n) {
      Yu(n, "");
    }
    function Zc(n, i, c) {
      n.nodeValue = c;
    }
    function oo(n) {
      return n === "head";
    }
    function xu(n, i) {
      n.removeChild(i);
    }
    function hi(n, i) {
      (n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n).removeChild(i);
    }
    function Si(n, i) {
      var c = i, g = 0, b = 0;
      do {
        var R = c.nextSibling;
        if (n.removeChild(c), R && R.nodeType === 8)
          if (c = R.data, c === XE) {
            if (0 < g && 8 > g) {
              c = g;
              var X = n.ownerDocument;
              if (c & xN && Vf(X.documentElement), c & TN && Vf(X.body), c & CN)
                for (c = X.head, Vf(c), X = c.firstChild; X; ) {
                  var K = X.nextSibling, de = X.nodeName;
                  X[Tv] || de === "SCRIPT" || de === "STYLE" || de === "LINK" && X.rel.toLowerCase() === "stylesheet" || c.removeChild(X), X = K;
                }
            }
            if (b === 0) {
              n.removeChild(R), Jo(i);
              return;
            }
            b--;
          } else
            c === PE || c === Ry || c === nA ? b++ : g = c.charCodeAt(0) - 48;
        else g = 0;
        c = R;
      } while (c);
      Jo(i);
    }
    function Dn(n) {
      n = n.style, typeof n.setProperty == "function" ? n.setProperty("display", "none", "important") : n.display = "none";
    }
    function qa(n) {
      n.nodeValue = "";
    }
    function Ri(n, i) {
      i = i[RN], i = i != null && i.hasOwnProperty("display") ? i.display : null, n.style.display = i == null || typeof i == "boolean" ? "" : ("" + i).trim();
    }
    function or(n, i) {
      n.nodeValue = i;
    }
    function uo(n) {
      var i = n.firstChild;
      for (i && i.nodeType === 10 && (i = i.nextSibling); i; ) {
        var c = i;
        switch (i = i.nextSibling, c.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            uo(c), gn(c);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (c.rel.toLowerCase() === "stylesheet") continue;
        }
        n.removeChild(c);
      }
    }
    function qo(n, i, c, g) {
      for (; n.nodeType === 1; ) {
        var b = c;
        if (n.nodeName.toLowerCase() !== i.toLowerCase()) {
          if (!g && (n.nodeName !== "INPUT" || n.type !== "hidden"))
            break;
        } else if (g) {
          if (!n[Tv])
            switch (i) {
              case "meta":
                if (!n.hasAttribute("itemprop")) break;
                return n;
              case "link":
                if (R = n.getAttribute("rel"), R === "stylesheet" && n.hasAttribute("data-precedence"))
                  break;
                if (R !== b.rel || n.getAttribute("href") !== (b.href == null || b.href === "" ? null : b.href) || n.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin) || n.getAttribute("title") !== (b.title == null ? null : b.title))
                  break;
                return n;
              case "style":
                if (n.hasAttribute("data-precedence")) break;
                return n;
              case "script":
                if (R = n.getAttribute("src"), (R !== (b.src == null ? null : b.src) || n.getAttribute("type") !== (b.type == null ? null : b.type) || n.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin)) && R && n.hasAttribute("async") && !n.hasAttribute("itemprop"))
                  break;
                return n;
              default:
                return n;
            }
        } else if (i === "input" && n.type === "hidden") {
          De(b.name, "name");
          var R = b.name == null ? null : "" + b.name;
          if (b.type === "hidden" && n.getAttribute("name") === R)
            return n;
        } else return n;
        if (n = Al(n.nextSibling), n === null) break;
      }
      return null;
    }
    function Rs(n, i, c) {
      if (i === "") return null;
      for (; n.nodeType !== 3; )
        if ((n.nodeType !== 1 || n.nodeName !== "INPUT" || n.type !== "hidden") && !c || (n = Al(n.nextSibling), n === null)) return null;
      return n;
    }
    function Ds(n) {
      return n.data === nA || n.data === Ry && n.ownerDocument.readyState === TD;
    }
    function Vi(n, i) {
      var c = n.ownerDocument;
      if (n.data !== Ry || c.readyState === TD)
        i();
      else {
        var g = function() {
          i(), c.removeEventListener("DOMContentLoaded", g);
        };
        c.addEventListener("DOMContentLoaded", g), n._reactRetry = g;
      }
    }
    function Al(n) {
      for (; n != null; n = n.nextSibling) {
        var i = n.nodeType;
        if (i === 1 || i === 3) break;
        if (i === 8) {
          if (i = n.data, i === PE || i === nA || i === Ry || i === AT || i === xD)
            break;
          if (i === XE) return null;
        }
      }
      return n;
    }
    function If(n) {
      if (n.nodeType === 1) {
        for (var i = n.nodeName.toLowerCase(), c = {}, g = n.attributes, b = 0; b < g.length; b++) {
          var R = g[b];
          c[ny(R.name)] = R.name.toLowerCase() === "style" ? Ii(n) : R.value;
        }
        return { type: i, props: c };
      }
      return n.nodeType === 8 ? { type: "Suspense", props: {} } : n.nodeValue;
    }
    function _m(n, i, c) {
      return c === null || c[MN] !== !0 ? (n.nodeValue === i ? n = null : (i = ui(i), n = ui(n.nodeValue) === i ? null : n.nodeValue), n) : null;
    }
    function co(n) {
      n = n.nextSibling;
      for (var i = 0; n; ) {
        if (n.nodeType === 8) {
          var c = n.data;
          if (c === XE) {
            if (i === 0)
              return Al(n.nextSibling);
            i--;
          } else
            c !== PE && c !== nA && c !== Ry || i++;
        }
        n = n.nextSibling;
      }
      return null;
    }
    function Qc(n) {
      n = n.previousSibling;
      for (var i = 0; n; ) {
        if (n.nodeType === 8) {
          var c = n.data;
          if (c === PE || c === nA || c === Ry) {
            if (i === 0) return n;
            i--;
          } else c === XE && i++;
        }
        n = n.previousSibling;
      }
      return null;
    }
    function Fl(n) {
      Jo(n);
    }
    function wl(n) {
      Jo(n);
    }
    function yv(n, i, c, g, b) {
      switch (b && ff(n, g.ancestorInfo), i = Fn(c), n) {
        case "html":
          if (n = i.documentElement, !n)
            throw Error(
              "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return n;
        case "head":
          if (n = i.head, !n)
            throw Error(
              "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return n;
        case "body":
          if (n = i.body, !n)
            throw Error(
              "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
            );
          return n;
        default:
          throw Error(
            "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
    }
    function fo(n, i, c, g) {
      if (!c[oa] && jt(c)) {
        var b = c.tagName.toLowerCase();
        console.error(
          "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
          b,
          b,
          b
        );
      }
      switch (n) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error(
            "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
          );
      }
      for (b = c.attributes; b.length; )
        c.removeAttributeNode(b[0]);
      yl(c, n, i), c[ws] = g, c[Hr] = i;
    }
    function Vf(n) {
      for (var i = n.attributes; i.length; )
        n.removeAttributeNode(i[0]);
      gn(n);
    }
    function Bd(n) {
      return typeof n.getRootNode == "function" ? n.getRootNode() : n.nodeType === 9 ? n : n.ownerDocument;
    }
    function jc(n, i, c) {
      var g = I_;
      if (g && typeof i == "string" && i) {
        var b = Ft(i);
        b = 'link[rel="' + n + '"][href="' + b + '"]', typeof c == "string" && (b += '[crossorigin="' + c + '"]'), OD.has(b) || (OD.add(b), n = { rel: n, crossOrigin: c, href: i }, g.querySelector(b) === null && (i = g.createElement("link"), yl(i, "link", n), Ht(i), g.head.appendChild(i)));
      }
    }
    function Zo(n, i, c, g) {
      var b = (b = dc.current) ? Bd(b) : null;
      if (!b)
        throw Error(
          '"resourceRoot" was expected to exist. This is a bug in React.'
        );
      switch (n) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof c.precedence == "string" && typeof c.href == "string" ? (c = Bs(c.href), i = ot(b).hoistableStyles, g = i.get(c), g || (g = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, i.set(c, g)), g) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
            n = Bs(c.href);
            var R = ot(b).hoistableStyles, X = R.get(n);
            if (!X && (b = b.ownerDocument || b, X = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: SS, preload: null }
            }, R.set(n, X), (R = b.querySelector(
              $i(n)
            )) && !R._p && (X.instance = R, X.state.loading = aA | Vm), !Fm.has(n))) {
              var K = {
                rel: "preload",
                as: "style",
                href: c.href,
                crossOrigin: c.crossOrigin,
                integrity: c.integrity,
                media: c.media,
                hrefLang: c.hrefLang,
                referrerPolicy: c.referrerPolicy
              };
              Fm.set(n, K), R || Am(
                b,
                n,
                K,
                X.state
              );
            }
            if (i && g === null)
              throw c = `

  - ` + Kl(i) + `
  + ` + Kl(c), Error(
                "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + c
              );
            return X;
          }
          if (i && g !== null)
            throw c = `

  - ` + Kl(i) + `
  + ` + Kl(c), Error(
              "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + c
            );
          return null;
        case "script":
          return i = c.async, c = c.src, typeof c == "string" && i && typeof i != "function" && typeof i != "symbol" ? (c = cc(c), i = ot(b).hoistableScripts, g = i.get(c), g || (g = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, i.set(c, g)), g) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(
            'getResource encountered a type it did not expect: "' + n + '". this is a bug in React.'
          );
      }
    }
    function Kl(n) {
      var i = 0, c = "<link";
      return typeof n.rel == "string" ? (i++, c += ' rel="' + n.rel + '"') : Kc.call(n, "rel") && (i++, c += ' rel="' + (n.rel === null ? "null" : "invalid type " + typeof n.rel) + '"'), typeof n.href == "string" ? (i++, c += ' href="' + n.href + '"') : Kc.call(n, "href") && (i++, c += ' href="' + (n.href === null ? "null" : "invalid type " + typeof n.href) + '"'), typeof n.precedence == "string" ? (i++, c += ' precedence="' + n.precedence + '"') : Kc.call(n, "precedence") && (i++, c += " precedence={" + (n.precedence === null ? "null" : "invalid type " + typeof n.precedence) + "}"), Object.getOwnPropertyNames(n).length > i && (c += " ..."), c + " />";
    }
    function Bs(n) {
      return 'href="' + Ft(n) + '"';
    }
    function $i(n) {
      return 'link[rel="stylesheet"][' + n + "]";
    }
    function Sv(n) {
      return Da({}, n, {
        "data-precedence": n.precedence,
        precedence: null
      });
    }
    function Am(n, i, c, g) {
      n.querySelector(
        'link[rel="preload"][as="style"][' + i + "]"
      ) ? g.loading = aA : (i = n.createElement("link"), g.preload = i, i.addEventListener("load", function() {
        return g.loading |= aA;
      }), i.addEventListener("error", function() {
        return g.loading |= BD;
      }), yl(i, "link", c), Ht(i), n.head.appendChild(i));
    }
    function cc(n) {
      return '[src="' + Ft(n) + '"]';
    }
    function h(n) {
      return "script[async]" + n;
    }
    function m(n, i, c) {
      if (i.count++, i.instance === null)
        switch (i.type) {
          case "style":
            var g = n.querySelector(
              'style[data-href~="' + Ft(c.href) + '"]'
            );
            if (g)
              return i.instance = g, Ht(g), g;
            var b = Da({}, c, {
              "data-href": c.href,
              "data-precedence": c.precedence,
              href: null,
              precedence: null
            });
            return g = (n.ownerDocument || n).createElement("style"), Ht(g), yl(g, "style", b), M(g, c.precedence, n), i.instance = g;
          case "stylesheet":
            b = Bs(c.href);
            var R = n.querySelector(
              $i(b)
            );
            if (R)
              return i.state.loading |= Vm, i.instance = R, Ht(R), R;
            g = Sv(c), (b = Fm.get(b)) && w(g, b), R = (n.ownerDocument || n).createElement("link"), Ht(R);
            var X = R;
            return X._p = new Promise(function(K, de) {
              X.onload = K, X.onerror = de;
            }), yl(R, "link", g), i.state.loading |= Vm, M(R, c.precedence, n), i.instance = R;
          case "script":
            return R = cc(c.src), (b = n.querySelector(
              h(R)
            )) ? (i.instance = b, Ht(b), b) : (g = c, (b = Fm.get(R)) && (g = Da({}, c), I(g, b)), n = n.ownerDocument || n, b = n.createElement("script"), Ht(b), yl(b, "link", g), n.head.appendChild(b), i.instance = b);
          case "void":
            return null;
          default:
            throw Error(
              'acquireResource encountered a resource type it did not expect: "' + i.type + '". this is a bug in React.'
            );
        }
      else
        i.type === "stylesheet" && (i.state.loading & Vm) === SS && (g = i.instance, i.state.loading |= Vm, M(g, c.precedence, n));
      return i.instance;
    }
    function M(n, i, c) {
      for (var g = c.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), b = g.length ? g[g.length - 1] : null, R = b, X = 0; X < g.length; X++) {
        var K = g[X];
        if (K.dataset.precedence === i) R = K;
        else if (R !== b) break;
      }
      R ? R.parentNode.insertBefore(n, R.nextSibling) : (i = c.nodeType === 9 ? c.head : c, i.insertBefore(n, i.firstChild));
    }
    function w(n, i) {
      n.crossOrigin == null && (n.crossOrigin = i.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = i.referrerPolicy), n.title == null && (n.title = i.title);
    }
    function I(n, i) {
      n.crossOrigin == null && (n.crossOrigin = i.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = i.referrerPolicy), n.integrity == null && (n.integrity = i.integrity);
    }
    function Z(n, i, c) {
      if (qE === null) {
        var g = /* @__PURE__ */ new Map(), b = qE = /* @__PURE__ */ new Map();
        b.set(c, g);
      } else
        b = qE, g = b.get(c), g || (g = /* @__PURE__ */ new Map(), b.set(c, g));
      if (g.has(n)) return g;
      for (g.set(n, null), c = c.getElementsByTagName(n), b = 0; b < c.length; b++) {
        var R = c[b];
        if (!(R[Tv] || R[ws] || n === "link" && R.getAttribute("rel") === "stylesheet") && R.namespaceURI !== Uv) {
          var X = R.getAttribute(i) || "";
          X = n + X;
          var K = g.get(X);
          K ? K.push(R) : g.set(X, [R]);
        }
      }
      return g;
    }
    function fe(n, i, c) {
      n = n.ownerDocument || n, n.head.insertBefore(
        c,
        i === "title" ? n.querySelector("head > title") : null
      );
    }
    function Be(n, i, c) {
      var g = !c.ancestorInfo.containerTagInScope;
      if (c.context === G_ || i.itemProp != null)
        return !g || i.itemProp == null || n !== "meta" && n !== "title" && n !== "style" && n !== "link" && n !== "script" || console.error(
          "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
          n,
          n
        ), !1;
      switch (n) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (typeof i.precedence != "string" || typeof i.href != "string" || i.href === "") {
            g && console.error(
              'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
            );
            break;
          }
          return !0;
        case "link":
          if (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" || i.onLoad || i.onError) {
            if (i.rel === "stylesheet" && typeof i.precedence == "string") {
              n = i.href;
              var b = i.onError, R = i.disabled;
              c = [], i.onLoad && c.push("`onLoad`"), b && c.push("`onError`"), R != null && c.push("`disabled`"), b = Ga(c, "and"), b += c.length === 1 ? " prop" : " props", R = c.length === 1 ? "an " + b : "the " + b, c.length && console.error(
                'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                n,
                R,
                b
              );
            }
            g && (typeof i.rel != "string" || typeof i.href != "string" || i.href === "" ? console.error(
              "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
            ) : (i.onError || i.onLoad) && console.error(
              "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ));
            break;
          }
          switch (i.rel) {
            case "stylesheet":
              return n = i.precedence, i = i.disabled, typeof n != "string" && g && console.error(
                'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
              ), typeof n == "string" && i == null;
            default:
              return !0;
          }
        case "script":
          if (n = i.async && typeof i.async != "function" && typeof i.async != "symbol", !n || i.onLoad || i.onError || !i.src || typeof i.src != "string") {
            g && (n ? i.onLoad || i.onError ? console.error(
              "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
            ) : console.error(
              'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
            ));
            break;
          }
          return !0;
        case "noscript":
        case "template":
          g && console.error(
            "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
            n
          );
      }
      return !1;
    }
    function qe(n) {
      return !(n.type === "stylesheet" && (n.state.loading & UD) === SS);
    }
    function wt() {
    }
    function en(n, i, c) {
      if (iA === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var g = iA;
      if (i.type === "stylesheet" && (typeof c.media != "string" || matchMedia(c.media).matches !== !1) && (i.state.loading & Vm) === SS) {
        if (i.instance === null) {
          var b = Bs(c.href), R = n.querySelector(
            $i(b)
          );
          if (R) {
            n = R._p, n !== null && typeof n == "object" && typeof n.then == "function" && (g.count++, g = cn.bind(g), n.then(g, g)), i.state.loading |= Vm, i.instance = R, Ht(R);
            return;
          }
          R = n.ownerDocument || n, c = Sv(c), (b = Fm.get(b)) && w(c, b), R = R.createElement("link"), Ht(R);
          var X = R;
          X._p = new Promise(function(K, de) {
            X.onload = K, X.onerror = de;
          }), yl(R, "link", c), i.instance = R;
        }
        g.stylesheets === null && (g.stylesheets = /* @__PURE__ */ new Map()), g.stylesheets.set(i, n), (n = i.state.preload) && (i.state.loading & UD) === SS && (g.count++, i = cn.bind(g), n.addEventListener("load", i), n.addEventListener("error", i));
      }
    }
    function mn() {
      if (iA === null)
        throw Error(
          "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
        );
      var n = iA;
      return n.stylesheets && n.count === 0 && Un(n, n.stylesheets), 0 < n.count ? function(i) {
        var c = setTimeout(function() {
          if (n.stylesheets && Un(n, n.stylesheets), n.unsuspend) {
            var g = n.unsuspend;
            n.unsuspend = null, g();
          }
        }, 6e4);
        return n.unsuspend = i, function() {
          n.unsuspend = null, clearTimeout(c);
        };
      } : null;
    }
    function cn() {
      if (this.count--, this.count === 0) {
        if (this.stylesheets)
          Un(this, this.stylesheets);
        else if (this.unsuspend) {
          var n = this.unsuspend;
          this.unsuspend = null, n();
        }
      }
    }
    function Un(n, i) {
      n.stylesheets = null, n.unsuspend !== null && (n.count++, ZE = /* @__PURE__ */ new Map(), i.forEach(an, n), ZE = null, cn.call(n));
    }
    function an(n, i) {
      if (!(i.state.loading & Vm)) {
        var c = ZE.get(n);
        if (c) var g = c.get(TT);
        else {
          c = /* @__PURE__ */ new Map(), ZE.set(n, c);
          for (var b = n.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), R = 0; R < b.length; R++) {
            var X = b[R];
            (X.nodeName === "LINK" || X.getAttribute("media") !== "not all") && (c.set(X.dataset.precedence, X), g = X);
          }
          g && c.set(TT, g);
        }
        b = i.instance, X = b.getAttribute("data-precedence"), R = c.get(X) || g, R === g && c.set(TT, b), c.set(X, b), this.count++, g = cn.bind(this), b.addEventListener("load", g), b.addEventListener("error", g), R ? R.parentNode.insertBefore(b, R.nextSibling) : (n = n.nodeType === 9 ? n.head : n, n.insertBefore(b, n.firstChild)), i.state.loading |= Vm;
      }
    }
    function ur(n, i, c, g, b, R, X, K) {
      for (this.tag = 1, this.containerInfo = n, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = yS, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = se(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = se(0), this.hiddenUpdates = se(null), this.identifierPrefix = g, this.onUncaughtError = b, this.onCaughtError = R, this.onRecoverableError = X, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = K, this.incompleteTransitions = /* @__PURE__ */ new Map(), this.passiveEffectDuration = this.effectDuration = -0, this.memoizedUpdaters = /* @__PURE__ */ new Set(), n = this.pendingUpdatersLaneMap = [], i = 0; 31 > i; i++) n.push(/* @__PURE__ */ new Set());
      this._debugRootType = c ? "hydrateRoot()" : "createRoot()";
    }
    function Us(n, i, c, g, b, R, X, K, de, ge, ut, xt) {
      return n = new ur(
        n,
        i,
        c,
        X,
        K,
        de,
        ge,
        xt
      ), i = rS, R === !0 && (i |= Wo | Bp), kl && (i |= _o), R = D(3, null, null, i), n.current = R, R.stateNode = n, i = rh(), Sf(i), n.pooledCache = i, Sf(i), R.memoizedState = {
        element: g,
        isDehydrated: c,
        cache: i
      }, ri(R), n;
    }
    function Ke(n) {
      return n ? (n = zh, n) : zh;
    }
    function Ge(n, i, c, g, b, R) {
      if (zr && typeof zr.onScheduleFiberRoot == "function")
        try {
          zr.onScheduleFiberRoot(yp, g, c);
        } catch (X) {
          Bu || (Bu = !0, console.error(
            "React instrumentation encountered an error: %s",
            X
          ));
        }
      vn !== null && typeof vn.markRenderScheduled == "function" && vn.markRenderScheduled(i), b = Ke(b), g.context === null ? g.context = b : g.pendingContext = b, Gn && Js !== null && !HD && (HD = !0, console.error(
        `Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,
        Q(Js) || "Unknown"
      )), g = ju(i), g.payload = { element: c }, R = R === void 0 ? null : R, R !== null && (typeof R != "function" && console.error(
        "Expected the last optional `callback` argument to be a function. Instead received: %s.",
        R
      ), g.callback = R), c = vu(n, g, i), c !== null && (Cl(c, n, i), gu(c, n, i));
    }
    function rt(n, i) {
      if (n = n.memoizedState, n !== null && n.dehydrated !== null) {
        var c = n.retryLane;
        n.retryLane = c !== 0 && c < i ? c : i;
      }
    }
    function qt(n, i) {
      rt(n, i), (n = n.alternate) && rt(n, i);
    }
    function On(n) {
      if (n.tag === 13) {
        var i = mr(n, 67108864);
        i !== null && Cl(i, n, 67108864), qt(n, 67108864);
      }
    }
    function Fi() {
      return Js;
    }
    function Hn() {
      for (var n = /* @__PURE__ */ new Map(), i = 1, c = 0; 31 > c; c++) {
        var g = Ha(i);
        n.set(i, g), i *= 2;
      }
      return n;
    }
    function ya(n, i, c, g) {
      var b = mt.T;
      mt.T = null;
      var R = Kn.p;
      try {
        Kn.p = mo, la(n, i, c, g);
      } finally {
        Kn.p = R, mt.T = b;
      }
    }
    function Ki(n, i, c, g) {
      var b = mt.T;
      mt.T = null;
      var R = Kn.p;
      try {
        Kn.p = Yf, la(n, i, c, g);
      } finally {
        Kn.p = R, mt.T = b;
      }
    }
    function la(n, i, c, g) {
      if (jE) {
        var b = cs(g);
        if (b === null)
          us(
            n,
            i,
            g,
            JE,
            c
          ), Cu(n, g);
        else if (Eg(
          b,
          n,
          i,
          c,
          g
        ))
          g.stopPropagation();
        else if (Cu(n, g), i & 4 && -1 < ON.indexOf(n)) {
          for (; b !== null; ) {
            var R = jt(b);
            if (R !== null)
              switch (R.tag) {
                case 3:
                  if (R = R.stateNode, R.current.memoizedState.isDehydrated) {
                    var X = Tt(R.pendingLanes);
                    if (X !== 0) {
                      var K = R;
                      for (K.pendingLanes |= 2, K.entangledLanes |= 2; X; ) {
                        var de = 1 << 31 - po(X);
                        K.entanglements[1] |= de, X &= ~de;
                      }
                      lr(R), (ol & (Yd | Vv)) === Op && (OE = Nd() + pD, rc(0));
                    }
                  }
                  break;
                case 13:
                  K = mr(R, 2), K !== null && Cl(K, R, 2), wf(), qt(R, 2);
              }
            if (R = cs(g), R === null && us(
              n,
              i,
              g,
              JE,
              c
            ), R === b) break;
            b = R;
          }
          b !== null && g.stopPropagation();
        } else
          us(
            n,
            i,
            g,
            null,
            c
          );
      }
    }
    function cs(n) {
      return n = fl(n), Tu(n);
    }
    function Tu(n) {
      if (JE = null, n = nn(n), n !== null) {
        var i = N(n);
        if (i === null) n = null;
        else {
          var c = i.tag;
          if (c === 13) {
            if (n = F(i), n !== null) return n;
            n = null;
          } else if (c === 3) {
            if (i.stateNode.current.memoizedState.isDehydrated)
              return i.tag === 3 ? i.stateNode.containerInfo : null;
            n = null;
          } else i !== n && (n = null);
        }
      }
      return JE = n, null;
    }
    function Em(n) {
      switch (n) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return mo;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Yf;
        case "message":
          switch (zd()) {
            case Tg:
              return mo;
            case xm:
              return Yf;
            case Hd:
            case l0:
              return Sp;
            case Cg:
              return oy;
            default:
              return Sp;
          }
        default:
          return Sp;
      }
    }
    function Cu(n, i) {
      switch (n) {
        case "focusin":
        case "focusout":
          T0 = null;
          break;
        case "dragenter":
        case "dragleave":
          C0 = null;
          break;
        case "mouseover":
        case "mouseout":
          R0 = null;
          break;
        case "pointerover":
        case "pointerout":
          sA.delete(i.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          rA.delete(i.pointerId);
      }
    }
    function ho(n, i, c, g, b, R) {
      return n === null || n.nativeEvent !== R ? (n = {
        blockedOn: i,
        domEventName: c,
        eventSystemFlags: g,
        nativeEvent: R,
        targetContainers: [b]
      }, i !== null && (i = jt(i), i !== null && On(i)), n) : (n.eventSystemFlags |= g, i = n.targetContainers, b !== null && i.indexOf(b) === -1 && i.push(b), n);
    }
    function Eg(n, i, c, g, b) {
      switch (i) {
        case "focusin":
          return T0 = ho(
            T0,
            n,
            i,
            c,
            g,
            b
          ), !0;
        case "dragenter":
          return C0 = ho(
            C0,
            n,
            i,
            c,
            g,
            b
          ), !0;
        case "mouseover":
          return R0 = ho(
            R0,
            n,
            i,
            c,
            g,
            b
          ), !0;
        case "pointerover":
          var R = b.pointerId;
          return sA.set(
            R,
            ho(
              sA.get(R) || null,
              n,
              i,
              c,
              g,
              b
            )
          ), !0;
        case "gotpointercapture":
          return R = b.pointerId, rA.set(
            R,
            ho(
              rA.get(R) || null,
              n,
              i,
              c,
              g,
              b
            )
          ), !0;
      }
      return !1;
    }
    function Qo(n) {
      var i = nn(n.target);
      if (i !== null) {
        var c = N(i);
        if (c !== null) {
          if (i = c.tag, i === 13) {
            if (i = F(c), i !== null) {
              n.blockedOn = i, pn(n.priority, function() {
                if (c.tag === 13) {
                  var g = ir(c);
                  g = Jt(g);
                  var b = mr(
                    c,
                    g
                  );
                  b !== null && Cl(b, c, g), qt(c, g);
                }
              });
              return;
            }
          } else if (i === 3 && c.stateNode.current.memoizedState.isDehydrated) {
            n.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      n.blockedOn = null;
    }
    function Os(n) {
      if (n.blockedOn !== null) return !1;
      for (var i = n.targetContainers; 0 < i.length; ) {
        var c = cs(n.nativeEvent);
        if (c === null) {
          c = n.nativeEvent;
          var g = new c.constructor(
            c.type,
            c
          ), b = g;
          U !== null && console.error(
            "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
          ), U = b, c.target.dispatchEvent(g), U === null && console.error(
            "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
          ), U = null;
        } else
          return i = jt(c), i !== null && On(i), n.blockedOn = c, !1;
        i.shift();
      }
      return !0;
    }
    function ei(n, i, c) {
      Os(n) && c.delete(i);
    }
    function Dh() {
      CT = !1, T0 !== null && Os(T0) && (T0 = null), C0 !== null && Os(C0) && (C0 = null), R0 !== null && Os(R0) && (R0 = null), sA.forEach(ei), rA.forEach(ei);
    }
    function jo(n, i) {
      n.blockedOn === i && (n.blockedOn = null, CT || (CT = !0, ll.unstable_scheduleCallback(
        ll.unstable_NormalPriority,
        Dh
      )));
    }
    function Ff(n) {
      KE !== n && (KE = n, ll.unstable_scheduleCallback(
        ll.unstable_NormalPriority,
        function() {
          KE === n && (KE = null);
          for (var i = 0; i < n.length; i += 3) {
            var c = n[i], g = n[i + 1], b = n[i + 2];
            if (typeof g != "function") {
              if (Tu(g || c) === null)
                continue;
              break;
            }
            var R = jt(c);
            R !== null && (n.splice(i, 3), i -= 3, c = {
              pending: !0,
              data: b,
              method: c.method,
              action: g
            }, Object.freeze(c), $r(
              R,
              c,
              g,
              b
            ));
          }
        }
      ));
    }
    function Jo(n) {
      function i(de) {
        return jo(de, n);
      }
      T0 !== null && jo(T0, n), C0 !== null && jo(C0, n), R0 !== null && jo(R0, n), sA.forEach(i), rA.forEach(i);
      for (var c = 0; c < D0.length; c++) {
        var g = D0[c];
        g.blockedOn === n && (g.blockedOn = null);
      }
      for (; 0 < D0.length && (c = D0[0], c.blockedOn === null); )
        Qo(c), c.blockedOn === null && D0.shift();
      if (c = (n.ownerDocument || n).$$reactFormReplay, c != null)
        for (g = 0; g < c.length; g += 3) {
          var b = c[g], R = c[g + 1], X = b[Hr] || null;
          if (typeof R == "function")
            X || Ff(c);
          else if (X) {
            var K = null;
            if (R && R.hasAttribute("formAction")) {
              if (b = R, X = R[Hr] || null)
                K = X.formAction;
              else if (Tu(b) !== null) continue;
            } else K = X.action;
            typeof K == "function" ? c[g + 1] = K : (c.splice(g, 3), g -= 3), Ff(c);
          }
        }
    }
    function bg(n) {
      this._internalRoot = n;
    }
    function Pi(n) {
      this._internalRoot = n;
    }
    function Jc(n) {
      n[oa] && (n._reactRootContainer ? console.error(
        "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
      ) : console.error(
        "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
      ));
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var ll = Iw(), _v = Qm, Mg = EU, Da = Object.assign, Nr = Symbol.for("react.element"), fc = Symbol.for("react.transitional.element"), Bh = Symbol.for("react.portal"), Sa = Symbol.for("react.fragment"), mp = Symbol.for("react.strict_mode"), Ud = Symbol.for("react.profiler"), ay = Symbol.for("react.provider"), xg = Symbol.for("react.consumer"), Ru = Symbol.for("react.context"), Od = Symbol.for("react.forward_ref"), wd = Symbol.for("react.suspense"), Uh = Symbol.for("react.suspense_list"), vp = Symbol.for("react.memo"), Du = Symbol.for("react.lazy"), gp = Symbol.for("react.activity"), Av = Symbol.for("react.memo_cache_sentinel"), a0 = Symbol.iterator, iy = Symbol.for("react.client.reference"), _a = Array.isArray, mt = _v.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Kn = Mg.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, o_ = Object.freeze({
      pending: !1,
      data: null,
      method: null,
      action: null
    }), Ev = [], bv = [], Pf = -1, cr = j(null), Oh = j(null), dc = j(null), wh = j(null), Kc = Object.prototype.hasOwnProperty, bm = ll.unstable_scheduleCallback, ly = ll.unstable_cancelCallback, Mm = ll.unstable_shouldYield, i0 = ll.unstable_requestPaint, Nd = ll.unstable_now, zd = ll.unstable_getCurrentPriorityLevel, Tg = ll.unstable_ImmediatePriority, xm = ll.unstable_UserBlockingPriority, Hd = ll.unstable_NormalPriority, l0 = ll.unstable_LowPriority, Cg = ll.unstable_IdlePriority, W0 = ll.log, Xf = ll.unstable_setDisableYieldValue, yp = null, zr = null, vn = null, Bu = !1, kl = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u", po = Math.clz32 ? Math.clz32 : Te, s0 = Math.log, Nh = Math.LN2, sy = 256, ry = 4194304, mo = 2, Yf = 8, Sp = 32, oy = 268435456, Uu = Math.random().toString(36).slice(2), ws = "__reactFiber$" + Uu, Hr = "__reactProps$" + Uu, oa = "__reactContainer$" + Uu, uy = "__reactEvents$" + Uu, $0 = "__reactListeners$" + Uu, Mv = "__reactHandles$" + Uu, xv = "__reactResources$" + Uu, Tv = "__reactMarker$" + Uu, Tm = /* @__PURE__ */ new Set(), kc = {}, qf = {}, cy = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    }, Ou = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), Wc = {}, _p = {}, Zf = 0, Ns, hc, $c, vo, fs, js, Cv;
    Xa.__reactDisabledLog = !0;
    var r0, Rg, Cm = !1, Dg = new (typeof WeakMap == "function" ? WeakMap : Map)(), Js = null, Gn = !1, el = /[\n"\\]/g, ds = !1, Bg = !1, Rm = !1, Ap = !1, Rv = !1, Dv = !1, ef = ["value", "defaultValue"], u_ = !1, c_ = /["'&<>\n\t]|^\s|\s$/, vt = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
      " "
    ), wu = "applet caption html table td th marquee object template foreignObject desc title".split(
      " "
    ), Qf = wu.concat(["button"]), Bv = "dd dt li option optgroup p rp rt".split(" "), fy = {
      current: null,
      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,
      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null,
      containerTagInScope: null,
      implicitRootScope: !1
    }, Nu = {}, go = {
      animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
        " "
      ),
      background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
        " "
      ),
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
        " "
      ),
      borderBlockEnd: [
        "borderBlockEndColor",
        "borderBlockEndStyle",
        "borderBlockEndWidth"
      ],
      borderBlockStart: [
        "borderBlockStartColor",
        "borderBlockStartStyle",
        "borderBlockStartWidth"
      ],
      borderBottom: [
        "borderBottomColor",
        "borderBottomStyle",
        "borderBottomWidth"
      ],
      borderColor: [
        "borderBottomColor",
        "borderLeftColor",
        "borderRightColor",
        "borderTopColor"
      ],
      borderImage: [
        "borderImageOutset",
        "borderImageRepeat",
        "borderImageSlice",
        "borderImageSource",
        "borderImageWidth"
      ],
      borderInlineEnd: [
        "borderInlineEndColor",
        "borderInlineEndStyle",
        "borderInlineEndWidth"
      ],
      borderInlineStart: [
        "borderInlineStartColor",
        "borderInlineStartStyle",
        "borderInlineStartWidth"
      ],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: [
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
        "borderTopLeftRadius",
        "borderTopRightRadius"
      ],
      borderRight: [
        "borderRightColor",
        "borderRightStyle",
        "borderRightWidth"
      ],
      borderStyle: [
        "borderBottomStyle",
        "borderLeftStyle",
        "borderRightStyle",
        "borderTopStyle"
      ],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: [
        "borderBottomWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderTopWidth"
      ],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
        " "
      ),
      fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
        " "
      ),
      gap: ["columnGap", "rowGap"],
      grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
        " "
      ),
      gridArea: [
        "gridColumnEnd",
        "gridColumnStart",
        "gridRowEnd",
        "gridRowStart"
      ],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: [
        "gridTemplateAreas",
        "gridTemplateColumns",
        "gridTemplateRows"
      ],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
        " "
      ),
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: [
        "textDecorationColor",
        "textDecorationLine",
        "textDecorationStyle"
      ],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: [
        "transitionDelay",
        "transitionDuration",
        "transitionProperty",
        "transitionTimingFunction"
      ],
      wordWrap: ["overflowWrap"]
    }, zu = /([A-Z])/g, Ko = /^ms-/, Ld = /^(?:webkit|moz|o)[A-Z]/, Lr = /^-ms-/, hs = /-(.)/g, Ep = /;\s*$/, Dm = {}, Bm = {}, eS = !1, o0 = !1, Ug = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    ), Og = "http://www.w3.org/1998/Math/MathML", Uv = "http://www.w3.org/2000/svg", dy = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), Um = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      fetchpriority: "fetchPriority",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      inert: "inert",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      popover: "popover",
      popovertarget: "popoverTarget",
      popovertargetaction: "popoverTargetAction",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      transformorigin: "transformOrigin",
      "transform-origin": "transformOrigin",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, u0 = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Gd = {}, hy = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), py = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), Om = !1, yo = {}, wg = /^on./, s = /^on[^A-Z]/, f = RegExp(
      "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), v = RegExp(
      "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), A = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, U = null, H = null, W = null, oe = !1, be = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), et = !1;
    if (be)
      try {
        var Rt = {};
        Object.defineProperty(Rt, "passive", {
          get: function() {
            et = !0;
          }
        }), window.addEventListener("test", Rt, Rt), window.removeEventListener("test", Rt, Rt);
      } catch {
        et = !1;
      }
    var zt = null, at = null, lt = null, Yn = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(n) {
        return n.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, In = Ll(Yn), ti = Da({}, Yn, { view: 0, detail: 0 }), Qe = Ll(ti), Ve, ke, gt, Cn = Da({}, ti, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: sd,
      button: 0,
      buttons: 0,
      relatedTarget: function(n) {
        return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
      },
      movementX: function(n) {
        return "movementX" in n ? n.movementX : (n !== gt && (gt && n.type === "mousemove" ? (Ve = n.screenX - gt.screenX, ke = n.screenY - gt.screenY) : ke = Ve = 0, gt = n), Ve);
      },
      movementY: function(n) {
        return "movementY" in n ? n.movementY : ke;
      }
    }), Aa = Ll(Cn), Pn = Da({}, Cn, { dataTransfer: 0 }), Xn = Ll(Pn), Za = Da({}, ti, { relatedTarget: 0 }), ci = Ll(Za), bp = Da({}, Yn, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Gr = Ll(bp), c0 = Da({}, Yn, {
      clipboardData: function(n) {
        return "clipboardData" in n ? n.clipboardData : window.clipboardData;
      }
    }), f0 = Ll(c0), _E = Da({}, Yn, { data: 0 }), fr = Ll(
      _E
    ), Id = fr, Mp = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, d0 = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Fx = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    }, f_ = Da({}, ti, {
      key: function(n) {
        if (n.key) {
          var i = Mp[n.key] || n.key;
          if (i !== "Unidentified") return i;
        }
        return n.type === "keypress" ? (n = ld(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? d0[n.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: sd,
      charCode: function(n) {
        return n.type === "keypress" ? ld(n) : 0;
      },
      keyCode: function(n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
      },
      which: function(n) {
        return n.type === "keypress" ? ld(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
      }
    }), d_ = Ll(f_), h_ = Da({}, Cn, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), tS = Ll(h_), p_ = Da({}, ti, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: sd
    }), nS = Ll(p_), m_ = Da({}, Yn, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Px = Ll(m_), tf = Da({}, Cn, {
      deltaX: function(n) {
        return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
      },
      deltaY: function(n) {
        return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), pc = Ll(tf), wm = Da({}, Yn, {
      newState: 0,
      oldState: 0
    }), Ov = Ll(wm), aS = [9, 13, 27, 32], my = 229, iS = be && "CompositionEvent" in window, xp = null;
    be && "documentMode" in document && (xp = document.documentMode);
    var AE = be && "TextEvent" in window && !xp, lS = be && (!iS || xp && 8 < xp && 11 >= xp), ki = 32, El = String.fromCharCode(ki), ka = !1, wa = !1, jf = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    }, wv = null, Tp = null, h0 = !1;
    be && (h0 = ra("input") && (!document.documentMode || 9 < document.documentMode));
    var mc = typeof Object.is == "function" ? Object.is : ag, N1 = be && "documentMode" in document && 11 >= document.documentMode, Cp = null, vy = null, gy = null, sl = !1, ko = {
      animationend: ou("Animation", "AnimationEnd"),
      animationiteration: ou("Animation", "AnimationIteration"),
      animationstart: ou("Animation", "AnimationStart"),
      transitionrun: ou("Transition", "TransitionRun"),
      transitionstart: ou("Transition", "TransitionStart"),
      transitioncancel: ou("Transition", "TransitionCancel"),
      transitionend: ou("Transition", "TransitionEnd")
    }, Rp = {}, yy = {};
    be && (yy = document.createElement("div").style, "AnimationEvent" in window || (delete ko.animationend.animation, delete ko.animationiteration.animation, delete ko.animationstart.animation), "TransitionEvent" in window || delete ko.transitionend.transition);
    var v_ = uu("animationend"), Dp = uu("animationiteration"), zs = uu("animationstart"), Ng = uu("transitionrun"), zg = uu("transitionstart"), z1 = uu("transitioncancel"), Jf = uu("transitionend"), Hg = /* @__PURE__ */ new Map(), Sy = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    Sy.push("scrollEnd");
    var Vd = /* @__PURE__ */ new WeakMap(), p0 = 1, Nv = 2, Fd = [], Nm = 0, sS = 0, zh = {};
    Object.freeze(zh);
    var So = null, zv = null, Xi = 0, rS = 1, _o = 2, Wo = 8, Bp = 16, m0 = 64, g_ = !1;
    try {
      var y_ = Object.preventExtensions({});
    } catch {
      g_ = !0;
    }
    var Hv = [], v0 = 0, zm = null, Lg = 0, Hu = [], Pd = 0, _y = null, Lv = 1, Hh = "", vc = null, Hs = null, Di = !1, Ir = !1, Lu = null, Gg = null, Up = !1, S_ = Error(
      "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), H1 = 0;
    if (typeof performance == "object" && typeof performance.now == "function")
      var EE = performance, L1 = function() {
        return EE.now();
      };
    else {
      var bE = Date;
      L1 = function() {
        return bE.now();
      };
    }
    var __ = j(null), A_ = j(null), G1 = {}, oS = null, Ay = null, Ey = !1, l = typeof AbortController < "u" ? AbortController : function() {
      var n = [], i = this.signal = {
        aborted: !1,
        addEventListener: function(c, g) {
          n.push(g);
        }
      };
      this.abort = function() {
        i.aborted = !0, n.forEach(function(c) {
          return c();
        });
      };
    }, u = ll.unstable_scheduleCallback, S = ll.unstable_NormalPriority, x = {
      $$typeof: Ru,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
      _currentRenderer: null,
      _currentRenderer2: null
    }, O = ll.unstable_now, L = -0, J = -0, he = -1.1, Pe = -0, ht = !1, Kt = !1, ln = null, Sn = 0, Na = 0, vi = null, by = mt.S;
    mt.S = function(n, i) {
      typeof i == "object" && i !== null && typeof i.then == "function" && Sr(n, i), by !== null && by(n, i);
    };
    var Lh = j(null), dr = {
      recordUnsafeLifecycleWarnings: function() {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function() {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    }, Le = [], ze = [], Ye = [], Nt = [], _n = [], ni = [], aa = /* @__PURE__ */ new Set();
    dr.recordUnsafeLifecycleWarnings = function(n, i) {
      aa.has(n.type) || (typeof i.componentWillMount == "function" && i.componentWillMount.__suppressDeprecationWarning !== !0 && Le.push(n), n.mode & Wo && typeof i.UNSAFE_componentWillMount == "function" && ze.push(n), typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Ye.push(n), n.mode & Wo && typeof i.UNSAFE_componentWillReceiveProps == "function" && Nt.push(n), typeof i.componentWillUpdate == "function" && i.componentWillUpdate.__suppressDeprecationWarning !== !0 && _n.push(n), n.mode & Wo && typeof i.UNSAFE_componentWillUpdate == "function" && ni.push(n));
    }, dr.flushPendingUnsafeLifecycleWarnings = function() {
      var n = /* @__PURE__ */ new Set();
      0 < Le.length && (Le.forEach(function(K) {
        n.add(
          Q(K) || "Component"
        ), aa.add(K.type);
      }), Le = []);
      var i = /* @__PURE__ */ new Set();
      0 < ze.length && (ze.forEach(function(K) {
        i.add(
          Q(K) || "Component"
        ), aa.add(K.type);
      }), ze = []);
      var c = /* @__PURE__ */ new Set();
      0 < Ye.length && (Ye.forEach(function(K) {
        c.add(
          Q(K) || "Component"
        ), aa.add(K.type);
      }), Ye = []);
      var g = /* @__PURE__ */ new Set();
      0 < Nt.length && (Nt.forEach(
        function(K) {
          g.add(
            Q(K) || "Component"
          ), aa.add(K.type);
        }
      ), Nt = []);
      var b = /* @__PURE__ */ new Set();
      0 < _n.length && (_n.forEach(function(K) {
        b.add(
          Q(K) || "Component"
        ), aa.add(K.type);
      }), _n = []);
      var R = /* @__PURE__ */ new Set();
      if (0 < ni.length && (ni.forEach(function(K) {
        R.add(
          Q(K) || "Component"
        ), aa.add(K.type);
      }), ni = []), 0 < i.size) {
        var X = C(
          i
        );
        console.error(
          `Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,
          X
        );
      }
      0 < g.size && (X = C(
        g
      ), console.error(
        `Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`,
        X
      )), 0 < R.size && (X = C(
        R
      ), console.error(
        `Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,
        X
      )), 0 < n.size && (X = C(n), console.warn(
        `componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        X
      )), 0 < c.size && (X = C(
        c
      ), console.warn(
        `componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        X
      )), 0 < b.size && (X = C(b), console.warn(
        `componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,
        X
      ));
    };
    var Ma = /* @__PURE__ */ new Map(), za = /* @__PURE__ */ new Set();
    dr.recordLegacyContextWarning = function(n, i) {
      for (var c = null, g = n; g !== null; )
        g.mode & Wo && (c = g), g = g.return;
      c === null ? console.error(
        "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
      ) : !za.has(n.type) && (g = Ma.get(c), n.type.contextTypes != null || n.type.childContextTypes != null || i !== null && typeof i.getChildContext == "function") && (g === void 0 && (g = [], Ma.set(c, g)), g.push(n));
    }, dr.flushLegacyContextWarning = function() {
      Ma.forEach(function(n) {
        if (n.length !== 0) {
          var i = n[0], c = /* @__PURE__ */ new Set();
          n.forEach(function(b) {
            c.add(Q(b) || "Component"), za.add(b.type);
          });
          var g = C(c);
          un(i, function() {
            console.error(
              `Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`,
              g
            );
          });
        }
      });
    }, dr.discardPendingWarnings = function() {
      Le = [], ze = [], Ye = [], Nt = [], _n = [], ni = [], Ma = /* @__PURE__ */ new Map();
    };
    var rl = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
    ), Ks = Error(
      "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
    ), Gh = Error(
      "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
    ), I1 = {
      then: function() {
        console.error(
          'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
        );
      }
    }, V1 = null, ME = !1, Hm = 0, Lm = 1, Xd = 2, nf = 4, Gu = 8, SR = 0, _R = 1, AR = 2, Xx = 3, g0 = !1, ER = !1, Yx = null, qx = !1, E_ = j(null), xE = j(0), b_, bR = /* @__PURE__ */ new Set(), MR = /* @__PURE__ */ new Set(), Zx = /* @__PURE__ */ new Set(), xR = /* @__PURE__ */ new Set(), y0 = 0, Ba = null, Pl = null, $o = null, TE = !1, M_ = !1, uS = !1, CE = 0, F1 = 0, My = null, sN = 0, rN = 25, bt = null, Gm = null, xy = -1, P1 = !1, RE = {
      readContext: Zi,
      use: wo,
      useCallback: nl,
      useContext: nl,
      useEffect: nl,
      useImperativeHandle: nl,
      useLayoutEffect: nl,
      useInsertionEffect: nl,
      useMemo: nl,
      useReducer: nl,
      useRef: nl,
      useState: nl,
      useDebugValue: nl,
      useDeferredValue: nl,
      useTransition: nl,
      useSyncExternalStore: nl,
      useId: nl,
      useHostTransitionStatus: nl,
      useFormState: nl,
      useActionState: nl,
      useOptimistic: nl,
      useMemoCache: nl,
      useCacheRefresh: nl
    }, Qx = null, TR = null, jx = null, CR = null, Ig = null, Gv = null, DE = null;
    Qx = {
      readContext: function(n) {
        return Zi(n);
      },
      use: wo,
      useCallback: function(n, i) {
        return bt = "useCallback", Ca(), Qr(i), wc(n, i);
      },
      useContext: function(n) {
        return bt = "useContext", Ca(), Zi(n);
      },
      useEffect: function(n, i) {
        return bt = "useEffect", Ca(), Qr(i), Mr(n, i);
      },
      useImperativeHandle: function(n, i, c) {
        return bt = "useImperativeHandle", Ca(), Qr(c), mh(n, i, c);
      },
      useInsertionEffect: function(n, i) {
        bt = "useInsertionEffect", Ca(), Qr(i), na(4, Xd, n, i);
      },
      useLayoutEffect: function(n, i) {
        return bt = "useLayoutEffect", Ca(), Qr(i), Wu(n, i);
      },
      useMemo: function(n, i) {
        bt = "useMemo", Ca(), Qr(i);
        var c = mt.H;
        mt.H = Ig;
        try {
          return np(n, i);
        } finally {
          mt.H = c;
        }
      },
      useReducer: function(n, i, c) {
        bt = "useReducer", Ca();
        var g = mt.H;
        mt.H = Ig;
        try {
          return Ln(n, i, c);
        } finally {
          mt.H = g;
        }
      },
      useRef: function(n) {
        return bt = "useRef", Ca(), tp(n);
      },
      useState: function(n) {
        bt = "useState", Ca();
        var i = mt.H;
        mt.H = Ig;
        try {
          return Bc(n);
        } finally {
          mt.H = i;
        }
      },
      useDebugValue: function() {
        bt = "useDebugValue", Ca();
      },
      useDeferredValue: function(n, i) {
        return bt = "useDeferredValue", Ca(), ap(n, i);
      },
      useTransition: function() {
        return bt = "useTransition", Ca(), $u();
      },
      useSyncExternalStore: function(n, i, c) {
        return bt = "useSyncExternalStore", Ca(), br(
          n,
          i,
          c
        );
      },
      useId: function() {
        return bt = "useId", Ca(), ml();
      },
      useFormState: function(n, i) {
        return bt = "useFormState", Ca(), Ef(), gd(n, i);
      },
      useActionState: function(n, i) {
        return bt = "useActionState", Ca(), gd(n, i);
      },
      useOptimistic: function(n) {
        return bt = "useOptimistic", Ca(), Ku(n);
      },
      useHostTransitionStatus: xr,
      useMemoCache: hl,
      useCacheRefresh: function() {
        return bt = "useCacheRefresh", Ca(), Tf();
      }
    }, TR = {
      readContext: function(n) {
        return Zi(n);
      },
      use: wo,
      useCallback: function(n, i) {
        return bt = "useCallback", Lt(), wc(n, i);
      },
      useContext: function(n) {
        return bt = "useContext", Lt(), Zi(n);
      },
      useEffect: function(n, i) {
        return bt = "useEffect", Lt(), Mr(n, i);
      },
      useImperativeHandle: function(n, i, c) {
        return bt = "useImperativeHandle", Lt(), mh(n, i, c);
      },
      useInsertionEffect: function(n, i) {
        bt = "useInsertionEffect", Lt(), na(4, Xd, n, i);
      },
      useLayoutEffect: function(n, i) {
        return bt = "useLayoutEffect", Lt(), Wu(n, i);
      },
      useMemo: function(n, i) {
        bt = "useMemo", Lt();
        var c = mt.H;
        mt.H = Ig;
        try {
          return np(n, i);
        } finally {
          mt.H = c;
        }
      },
      useReducer: function(n, i, c) {
        bt = "useReducer", Lt();
        var g = mt.H;
        mt.H = Ig;
        try {
          return Ln(n, i, c);
        } finally {
          mt.H = g;
        }
      },
      useRef: function(n) {
        return bt = "useRef", Lt(), tp(n);
      },
      useState: function(n) {
        bt = "useState", Lt();
        var i = mt.H;
        mt.H = Ig;
        try {
          return Bc(n);
        } finally {
          mt.H = i;
        }
      },
      useDebugValue: function() {
        bt = "useDebugValue", Lt();
      },
      useDeferredValue: function(n, i) {
        return bt = "useDeferredValue", Lt(), ap(n, i);
      },
      useTransition: function() {
        return bt = "useTransition", Lt(), $u();
      },
      useSyncExternalStore: function(n, i, c) {
        return bt = "useSyncExternalStore", Lt(), br(
          n,
          i,
          c
        );
      },
      useId: function() {
        return bt = "useId", Lt(), ml();
      },
      useActionState: function(n, i) {
        return bt = "useActionState", Lt(), gd(n, i);
      },
      useFormState: function(n, i) {
        return bt = "useFormState", Lt(), Ef(), gd(n, i);
      },
      useOptimistic: function(n) {
        return bt = "useOptimistic", Lt(), Ku(n);
      },
      useHostTransitionStatus: xr,
      useMemoCache: hl,
      useCacheRefresh: function() {
        return bt = "useCacheRefresh", Lt(), Tf();
      }
    }, jx = {
      readContext: function(n) {
        return Zi(n);
      },
      use: wo,
      useCallback: function(n, i) {
        return bt = "useCallback", Lt(), yd(n, i);
      },
      useContext: function(n) {
        return bt = "useContext", Lt(), Zi(n);
      },
      useEffect: function(n, i) {
        bt = "useEffect", Lt(), is(2048, Gu, n, i);
      },
      useImperativeHandle: function(n, i, c) {
        return bt = "useImperativeHandle", Lt(), kr(n, i, c);
      },
      useInsertionEffect: function(n, i) {
        return bt = "useInsertionEffect", Lt(), is(4, Xd, n, i);
      },
      useLayoutEffect: function(n, i) {
        return bt = "useLayoutEffect", Lt(), is(4, nf, n, i);
      },
      useMemo: function(n, i) {
        bt = "useMemo", Lt();
        var c = mt.H;
        mt.H = Gv;
        try {
          return xf(n, i);
        } finally {
          mt.H = c;
        }
      },
      useReducer: function(n, i, c) {
        bt = "useReducer", Lt();
        var g = mt.H;
        mt.H = Gv;
        try {
          return as(n, i, c);
        } finally {
          mt.H = g;
        }
      },
      useRef: function() {
        return bt = "useRef", Lt(), fa().memoizedState;
      },
      useState: function() {
        bt = "useState", Lt();
        var n = mt.H;
        mt.H = Gv;
        try {
          return as(Ua);
        } finally {
          mt.H = n;
        }
      },
      useDebugValue: function() {
        bt = "useDebugValue", Lt();
      },
      useDeferredValue: function(n, i) {
        return bt = "useDeferredValue", Lt(), Wr(n, i);
      },
      useTransition: function() {
        return bt = "useTransition", Lt(), ig();
      },
      useSyncExternalStore: function(n, i, c) {
        return bt = "useSyncExternalStore", Lt(), md(
          n,
          i,
          c
        );
      },
      useId: function() {
        return bt = "useId", Lt(), fa().memoizedState;
      },
      useFormState: function(n) {
        return bt = "useFormState", Lt(), Ef(), $p(n);
      },
      useActionState: function(n) {
        return bt = "useActionState", Lt(), $p(n);
      },
      useOptimistic: function(n, i) {
        return bt = "useOptimistic", Lt(), Uc(n, i);
      },
      useHostTransitionStatus: xr,
      useMemoCache: hl,
      useCacheRefresh: function() {
        return bt = "useCacheRefresh", Lt(), fa().memoizedState;
      }
    }, CR = {
      readContext: function(n) {
        return Zi(n);
      },
      use: wo,
      useCallback: function(n, i) {
        return bt = "useCallback", Lt(), yd(n, i);
      },
      useContext: function(n) {
        return bt = "useContext", Lt(), Zi(n);
      },
      useEffect: function(n, i) {
        bt = "useEffect", Lt(), is(2048, Gu, n, i);
      },
      useImperativeHandle: function(n, i, c) {
        return bt = "useImperativeHandle", Lt(), kr(n, i, c);
      },
      useInsertionEffect: function(n, i) {
        return bt = "useInsertionEffect", Lt(), is(4, Xd, n, i);
      },
      useLayoutEffect: function(n, i) {
        return bt = "useLayoutEffect", Lt(), is(4, nf, n, i);
      },
      useMemo: function(n, i) {
        bt = "useMemo", Lt();
        var c = mt.H;
        mt.H = DE;
        try {
          return xf(n, i);
        } finally {
          mt.H = c;
        }
      },
      useReducer: function(n, i, c) {
        bt = "useReducer", Lt();
        var g = mt.H;
        mt.H = DE;
        try {
          return bf(n, i, c);
        } finally {
          mt.H = g;
        }
      },
      useRef: function() {
        return bt = "useRef", Lt(), fa().memoizedState;
      },
      useState: function() {
        bt = "useState", Lt();
        var n = mt.H;
        mt.H = DE;
        try {
          return bf(Ua);
        } finally {
          mt.H = n;
        }
      },
      useDebugValue: function() {
        bt = "useDebugValue", Lt();
      },
      useDeferredValue: function(n, i) {
        return bt = "useDeferredValue", Lt(), em(n, i);
      },
      useTransition: function() {
        return bt = "useTransition", Lt(), $n();
      },
      useSyncExternalStore: function(n, i, c) {
        return bt = "useSyncExternalStore", Lt(), md(
          n,
          i,
          c
        );
      },
      useId: function() {
        return bt = "useId", Lt(), fa().memoizedState;
      },
      useFormState: function(n) {
        return bt = "useFormState", Lt(), Ef(), ph(n);
      },
      useActionState: function(n) {
        return bt = "useActionState", Lt(), ph(n);
      },
      useOptimistic: function(n, i) {
        return bt = "useOptimistic", Lt(), av(n, i);
      },
      useHostTransitionStatus: xr,
      useMemoCache: hl,
      useCacheRefresh: function() {
        return bt = "useCacheRefresh", Lt(), fa().memoizedState;
      }
    }, Ig = {
      readContext: function(n) {
        return E(), Zi(n);
      },
      use: function(n) {
        return _(), wo(n);
      },
      useCallback: function(n, i) {
        return bt = "useCallback", _(), Ca(), wc(n, i);
      },
      useContext: function(n) {
        return bt = "useContext", _(), Ca(), Zi(n);
      },
      useEffect: function(n, i) {
        return bt = "useEffect", _(), Ca(), Mr(n, i);
      },
      useImperativeHandle: function(n, i, c) {
        return bt = "useImperativeHandle", _(), Ca(), mh(n, i, c);
      },
      useInsertionEffect: function(n, i) {
        bt = "useInsertionEffect", _(), Ca(), na(4, Xd, n, i);
      },
      useLayoutEffect: function(n, i) {
        return bt = "useLayoutEffect", _(), Ca(), Wu(n, i);
      },
      useMemo: function(n, i) {
        bt = "useMemo", _(), Ca();
        var c = mt.H;
        mt.H = Ig;
        try {
          return np(n, i);
        } finally {
          mt.H = c;
        }
      },
      useReducer: function(n, i, c) {
        bt = "useReducer", _(), Ca();
        var g = mt.H;
        mt.H = Ig;
        try {
          return Ln(n, i, c);
        } finally {
          mt.H = g;
        }
      },
      useRef: function(n) {
        return bt = "useRef", _(), Ca(), tp(n);
      },
      useState: function(n) {
        bt = "useState", _(), Ca();
        var i = mt.H;
        mt.H = Ig;
        try {
          return Bc(n);
        } finally {
          mt.H = i;
        }
      },
      useDebugValue: function() {
        bt = "useDebugValue", _(), Ca();
      },
      useDeferredValue: function(n, i) {
        return bt = "useDeferredValue", _(), Ca(), ap(n, i);
      },
      useTransition: function() {
        return bt = "useTransition", _(), Ca(), $u();
      },
      useSyncExternalStore: function(n, i, c) {
        return bt = "useSyncExternalStore", _(), Ca(), br(
          n,
          i,
          c
        );
      },
      useId: function() {
        return bt = "useId", _(), Ca(), ml();
      },
      useFormState: function(n, i) {
        return bt = "useFormState", _(), Ca(), gd(n, i);
      },
      useActionState: function(n, i) {
        return bt = "useActionState", _(), Ca(), gd(n, i);
      },
      useOptimistic: function(n) {
        return bt = "useOptimistic", _(), Ca(), Ku(n);
      },
      useMemoCache: function(n) {
        return _(), hl(n);
      },
      useHostTransitionStatus: xr,
      useCacheRefresh: function() {
        return bt = "useCacheRefresh", Ca(), Tf();
      }
    }, Gv = {
      readContext: function(n) {
        return E(), Zi(n);
      },
      use: function(n) {
        return _(), wo(n);
      },
      useCallback: function(n, i) {
        return bt = "useCallback", _(), Lt(), yd(n, i);
      },
      useContext: function(n) {
        return bt = "useContext", _(), Lt(), Zi(n);
      },
      useEffect: function(n, i) {
        bt = "useEffect", _(), Lt(), is(2048, Gu, n, i);
      },
      useImperativeHandle: function(n, i, c) {
        return bt = "useImperativeHandle", _(), Lt(), kr(n, i, c);
      },
      useInsertionEffect: function(n, i) {
        return bt = "useInsertionEffect", _(), Lt(), is(4, Xd, n, i);
      },
      useLayoutEffect: function(n, i) {
        return bt = "useLayoutEffect", _(), Lt(), is(4, nf, n, i);
      },
      useMemo: function(n, i) {
        bt = "useMemo", _(), Lt();
        var c = mt.H;
        mt.H = Gv;
        try {
          return xf(n, i);
        } finally {
          mt.H = c;
        }
      },
      useReducer: function(n, i, c) {
        bt = "useReducer", _(), Lt();
        var g = mt.H;
        mt.H = Gv;
        try {
          return as(n, i, c);
        } finally {
          mt.H = g;
        }
      },
      useRef: function() {
        return bt = "useRef", _(), Lt(), fa().memoizedState;
      },
      useState: function() {
        bt = "useState", _(), Lt();
        var n = mt.H;
        mt.H = Gv;
        try {
          return as(Ua);
        } finally {
          mt.H = n;
        }
      },
      useDebugValue: function() {
        bt = "useDebugValue", _(), Lt();
      },
      useDeferredValue: function(n, i) {
        return bt = "useDeferredValue", _(), Lt(), Wr(n, i);
      },
      useTransition: function() {
        return bt = "useTransition", _(), Lt(), ig();
      },
      useSyncExternalStore: function(n, i, c) {
        return bt = "useSyncExternalStore", _(), Lt(), md(
          n,
          i,
          c
        );
      },
      useId: function() {
        return bt = "useId", _(), Lt(), fa().memoizedState;
      },
      useFormState: function(n) {
        return bt = "useFormState", _(), Lt(), $p(n);
      },
      useActionState: function(n) {
        return bt = "useActionState", _(), Lt(), $p(n);
      },
      useOptimistic: function(n, i) {
        return bt = "useOptimistic", _(), Lt(), Uc(n, i);
      },
      useMemoCache: function(n) {
        return _(), hl(n);
      },
      useHostTransitionStatus: xr,
      useCacheRefresh: function() {
        return bt = "useCacheRefresh", Lt(), fa().memoizedState;
      }
    }, DE = {
      readContext: function(n) {
        return E(), Zi(n);
      },
      use: function(n) {
        return _(), wo(n);
      },
      useCallback: function(n, i) {
        return bt = "useCallback", _(), Lt(), yd(n, i);
      },
      useContext: function(n) {
        return bt = "useContext", _(), Lt(), Zi(n);
      },
      useEffect: function(n, i) {
        bt = "useEffect", _(), Lt(), is(2048, Gu, n, i);
      },
      useImperativeHandle: function(n, i, c) {
        return bt = "useImperativeHandle", _(), Lt(), kr(n, i, c);
      },
      useInsertionEffect: function(n, i) {
        return bt = "useInsertionEffect", _(), Lt(), is(4, Xd, n, i);
      },
      useLayoutEffect: function(n, i) {
        return bt = "useLayoutEffect", _(), Lt(), is(4, nf, n, i);
      },
      useMemo: function(n, i) {
        bt = "useMemo", _(), Lt();
        var c = mt.H;
        mt.H = Gv;
        try {
          return xf(n, i);
        } finally {
          mt.H = c;
        }
      },
      useReducer: function(n, i, c) {
        bt = "useReducer", _(), Lt();
        var g = mt.H;
        mt.H = Gv;
        try {
          return bf(n, i, c);
        } finally {
          mt.H = g;
        }
      },
      useRef: function() {
        return bt = "useRef", _(), Lt(), fa().memoizedState;
      },
      useState: function() {
        bt = "useState", _(), Lt();
        var n = mt.H;
        mt.H = Gv;
        try {
          return bf(Ua);
        } finally {
          mt.H = n;
        }
      },
      useDebugValue: function() {
        bt = "useDebugValue", _(), Lt();
      },
      useDeferredValue: function(n, i) {
        return bt = "useDeferredValue", _(), Lt(), em(n, i);
      },
      useTransition: function() {
        return bt = "useTransition", _(), Lt(), $n();
      },
      useSyncExternalStore: function(n, i, c) {
        return bt = "useSyncExternalStore", _(), Lt(), md(
          n,
          i,
          c
        );
      },
      useId: function() {
        return bt = "useId", _(), Lt(), fa().memoizedState;
      },
      useFormState: function(n) {
        return bt = "useFormState", _(), Lt(), ph(n);
      },
      useActionState: function(n) {
        return bt = "useActionState", _(), Lt(), ph(n);
      },
      useOptimistic: function(n, i) {
        return bt = "useOptimistic", _(), Lt(), av(n, i);
      },
      useMemoCache: function(n) {
        return _(), hl(n);
      },
      useHostTransitionStatus: xr,
      useCacheRefresh: function() {
        return bt = "useCacheRefresh", Lt(), fa().memoizedState;
      }
    };
    var RR = {
      "react-stack-bottom-frame": function(n, i, c) {
        var g = Gn;
        Gn = !0;
        try {
          return n(i, c);
        } finally {
          Gn = g;
        }
      }
    }, Jx = RR["react-stack-bottom-frame"].bind(RR), DR = {
      "react-stack-bottom-frame": function(n) {
        var i = Gn;
        Gn = !0;
        try {
          return n.render();
        } finally {
          Gn = i;
        }
      }
    }, BR = DR["react-stack-bottom-frame"].bind(DR), UR = {
      "react-stack-bottom-frame": function(n, i) {
        try {
          i.componentDidMount();
        } catch (c) {
          Tn(n, n.return, c);
        }
      }
    }, Kx = UR["react-stack-bottom-frame"].bind(UR), OR = {
      "react-stack-bottom-frame": function(n, i, c, g, b) {
        try {
          i.componentDidUpdate(c, g, b);
        } catch (R) {
          Tn(n, n.return, R);
        }
      }
    }, wR = OR["react-stack-bottom-frame"].bind(OR), NR = {
      "react-stack-bottom-frame": function(n, i) {
        var c = i.stack;
        n.componentDidCatch(i.value, {
          componentStack: c !== null ? c : ""
        });
      }
    }, oN = NR["react-stack-bottom-frame"].bind(NR), zR = {
      "react-stack-bottom-frame": function(n, i, c) {
        try {
          c.componentWillUnmount();
        } catch (g) {
          Tn(n, i, g);
        }
      }
    }, HR = zR["react-stack-bottom-frame"].bind(zR), LR = {
      "react-stack-bottom-frame": function(n) {
        n.resourceKind != null && console.error(
          "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
          n.resourceKind
        );
        var i = n.create;
        return n = n.inst, i = i(), n.destroy = i;
      }
    }, uN = LR["react-stack-bottom-frame"].bind(LR), GR = {
      "react-stack-bottom-frame": function(n, i, c) {
        try {
          c();
        } catch (g) {
          Tn(n, i, g);
        }
      }
    }, cN = GR["react-stack-bottom-frame"].bind(GR), IR = {
      "react-stack-bottom-frame": function(n) {
        var i = n._init;
        return i(n._payload);
      }
    }, S0 = IR["react-stack-bottom-frame"].bind(IR), x_ = null, X1 = 0, ai = null, kx, VR = kx = !1, FR = {}, PR = {}, XR = {};
    y = function(n, i, c) {
      if (c !== null && typeof c == "object" && c._store && (!c._store.validated && c.key == null || c._store.validated === 2)) {
        if (typeof c._store != "object")
          throw Error(
            "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
          );
        c._store.validated = 1;
        var g = Q(n), b = g || "null";
        if (!FR[b]) {
          FR[b] = !0, c = c._owner, n = n._debugOwner;
          var R = "";
          n && typeof n.tag == "number" && (b = Q(n)) && (R = `

Check the render method of \`` + b + "`."), R || g && (R = `

Check the top-level render call using <` + g + ">.");
          var X = "";
          c != null && n !== c && (g = null, typeof c.tag == "number" ? g = Q(c) : typeof c.name == "string" && (g = c.name), g && (X = " It was passed a child from " + g + ".")), un(i, function() {
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              R,
              X
            );
          });
        }
      }
    };
    var T_ = Nc(!0), YR = Nc(!1), Im = j(null), Vg = null, C_ = 1, Y1 = 2, Iu = j(0), qR = {}, ZR = /* @__PURE__ */ new Set(), QR = /* @__PURE__ */ new Set(), jR = /* @__PURE__ */ new Set(), JR = /* @__PURE__ */ new Set(), KR = /* @__PURE__ */ new Set(), kR = /* @__PURE__ */ new Set(), WR = /* @__PURE__ */ new Set(), $R = /* @__PURE__ */ new Set(), eD = /* @__PURE__ */ new Set(), tD = /* @__PURE__ */ new Set();
    Object.freeze(qR);
    var Wx = {
      enqueueSetState: function(n, i, c) {
        n = n._reactInternals;
        var g = ir(n), b = ju(g);
        b.payload = i, c != null && (lv(c), b.callback = c), i = vu(n, b, g), i !== null && (Cl(i, n, g), gu(i, n, g)), Rn(n, g);
      },
      enqueueReplaceState: function(n, i, c) {
        n = n._reactInternals;
        var g = ir(n), b = ju(g);
        b.tag = _R, b.payload = i, c != null && (lv(c), b.callback = c), i = vu(n, b, g), i !== null && (Cl(i, n, g), gu(i, n, g)), Rn(n, g);
      },
      enqueueForceUpdate: function(n, i) {
        n = n._reactInternals;
        var c = ir(n), g = ju(c);
        g.tag = AR, i != null && (lv(i), g.callback = i), i = vu(n, g, c), i !== null && (Cl(i, n, c), gu(i, n, c)), vn !== null && typeof vn.markForceUpdateScheduled == "function" && vn.markForceUpdateScheduled(n, c);
      }
    }, $x = typeof reportError == "function" ? reportError : function(n) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var i = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof n == "object" && n !== null && typeof n.message == "string" ? String(n.message) : String(n),
          error: n
        });
        if (!window.dispatchEvent(i)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", n);
        return;
      }
      console.error(n);
    }, R_ = null, eT = null, nD = Error(
      "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
    ), gc = !1, aD = {}, iD = {}, lD = {}, sD = {}, D_ = !1, rD = {}, tT = {}, nT = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    }, oD = !1, uD = null;
    uD = /* @__PURE__ */ new Set();
    var Ty = !1, Ao = !1, aT = !1, cD = typeof WeakSet == "function" ? WeakSet : Set, yc = null, B_ = null, U_ = null, eu = null, Ih = !1, Iv = null, q1 = 8192, fN = {
      getCacheForType: function(n) {
        var i = Zi(x), c = i.data.get(n);
        return c === void 0 && (c = n(), i.data.set(n, c)), c;
      },
      getOwner: function() {
        return Js;
      }
    };
    if (typeof Symbol == "function" && Symbol.for) {
      var Z1 = Symbol.for;
      Z1("selector.component"), Z1("selector.has_pseudo_class"), Z1("selector.role"), Z1("selector.test_id"), Z1("selector.text");
    }
    var dN = [], hN = typeof WeakMap == "function" ? WeakMap : Map, Op = 0, Yd = 2, Vv = 4, Cy = 0, Q1 = 1, O_ = 2, iT = 3, cS = 4, BE = 6, fD = 5, ol = Op, Wl = null, pi = null, gi = 0, Vh = 0, j1 = 1, fS = 2, J1 = 3, dD = 4, lT = 5, w_ = 6, K1 = 7, sT = 8, dS = 9, bl = Vh, wp = null, _0 = !1, N_ = !1, rT = !1, Fg = 0, Vr = Cy, A0 = 0, E0 = 0, oT = 0, Np = 0, hS = 0, k1 = null, qd = null, UE = !1, uT = 0, hD = 300, OE = 1 / 0, pD = 500, W1 = null, b0 = null, pN = 0, mN = 1, vN = 2, pS = 0, mD = 1, vD = 2, gD = 3, gN = 4, cT = 5, af = 0, M0 = null, z_ = null, x0 = 0, fT = 0, dT = null, yD = null, yN = 50, $1 = 0, hT = null, pT = !1, wE = !1, SN = 50, mS = 0, eA = null, H_ = !1, NE = null, SD = !1, _D = /* @__PURE__ */ new Set(), _N = {}, zE = null, L_ = null, mT = !1, vT = !1, HE = !1, gT = !1, vS = 0, yT = {};
    (function() {
      for (var n = 0; n < Sy.length; n++) {
        var i = Sy[n], c = i.toLowerCase();
        i = i[0].toUpperCase() + i.slice(1), Xr(c, "on" + i);
      }
      Xr(v_, "onAnimationEnd"), Xr(Dp, "onAnimationIteration"), Xr(zs, "onAnimationStart"), Xr("dblclick", "onDoubleClick"), Xr("focusin", "onFocus"), Xr("focusout", "onBlur"), Xr(Ng, "onTransitionRun"), Xr(zg, "onTransitionStart"), Xr(z1, "onTransitionCancel"), Xr(Jf, "onTransitionEnd");
    })(), Je("onMouseEnter", ["mouseout", "mouseover"]), Je("onMouseLeave", ["mouseout", "mouseover"]), Je("onPointerEnter", ["pointerout", "pointerover"]), Je("onPointerLeave", ["pointerout", "pointerover"]), xe(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(
        " "
      )
    ), xe(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ), xe("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), xe(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ), xe(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ), xe(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var tA = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), ST = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(tA)
    ), LE = "_reactListening" + Math.random().toString(36).slice(2), AD = !1, ED = !1, GE = !1, bD = !1, IE = !1, VE = !1, MD = !1, FE = {}, AN = /\r\n?/g, EN = /\u0000|\uFFFD/g, gS = "http://www.w3.org/1999/xlink", _T = "http://www.w3.org/XML/1998/namespace", bN = "javascript:throw new Error('React form unexpectedly submitted.')", MN = "suppressHydrationWarning", PE = "$", XE = "/$", Ry = "$?", nA = "$!", xN = 1, TN = 2, CN = 4, AT = "F!", xD = "F", TD = "complete", RN = "style", Dy = 0, G_ = 1, YE = 2, ET = null, bT = null, CD = { dialog: !0, webview: !0 }, MT = null, RD = typeof setTimeout == "function" ? setTimeout : void 0, DN = typeof clearTimeout == "function" ? clearTimeout : void 0, yS = -1, DD = typeof Promise == "function" ? Promise : void 0, BN = typeof queueMicrotask == "function" ? queueMicrotask : typeof DD < "u" ? function(n) {
      return DD.resolve(null).then(n).catch(Sm);
    } : RD, xT = null, SS = 0, aA = 1, BD = 2, UD = 3, Vm = 4, Fm = /* @__PURE__ */ new Map(), OD = /* @__PURE__ */ new Set(), By = Kn.d;
    Kn.d = {
      f: function() {
        var n = By.f(), i = wf();
        return n || i;
      },
      r: function(n) {
        var i = jt(n);
        i !== null && i.tag === 5 && i.type === "form" ? iv(i) : By.r(n);
      },
      D: function(n) {
        By.D(n), jc("dns-prefetch", n, null);
      },
      C: function(n, i) {
        By.C(n, i), jc("preconnect", n, i);
      },
      L: function(n, i, c) {
        By.L(n, i, c);
        var g = I_;
        if (g && n && i) {
          var b = 'link[rel="preload"][as="' + Ft(i) + '"]';
          i === "image" && c && c.imageSrcSet ? (b += '[imagesrcset="' + Ft(
            c.imageSrcSet
          ) + '"]', typeof c.imageSizes == "string" && (b += '[imagesizes="' + Ft(
            c.imageSizes
          ) + '"]')) : b += '[href="' + Ft(n) + '"]';
          var R = b;
          switch (i) {
            case "style":
              R = Bs(n);
              break;
            case "script":
              R = cc(n);
          }
          Fm.has(R) || (n = Da(
            {
              rel: "preload",
              href: i === "image" && c && c.imageSrcSet ? void 0 : n,
              as: i
            },
            c
          ), Fm.set(R, n), g.querySelector(b) !== null || i === "style" && g.querySelector(
            $i(R)
          ) || i === "script" && g.querySelector(h(R)) || (i = g.createElement("link"), yl(i, "link", n), Ht(i), g.head.appendChild(i)));
        }
      },
      m: function(n, i) {
        By.m(n, i);
        var c = I_;
        if (c && n) {
          var g = i && typeof i.as == "string" ? i.as : "script", b = 'link[rel="modulepreload"][as="' + Ft(g) + '"][href="' + Ft(n) + '"]', R = b;
          switch (g) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              R = cc(n);
          }
          if (!Fm.has(R) && (n = Da({ rel: "modulepreload", href: n }, i), Fm.set(R, n), c.querySelector(b) === null)) {
            switch (g) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (c.querySelector(h(R)))
                  return;
            }
            g = c.createElement("link"), yl(g, "link", n), Ht(g), c.head.appendChild(g);
          }
        }
      },
      X: function(n, i) {
        By.X(n, i);
        var c = I_;
        if (c && n) {
          var g = ot(c).hoistableScripts, b = cc(n), R = g.get(b);
          R || (R = c.querySelector(
            h(b)
          ), R || (n = Da({ src: n, async: !0 }, i), (i = Fm.get(b)) && I(n, i), R = c.createElement("script"), Ht(R), yl(R, "link", n), c.head.appendChild(R)), R = {
            type: "script",
            instance: R,
            count: 1,
            state: null
          }, g.set(b, R));
        }
      },
      S: function(n, i, c) {
        By.S(n, i, c);
        var g = I_;
        if (g && n) {
          var b = ot(g).hoistableStyles, R = Bs(n);
          i = i || "default";
          var X = b.get(R);
          if (!X) {
            var K = { loading: SS, preload: null };
            if (X = g.querySelector(
              $i(R)
            ))
              K.loading = aA | Vm;
            else {
              n = Da(
                {
                  rel: "stylesheet",
                  href: n,
                  "data-precedence": i
                },
                c
              ), (c = Fm.get(R)) && w(n, c);
              var de = X = g.createElement("link");
              Ht(de), yl(de, "link", n), de._p = new Promise(function(ge, ut) {
                de.onload = ge, de.onerror = ut;
              }), de.addEventListener("load", function() {
                K.loading |= aA;
              }), de.addEventListener("error", function() {
                K.loading |= BD;
              }), K.loading |= Vm, M(X, i, g);
            }
            X = {
              type: "stylesheet",
              instance: X,
              count: 1,
              state: K
            }, b.set(R, X);
          }
        }
      },
      M: function(n, i) {
        By.M(n, i);
        var c = I_;
        if (c && n) {
          var g = ot(c).hoistableScripts, b = cc(n), R = g.get(b);
          R || (R = c.querySelector(
            h(b)
          ), R || (n = Da({ src: n, async: !0, type: "module" }, i), (i = Fm.get(b)) && I(n, i), R = c.createElement("script"), Ht(R), yl(R, "link", n), c.head.appendChild(R)), R = {
            type: "script",
            instance: R,
            count: 1,
            state: null
          }, g.set(b, R));
        }
      }
    };
    var I_ = typeof document > "u" ? null : document, qE = null, iA = null, TT = null, ZE = null, _S = o_, lA = {
      $$typeof: Ru,
      Provider: null,
      Consumer: null,
      _currentValue: _S,
      _currentValue2: _S,
      _threadCount: 0
    }, wD = "%c%s%c ", ND = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", zD = "", QE = " ", UN = Function.prototype.bind, HD = !1, LD = null, GD = null, ID = null, VD = null, FD = null, PD = null, XD = null, YD = null, qD = null;
    LD = function(n, i, c, g) {
      i = o(n, i), i !== null && (c = e(i.memoizedState, c, 0, g), i.memoizedState = c, i.baseState = c, n.memoizedProps = Da({}, n.memoizedProps), c = mr(n, 2), c !== null && Cl(c, n, 2));
    }, GD = function(n, i, c) {
      i = o(n, i), i !== null && (c = r(i.memoizedState, c, 0), i.memoizedState = c, i.baseState = c, n.memoizedProps = Da({}, n.memoizedProps), c = mr(n, 2), c !== null && Cl(c, n, 2));
    }, ID = function(n, i, c, g) {
      i = o(n, i), i !== null && (c = t(i.memoizedState, c, g), i.memoizedState = c, i.baseState = c, n.memoizedProps = Da({}, n.memoizedProps), c = mr(n, 2), c !== null && Cl(c, n, 2));
    }, VD = function(n, i, c) {
      n.pendingProps = e(n.memoizedProps, i, 0, c), n.alternate && (n.alternate.pendingProps = n.pendingProps), i = mr(n, 2), i !== null && Cl(i, n, 2);
    }, FD = function(n, i) {
      n.pendingProps = r(n.memoizedProps, i, 0), n.alternate && (n.alternate.pendingProps = n.pendingProps), i = mr(n, 2), i !== null && Cl(i, n, 2);
    }, PD = function(n, i, c) {
      n.pendingProps = t(
        n.memoizedProps,
        i,
        c
      ), n.alternate && (n.alternate.pendingProps = n.pendingProps), i = mr(n, 2), i !== null && Cl(i, n, 2);
    }, XD = function(n) {
      var i = mr(n, 2);
      i !== null && Cl(i, n, 2);
    }, YD = function(n) {
      p = n;
    }, qD = function(n) {
      d = n;
    };
    var jE = !0, JE = null, CT = !1, T0 = null, C0 = null, R0 = null, sA = /* @__PURE__ */ new Map(), rA = /* @__PURE__ */ new Map(), D0 = [], ON = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    ), KE = null;
    if (Pi.prototype.render = bg.prototype.render = function(n) {
      var i = this._internalRoot;
      if (i === null) throw Error("Cannot update an unmounted root.");
      var c = arguments;
      typeof c[1] == "function" ? console.error(
        "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ) : G(c[1]) ? console.error(
        "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
      ) : typeof c[1] < "u" && console.error(
        "You passed a second argument to root.render(...) but it only accepts one argument."
      ), c = n;
      var g = i.current, b = ir(g);
      Ge(g, b, c, i, null, null);
    }, Pi.prototype.unmount = bg.prototype.unmount = function() {
      var n = arguments;
      if (typeof n[0] == "function" && console.error(
        "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
      ), n = this._internalRoot, n !== null) {
        this._internalRoot = null;
        var i = n.containerInfo;
        (ol & (Yd | Vv)) !== Op && console.error(
          "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
        ), Ge(n.current, 2, null, n, null, null), wf(), i[oa] = null;
      }
    }, Pi.prototype.unstable_scheduleHydration = function(n) {
      if (n) {
        var i = Pt();
        n = { blockedOn: null, target: n, priority: i };
        for (var c = 0; c < D0.length && i !== 0 && i < D0[c].priority; c++) ;
        D0.splice(c, 0, n), c === 0 && Qo(n);
      }
    }, function() {
      var n = _v.version;
      if (n !== "19.1.0")
        throw Error(
          `Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      ` + (n + `
  - react-dom:  19.1.0
Learn more: https://react.dev/warnings/version-mismatch`)
        );
    }(), typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
    ), Kn.findDOMNode = function(n) {
      var i = n._reactInternals;
      if (i === void 0)
        throw typeof n.render == "function" ? Error("Unable to find node on an unmounted component.") : (n = Object.keys(n).join(","), Error(
          "Argument appears to not be a ReactComponent. Keys: " + n
        ));
      return n = Y(i), n = n !== null ? ie(n) : null, n = n === null ? null : n.stateNode, n;
    }, !function() {
      var n = {
        bundleType: 1,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: mt,
        reconcilerVersion: "19.1.0"
      };
      return n.overrideHookState = LD, n.overrideHookStateDeletePath = GD, n.overrideHookStateRenamePath = ID, n.overrideProps = VD, n.overridePropsDeletePath = FD, n.overridePropsRenamePath = PD, n.scheduleUpdate = XD, n.setErrorHandler = YD, n.setSuspenseHandler = qD, n.scheduleRefresh = z, n.scheduleRoot = B, n.setRefreshHandler = V, n.getCurrentFiber = Fi, n.getLaneLabelMap = Hn, n.injectProfilingHooks = Vt, Ze(n);
    }() && be && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && navigator.userAgent.indexOf("Edge") === -1 || -1 < navigator.userAgent.indexOf("Firefox"))) {
      var ZD = window.location.protocol;
      /^(https?|file):$/.test(ZD) && console.info(
        "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + (ZD === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq` : ""),
        "font-weight:bold"
      );
    }
    bA.createRoot = function(n, i) {
      if (!G(n))
        throw Error("Target container is not a DOM element.");
      Jc(n);
      var c = !1, g = "", b = sg, R = sv, X = rg, K = null;
      return i != null && (i.hydrate ? console.warn(
        "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
      ) : typeof i == "object" && i !== null && i.$$typeof === fc && console.error(
        `You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`
      ), i.unstable_strictMode === !0 && (c = !0), i.identifierPrefix !== void 0 && (g = i.identifierPrefix), i.onUncaughtError !== void 0 && (b = i.onUncaughtError), i.onCaughtError !== void 0 && (R = i.onCaughtError), i.onRecoverableError !== void 0 && (X = i.onRecoverableError), i.unstable_transitionCallbacks !== void 0 && (K = i.unstable_transitionCallbacks)), i = Us(
        n,
        1,
        !1,
        null,
        null,
        c,
        g,
        b,
        R,
        X,
        K,
        null
      ), n[oa] = i.current, mm(n), new bg(i);
    }, bA.hydrateRoot = function(n, i, c) {
      if (!G(n))
        throw Error("Target container is not a DOM element.");
      Jc(n), i === void 0 && console.error(
        "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
      );
      var g = !1, b = "", R = sg, X = sv, K = rg, de = null, ge = null;
      return c != null && (c.unstable_strictMode === !0 && (g = !0), c.identifierPrefix !== void 0 && (b = c.identifierPrefix), c.onUncaughtError !== void 0 && (R = c.onUncaughtError), c.onCaughtError !== void 0 && (X = c.onCaughtError), c.onRecoverableError !== void 0 && (K = c.onRecoverableError), c.unstable_transitionCallbacks !== void 0 && (de = c.unstable_transitionCallbacks), c.formState !== void 0 && (ge = c.formState)), i = Us(
        n,
        1,
        !0,
        i,
        c ?? null,
        g,
        b,
        R,
        X,
        K,
        de,
        ge
      ), i.context = Ke(null), c = i.current, g = ir(c), g = Jt(g), b = ju(g), b.callback = null, vu(c, b, g), c = g, i.current.lanes = c, Xe(i, c), lr(i), n[oa] = i.current, mm(n), new Pi(i);
    }, bA.version = "19.1.0", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), bA;
}
var uU;
function fI() {
  if (uU) return kb.exports;
  uU = 1;
  function o() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(o);
      } catch (e) {
        console.error(e);
      }
    }
  }
  return process.env.NODE_ENV === "production" ? (o(), kb.exports = uI()) : kb.exports = cI(), kb.exports;
}
var dI = fI();
const yE = /* @__PURE__ */ new ve(), oR = /* @__PURE__ */ new ve(), hI = /* @__PURE__ */ new ve(), cU = /* @__PURE__ */ new Ot();
function pI(o, e, t) {
  const a = yE.setFromMatrixPosition(o.matrixWorld);
  a.project(e);
  const r = t.width / 2, d = t.height / 2;
  return [a.x * r + r, -(a.y * d) + d];
}
function mI(o, e) {
  const t = yE.setFromMatrixPosition(o.matrixWorld), a = oR.setFromMatrixPosition(e.matrixWorld), r = t.sub(a), d = e.getWorldDirection(hI);
  return r.angleTo(d) > Math.PI / 2;
}
function vI(o, e, t, a) {
  const r = yE.setFromMatrixPosition(o.matrixWorld), d = r.clone();
  d.project(e), cU.set(d.x, d.y), t.setFromCamera(cU, e);
  const p = t.intersectObjects(a, !0);
  if (p.length) {
    const y = p[0].distance;
    return r.distanceTo(t.ray.origin) < y;
  }
  return !0;
}
function gI(o, e) {
  if (e instanceof Zm)
    return e.zoom;
  if (e instanceof Ls) {
    const t = yE.setFromMatrixPosition(o.matrixWorld), a = oR.setFromMatrixPosition(e.matrixWorld), r = e.fov * Math.PI / 180, d = t.distanceTo(a);
    return 1 / (2 * Math.tan(r / 2) * d);
  } else
    return 1;
}
function yI(o, e, t) {
  if (e instanceof Ls || e instanceof Zm) {
    const a = yE.setFromMatrixPosition(o.matrixWorld), r = oR.setFromMatrixPosition(e.matrixWorld), d = a.distanceTo(r), p = (t[1] - t[0]) / (e.far - e.near), y = t[1] - p * e.far;
    return Math.round(p * d + y);
  }
}
const r2 = (o) => Math.abs(o) < 1e-10 ? 0 : o;
function Vw(o, e, t = "") {
  let a = "matrix3d(";
  for (let r = 0; r !== 16; r++)
    a += r2(e[r] * o.elements[r]) + (r !== 15 ? "," : ")");
  return t + a;
}
const SI = /* @__PURE__ */ ((o) => (e) => Vw(e, o))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), _I = /* @__PURE__ */ ((o) => (e, t) => Vw(e, o(t), "translate(-50%,-50%)"))((o) => [1 / o, 1 / o, 1 / o, 1, -1 / o, -1 / o, -1 / o, -1, 1 / o, 1 / o, 1 / o, 1, 1, 1, 1, 1]);
function AI(o) {
  return o && typeof o == "object" && "current" in o;
}
const hF = /* @__PURE__ */ st.forwardRef(({
  children: o,
  eps: e = 1e-3,
  style: t,
  className: a,
  prepend: r,
  center: d,
  fullscreen: p,
  portal: y,
  distanceFactor: _,
  sprite: E = !1,
  transform: T = !1,
  occlude: C,
  onOcclude: D,
  castShadow: B,
  receiveShadow: z,
  material: V,
  geometry: G,
  zIndexRange: N = [16777271, 0],
  calculatePosition: F = pI,
  as: q = "div",
  wrapperClass: Y,
  pointerEvents: ie = "auto",
  ...k
}, le) => {
  const {
    gl: ne,
    camera: Q,
    scene: j,
    size: re,
    raycaster: _e,
    events: me,
    viewport: Ae
  } = nu(), [He] = st.useState(() => document.createElement(q)), P = st.useRef(null), te = st.useRef(null), ae = st.useRef(0), Se = st.useRef([0, 0]), ue = st.useRef(null), we = st.useRef(null), De = (y == null ? void 0 : y.current) || me.connected || ne.domElement.parentNode, We = st.useRef(null), Me = st.useRef(!1), Ze = st.useMemo(() => C && C !== "blending" || Array.isArray(C) && C.length && AI(C[0]), [C]);
  st.useLayoutEffect(() => {
    const rn = ne.domElement;
    C && C === "blending" ? (rn.style.zIndex = `${Math.floor(N[0] / 2)}`, rn.style.position = "absolute", rn.style.pointerEvents = "none") : (rn.style.zIndex = null, rn.style.position = null, rn.style.pointerEvents = null);
  }, [C]), st.useLayoutEffect(() => {
    if (te.current) {
      const rn = P.current = dI.createRoot(He);
      if (j.updateMatrixWorld(), T)
        He.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
      else {
        const dn = F(te.current, Q, re);
        He.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${dn[0]}px,${dn[1]}px,0);transform-origin:0 0;`;
      }
      return De && (r ? De.prepend(He) : De.appendChild(He)), () => {
        De && De.removeChild(He), rn.unmount();
      };
    }
  }, [De, T]), st.useLayoutEffect(() => {
    Y && (He.className = Y);
  }, [Y]);
  const ct = st.useMemo(() => T ? {
    position: "absolute",
    top: 0,
    left: 0,
    width: re.width,
    height: re.height,
    transformStyle: "preserve-3d",
    pointerEvents: "none"
  } : {
    position: "absolute",
    transform: d ? "translate3d(-50%,-50%,0)" : "none",
    ...p && {
      top: -re.height / 2,
      left: -re.width / 2,
      width: re.width,
      height: re.height
    },
    ...t
  }, [t, d, p, re, T]), Vt = st.useMemo(() => ({
    position: "absolute",
    pointerEvents: ie
  }), [ie]);
  st.useLayoutEffect(() => {
    if (Me.current = !1, T) {
      var rn;
      (rn = P.current) == null || rn.render(/* @__PURE__ */ st.createElement("div", {
        ref: ue,
        style: ct
      }, /* @__PURE__ */ st.createElement("div", {
        ref: we,
        style: Vt
      }, /* @__PURE__ */ st.createElement("div", {
        ref: le,
        className: a,
        style: t,
        children: o
      }))));
    } else {
      var dn;
      (dn = P.current) == null || dn.render(/* @__PURE__ */ st.createElement("div", {
        ref: le,
        style: ct,
        className: a,
        children: o
      }));
    }
  });
  const Zt = st.useRef(!0);
  k0((rn) => {
    if (te.current) {
      Q.updateMatrixWorld(), te.current.updateWorldMatrix(!0, !1);
      const dn = T ? Se.current : F(te.current, Q, re);
      if (T || Math.abs(ae.current - Q.zoom) > e || Math.abs(Se.current[0] - dn[0]) > e || Math.abs(Se.current[1] - dn[1]) > e) {
        const Zn = mI(te.current, Q);
        let Rn = !1;
        Ze && (Array.isArray(C) ? Rn = C.map((St) => St.current) : C !== "blending" && (Rn = [j]));
        const Te = Zt.current;
        if (Rn) {
          const St = vI(te.current, Q, _e, Rn);
          Zt.current = St && !Zn;
        } else
          Zt.current = !Zn;
        Te !== Zt.current && (D ? D(!Zt.current) : He.style.display = Zt.current ? "block" : "none");
        const Ha = Math.floor(N[0] / 2), Tt = C ? Ze ? [N[0], Ha] : [Ha - 1, 0] : N;
        if (He.style.zIndex = `${yI(te.current, Q, Tt)}`, T) {
          const [St, Mt] = [re.width / 2, re.height / 2], kt = Q.projectionMatrix.elements[5] * Mt, {
            isOrthographicCamera: At,
            top: ce,
            left: se,
            bottom: Xe,
            right: dt
          } = Q, Et = SI(Q.matrixWorldInverse), yt = At ? `scale(${kt})translate(${r2(-(dt + se) / 2)}px,${r2((ce + Xe) / 2)}px)` : `translateZ(${kt}px)`;
          let Jt = te.current.matrixWorld;
          E && (Jt = Q.matrixWorldInverse.clone().transpose().copyPosition(Jt).scale(te.current.scale), Jt.elements[3] = Jt.elements[7] = Jt.elements[11] = 0, Jt.elements[15] = 1), He.style.width = re.width + "px", He.style.height = re.height + "px", He.style.perspective = At ? "" : `${kt}px`, ue.current && we.current && (ue.current.style.transform = `${yt}${Et}translate(${St}px,${Mt}px)`, we.current.style.transform = _I(Jt, 1 / ((_ || 10) / 400)));
        } else {
          const St = _ === void 0 ? 1 : gI(te.current, Q) * _;
          He.style.transform = `translate3d(${dn[0]}px,${dn[1]}px,0) scale(${St})`;
        }
        Se.current = dn, ae.current = Q.zoom;
      }
    }
    if (!Ze && We.current && !Me.current)
      if (T) {
        if (ue.current) {
          const dn = ue.current.children[0];
          if (dn != null && dn.clientWidth && dn != null && dn.clientHeight) {
            const {
              isOrthographicCamera: Zn
            } = Q;
            if (Zn || G)
              k.scale && (Array.isArray(k.scale) ? k.scale instanceof ve ? We.current.scale.copy(k.scale.clone().divideScalar(1)) : We.current.scale.set(1 / k.scale[0], 1 / k.scale[1], 1 / k.scale[2]) : We.current.scale.setScalar(1 / k.scale));
            else {
              const Rn = (_ || 10) / 400, Te = dn.clientWidth * Rn, Ha = dn.clientHeight * Rn;
              We.current.scale.set(Te, Ha, 1);
            }
            Me.current = !0;
          }
        }
      } else {
        const dn = He.children[0];
        if (dn != null && dn.clientWidth && dn != null && dn.clientHeight) {
          const Zn = 1 / Ae.factor, Rn = dn.clientWidth * Zn, Te = dn.clientHeight * Zn;
          We.current.scale.set(Rn, Te, 1), Me.current = !0;
        }
        We.current.lookAt(rn.camera.position);
      }
  });
  const Bn = st.useMemo(() => ({
    vertexShader: T ? void 0 : (
      /* glsl */
      `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `
    ),
    fragmentShader: (
      /* glsl */
      `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
    )
  }), [T]);
  return /* @__PURE__ */ st.createElement("group", Jy({}, k, {
    ref: te
  }), C && !Ze && /* @__PURE__ */ st.createElement("mesh", {
    castShadow: B,
    receiveShadow: z,
    ref: We
  }, G || /* @__PURE__ */ st.createElement("planeGeometry", null), V || /* @__PURE__ */ st.createElement("shaderMaterial", {
    side: Lp,
    vertexShader: Bn.vertexShader,
    fragmentShader: Bn.fragmentShader
  })));
}), EI = (o) => o;
function bI(o, e = EI) {
  const t = Qm.useSyncExternalStore(
    o.subscribe,
    () => e(o.getState()),
    () => e(o.getInitialState())
  );
  return Qm.useDebugValue(t), t;
}
const fU = (o) => {
  const e = gw(o), t = (a) => bI(e, a);
  return Object.assign(t, e), t;
}, MI = (o) => o ? fU(o) : fU;
let MA = 0;
const pF = /* @__PURE__ */ MI((o) => (o1.onStart = (e, t, a) => {
  o({
    active: !0,
    item: e,
    loaded: t,
    total: a,
    progress: (t - MA) / (a - MA) * 100
  });
}, o1.onLoad = () => {
  o({
    active: !1
  });
}, o1.onError = (e) => o((t) => ({
  errors: [...t.errors, e]
})), o1.onProgress = (e, t, a) => {
  t === a && (MA = a), o({
    active: !0,
    item: e,
    loaded: t,
    total: a,
    progress: (t - MA) / (a - MA) * 100 || 100
  });
}, {
  errors: [],
  active: !1,
  progress: 0,
  item: "",
  loaded: 0,
  total: 0
})), Ix = parseInt(T1.replace(/\D+/g, ""));
function dU(o, e) {
  if (e === nO)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), o;
  if (e === ZM || e === A2) {
    let t = o.getIndex();
    if (t === null) {
      const p = [], y = o.getAttribute("position");
      if (y !== void 0) {
        for (let _ = 0; _ < y.count; _++)
          p.push(_);
        o.setIndex(p), t = o.getIndex();
      } else
        return console.error(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ), o;
    }
    const a = t.count - 2, r = [];
    if (t)
      if (e === ZM)
        for (let p = 1; p <= a; p++)
          r.push(t.getX(0)), r.push(t.getX(p)), r.push(t.getX(p + 1));
      else
        for (let p = 0; p < a; p++)
          p % 2 === 0 ? (r.push(t.getX(p)), r.push(t.getX(p + 1)), r.push(t.getX(p + 2))) : (r.push(t.getX(p + 2)), r.push(t.getX(p + 1)), r.push(t.getX(p)));
    r.length / 3 !== a && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const d = o.clone();
    return d.setIndex(r), d.clearGroups(), d;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), o;
}
var Ym = Uint8Array, F0 = Uint16Array, o2 = Uint32Array, Fw = new Ym([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Pw = new Ym([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), xI = new Ym([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Xw = function(o, e) {
  for (var t = new F0(31), a = 0; a < 31; ++a)
    t[a] = e += 1 << o[a - 1];
  for (var r = new o2(t[30]), a = 1; a < 30; ++a)
    for (var d = t[a]; d < t[a + 1]; ++d)
      r[d] = d - t[a] << 5 | a;
  return [t, r];
}, Yw = Xw(Fw, 2), qw = Yw[0], TI = Yw[1];
qw[28] = 258, TI[258] = 28;
var CI = Xw(Pw, 0), RI = CI[0], u2 = new F0(32768);
for (var Gs = 0; Gs < 32768; ++Gs) {
  var L0 = (Gs & 43690) >>> 1 | (Gs & 21845) << 1;
  L0 = (L0 & 52428) >>> 2 | (L0 & 13107) << 2, L0 = (L0 & 61680) >>> 4 | (L0 & 3855) << 4, u2[Gs] = ((L0 & 65280) >>> 8 | (L0 & 255) << 8) >>> 1;
}
var XA = function(o, e, t) {
  for (var a = o.length, r = 0, d = new F0(e); r < a; ++r)
    ++d[o[r] - 1];
  var p = new F0(e);
  for (r = 0; r < e; ++r)
    p[r] = p[r - 1] + d[r - 1] << 1;
  var y;
  if (t) {
    y = new F0(1 << e);
    var _ = 15 - e;
    for (r = 0; r < a; ++r)
      if (o[r])
        for (var E = r << 4 | o[r], T = e - o[r], C = p[o[r] - 1]++ << T, D = C | (1 << T) - 1; C <= D; ++C)
          y[u2[C] >>> _] = E;
  } else
    for (y = new F0(a), r = 0; r < a; ++r)
      o[r] && (y[r] = u2[p[o[r] - 1]++] >>> 15 - o[r]);
  return y;
}, SE = new Ym(288);
for (var Gs = 0; Gs < 144; ++Gs)
  SE[Gs] = 8;
for (var Gs = 144; Gs < 256; ++Gs)
  SE[Gs] = 9;
for (var Gs = 256; Gs < 280; ++Gs)
  SE[Gs] = 7;
for (var Gs = 280; Gs < 288; ++Gs)
  SE[Gs] = 8;
var Zw = new Ym(32);
for (var Gs = 0; Gs < 32; ++Gs)
  Zw[Gs] = 5;
var DI = /* @__PURE__ */ XA(SE, 9, 1), BI = /* @__PURE__ */ XA(Zw, 5, 1), NC = function(o) {
  for (var e = o[0], t = 1; t < o.length; ++t)
    o[t] > e && (e = o[t]);
  return e;
}, Yv = function(o, e, t) {
  var a = e / 8 | 0;
  return (o[a] | o[a + 1] << 8) >> (e & 7) & t;
}, zC = function(o, e) {
  var t = e / 8 | 0;
  return (o[t] | o[t + 1] << 8 | o[t + 2] << 16) >> (e & 7);
}, UI = function(o) {
  return (o / 8 | 0) + (o & 7 && 1);
}, OI = function(o, e, t) {
  (t == null || t > o.length) && (t = o.length);
  var a = new (o instanceof F0 ? F0 : o instanceof o2 ? o2 : Ym)(t - e);
  return a.set(o.subarray(e, t)), a;
}, wI = function(o, e, t) {
  var a = o.length;
  if (!a || t && !t.l && a < 5)
    return e || new Ym(0);
  var r = !e || t, d = !t || t.i;
  t || (t = {}), e || (e = new Ym(a * 3));
  var p = function(ct) {
    var Vt = e.length;
    if (ct > Vt) {
      var Zt = new Ym(Math.max(Vt * 2, ct));
      Zt.set(e), e = Zt;
    }
  }, y = t.f || 0, _ = t.p || 0, E = t.b || 0, T = t.l, C = t.d, D = t.m, B = t.n, z = a * 8;
  do {
    if (!T) {
      t.f = y = Yv(o, _, 1);
      var V = Yv(o, _ + 1, 3);
      if (_ += 3, V)
        if (V == 1)
          T = DI, C = BI, D = 9, B = 5;
        else if (V == 2) {
          var q = Yv(o, _, 31) + 257, Y = Yv(o, _ + 10, 15) + 4, ie = q + Yv(o, _ + 5, 31) + 1;
          _ += 14;
          for (var k = new Ym(ie), le = new Ym(19), ne = 0; ne < Y; ++ne)
            le[xI[ne]] = Yv(o, _ + ne * 3, 7);
          _ += Y * 3;
          for (var Q = NC(le), j = (1 << Q) - 1, re = XA(le, Q, 1), ne = 0; ne < ie; ) {
            var _e = re[Yv(o, _, j)];
            _ += _e & 15;
            var G = _e >>> 4;
            if (G < 16)
              k[ne++] = G;
            else {
              var me = 0, Ae = 0;
              for (G == 16 ? (Ae = 3 + Yv(o, _, 3), _ += 2, me = k[ne - 1]) : G == 17 ? (Ae = 3 + Yv(o, _, 7), _ += 3) : G == 18 && (Ae = 11 + Yv(o, _, 127), _ += 7); Ae--; )
                k[ne++] = me;
            }
          }
          var He = k.subarray(0, q), P = k.subarray(q);
          D = NC(He), B = NC(P), T = XA(He, D, 1), C = XA(P, B, 1);
        } else
          throw "invalid block type";
      else {
        var G = UI(_) + 4, N = o[G - 4] | o[G - 3] << 8, F = G + N;
        if (F > a) {
          if (d)
            throw "unexpected EOF";
          break;
        }
        r && p(E + N), e.set(o.subarray(G, F), E), t.b = E += N, t.p = _ = F * 8;
        continue;
      }
      if (_ > z) {
        if (d)
          throw "unexpected EOF";
        break;
      }
    }
    r && p(E + 131072);
    for (var te = (1 << D) - 1, ae = (1 << B) - 1, Se = _; ; Se = _) {
      var me = T[zC(o, _) & te], ue = me >>> 4;
      if (_ += me & 15, _ > z) {
        if (d)
          throw "unexpected EOF";
        break;
      }
      if (!me)
        throw "invalid length/literal";
      if (ue < 256)
        e[E++] = ue;
      else if (ue == 256) {
        Se = _, T = null;
        break;
      } else {
        var we = ue - 254;
        if (ue > 264) {
          var ne = ue - 257, De = Fw[ne];
          we = Yv(o, _, (1 << De) - 1) + qw[ne], _ += De;
        }
        var We = C[zC(o, _) & ae], Me = We >>> 4;
        if (!We)
          throw "invalid distance";
        _ += We & 15;
        var P = RI[Me];
        if (Me > 3) {
          var De = Pw[Me];
          P += zC(o, _) & (1 << De) - 1, _ += De;
        }
        if (_ > z) {
          if (d)
            throw "unexpected EOF";
          break;
        }
        r && p(E + 131072);
        for (var Ze = E + we; E < Ze; E += 4)
          e[E] = e[E - P], e[E + 1] = e[E + 1 - P], e[E + 2] = e[E + 2 - P], e[E + 3] = e[E + 3 - P];
        E = Ze;
      }
    }
    t.l = T, t.p = Se, t.b = E, T && (y = 1, t.m = D, t.d = C, t.n = B);
  } while (!y);
  return E == e.length ? e : OI(e, 0, E);
}, NI = /* @__PURE__ */ new Ym(0), zI = function(o) {
  if ((o[0] & 15) != 8 || o[0] >>> 4 > 7 || (o[0] << 8 | o[1]) % 31)
    throw "invalid zlib data";
  if (o[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function $b(o, e) {
  return wI((zI(o), o.subarray(2, -4)), e);
}
var HI = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), LI = 0;
try {
  HI.decode(NI, { stream: !0 }), LI = 1;
} catch {
}
var GI = Object.defineProperty, II = (o, e, t) => e in o ? GI(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, hU = (o, e, t) => (II(o, typeof e != "symbol" ? e + "" : e, t), t);
const VI = /* @__PURE__ */ (() => {
  const o = {
    uniforms: {
      turbidity: { value: 2 },
      rayleigh: { value: 1 },
      mieCoefficient: { value: 5e-3 },
      mieDirectionalG: { value: 0.8 },
      sunPosition: { value: new ve() },
      up: { value: new ve(0, 1, 0) }
    },
    vertexShader: (
      /* glsl */
      `
      uniform vec3 sunPosition;
      uniform float rayleigh;
      uniform float turbidity;
      uniform float mieCoefficient;
      uniform vec3 up;

      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      // constants for atmospheric scattering
      const float e = 2.71828182845904523536028747135266249775724709369995957;
      const float pi = 3.141592653589793238462643383279502884197169;

      // wavelength of used primaries, according to preetham
      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

      // mie stuff
      // K coefficient for the primaries
      const float v = 4.0;
      const vec3 K = vec3( 0.686, 0.678, 0.666 );
      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

      // earth shadow hack
      // cutoffAngle = pi / 1.95;
      const float cutoffAngle = 1.6110731556870734;
      const float steepness = 1.5;
      const float EE = 1000.0;

      float sunIntensity( float zenithAngleCos ) {
        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
      }

      vec3 totalMie( float T ) {
        float c = ( 0.2 * T ) * 10E-18;
        return 0.434 * c * MieConst;
      }

      void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        gl_Position.z = gl_Position.w; // set z to camera.far

        vSunDirection = normalize( sunPosition );

        vSunE = sunIntensity( dot( vSunDirection, up ) );

        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

      // extinction (absorbtion + out scattering)
      // rayleigh coefficients
        vBetaR = totalRayleigh * rayleighCoefficient;

      // mie coefficients
        vBetaM = totalMie( turbidity ) * mieCoefficient;

      }
    `
    ),
    fragmentShader: (
      /* glsl */
      `
      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      uniform float mieDirectionalG;
      uniform vec3 up;

      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

      // constants for atmospheric scattering
      const float pi = 3.141592653589793238462643383279502884197169;

      const float n = 1.0003; // refractive index of air
      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

      // optical length at zenith for molecules
      const float rayleighZenithLength = 8.4E3;
      const float mieZenithLength = 1.25E3;
      // 66 arc seconds -> degrees, and the cosine of that
      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

      // 3.0 / ( 16.0 * pi )
      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
      // 1.0 / ( 4.0 * pi )
      const float ONE_OVER_FOURPI = 0.07957747154594767;

      float rayleighPhase( float cosTheta ) {
        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
      }

      float hgPhase( float cosTheta, float g ) {
        float g2 = pow( g, 2.0 );
        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
      }

      void main() {

        vec3 direction = normalize( vWorldPosition - cameraPos );

      // optical length
      // cutoff angle at 90 to avoid singularity in next formula.
        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
        float sR = rayleighZenithLength * inverse;
        float sM = mieZenithLength * inverse;

      // combined extinction factor
        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

      // in scattering
        float cosTheta = dot( direction, vSunDirection );

        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
        vec3 betaRTheta = vBetaR * rPhase;

        float mPhase = hgPhase( cosTheta, mieDirectionalG );
        vec3 betaMTheta = vBetaM * mPhase;

        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

      // nightsky
        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
        vec3 L0 = vec3( 0.1 ) * Fex;

      // composition + solar disc
        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

        gl_FragColor = vec4( retColor, 1.0 );

      #include <tonemapping_fragment>
      #include <${Ix >= 154 ? "colorspace_fragment" : "encodings_fragment"}>

      }
    `
    )
  }, e = new iu({
    name: "SkyShader",
    fragmentShader: o.fragmentShader,
    vertexShader: o.vertexShader,
    uniforms: T2.clone(o.uniforms),
    side: ed,
    depthWrite: !1
  });
  class t extends es {
    constructor() {
      super(new j0(1, 1, 1), e);
    }
  }
  return hU(t, "SkyShader", o), hU(t, "material", e), t;
})(), FI = (o) => o && o.isCubeTexture;
class PI extends es {
  constructor(e, t) {
    var a, r;
    const d = FI(e), y = ((r = d ? (a = e.image[0]) == null ? void 0 : a.width : e.image.width) != null ? r : 1024) / 4, _ = Math.floor(Math.log2(y)), E = Math.pow(2, _), T = 3 * Math.max(E, 16 * 7), C = 4 * E, D = [
      d ? "#define ENVMAP_TYPE_CUBE" : "",
      `#define CUBEUV_TEXEL_WIDTH ${1 / T}`,
      `#define CUBEUV_TEXEL_HEIGHT ${1 / C}`,
      `#define CUBEUV_MAX_MIP ${_}.0`
    ], B = (
      /* glsl */
      `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `
    ), z = D.join(`
`) + /* glsl */
    `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${Ix >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }
        `, V = {
      map: { value: e },
      height: { value: (t == null ? void 0 : t.height) || 15 },
      radius: { value: (t == null ? void 0 : t.radius) || 100 }
    }, G = new pE(1, 16), N = new iu({
      uniforms: V,
      fragmentShader: z,
      vertexShader: B,
      side: Lp
    });
    super(G, N);
  }
  set radius(e) {
    this.material.uniforms.radius.value = e;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(e) {
    this.material.uniforms.height.value = e;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
}
var XI = Object.defineProperty, YI = (o, e, t) => e in o ? XI(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, qI = (o, e, t) => (YI(o, e + "", t), t);
class ZI {
  constructor() {
    qI(this, "_listeners");
  }
  /**
   * Adds a listener to an event type.
   * @param type The type of event to listen to.
   * @param listener The function that gets called when the event is fired.
   */
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const a = this._listeners;
    a[e] === void 0 && (a[e] = []), a[e].indexOf(t) === -1 && a[e].push(t);
  }
  /**
      * Checks if listener is added to an event type.
      * @param type The type of event to listen to.
      * @param listener The function that gets called when the event is fired.
      */
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const a = this._listeners;
    return a[e] !== void 0 && a[e].indexOf(t) !== -1;
  }
  /**
      * Removes a listener from an event type.
      * @param type The type of the listener that gets removed.
      * @param listener The listener function that gets removed.
      */
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const d = r.indexOf(t);
      d !== -1 && r.splice(d, 1);
    }
  }
  /**
      * Fire an event type.
      * @param event The event that gets fired.
      */
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const a = this._listeners[e.type];
    if (a !== void 0) {
      e.target = this;
      const r = a.slice(0);
      for (let d = 0, p = r.length; d < p; d++)
        r[d].call(this, e);
      e.target = null;
    }
  }
}
var QI = Object.defineProperty, jI = (o, e, t) => e in o ? QI(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, ua = (o, e, t) => (jI(o, typeof e != "symbol" ? e + "" : e, t), t);
const eM = /* @__PURE__ */ new l_(), pU = /* @__PURE__ */ new Pg(), JI = Math.cos(70 * (Math.PI / 180)), mU = (o, e) => (o % e + e) % e;
let KI = class extends ZI {
  constructor(e, t) {
    super(), ua(this, "object"), ua(this, "domElement"), ua(this, "enabled", !0), ua(this, "target", new ve()), ua(this, "minDistance", 0), ua(this, "maxDistance", 1 / 0), ua(this, "minZoom", 0), ua(this, "maxZoom", 1 / 0), ua(this, "minPolarAngle", 0), ua(this, "maxPolarAngle", Math.PI), ua(this, "minAzimuthAngle", -1 / 0), ua(this, "maxAzimuthAngle", 1 / 0), ua(this, "enableDamping", !1), ua(this, "dampingFactor", 0.05), ua(this, "enableZoom", !0), ua(this, "zoomSpeed", 1), ua(this, "enableRotate", !0), ua(this, "rotateSpeed", 1), ua(this, "enablePan", !0), ua(this, "panSpeed", 1), ua(this, "screenSpacePanning", !0), ua(this, "keyPanSpeed", 7), ua(this, "zoomToCursor", !1), ua(this, "autoRotate", !1), ua(this, "autoRotateSpeed", 2), ua(this, "reverseOrbit", !1), ua(this, "reverseHorizontalOrbit", !1), ua(this, "reverseVerticalOrbit", !1), ua(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), ua(this, "mouseButtons", {
      LEFT: zS.ROTATE,
      MIDDLE: zS.DOLLY,
      RIGHT: zS.PAN
    }), ua(this, "touches", { ONE: HS.ROTATE, TWO: HS.DOLLY_PAN }), ua(this, "target0"), ua(this, "position0"), ua(this, "zoom0"), ua(this, "_domElementKeyEvents", null), ua(this, "getPolarAngle"), ua(this, "getAzimuthalAngle"), ua(this, "setPolarAngle"), ua(this, "setAzimuthalAngle"), ua(this, "getDistance"), ua(this, "getZoomScale"), ua(this, "listenToKeyEvents"), ua(this, "stopListenToKeyEvents"), ua(this, "saveState"), ua(this, "reset"), ua(this, "update"), ua(this, "connect"), ua(this, "dispose"), ua(this, "dollyIn"), ua(this, "dollyOut"), ua(this, "getScale"), ua(this, "setScale"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => T.phi, this.getAzimuthalAngle = () => T.theta, this.setPolarAngle = (Ue) => {
      let ot = mU(Ue, 2 * Math.PI), Ht = T.phi;
      Ht < 0 && (Ht += 2 * Math.PI), ot < 0 && (ot += 2 * Math.PI);
      let xe = Math.abs(ot - Ht);
      2 * Math.PI - xe < xe && (ot < Ht ? ot += 2 * Math.PI : Ht += 2 * Math.PI), C.phi = ot - Ht, a.update();
    }, this.setAzimuthalAngle = (Ue) => {
      let ot = mU(Ue, 2 * Math.PI), Ht = T.theta;
      Ht < 0 && (Ht += 2 * Math.PI), ot < 0 && (ot += 2 * Math.PI);
      let xe = Math.abs(ot - Ht);
      2 * Math.PI - xe < xe && (ot < Ht ? ot += 2 * Math.PI : Ht += 2 * Math.PI), C.theta = ot - Ht, a.update();
    }, this.getDistance = () => a.object.position.distanceTo(a.target), this.listenToKeyEvents = (Ue) => {
      Ue.addEventListener("keydown", Xt), this._domElementKeyEvents = Ue;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", Xt), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      a.target0.copy(a.target), a.position0.copy(a.object.position), a.zoom0 = a.object.zoom;
    }, this.reset = () => {
      a.target.copy(a.target0), a.object.position.copy(a.position0), a.object.zoom = a.zoom0, a.object.updateProjectionMatrix(), a.dispatchEvent(r), a.update(), _ = y.NONE;
    }, this.update = (() => {
      const Ue = new ve(), ot = new ve(0, 1, 0), Ht = new Ac().setFromUnitVectors(e.up, ot), xe = Ht.clone().invert(), Je = new ve(), tt = new Ac(), Ct = 2 * Math.PI;
      return function() {
        const tn = a.object.position;
        Ht.setFromUnitVectors(e.up, ot), xe.copy(Ht).invert(), Ue.copy(tn).sub(a.target), Ue.applyQuaternion(Ht), T.setFromVector3(Ue), a.autoRotate && _ === y.NONE && Ae(_e()), a.enableDamping ? (T.theta += C.theta * a.dampingFactor, T.phi += C.phi * a.dampingFactor) : (T.theta += C.theta, T.phi += C.phi);
        let Mn = a.minAzimuthAngle, Wn = a.maxAzimuthAngle;
        isFinite(Mn) && isFinite(Wn) && (Mn < -Math.PI ? Mn += Ct : Mn > Math.PI && (Mn -= Ct), Wn < -Math.PI ? Wn += Ct : Wn > Math.PI && (Wn -= Ct), Mn <= Wn ? T.theta = Math.max(Mn, Math.min(Wn, T.theta)) : T.theta = T.theta > (Mn + Wn) / 2 ? Math.max(Mn, T.theta) : Math.min(Wn, T.theta)), T.phi = Math.max(a.minPolarAngle, Math.min(a.maxPolarAngle, T.phi)), T.makeSafe(), a.enableDamping === !0 ? a.target.addScaledVector(B, a.dampingFactor) : a.target.add(B), a.zoomToCursor && Q || a.object.isOrthographicCamera ? T.radius = We(T.radius) : T.radius = We(T.radius * D), Ue.setFromSpherical(T), Ue.applyQuaternion(xe), tn.copy(a.target).add(Ue), a.object.matrixAutoUpdate || a.object.updateMatrix(), a.object.lookAt(a.target), a.enableDamping === !0 ? (C.theta *= 1 - a.dampingFactor, C.phi *= 1 - a.dampingFactor, B.multiplyScalar(1 - a.dampingFactor)) : (C.set(0, 0, 0), B.set(0, 0, 0));
        let Xa = !1;
        if (a.zoomToCursor && Q) {
          let sa = null;
          if (a.object instanceof Ls && a.object.isPerspectiveCamera) {
            const ul = Ue.length();
            sa = We(ul * D);
            const xa = ul - sa;
            a.object.position.addScaledVector(le, xa), a.object.updateMatrixWorld();
          } else if (a.object.isOrthographicCamera) {
            const ul = new ve(ne.x, ne.y, 0);
            ul.unproject(a.object), a.object.zoom = Math.max(a.minZoom, Math.min(a.maxZoom, a.object.zoom / D)), a.object.updateProjectionMatrix(), Xa = !0;
            const xa = new ve(ne.x, ne.y, 0);
            xa.unproject(a.object), a.object.position.sub(xa).add(ul), a.object.updateMatrixWorld(), sa = Ue.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), a.zoomToCursor = !1;
          sa !== null && (a.screenSpacePanning ? a.target.set(0, 0, -1).transformDirection(a.object.matrix).multiplyScalar(sa).add(a.object.position) : (eM.origin.copy(a.object.position), eM.direction.set(0, 0, -1).transformDirection(a.object.matrix), Math.abs(a.object.up.dot(eM.direction)) < JI ? e.lookAt(a.target) : (pU.setFromNormalAndCoplanarPoint(a.object.up, a.target), eM.intersectPlane(pU, a.target))));
        } else a.object instanceof Zm && a.object.isOrthographicCamera && (Xa = D !== 1, Xa && (a.object.zoom = Math.max(a.minZoom, Math.min(a.maxZoom, a.object.zoom / D)), a.object.updateProjectionMatrix()));
        return D = 1, Q = !1, Xa || Je.distanceToSquared(a.object.position) > E || 8 * (1 - tt.dot(a.object.quaternion)) > E ? (a.dispatchEvent(r), Je.copy(a.object.position), tt.copy(a.object.quaternion), Xa = !1, !0) : !1;
      };
    })(), this.connect = (Ue) => {
      a.domElement = Ue, a.domElement.style.touchAction = "none", a.domElement.addEventListener("contextmenu", Pt), a.domElement.addEventListener("pointerdown", se), a.domElement.addEventListener("pointercancel", dt), a.domElement.addEventListener("wheel", Jt);
    }, this.dispose = () => {
      var Ue, ot, Ht, xe, Je, tt;
      a.domElement && (a.domElement.style.touchAction = "auto"), (Ue = a.domElement) == null || Ue.removeEventListener("contextmenu", Pt), (ot = a.domElement) == null || ot.removeEventListener("pointerdown", se), (Ht = a.domElement) == null || Ht.removeEventListener("pointercancel", dt), (xe = a.domElement) == null || xe.removeEventListener("wheel", Jt), (Je = a.domElement) == null || Je.ownerDocument.removeEventListener("pointermove", Xe), (tt = a.domElement) == null || tt.ownerDocument.removeEventListener("pointerup", dt), a._domElementKeyEvents !== null && a._domElementKeyEvents.removeEventListener("keydown", Xt);
    };
    const a = this, r = { type: "change" }, d = { type: "start" }, p = { type: "end" }, y = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let _ = y.NONE;
    const E = 1e-6, T = new KM(), C = new KM();
    let D = 1;
    const B = new ve(), z = new Ot(), V = new Ot(), G = new Ot(), N = new Ot(), F = new Ot(), q = new Ot(), Y = new Ot(), ie = new Ot(), k = new Ot(), le = new ve(), ne = new Ot();
    let Q = !1;
    const j = [], re = {};
    function _e() {
      return 2 * Math.PI / 60 / 60 * a.autoRotateSpeed;
    }
    function me() {
      return Math.pow(0.95, a.zoomSpeed);
    }
    function Ae(Ue) {
      a.reverseOrbit || a.reverseHorizontalOrbit ? C.theta += Ue : C.theta -= Ue;
    }
    function He(Ue) {
      a.reverseOrbit || a.reverseVerticalOrbit ? C.phi += Ue : C.phi -= Ue;
    }
    const P = (() => {
      const Ue = new ve();
      return function(Ht, xe) {
        Ue.setFromMatrixColumn(xe, 0), Ue.multiplyScalar(-Ht), B.add(Ue);
      };
    })(), te = (() => {
      const Ue = new ve();
      return function(Ht, xe) {
        a.screenSpacePanning === !0 ? Ue.setFromMatrixColumn(xe, 1) : (Ue.setFromMatrixColumn(xe, 0), Ue.crossVectors(a.object.up, Ue)), Ue.multiplyScalar(Ht), B.add(Ue);
      };
    })(), ae = (() => {
      const Ue = new ve();
      return function(Ht, xe) {
        const Je = a.domElement;
        if (Je && a.object instanceof Ls && a.object.isPerspectiveCamera) {
          const tt = a.object.position;
          Ue.copy(tt).sub(a.target);
          let Ct = Ue.length();
          Ct *= Math.tan(a.object.fov / 2 * Math.PI / 180), P(2 * Ht * Ct / Je.clientHeight, a.object.matrix), te(2 * xe * Ct / Je.clientHeight, a.object.matrix);
        } else Je && a.object instanceof Zm && a.object.isOrthographicCamera ? (P(
          Ht * (a.object.right - a.object.left) / a.object.zoom / Je.clientWidth,
          a.object.matrix
        ), te(
          xe * (a.object.top - a.object.bottom) / a.object.zoom / Je.clientHeight,
          a.object.matrix
        )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), a.enablePan = !1);
      };
    })();
    function Se(Ue) {
      a.object instanceof Ls && a.object.isPerspectiveCamera || a.object instanceof Zm && a.object.isOrthographicCamera ? D = Ue : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), a.enableZoom = !1);
    }
    function ue(Ue) {
      Se(D / Ue);
    }
    function we(Ue) {
      Se(D * Ue);
    }
    function De(Ue) {
      if (!a.zoomToCursor || !a.domElement)
        return;
      Q = !0;
      const ot = a.domElement.getBoundingClientRect(), Ht = Ue.clientX - ot.left, xe = Ue.clientY - ot.top, Je = ot.width, tt = ot.height;
      ne.x = Ht / Je * 2 - 1, ne.y = -(xe / tt) * 2 + 1, le.set(ne.x, ne.y, 1).unproject(a.object).sub(a.object.position).normalize();
    }
    function We(Ue) {
      return Math.max(a.minDistance, Math.min(a.maxDistance, Ue));
    }
    function Me(Ue) {
      z.set(Ue.clientX, Ue.clientY);
    }
    function Ze(Ue) {
      De(Ue), Y.set(Ue.clientX, Ue.clientY);
    }
    function ct(Ue) {
      N.set(Ue.clientX, Ue.clientY);
    }
    function Vt(Ue) {
      V.set(Ue.clientX, Ue.clientY), G.subVectors(V, z).multiplyScalar(a.rotateSpeed);
      const ot = a.domElement;
      ot && (Ae(2 * Math.PI * G.x / ot.clientHeight), He(2 * Math.PI * G.y / ot.clientHeight)), z.copy(V), a.update();
    }
    function Zt(Ue) {
      ie.set(Ue.clientX, Ue.clientY), k.subVectors(ie, Y), k.y > 0 ? ue(me()) : k.y < 0 && we(me()), Y.copy(ie), a.update();
    }
    function Bn(Ue) {
      F.set(Ue.clientX, Ue.clientY), q.subVectors(F, N).multiplyScalar(a.panSpeed), ae(q.x, q.y), N.copy(F), a.update();
    }
    function rn(Ue) {
      De(Ue), Ue.deltaY < 0 ? we(me()) : Ue.deltaY > 0 && ue(me()), a.update();
    }
    function dn(Ue) {
      let ot = !1;
      switch (Ue.code) {
        case a.keys.UP:
          ae(0, a.keyPanSpeed), ot = !0;
          break;
        case a.keys.BOTTOM:
          ae(0, -a.keyPanSpeed), ot = !0;
          break;
        case a.keys.LEFT:
          ae(a.keyPanSpeed, 0), ot = !0;
          break;
        case a.keys.RIGHT:
          ae(-a.keyPanSpeed, 0), ot = !0;
          break;
      }
      ot && (Ue.preventDefault(), a.update());
    }
    function Zn() {
      if (j.length == 1)
        z.set(j[0].pageX, j[0].pageY);
      else {
        const Ue = 0.5 * (j[0].pageX + j[1].pageX), ot = 0.5 * (j[0].pageY + j[1].pageY);
        z.set(Ue, ot);
      }
    }
    function Rn() {
      if (j.length == 1)
        N.set(j[0].pageX, j[0].pageY);
      else {
        const Ue = 0.5 * (j[0].pageX + j[1].pageX), ot = 0.5 * (j[0].pageY + j[1].pageY);
        N.set(Ue, ot);
      }
    }
    function Te() {
      const Ue = j[0].pageX - j[1].pageX, ot = j[0].pageY - j[1].pageY, Ht = Math.sqrt(Ue * Ue + ot * ot);
      Y.set(0, Ht);
    }
    function Ha() {
      a.enableZoom && Te(), a.enablePan && Rn();
    }
    function Tt() {
      a.enableZoom && Te(), a.enableRotate && Zn();
    }
    function St(Ue) {
      if (j.length == 1)
        V.set(Ue.pageX, Ue.pageY);
      else {
        const Ht = jt(Ue), xe = 0.5 * (Ue.pageX + Ht.x), Je = 0.5 * (Ue.pageY + Ht.y);
        V.set(xe, Je);
      }
      G.subVectors(V, z).multiplyScalar(a.rotateSpeed);
      const ot = a.domElement;
      ot && (Ae(2 * Math.PI * G.x / ot.clientHeight), He(2 * Math.PI * G.y / ot.clientHeight)), z.copy(V);
    }
    function Mt(Ue) {
      if (j.length == 1)
        F.set(Ue.pageX, Ue.pageY);
      else {
        const ot = jt(Ue), Ht = 0.5 * (Ue.pageX + ot.x), xe = 0.5 * (Ue.pageY + ot.y);
        F.set(Ht, xe);
      }
      q.subVectors(F, N).multiplyScalar(a.panSpeed), ae(q.x, q.y), N.copy(F);
    }
    function kt(Ue) {
      const ot = jt(Ue), Ht = Ue.pageX - ot.x, xe = Ue.pageY - ot.y, Je = Math.sqrt(Ht * Ht + xe * xe);
      ie.set(0, Je), k.set(0, Math.pow(ie.y / Y.y, a.zoomSpeed)), ue(k.y), Y.copy(ie);
    }
    function At(Ue) {
      a.enableZoom && kt(Ue), a.enablePan && Mt(Ue);
    }
    function ce(Ue) {
      a.enableZoom && kt(Ue), a.enableRotate && St(Ue);
    }
    function se(Ue) {
      var ot, Ht;
      a.enabled !== !1 && (j.length === 0 && ((ot = a.domElement) == null || ot.ownerDocument.addEventListener("pointermove", Xe), (Ht = a.domElement) == null || Ht.ownerDocument.addEventListener("pointerup", dt)), pn(Ue), Ue.pointerType === "touch" ? Wt(Ue) : Et(Ue));
    }
    function Xe(Ue) {
      a.enabled !== !1 && (Ue.pointerType === "touch" ? Vn(Ue) : yt(Ue));
    }
    function dt(Ue) {
      var ot, Ht, xe;
      gn(Ue), j.length === 0 && ((ot = a.domElement) == null || ot.releasePointerCapture(Ue.pointerId), (Ht = a.domElement) == null || Ht.ownerDocument.removeEventListener("pointermove", Xe), (xe = a.domElement) == null || xe.ownerDocument.removeEventListener("pointerup", dt)), a.dispatchEvent(p), _ = y.NONE;
    }
    function Et(Ue) {
      let ot;
      switch (Ue.button) {
        case 0:
          ot = a.mouseButtons.LEFT;
          break;
        case 1:
          ot = a.mouseButtons.MIDDLE;
          break;
        case 2:
          ot = a.mouseButtons.RIGHT;
          break;
        default:
          ot = -1;
      }
      switch (ot) {
        case zS.DOLLY:
          if (a.enableZoom === !1)
            return;
          Ze(Ue), _ = y.DOLLY;
          break;
        case zS.ROTATE:
          if (Ue.ctrlKey || Ue.metaKey || Ue.shiftKey) {
            if (a.enablePan === !1)
              return;
            ct(Ue), _ = y.PAN;
          } else {
            if (a.enableRotate === !1)
              return;
            Me(Ue), _ = y.ROTATE;
          }
          break;
        case zS.PAN:
          if (Ue.ctrlKey || Ue.metaKey || Ue.shiftKey) {
            if (a.enableRotate === !1)
              return;
            Me(Ue), _ = y.ROTATE;
          } else {
            if (a.enablePan === !1)
              return;
            ct(Ue), _ = y.PAN;
          }
          break;
        default:
          _ = y.NONE;
      }
      _ !== y.NONE && a.dispatchEvent(d);
    }
    function yt(Ue) {
      if (a.enabled !== !1)
        switch (_) {
          case y.ROTATE:
            if (a.enableRotate === !1)
              return;
            Vt(Ue);
            break;
          case y.DOLLY:
            if (a.enableZoom === !1)
              return;
            Zt(Ue);
            break;
          case y.PAN:
            if (a.enablePan === !1)
              return;
            Bn(Ue);
            break;
        }
    }
    function Jt(Ue) {
      a.enabled === !1 || a.enableZoom === !1 || _ !== y.NONE && _ !== y.ROTATE || (Ue.preventDefault(), a.dispatchEvent(d), rn(Ue), a.dispatchEvent(p));
    }
    function Xt(Ue) {
      a.enabled === !1 || a.enablePan === !1 || dn(Ue);
    }
    function Wt(Ue) {
      switch (nn(Ue), j.length) {
        case 1:
          switch (a.touches.ONE) {
            case HS.ROTATE:
              if (a.enableRotate === !1)
                return;
              Zn(), _ = y.TOUCH_ROTATE;
              break;
            case HS.PAN:
              if (a.enablePan === !1)
                return;
              Rn(), _ = y.TOUCH_PAN;
              break;
            default:
              _ = y.NONE;
          }
          break;
        case 2:
          switch (a.touches.TWO) {
            case HS.DOLLY_PAN:
              if (a.enableZoom === !1 && a.enablePan === !1)
                return;
              Ha(), _ = y.TOUCH_DOLLY_PAN;
              break;
            case HS.DOLLY_ROTATE:
              if (a.enableZoom === !1 && a.enableRotate === !1)
                return;
              Tt(), _ = y.TOUCH_DOLLY_ROTATE;
              break;
            default:
              _ = y.NONE;
          }
          break;
        default:
          _ = y.NONE;
      }
      _ !== y.NONE && a.dispatchEvent(d);
    }
    function Vn(Ue) {
      switch (nn(Ue), _) {
        case y.TOUCH_ROTATE:
          if (a.enableRotate === !1)
            return;
          St(Ue), a.update();
          break;
        case y.TOUCH_PAN:
          if (a.enablePan === !1)
            return;
          Mt(Ue), a.update();
          break;
        case y.TOUCH_DOLLY_PAN:
          if (a.enableZoom === !1 && a.enablePan === !1)
            return;
          At(Ue), a.update();
          break;
        case y.TOUCH_DOLLY_ROTATE:
          if (a.enableZoom === !1 && a.enableRotate === !1)
            return;
          ce(Ue), a.update();
          break;
        default:
          _ = y.NONE;
      }
    }
    function Pt(Ue) {
      a.enabled !== !1 && Ue.preventDefault();
    }
    function pn(Ue) {
      j.push(Ue);
    }
    function gn(Ue) {
      delete re[Ue.pointerId];
      for (let ot = 0; ot < j.length; ot++)
        if (j[ot].pointerId == Ue.pointerId) {
          j.splice(ot, 1);
          return;
        }
    }
    function nn(Ue) {
      let ot = re[Ue.pointerId];
      ot === void 0 && (ot = new Ot(), re[Ue.pointerId] = ot), ot.set(Ue.pageX, Ue.pageY);
    }
    function jt(Ue) {
      const ot = Ue.pointerId === j[0].pointerId ? j[1] : j[0];
      return re[ot.pointerId];
    }
    this.dollyIn = (Ue = me()) => {
      we(Ue), a.update();
    }, this.dollyOut = (Ue = me()) => {
      ue(Ue), a.update();
    }, this.getScale = () => D, this.setScale = (Ue) => {
      Se(Ue), a.update();
    }, this.getZoomScale = () => me(), t !== void 0 && this.connect(t), this.update();
  }
};
function nx(o) {
  if (typeof TextDecoder < "u")
    return new TextDecoder().decode(o);
  let e = "";
  for (let t = 0, a = o.length; t < a; t++)
    e += String.fromCharCode(o[t]);
  try {
    return decodeURIComponent(escape(e));
  } catch {
    return e;
  }
}
const ZS = "srgb", Zy = "srgb-linear", vU = 3001, kI = 3e3;
class uR extends cf {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new nV(t);
    }), this.register(function(t) {
      return new aV(t);
    }), this.register(function(t) {
      return new dV(t);
    }), this.register(function(t) {
      return new hV(t);
    }), this.register(function(t) {
      return new pV(t);
    }), this.register(function(t) {
      return new lV(t);
    }), this.register(function(t) {
      return new sV(t);
    }), this.register(function(t) {
      return new rV(t);
    }), this.register(function(t) {
      return new oV(t);
    }), this.register(function(t) {
      return new tV(t);
    }), this.register(function(t) {
      return new uV(t);
    }), this.register(function(t) {
      return new iV(t);
    }), this.register(function(t) {
      return new fV(t);
    }), this.register(function(t) {
      return new cV(t);
    }), this.register(function(t) {
      return new $I(t);
    }), this.register(function(t) {
      return new mV(t);
    }), this.register(function(t) {
      return new vV(t);
    });
  }
  load(e, t, a, r) {
    const d = this;
    let p;
    if (this.resourcePath !== "")
      p = this.resourcePath;
    else if (this.path !== "") {
      const E = P0.extractUrlBase(e);
      p = P0.resolveURL(E, this.path);
    } else
      p = P0.extractUrlBase(e);
    this.manager.itemStart(e);
    const y = function(E) {
      r ? r(E) : console.error(E), d.manager.itemError(e), d.manager.itemEnd(e);
    }, _ = new of(this.manager);
    _.setPath(this.path), _.setResponseType("arraybuffer"), _.setRequestHeader(this.requestHeader), _.setWithCredentials(this.withCredentials), _.load(
      e,
      function(E) {
        try {
          d.parse(
            E,
            p,
            function(T) {
              t(T), d.manager.itemEnd(e);
            },
            y
          );
        } catch (T) {
          y(T);
        }
      },
      a,
      y
    );
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, a, r) {
    let d;
    const p = {}, y = {};
    if (typeof e == "string")
      d = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (nx(new Uint8Array(e.slice(0, 4))) === Qw) {
        try {
          p[Ai.KHR_BINARY_GLTF] = new gV(e);
        } catch (T) {
          r && r(T);
          return;
        }
        d = JSON.parse(p[Ai.KHR_BINARY_GLTF].content);
      } else
        d = JSON.parse(nx(new Uint8Array(e)));
    else
      d = e;
    if (d.asset === void 0 || d.asset.version[0] < 2) {
      r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const _ = new BV(d, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    _.fileLoader.setRequestHeader(this.requestHeader);
    for (let E = 0; E < this.pluginCallbacks.length; E++) {
      const T = this.pluginCallbacks[E](_);
      T.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), y[T.name] = T, p[T.name] = !0;
    }
    if (d.extensionsUsed)
      for (let E = 0; E < d.extensionsUsed.length; ++E) {
        const T = d.extensionsUsed[E], C = d.extensionsRequired || [];
        switch (T) {
          case Ai.KHR_MATERIALS_UNLIT:
            p[T] = new eV();
            break;
          case Ai.KHR_DRACO_MESH_COMPRESSION:
            p[T] = new yV(d, this.dracoLoader);
            break;
          case Ai.KHR_TEXTURE_TRANSFORM:
            p[T] = new SV();
            break;
          case Ai.KHR_MESH_QUANTIZATION:
            p[T] = new _V();
            break;
          default:
            C.indexOf(T) >= 0 && y[T] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + T + '".');
        }
      }
    _.setExtensions(p), _.setPlugins(y), _.parse(a, r);
  }
  parseAsync(e, t) {
    const a = this;
    return new Promise(function(r, d) {
      a.parse(e, t, r, d);
    });
  }
}
function WI() {
  let o = {};
  return {
    get: function(e) {
      return o[e];
    },
    add: function(e, t) {
      o[e] = t;
    },
    remove: function(e) {
      delete o[e];
    },
    removeAll: function() {
      o = {};
    }
  };
}
const Ai = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class $I {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let a = 0, r = t.length; a < r; a++) {
      const d = t[a];
      d.extensions && d.extensions[this.name] && d.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, d.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, a = "light:" + e;
    let r = t.cache.get(a);
    if (r)
      return r;
    const d = t.json, _ = ((d.extensions && d.extensions[this.name] || {}).lights || [])[e];
    let E;
    const T = new hn(16777215);
    _.color !== void 0 && T.setRGB(_.color[0], _.color[1], _.color[2], Zy);
    const C = _.range !== void 0 ? _.range : 0;
    switch (_.type) {
      case "directional":
        E = new Q2(T), E.target.position.set(0, 0, -1), E.add(E.target);
        break;
      case "point":
        E = new Z2(T), E.distance = C;
        break;
      case "spot":
        E = new q2(T), E.distance = C, _.spot = _.spot || {}, _.spot.innerConeAngle = _.spot.innerConeAngle !== void 0 ? _.spot.innerConeAngle : 0, _.spot.outerConeAngle = _.spot.outerConeAngle !== void 0 ? _.spot.outerConeAngle : Math.PI / 4, E.angle = _.spot.outerConeAngle, E.penumbra = 1 - _.spot.innerConeAngle / _.spot.outerConeAngle, E.target.position.set(0, 0, -1), E.add(E.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + _.type);
    }
    return E.position.set(0, 0, 0), E.decay = 2, Vy(E, _), _.intensity !== void 0 && (E.intensity = _.intensity), E.name = t.createUniqueName(_.name || "light_" + e), r = Promise.resolve(E), t.cache.add(a, r), r;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, a = this.parser, d = a.json.nodes[e], y = (d.extensions && d.extensions[this.name] || {}).light;
    return y === void 0 ? null : this._loadLight(y).then(function(_) {
      return a._getNodeRef(t.cache, y, _);
    });
  }
}
class eV {
  constructor() {
    this.name = Ai.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Yh;
  }
  extendParams(e, t, a) {
    const r = [];
    e.color = new hn(1, 1, 1), e.opacity = 1;
    const d = t.pbrMetallicRoughness;
    if (d) {
      if (Array.isArray(d.baseColorFactor)) {
        const p = d.baseColorFactor;
        e.color.setRGB(p[0], p[1], p[2], Zy), e.opacity = p[3];
      }
      d.baseColorTexture !== void 0 && r.push(a.assignTexture(e, "map", d.baseColorTexture, ZS));
    }
    return Promise.all(r);
  }
}
class tV {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const d = r.extensions[this.name].emissiveStrength;
    return d !== void 0 && (t.emissiveIntensity = d), Promise.resolve();
  }
}
class nV {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name] ? null : jm;
  }
  extendMaterialParams(e, t) {
    const a = this.parser, r = a.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const d = [], p = r.extensions[this.name];
    if (p.clearcoatFactor !== void 0 && (t.clearcoat = p.clearcoatFactor), p.clearcoatTexture !== void 0 && d.push(a.assignTexture(t, "clearcoatMap", p.clearcoatTexture)), p.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = p.clearcoatRoughnessFactor), p.clearcoatRoughnessTexture !== void 0 && d.push(a.assignTexture(t, "clearcoatRoughnessMap", p.clearcoatRoughnessTexture)), p.clearcoatNormalTexture !== void 0 && (d.push(a.assignTexture(t, "clearcoatNormalMap", p.clearcoatNormalTexture)), p.clearcoatNormalTexture.scale !== void 0)) {
      const y = p.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Ot(y, y);
    }
    return Promise.all(d);
  }
}
class aV {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name] ? null : jm;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const d = r.extensions[this.name];
    return t.dispersion = d.dispersion !== void 0 ? d.dispersion : 0, Promise.resolve();
  }
}
class iV {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name] ? null : jm;
  }
  extendMaterialParams(e, t) {
    const a = this.parser, r = a.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const d = [], p = r.extensions[this.name];
    return p.iridescenceFactor !== void 0 && (t.iridescence = p.iridescenceFactor), p.iridescenceTexture !== void 0 && d.push(a.assignTexture(t, "iridescenceMap", p.iridescenceTexture)), p.iridescenceIor !== void 0 && (t.iridescenceIOR = p.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), p.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = p.iridescenceThicknessMinimum), p.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = p.iridescenceThicknessMaximum), p.iridescenceThicknessTexture !== void 0 && d.push(
      a.assignTexture(t, "iridescenceThicknessMap", p.iridescenceThicknessTexture)
    ), Promise.all(d);
  }
}
class lV {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name] ? null : jm;
  }
  extendMaterialParams(e, t) {
    const a = this.parser, r = a.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const d = [];
    t.sheenColor = new hn(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const p = r.extensions[this.name];
    if (p.sheenColorFactor !== void 0) {
      const y = p.sheenColorFactor;
      t.sheenColor.setRGB(y[0], y[1], y[2], Zy);
    }
    return p.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = p.sheenRoughnessFactor), p.sheenColorTexture !== void 0 && d.push(a.assignTexture(t, "sheenColorMap", p.sheenColorTexture, ZS)), p.sheenRoughnessTexture !== void 0 && d.push(a.assignTexture(t, "sheenRoughnessMap", p.sheenRoughnessTexture)), Promise.all(d);
  }
}
class sV {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name] ? null : jm;
  }
  extendMaterialParams(e, t) {
    const a = this.parser, r = a.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const d = [], p = r.extensions[this.name];
    return p.transmissionFactor !== void 0 && (t.transmission = p.transmissionFactor), p.transmissionTexture !== void 0 && d.push(a.assignTexture(t, "transmissionMap", p.transmissionTexture)), Promise.all(d);
  }
}
class rV {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name] ? null : jm;
  }
  extendMaterialParams(e, t) {
    const a = this.parser, r = a.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const d = [], p = r.extensions[this.name];
    t.thickness = p.thicknessFactor !== void 0 ? p.thicknessFactor : 0, p.thicknessTexture !== void 0 && d.push(a.assignTexture(t, "thicknessMap", p.thicknessTexture)), t.attenuationDistance = p.attenuationDistance || 1 / 0;
    const y = p.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new hn().setRGB(
      y[0],
      y[1],
      y[2],
      Zy
    ), Promise.all(d);
  }
}
class oV {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name] ? null : jm;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const d = r.extensions[this.name];
    return t.ior = d.ior !== void 0 ? d.ior : 1.5, Promise.resolve();
  }
}
class uV {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name] ? null : jm;
  }
  extendMaterialParams(e, t) {
    const a = this.parser, r = a.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const d = [], p = r.extensions[this.name];
    t.specularIntensity = p.specularFactor !== void 0 ? p.specularFactor : 1, p.specularTexture !== void 0 && d.push(a.assignTexture(t, "specularIntensityMap", p.specularTexture));
    const y = p.specularColorFactor || [1, 1, 1];
    return t.specularColor = new hn().setRGB(y[0], y[1], y[2], Zy), p.specularColorTexture !== void 0 && d.push(
      a.assignTexture(t, "specularColorMap", p.specularColorTexture, ZS)
    ), Promise.all(d);
  }
}
class cV {
  constructor(e) {
    this.parser = e, this.name = Ai.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name] ? null : jm;
  }
  extendMaterialParams(e, t) {
    const a = this.parser, r = a.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const d = [], p = r.extensions[this.name];
    return t.bumpScale = p.bumpFactor !== void 0 ? p.bumpFactor : 1, p.bumpTexture !== void 0 && d.push(a.assignTexture(t, "bumpMap", p.bumpTexture)), Promise.all(d);
  }
}
class fV {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const a = this.parser.json.materials[e];
    return !a.extensions || !a.extensions[this.name] ? null : jm;
  }
  extendMaterialParams(e, t) {
    const a = this.parser, r = a.json.materials[e];
    if (!r.extensions || !r.extensions[this.name])
      return Promise.resolve();
    const d = [], p = r.extensions[this.name];
    return p.anisotropyStrength !== void 0 && (t.anisotropy = p.anisotropyStrength), p.anisotropyRotation !== void 0 && (t.anisotropyRotation = p.anisotropyRotation), p.anisotropyTexture !== void 0 && d.push(a.assignTexture(t, "anisotropyMap", p.anisotropyTexture)), Promise.all(d);
  }
}
class dV {
  constructor(e) {
    this.parser = e, this.name = Ai.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, a = t.json, r = a.textures[e];
    if (!r.extensions || !r.extensions[this.name])
      return null;
    const d = r.extensions[this.name], p = t.options.ktx2Loader;
    if (!p) {
      if (a.extensionsRequired && a.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, d.source, p);
  }
}
class hV {
  constructor(e) {
    this.parser = e, this.name = Ai.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, a = this.parser, r = a.json, d = r.textures[e];
    if (!d.extensions || !d.extensions[t])
      return null;
    const p = d.extensions[t], y = r.images[p.source];
    let _ = a.textureLoader;
    if (y.uri) {
      const E = a.options.manager.getHandler(y.uri);
      E !== null && (_ = E);
    }
    return this.detectSupport().then(function(E) {
      if (E)
        return a.loadTextureImage(e, p.source, _);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return a.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class pV {
  constructor(e) {
    this.parser = e, this.name = Ai.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, a = this.parser, r = a.json, d = r.textures[e];
    if (!d.extensions || !d.extensions[t])
      return null;
    const p = d.extensions[t], y = r.images[p.source];
    let _ = a.textureLoader;
    if (y.uri) {
      const E = a.options.manager.getHandler(y.uri);
      E !== null && (_ = E);
    }
    return this.detectSupport().then(function(E) {
      if (E)
        return a.loadTextureImage(e, p.source, _);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return a.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class mV {
  constructor(e) {
    this.name = Ai.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, a = t.bufferViews[e];
    if (a.extensions && a.extensions[this.name]) {
      const r = a.extensions[this.name], d = this.parser.getDependency("buffer", r.buffer), p = this.parser.options.meshoptDecoder;
      if (!p || !p.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return d.then(function(y) {
        const _ = r.byteOffset || 0, E = r.byteLength || 0, T = r.count, C = r.byteStride, D = new Uint8Array(y, _, E);
        return p.decodeGltfBufferAsync ? p.decodeGltfBufferAsync(T, C, D, r.mode, r.filter).then(function(B) {
          return B.buffer;
        }) : p.ready.then(function() {
          const B = new ArrayBuffer(T * C);
          return p.decodeGltfBuffer(
            new Uint8Array(B),
            T,
            C,
            D,
            r.mode,
            r.filter
          ), B;
        });
      });
    } else
      return null;
  }
}
class vV {
  constructor(e) {
    this.name = Ai.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, a = t.nodes[e];
    if (!a.extensions || !a.extensions[this.name] || a.mesh === void 0)
      return null;
    const r = t.meshes[a.mesh];
    for (const E of r.primitives)
      if (E.mode !== Xm.TRIANGLES && E.mode !== Xm.TRIANGLE_STRIP && E.mode !== Xm.TRIANGLE_FAN && E.mode !== void 0)
        return null;
    const p = a.extensions[this.name].attributes, y = [], _ = {};
    for (const E in p)
      y.push(
        this.parser.getDependency("accessor", p[E]).then((T) => (_[E] = T, _[E]))
      );
    return y.length < 1 ? null : (y.push(this.parser.createNodeMesh(e)), Promise.all(y).then((E) => {
      const T = E.pop(), C = T.isGroup ? T.children : [T], D = E[0].count, B = [];
      for (const z of C) {
        const V = new ia(), G = new ve(), N = new Ac(), F = new ve(1, 1, 1), q = new B2(z.geometry, z.material, D);
        for (let Y = 0; Y < D; Y++)
          _.TRANSLATION && G.fromBufferAttribute(_.TRANSLATION, Y), _.ROTATION && N.fromBufferAttribute(_.ROTATION, Y), _.SCALE && F.fromBufferAttribute(_.SCALE, Y), q.setMatrixAt(Y, V.compose(G, N, F));
        for (const Y in _)
          if (Y === "_COLOR_0") {
            const ie = _[Y];
            q.instanceColor = new $S(ie.array, ie.itemSize, ie.normalized);
          } else Y !== "TRANSLATION" && Y !== "ROTATION" && Y !== "SCALE" && z.geometry.setAttribute(Y, _[Y]);
        zi.prototype.copy.call(q, z), this.parser.assignFinalMaterial(q), B.push(q);
      }
      return T.isGroup ? (T.clear(), T.add(...B), T) : B[0];
    }));
  }
}
const Qw = "glTF", xA = 12, gU = { JSON: 1313821514, BIN: 5130562 };
class gV {
  constructor(e) {
    this.name = Ai.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, xA);
    if (this.header = {
      magic: nx(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== Qw)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const a = this.header.length - xA, r = new DataView(e, xA);
    let d = 0;
    for (; d < a; ) {
      const p = r.getUint32(d, !0);
      d += 4;
      const y = r.getUint32(d, !0);
      if (d += 4, y === gU.JSON) {
        const _ = new Uint8Array(e, xA + d, p);
        this.content = nx(_);
      } else if (y === gU.BIN) {
        const _ = xA + d;
        this.body = e.slice(_, _ + p);
      }
      d += p;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class yV {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Ai.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const a = this.json, r = this.dracoLoader, d = e.extensions[this.name].bufferView, p = e.extensions[this.name].attributes, y = {}, _ = {}, E = {};
    for (const T in p) {
      const C = c2[T] || T.toLowerCase();
      y[C] = p[T];
    }
    for (const T in e.attributes) {
      const C = c2[T] || T.toLowerCase();
      if (p[T] !== void 0) {
        const D = a.accessors[e.attributes[T]], B = d1[D.componentType];
        E[C] = B.name, _[C] = D.normalized === !0;
      }
    }
    return t.getDependency("bufferView", d).then(function(T) {
      return new Promise(function(C, D) {
        r.decodeDracoFile(
          T,
          function(B) {
            for (const z in B.attributes) {
              const V = B.attributes[z], G = _[z];
              G !== void 0 && (V.normalized = G);
            }
            C(B);
          },
          y,
          E,
          Zy,
          D
        );
      });
    });
  }
}
class SV {
  constructor() {
    this.name = Ai.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class _V {
  constructor() {
    this.name = Ai.KHR_MESH_QUANTIZATION;
  }
}
class jw extends U1 {
  constructor(e, t, a, r) {
    super(e, t, a, r);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, a = this.sampleValues, r = this.valueSize, d = e * r * 3 + r;
    for (let p = 0; p !== r; p++)
      t[p] = a[d + p];
    return t;
  }
  interpolate_(e, t, a, r) {
    const d = this.resultBuffer, p = this.sampleValues, y = this.valueSize, _ = y * 2, E = y * 3, T = r - t, C = (a - t) / T, D = C * C, B = D * C, z = e * E, V = z - E, G = -2 * B + 3 * D, N = B - D, F = 1 - G, q = N - D + C;
    for (let Y = 0; Y !== y; Y++) {
      const ie = p[V + Y + y], k = p[V + Y + _] * T, le = p[z + Y + y], ne = p[z + Y] * T;
      d[Y] = F * ie + q * k + G * le + N * ne;
    }
    return d;
  }
}
const AV = /* @__PURE__ */ new Ac();
class EV extends jw {
  interpolate_(e, t, a, r) {
    const d = super.interpolate_(e, t, a, r);
    return AV.fromArray(d).normalize().toArray(d), d;
  }
}
const Xm = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, d1 = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, yU = {
  9728: _c,
  9729: Ni,
  9984: ix,
  9985: c1,
  9986: VS,
  9987: qm
}, SU = {
  33071: Mo,
  33648: m1,
  10497: q0
}, HC = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, c2 = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  // uv => uv1, 4 uv channels
  // https://github.com/mrdoob/three.js/pull/25943
  // https://github.com/mrdoob/three.js/pull/25788
  ...Ix >= 152 ? {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3"
  } : {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2"
  },
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, G0 = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, bV = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: S1,
  STEP: y1
}, LC = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function MV(o) {
  return o.DefaultMaterial === void 0 && (o.DefaultMaterial = new B1({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: Zg
  })), o.DefaultMaterial;
}
function NS(o, e, t) {
  for (const a in t.extensions)
    o[a] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[a] = t.extensions[a]);
}
function Vy(o, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(o.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function xV(o, e, t) {
  let a = !1, r = !1, d = !1;
  for (let E = 0, T = e.length; E < T; E++) {
    const C = e[E];
    if (C.POSITION !== void 0 && (a = !0), C.NORMAL !== void 0 && (r = !0), C.COLOR_0 !== void 0 && (d = !0), a && r && d)
      break;
  }
  if (!a && !r && !d)
    return Promise.resolve(o);
  const p = [], y = [], _ = [];
  for (let E = 0, T = e.length; E < T; E++) {
    const C = e[E];
    if (a) {
      const D = C.POSITION !== void 0 ? t.getDependency("accessor", C.POSITION) : o.attributes.position;
      p.push(D);
    }
    if (r) {
      const D = C.NORMAL !== void 0 ? t.getDependency("accessor", C.NORMAL) : o.attributes.normal;
      y.push(D);
    }
    if (d) {
      const D = C.COLOR_0 !== void 0 ? t.getDependency("accessor", C.COLOR_0) : o.attributes.color;
      _.push(D);
    }
  }
  return Promise.all([
    Promise.all(p),
    Promise.all(y),
    Promise.all(_)
  ]).then(function(E) {
    const T = E[0], C = E[1], D = E[2];
    return a && (o.morphAttributes.position = T), r && (o.morphAttributes.normal = C), d && (o.morphAttributes.color = D), o.morphTargetsRelative = !0, o;
  });
}
function TV(o, e) {
  if (o.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, a = e.weights.length; t < a; t++)
      o.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (o.morphTargetInfluences.length === t.length) {
      o.morphTargetDictionary = {};
      for (let a = 0, r = t.length; a < r; a++)
        o.morphTargetDictionary[t[a]] = a;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function CV(o) {
  let e;
  const t = o.extensions && o.extensions[Ai.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + GC(t.attributes) : e = o.indices + ":" + GC(o.attributes) + ":" + o.mode, o.targets !== void 0)
    for (let a = 0, r = o.targets.length; a < r; a++)
      e += ":" + GC(o.targets[a]);
  return e;
}
function GC(o) {
  let e = "";
  const t = Object.keys(o).sort();
  for (let a = 0, r = t.length; a < r; a++)
    e += t[a] + ":" + o[t[a]] + ";";
  return e;
}
function f2(o) {
  switch (o) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function RV(o) {
  return o.search(/\.jpe?g($|\?)/i) > 0 || o.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : o.search(/\.webp($|\?)/i) > 0 || o.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const DV = /* @__PURE__ */ new ia();
class BV {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new WI(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let a = !1, r = !1, d = -1;
    typeof navigator < "u" && typeof navigator.userAgent < "u" && (a = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, r = navigator.userAgent.indexOf("Firefox") > -1, d = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || a || r && d < 98 ? this.textureLoader = new JO(this.options.manager) : this.textureLoader = new aw(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new of(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const a = this, r = this.json, d = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(p) {
      return p._markDefs && p._markDefs();
    }), Promise.all(
      this._invokeAll(function(p) {
        return p.beforeRoot && p.beforeRoot();
      })
    ).then(function() {
      return Promise.all([
        a.getDependencies("scene"),
        a.getDependencies("animation"),
        a.getDependencies("camera")
      ]);
    }).then(function(p) {
      const y = {
        scene: p[0][r.scene || 0],
        scenes: p[0],
        animations: p[1],
        cameras: p[2],
        asset: r.asset,
        parser: a,
        userData: {}
      };
      return NS(d, y, r), Vy(y, r), Promise.all(
        a._invokeAll(function(_) {
          return _.afterRoot && _.afterRoot(y);
        })
      ).then(function() {
        for (const _ of y.scenes)
          _.updateMatrixWorld();
        e(y);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], a = this.json.meshes || [];
    for (let r = 0, d = t.length; r < d; r++) {
      const p = t[r].joints;
      for (let y = 0, _ = p.length; y < _; y++)
        e[p[y]].isBone = !0;
    }
    for (let r = 0, d = e.length; r < d; r++) {
      const p = e[r];
      p.mesh !== void 0 && (this._addNodeRef(this.meshCache, p.mesh), p.skin !== void 0 && (a[p.mesh].isSkinnedMesh = !0)), p.camera !== void 0 && this._addNodeRef(this.cameraCache, p.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, a) {
    if (e.refs[t] <= 1)
      return a;
    const r = a.clone(), d = (p, y) => {
      const _ = this.associations.get(p);
      _ != null && this.associations.set(y, _);
      for (const [E, T] of p.children.entries())
        d(T, y.children[E]);
    };
    return d(a, r), r.name += "_instance_" + e.uses[t]++, r;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let a = 0; a < t.length; a++) {
      const r = e(t[a]);
      if (r)
        return r;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const a = [];
    for (let r = 0; r < t.length; r++) {
      const d = e(t[r]);
      d && a.push(d);
    }
    return a;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const a = e + ":" + t;
    let r = this.cache.get(a);
    if (!r) {
      switch (e) {
        case "scene":
          r = this.loadScene(t);
          break;
        case "node":
          r = this._invokeOne(function(d) {
            return d.loadNode && d.loadNode(t);
          });
          break;
        case "mesh":
          r = this._invokeOne(function(d) {
            return d.loadMesh && d.loadMesh(t);
          });
          break;
        case "accessor":
          r = this.loadAccessor(t);
          break;
        case "bufferView":
          r = this._invokeOne(function(d) {
            return d.loadBufferView && d.loadBufferView(t);
          });
          break;
        case "buffer":
          r = this.loadBuffer(t);
          break;
        case "material":
          r = this._invokeOne(function(d) {
            return d.loadMaterial && d.loadMaterial(t);
          });
          break;
        case "texture":
          r = this._invokeOne(function(d) {
            return d.loadTexture && d.loadTexture(t);
          });
          break;
        case "skin":
          r = this.loadSkin(t);
          break;
        case "animation":
          r = this._invokeOne(function(d) {
            return d.loadAnimation && d.loadAnimation(t);
          });
          break;
        case "camera":
          r = this.loadCamera(t);
          break;
        default:
          if (r = this._invokeOne(function(d) {
            return d != this && d.getDependency && d.getDependency(e, t);
          }), !r)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(a, r);
    }
    return r;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const a = this, r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(
        r.map(function(d, p) {
          return a.getDependency(e, p);
        })
      ), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], a = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ai.KHR_BINARY_GLTF].body);
    const r = this.options;
    return new Promise(function(d, p) {
      a.load(P0.resolveURL(t.uri, r.path), d, void 0, function() {
        p(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(a) {
      const r = t.byteLength || 0, d = t.byteOffset || 0;
      return a.slice(d, d + r);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, a = this.json, r = this.json.accessors[e];
    if (r.bufferView === void 0 && r.sparse === void 0) {
      const p = HC[r.type], y = d1[r.componentType], _ = r.normalized === !0, E = new y(r.count * p);
      return Promise.resolve(new Hi(E, p, _));
    }
    const d = [];
    return r.bufferView !== void 0 ? d.push(this.getDependency("bufferView", r.bufferView)) : d.push(null), r.sparse !== void 0 && (d.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), d.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(d).then(function(p) {
      const y = p[0], _ = HC[r.type], E = d1[r.componentType], T = E.BYTES_PER_ELEMENT, C = T * _, D = r.byteOffset || 0, B = r.bufferView !== void 0 ? a.bufferViews[r.bufferView].byteStride : void 0, z = r.normalized === !0;
      let V, G;
      if (B && B !== C) {
        const N = Math.floor(D / B), F = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + N + ":" + r.count;
        let q = t.cache.get(F);
        q || (V = new E(y, N * B, r.count * B / T), q = new cE(V, B / T), t.cache.add(F, q)), G = new Z0(
          q,
          _,
          D % B / T,
          z
        );
      } else
        y === null ? V = new E(r.count * _) : V = new E(y, D, r.count * _), G = new Hi(V, _, z);
      if (r.sparse !== void 0) {
        const N = HC.SCALAR, F = d1[r.sparse.indices.componentType], q = r.sparse.indices.byteOffset || 0, Y = r.sparse.values.byteOffset || 0, ie = new F(
          p[1],
          q,
          r.sparse.count * N
        ), k = new E(p[2], Y, r.sparse.count * _);
        y !== null && (G = new Hi(
          G.array.slice(),
          G.itemSize,
          G.normalized
        ));
        for (let le = 0, ne = ie.length; le < ne; le++) {
          const Q = ie[le];
          if (G.setX(Q, k[le * _]), _ >= 2 && G.setY(Q, k[le * _ + 1]), _ >= 3 && G.setZ(Q, k[le * _ + 2]), _ >= 4 && G.setW(Q, k[le * _ + 3]), _ >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return G;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, a = this.options, d = t.textures[e].source, p = t.images[d];
    let y = this.textureLoader;
    if (p.uri) {
      const _ = a.manager.getHandler(p.uri);
      _ !== null && (y = _);
    }
    return this.loadTextureImage(e, d, y);
  }
  loadTextureImage(e, t, a) {
    const r = this, d = this.json, p = d.textures[e], y = d.images[t], _ = (y.uri || y.bufferView) + ":" + p.sampler;
    if (this.textureCache[_])
      return this.textureCache[_];
    const E = this.loadImageSource(t, a).then(function(T) {
      T.flipY = !1, T.name = p.name || y.name || "", T.name === "" && typeof y.uri == "string" && y.uri.startsWith("data:image/") === !1 && (T.name = y.uri);
      const D = (d.samplers || {})[p.sampler] || {};
      return T.magFilter = yU[D.magFilter] || Ni, T.minFilter = yU[D.minFilter] || qm, T.wrapS = SU[D.wrapS] || q0, T.wrapT = SU[D.wrapT] || q0, r.associations.set(T, { textures: e }), T;
    }).catch(function() {
      return null;
    });
    return this.textureCache[_] = E, E;
  }
  loadImageSource(e, t) {
    const a = this, r = this.json, d = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((C) => C.clone());
    const p = r.images[e], y = self.URL || self.webkitURL;
    let _ = p.uri || "", E = !1;
    if (p.bufferView !== void 0)
      _ = a.getDependency("bufferView", p.bufferView).then(function(C) {
        E = !0;
        const D = new Blob([C], { type: p.mimeType });
        return _ = y.createObjectURL(D), _;
      });
    else if (p.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const T = Promise.resolve(_).then(function(C) {
      return new Promise(function(D, B) {
        let z = D;
        t.isImageBitmapLoader === !0 && (z = function(V) {
          const G = new Ml(V);
          G.needsUpdate = !0, D(G);
        }), t.load(P0.resolveURL(C, d.path), z, void 0, B);
      });
    }).then(function(C) {
      return E === !0 && y.revokeObjectURL(_), Vy(C, p), C.userData.mimeType = p.mimeType || RV(p.uri), C;
    }).catch(function(C) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", _), C;
    });
    return this.sourceCache[e] = T, T;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, a, r) {
    const d = this;
    return this.getDependency("texture", a.index).then(function(p) {
      if (!p)
        return null;
      if (a.texCoord !== void 0 && a.texCoord > 0 && (p = p.clone(), p.channel = a.texCoord), d.extensions[Ai.KHR_TEXTURE_TRANSFORM]) {
        const y = a.extensions !== void 0 ? a.extensions[Ai.KHR_TEXTURE_TRANSFORM] : void 0;
        if (y) {
          const _ = d.associations.get(p);
          p = d.extensions[Ai.KHR_TEXTURE_TRANSFORM].extendTexture(p, y), d.associations.set(p, _);
        }
      }
      return r !== void 0 && (typeof r == "number" && (r = r === vU ? ZS : Zy), "colorSpace" in p ? p.colorSpace = r : p.encoding = r === ZS ? vU : kI), e[t] = p, p;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let a = e.material;
    const r = t.attributes.tangent === void 0, d = t.attributes.color !== void 0, p = t.attributes.normal === void 0;
    if (e.isPoints) {
      const y = "PointsMaterial:" + a.uuid;
      let _ = this.cache.get(y);
      _ || (_ = new yx(), Vu.prototype.copy.call(_, a), _.color.copy(a.color), _.map = a.map, _.sizeAttenuation = !1, this.cache.add(y, _)), a = _;
    } else if (e.isLine) {
      const y = "LineBasicMaterial:" + a.uuid;
      let _ = this.cache.get(y);
      _ || (_ = new nd(), Vu.prototype.copy.call(_, a), _.color.copy(a.color), _.map = a.map, this.cache.add(y, _)), a = _;
    }
    if (r || d || p) {
      let y = "ClonedMaterial:" + a.uuid + ":";
      r && (y += "derivative-tangents:"), d && (y += "vertex-colors:"), p && (y += "flat-shading:");
      let _ = this.cache.get(y);
      _ || (_ = a.clone(), d && (_.vertexColors = !0), p && (_.flatShading = !0), r && (_.normalScale && (_.normalScale.y *= -1), _.clearcoatNormalScale && (_.clearcoatNormalScale.y *= -1)), this.cache.add(y, _), this.associations.set(_, this.associations.get(a))), a = _;
    }
    e.material = a;
  }
  getMaterialType() {
    return B1;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, a = this.json, r = this.extensions, d = a.materials[e];
    let p;
    const y = {}, _ = d.extensions || {}, E = [];
    if (_[Ai.KHR_MATERIALS_UNLIT]) {
      const C = r[Ai.KHR_MATERIALS_UNLIT];
      p = C.getMaterialType(), E.push(C.extendParams(y, d, t));
    } else {
      const C = d.pbrMetallicRoughness || {};
      if (y.color = new hn(1, 1, 1), y.opacity = 1, Array.isArray(C.baseColorFactor)) {
        const D = C.baseColorFactor;
        y.color.setRGB(D[0], D[1], D[2], Zy), y.opacity = D[3];
      }
      C.baseColorTexture !== void 0 && E.push(t.assignTexture(y, "map", C.baseColorTexture, ZS)), y.metalness = C.metallicFactor !== void 0 ? C.metallicFactor : 1, y.roughness = C.roughnessFactor !== void 0 ? C.roughnessFactor : 1, C.metallicRoughnessTexture !== void 0 && (E.push(t.assignTexture(y, "metalnessMap", C.metallicRoughnessTexture)), E.push(t.assignTexture(y, "roughnessMap", C.metallicRoughnessTexture))), p = this._invokeOne(function(D) {
        return D.getMaterialType && D.getMaterialType(e);
      }), E.push(
        Promise.all(
          this._invokeAll(function(D) {
            return D.extendMaterialParams && D.extendMaterialParams(e, y);
          })
        )
      );
    }
    d.doubleSided === !0 && (y.side = Lp);
    const T = d.alphaMode || LC.OPAQUE;
    if (T === LC.BLEND ? (y.transparent = !0, y.depthWrite = !1) : (y.transparent = !1, T === LC.MASK && (y.alphaTest = d.alphaCutoff !== void 0 ? d.alphaCutoff : 0.5)), d.normalTexture !== void 0 && p !== Yh && (E.push(t.assignTexture(y, "normalMap", d.normalTexture)), y.normalScale = new Ot(1, 1), d.normalTexture.scale !== void 0)) {
      const C = d.normalTexture.scale;
      y.normalScale.set(C, C);
    }
    if (d.occlusionTexture !== void 0 && p !== Yh && (E.push(t.assignTexture(y, "aoMap", d.occlusionTexture)), d.occlusionTexture.strength !== void 0 && (y.aoMapIntensity = d.occlusionTexture.strength)), d.emissiveFactor !== void 0 && p !== Yh) {
      const C = d.emissiveFactor;
      y.emissive = new hn().setRGB(
        C[0],
        C[1],
        C[2],
        Zy
      );
    }
    return d.emissiveTexture !== void 0 && p !== Yh && E.push(t.assignTexture(y, "emissiveMap", d.emissiveTexture, ZS)), Promise.all(E).then(function() {
      const C = new p(y);
      return d.name && (C.name = d.name), Vy(C, d), t.associations.set(C, { materials: e }), d.extensions && NS(r, C, d), C;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Yi.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, a = this.extensions, r = this.primitiveCache;
    function d(y) {
      return a[Ai.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(y, t).then(function(_) {
        return _U(_, y, t);
      });
    }
    const p = [];
    for (let y = 0, _ = e.length; y < _; y++) {
      const E = e[y], T = CV(E), C = r[T];
      if (C)
        p.push(C.promise);
      else {
        let D;
        E.extensions && E.extensions[Ai.KHR_DRACO_MESH_COMPRESSION] ? D = d(E) : D = _U(new Pa(), E, t), r[T] = { primitive: E, promise: D }, p.push(D);
      }
    }
    return Promise.all(p);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, a = this.json, r = this.extensions, d = a.meshes[e], p = d.primitives, y = [];
    for (let _ = 0, E = p.length; _ < E; _++) {
      const T = p[_].material === void 0 ? MV(this.cache) : this.getDependency("material", p[_].material);
      y.push(T);
    }
    return y.push(t.loadGeometries(p)), Promise.all(y).then(function(_) {
      const E = _.slice(0, _.length - 1), T = _[_.length - 1], C = [];
      for (let B = 0, z = T.length; B < z; B++) {
        const V = T[B], G = p[B];
        let N;
        const F = E[B];
        if (G.mode === Xm.TRIANGLES || G.mode === Xm.TRIANGLE_STRIP || G.mode === Xm.TRIANGLE_FAN || G.mode === void 0)
          N = d.isSkinnedMesh === !0 ? new D2(V, F) : new es(V, F), N.isSkinnedMesh === !0 && N.normalizeSkinWeights(), G.mode === Xm.TRIANGLE_STRIP ? N.geometry = dU(N.geometry, A2) : G.mode === Xm.TRIANGLE_FAN && (N.geometry = dU(N.geometry, ZM));
        else if (G.mode === Xm.LINES)
          N = new kv(V, F);
        else if (G.mode === Xm.LINE_STRIP)
          N = new Qy(V, F);
        else if (G.mode === Xm.LINE_LOOP)
          N = new U2(V, F);
        else if (G.mode === Xm.POINTS)
          N = new O2(V, F);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + G.mode);
        Object.keys(N.geometry.morphAttributes).length > 0 && TV(N, d), N.name = t.createUniqueName(d.name || "mesh_" + e), Vy(N, d), G.extensions && NS(r, N, G), t.assignFinalMaterial(N), C.push(N);
      }
      for (let B = 0, z = C.length; B < z; B++)
        t.associations.set(C[B], {
          meshes: e,
          primitives: B
        });
      if (C.length === 1)
        return d.extensions && NS(r, C[0], d), C[0];
      const D = new Xy();
      d.extensions && NS(r, D, d), t.associations.set(D, { meshes: e });
      for (let B = 0, z = C.length; B < z; B++)
        D.add(C[B]);
      return D;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const a = this.json.cameras[e], r = a[a.type];
    if (!r) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return a.type === "perspective" ? t = new Ls(
      dx.radToDeg(r.yfov),
      r.aspectRatio || 1,
      r.znear || 1,
      r.zfar || 2e6
    ) : a.type === "orthographic" && (t = new Zm(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), a.name && (t.name = this.createUniqueName(a.name)), Vy(t, a), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], a = [];
    for (let r = 0, d = t.joints.length; r < d; r++)
      a.push(this._loadNodeShallow(t.joints[r]));
    return t.inverseBindMatrices !== void 0 ? a.push(this.getDependency("accessor", t.inverseBindMatrices)) : a.push(null), Promise.all(a).then(function(r) {
      const d = r.pop(), p = r, y = [], _ = [];
      for (let E = 0, T = p.length; E < T; E++) {
        const C = p[E];
        if (C) {
          y.push(C);
          const D = new ia();
          d !== null && D.fromArray(d.array, E * 16), _.push(D);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[E]);
      }
      return new fE(y, _);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, a = this, r = t.animations[e], d = r.name ? r.name : "animation_" + e, p = [], y = [], _ = [], E = [], T = [];
    for (let C = 0, D = r.channels.length; C < D; C++) {
      const B = r.channels[C], z = r.samplers[B.sampler], V = B.target, G = V.node, N = r.parameters !== void 0 ? r.parameters[z.input] : z.input, F = r.parameters !== void 0 ? r.parameters[z.output] : z.output;
      V.node !== void 0 && (p.push(this.getDependency("node", G)), y.push(this.getDependency("accessor", N)), _.push(this.getDependency("accessor", F)), E.push(z), T.push(V));
    }
    return Promise.all([
      Promise.all(p),
      Promise.all(y),
      Promise.all(_),
      Promise.all(E),
      Promise.all(T)
    ]).then(function(C) {
      const D = C[0], B = C[1], z = C[2], V = C[3], G = C[4], N = [];
      for (let F = 0, q = D.length; F < q; F++) {
        const Y = D[F], ie = B[F], k = z[F], le = V[F], ne = G[F];
        if (Y === void 0)
          continue;
        Y.updateMatrix && Y.updateMatrix();
        const Q = a._createAnimationTracks(Y, ie, k, le, ne);
        if (Q)
          for (let j = 0; j < Q.length; j++)
            N.push(Q[j]);
      }
      return new M1(d, void 0, N);
    });
  }
  createNodeMesh(e) {
    const t = this.json, a = this, r = t.nodes[e];
    return r.mesh === void 0 ? null : a.getDependency("mesh", r.mesh).then(function(d) {
      const p = a._getNodeRef(a.meshCache, r.mesh, d);
      return r.weights !== void 0 && p.traverse(function(y) {
        if (y.isMesh)
          for (let _ = 0, E = r.weights.length; _ < E; _++)
            y.morphTargetInfluences[_] = r.weights[_];
      }), p;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, a = this, r = t.nodes[e], d = a._loadNodeShallow(e), p = [], y = r.children || [];
    for (let E = 0, T = y.length; E < T; E++)
      p.push(a.getDependency("node", y[E]));
    const _ = r.skin === void 0 ? Promise.resolve(null) : a.getDependency("skin", r.skin);
    return Promise.all([d, Promise.all(p), _]).then(function(E) {
      const T = E[0], C = E[1], D = E[2];
      D !== null && T.traverse(function(B) {
        B.isSkinnedMesh && B.bind(D, DV);
      });
      for (let B = 0, z = C.length; B < z; B++)
        T.add(C[B]);
      return T;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, a = this.extensions, r = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const d = t.nodes[e], p = d.name ? r.createUniqueName(d.name) : "", y = [], _ = r._invokeOne(function(E) {
      return E.createNodeMesh && E.createNodeMesh(e);
    });
    return _ && y.push(_), d.camera !== void 0 && y.push(
      r.getDependency("camera", d.camera).then(function(E) {
        return r._getNodeRef(r.cameraCache, d.camera, E);
      })
    ), r._invokeAll(function(E) {
      return E.createNodeAttachment && E.createNodeAttachment(e);
    }).forEach(function(E) {
      y.push(E);
    }), this.nodeCache[e] = Promise.all(y).then(function(E) {
      let T;
      if (d.isBone === !0 ? T = new gx() : E.length > 1 ? T = new Xy() : E.length === 1 ? T = E[0] : T = new zi(), T !== E[0])
        for (let C = 0, D = E.length; C < D; C++)
          T.add(E[C]);
      if (d.name && (T.userData.name = d.name, T.name = p), Vy(T, d), d.extensions && NS(a, T, d), d.matrix !== void 0) {
        const C = new ia();
        C.fromArray(d.matrix), T.applyMatrix4(C);
      } else
        d.translation !== void 0 && T.position.fromArray(d.translation), d.rotation !== void 0 && T.quaternion.fromArray(d.rotation), d.scale !== void 0 && T.scale.fromArray(d.scale);
      return r.associations.has(T) || r.associations.set(T, {}), r.associations.get(T).nodes = e, T;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, a = this.json.scenes[e], r = this, d = new Xy();
    a.name && (d.name = r.createUniqueName(a.name)), Vy(d, a), a.extensions && NS(t, d, a);
    const p = a.nodes || [], y = [];
    for (let _ = 0, E = p.length; _ < E; _++)
      y.push(r.getDependency("node", p[_]));
    return Promise.all(y).then(function(_) {
      for (let T = 0, C = _.length; T < C; T++)
        d.add(_[T]);
      const E = (T) => {
        const C = /* @__PURE__ */ new Map();
        for (const [D, B] of r.associations)
          (D instanceof Vu || D instanceof Ml) && C.set(D, B);
        return T.traverse((D) => {
          const B = r.associations.get(D);
          B != null && C.set(D, B);
        }), C;
      };
      return r.associations = E(d), d;
    });
  }
  _createAnimationTracks(e, t, a, r, d) {
    const p = [], y = e.name ? e.name : e.uuid, _ = [];
    G0[d.path] === G0.weights ? e.traverse(function(D) {
      D.morphTargetInfluences && _.push(D.name ? D.name : D.uuid);
    }) : _.push(y);
    let E;
    switch (G0[d.path]) {
      case G0.weights:
        E = t_;
        break;
      case G0.rotation:
        E = n_;
        break;
      case G0.position:
      case G0.scale:
        E = a_;
        break;
      default:
        switch (a.itemSize) {
          case 1:
            E = t_;
            break;
          case 2:
          case 3:
          default:
            E = a_;
            break;
        }
        break;
    }
    const T = r.interpolation !== void 0 ? bV[r.interpolation] : S1, C = this._getArrayFromAccessor(a);
    for (let D = 0, B = _.length; D < B; D++) {
      const z = new E(
        _[D] + "." + G0[d.path],
        t.array,
        C,
        T
      );
      r.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(z), p.push(z);
    }
    return p;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const a = f2(t.constructor), r = new Float32Array(t.length);
      for (let d = 0, p = t.length; d < p; d++)
        r[d] = t[d] * a;
      t = r;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(a) {
      const r = this instanceof n_ ? EV : jw;
      return new r(this.times, this.values, this.getValueSize() / 3, a);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function UV(o, e, t) {
  const a = e.attributes, r = new td();
  if (a.POSITION !== void 0) {
    const y = t.json.accessors[a.POSITION], _ = y.min, E = y.max;
    if (_ !== void 0 && E !== void 0) {
      if (r.set(new ve(_[0], _[1], _[2]), new ve(E[0], E[1], E[2])), y.normalized) {
        const T = f2(d1[y.componentType]);
        r.min.multiplyScalar(T), r.max.multiplyScalar(T);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const d = e.targets;
  if (d !== void 0) {
    const y = new ve(), _ = new ve();
    for (let E = 0, T = d.length; E < T; E++) {
      const C = d[E];
      if (C.POSITION !== void 0) {
        const D = t.json.accessors[C.POSITION], B = D.min, z = D.max;
        if (B !== void 0 && z !== void 0) {
          if (_.setX(Math.max(Math.abs(B[0]), Math.abs(z[0]))), _.setY(Math.max(Math.abs(B[1]), Math.abs(z[1]))), _.setZ(Math.max(Math.abs(B[2]), Math.abs(z[2]))), D.normalized) {
            const V = f2(d1[D.componentType]);
            _.multiplyScalar(V);
          }
          y.max(_);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    r.expandByVector(y);
  }
  o.boundingBox = r;
  const p = new rf();
  r.getCenter(p.center), p.radius = r.min.distanceTo(r.max) / 2, o.boundingSphere = p;
}
function _U(o, e, t) {
  const a = e.attributes, r = [];
  function d(p, y) {
    return t.getDependency("accessor", p).then(function(_) {
      o.setAttribute(y, _);
    });
  }
  for (const p in a) {
    const y = c2[p] || p.toLowerCase();
    y in o.attributes || r.push(d(a[p], y));
  }
  if (e.indices !== void 0 && !o.index) {
    const p = t.getDependency("accessor", e.indices).then(function(y) {
      o.setIndex(y);
    });
    r.push(p);
  }
  return Vy(o, e), UV(o, e, t), Promise.all(r).then(function() {
    return e.targets !== void 0 ? xV(o, e.targets, t) : o;
  });
}
const OV = {
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `
  )
}, wV = {
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `
  ),
  fragmentShader: (
    /* glsl */
    `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `
  )
};
class NV extends X2 {
  constructor(e) {
    super(e), this.type = au;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const p = function(ne, Q) {
      switch (ne) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (Q || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (Q || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (Q || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (Q || ""));
      }
    }, T = `
`, C = function(ne, Q, j) {
      Q = Q || 1024;
      let _e = ne.pos, me = -1, Ae = 0, He = "", P = String.fromCharCode.apply(null, new Uint16Array(ne.subarray(_e, _e + 128)));
      for (; 0 > (me = P.indexOf(T)) && Ae < Q && _e < ne.byteLength; )
        He += P, Ae += P.length, _e += 128, P += String.fromCharCode.apply(null, new Uint16Array(ne.subarray(_e, _e + 128)));
      return -1 < me ? (ne.pos += Ae + me + 1, He + P.slice(0, me)) : !1;
    }, D = function(ne) {
      const Q = /^#\?(\S+)/, j = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, _e = /^\s*FORMAT=(\S+)\s*$/, me = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, Ae = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let He, P;
      for ((ne.pos >= ne.byteLength || !(He = C(ne))) && p(1, "no header found"), (P = He.match(Q)) || p(3, "bad initial token"), Ae.valid |= 1, Ae.programtype = P[1], Ae.string += He + `
`; He = C(ne), He !== !1; ) {
        if (Ae.string += He + `
`, He.charAt(0) === "#") {
          Ae.comments += He + `
`;
          continue;
        }
        if ((P = He.match(j)) && (Ae.gamma = parseFloat(P[1])), (P = He.match(re)) && (Ae.exposure = parseFloat(P[1])), (P = He.match(_e)) && (Ae.valid |= 2, Ae.format = P[1]), (P = He.match(me)) && (Ae.valid |= 4, Ae.height = parseInt(P[1], 10), Ae.width = parseInt(P[2], 10)), Ae.valid & 2 && Ae.valid & 4)
          break;
      }
      return Ae.valid & 2 || p(3, "missing format specifier"), Ae.valid & 4 || p(3, "missing image size specifier"), Ae;
    }, B = function(ne, Q, j) {
      const re = Q;
      if (
        // run length encoding is not allowed so read flat
        re < 8 || re > 32767 || // this file is not run length encoded
        ne[0] !== 2 || ne[1] !== 2 || ne[2] & 128
      )
        return new Uint8Array(ne);
      re !== (ne[2] << 8 | ne[3]) && p(3, "wrong scanline width");
      const _e = new Uint8Array(4 * Q * j);
      _e.length || p(4, "unable to allocate buffer space");
      let me = 0, Ae = 0;
      const He = 4 * re, P = new Uint8Array(4), te = new Uint8Array(He);
      let ae = j;
      for (; ae > 0 && Ae < ne.byteLength; ) {
        Ae + 4 > ne.byteLength && p(1), P[0] = ne[Ae++], P[1] = ne[Ae++], P[2] = ne[Ae++], P[3] = ne[Ae++], (P[0] != 2 || P[1] != 2 || (P[2] << 8 | P[3]) != re) && p(3, "bad rgbe scanline format");
        let Se = 0, ue;
        for (; Se < He && Ae < ne.byteLength; ) {
          ue = ne[Ae++];
          const De = ue > 128;
          if (De && (ue -= 128), (ue === 0 || Se + ue > He) && p(3, "bad scanline data"), De) {
            const We = ne[Ae++];
            for (let Me = 0; Me < ue; Me++)
              te[Se++] = We;
          } else
            te.set(ne.subarray(Ae, Ae + ue), Se), Se += ue, Ae += ue;
        }
        const we = re;
        for (let De = 0; De < we; De++) {
          let We = 0;
          _e[me] = te[De + We], We += re, _e[me + 1] = te[De + We], We += re, _e[me + 2] = te[De + We], We += re, _e[me + 3] = te[De + We], me += 4;
        }
        ae--;
      }
      return _e;
    }, z = function(ne, Q, j, re) {
      const _e = ne[Q + 3], me = Math.pow(2, _e - 128) / 255;
      j[re + 0] = ne[Q + 0] * me, j[re + 1] = ne[Q + 1] * me, j[re + 2] = ne[Q + 2] * me, j[re + 3] = 1;
    }, V = function(ne, Q, j, re) {
      const _e = ne[Q + 3], me = Math.pow(2, _e - 128) / 255;
      j[re + 0] = XS.toHalfFloat(Math.min(ne[Q + 0] * me, 65504)), j[re + 1] = XS.toHalfFloat(Math.min(ne[Q + 1] * me, 65504)), j[re + 2] = XS.toHalfFloat(Math.min(ne[Q + 2] * me, 65504)), j[re + 3] = XS.toHalfFloat(1);
    }, G = new Uint8Array(e);
    G.pos = 0;
    const N = D(G), F = N.width, q = N.height, Y = B(G.subarray(G.pos), F, q);
    let ie, k, le;
    switch (this.type) {
      case pr:
        le = Y.length / 4;
        const ne = new Float32Array(le * 4);
        for (let j = 0; j < le; j++)
          z(Y, j * 4, ne, j * 4);
        ie = ne, k = pr;
        break;
      case au:
        le = Y.length / 4;
        const Q = new Uint16Array(le * 4);
        for (let j = 0; j < le; j++)
          V(Y, j * 4, Q, j * 4);
        ie = Q, k = au;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: F,
      height: q,
      data: ie,
      header: N.string,
      gamma: N.gamma,
      exposure: N.exposure,
      type: k
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, a, r) {
    function d(p, y) {
      switch (p.type) {
        case pr:
        case au:
          "colorSpace" in p ? p.colorSpace = "srgb-linear" : p.encoding = 3e3, p.minFilter = Ni, p.magFilter = Ni, p.generateMipmaps = !1, p.flipY = !0;
          break;
      }
      t && t(p, y);
    }
    return super.load(e, d, a, r);
  }
}
const TA = Ix >= 152;
class zV extends X2 {
  constructor(e) {
    super(e), this.type = au;
  }
  parse(e) {
    const Q = Math.pow(2.7182818, 2.2);
    function j($, pe) {
      for (var Ne = 0, $e = 0; $e < 65536; ++$e)
        ($e == 0 || $[$e >> 3] & 1 << ($e & 7)) && (pe[Ne++] = $e);
      for (var nt = Ne - 1; Ne < 65536; )
        pe[Ne++] = 0;
      return nt;
    }
    function re($) {
      for (var pe = 0; pe < 16384; pe++)
        $[pe] = {}, $[pe].len = 0, $[pe].lit = 0, $[pe].p = null;
    }
    const _e = { l: 0, c: 0, lc: 0 };
    function me($, pe, Ne, $e, nt) {
      for (; Ne < $; )
        pe = pe << 8 | jt($e, nt), Ne += 8;
      Ne -= $, _e.l = pe >> Ne & (1 << $) - 1, _e.c = pe, _e.lc = Ne;
    }
    const Ae = new Array(59);
    function He($) {
      for (var pe = 0; pe <= 58; ++pe)
        Ae[pe] = 0;
      for (var pe = 0; pe < 65537; ++pe)
        Ae[$[pe]] += 1;
      for (var Ne = 0, pe = 58; pe > 0; --pe) {
        var $e = Ne + Ae[pe] >> 1;
        Ae[pe] = Ne, Ne = $e;
      }
      for (var pe = 0; pe < 65537; ++pe) {
        var nt = $[pe];
        nt > 0 && ($[pe] = nt | Ae[nt]++ << 6);
      }
    }
    function P($, pe, Ne, $e, nt, pt, Ft) {
      for (var Gt = Ne, ee = 0, ye = 0; nt <= pt; nt++) {
        if (Gt.value - Ne.value > $e)
          return !1;
        me(6, ee, ye, $, Gt);
        var Ee = _e.l;
        if (ee = _e.c, ye = _e.lc, Ft[nt] = Ee, Ee == 63) {
          if (Gt.value - Ne.value > $e)
            throw "Something wrong with hufUnpackEncTable";
          me(8, ee, ye, $, Gt);
          var Re = _e.l + 6;
          if (ee = _e.c, ye = _e.lc, nt + Re > pt + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; Re--; )
            Ft[nt++] = 0;
          nt--;
        } else if (Ee >= 59) {
          var Re = Ee - 59 + 2;
          if (nt + Re > pt + 1)
            throw "Something wrong with hufUnpackEncTable";
          for (; Re--; )
            Ft[nt++] = 0;
          nt--;
        }
      }
      He(Ft);
    }
    function te($) {
      return $ & 63;
    }
    function ae($) {
      return $ >> 6;
    }
    function Se($, pe, Ne, $e) {
      for (; pe <= Ne; pe++) {
        var nt = ae($[pe]), pt = te($[pe]);
        if (nt >> pt)
          throw "Invalid table entry";
        if (pt > 14) {
          var Ft = $e[nt >> pt - 14];
          if (Ft.len)
            throw "Invalid table entry";
          if (Ft.lit++, Ft.p) {
            var Gt = Ft.p;
            Ft.p = new Array(Ft.lit);
            for (var ee = 0; ee < Ft.lit - 1; ++ee)
              Ft.p[ee] = Gt[ee];
          } else
            Ft.p = new Array(1);
          Ft.p[Ft.lit - 1] = pe;
        } else if (pt)
          for (var ye = 0, ee = 1 << 14 - pt; ee > 0; ee--) {
            var Ft = $e[(nt << 14 - pt) + ye];
            if (Ft.len || Ft.p)
              throw "Invalid table entry";
            Ft.len = pt, Ft.lit = pe, ye++;
          }
      }
      return !0;
    }
    const ue = { c: 0, lc: 0 };
    function we($, pe, Ne, $e) {
      $ = $ << 8 | jt(Ne, $e), pe += 8, ue.c = $, ue.lc = pe;
    }
    const De = { c: 0, lc: 0 };
    function We($, pe, Ne, $e, nt, pt, Ft, Gt, ee, ye) {
      if ($ == pe) {
        $e < 8 && (we(Ne, $e, nt, Ft), Ne = ue.c, $e = ue.lc), $e -= 8;
        var Ee = Ne >> $e, Ee = new Uint8Array([Ee])[0];
        if (ee.value + Ee > ye)
          return !1;
        for (var Re = Gt[ee.value - 1]; Ee-- > 0; )
          Gt[ee.value++] = Re;
      } else if (ee.value < ye)
        Gt[ee.value++] = $;
      else
        return !1;
      De.c = Ne, De.lc = $e;
    }
    function Me($) {
      return $ & 65535;
    }
    function Ze($) {
      var pe = Me($);
      return pe > 32767 ? pe - 65536 : pe;
    }
    const ct = { a: 0, b: 0 };
    function Vt($, pe) {
      var Ne = Ze($), $e = Ze(pe), nt = $e, pt = Ne + (nt & 1) + (nt >> 1), Ft = pt, Gt = pt - nt;
      ct.a = Ft, ct.b = Gt;
    }
    function Zt($, pe) {
      var Ne = Me($), $e = Me(pe), nt = Ne - ($e >> 1) & 65535, pt = $e + nt - 32768 & 65535;
      ct.a = pt, ct.b = nt;
    }
    function Bn($, pe, Ne, $e, nt, pt, Ft) {
      for (var Gt = Ft < 16384, ee = Ne > nt ? nt : Ne, ye = 1, Ee; ye <= ee; )
        ye <<= 1;
      for (ye >>= 1, Ee = ye, ye >>= 1; ye >= 1; ) {
        for (var Re = 0, Ie = Re + pt * (nt - Ee), je = pt * ye, _t = pt * Ee, Ut = $e * ye, It = $e * Ee, on, sn, Qt, bn; Re <= Ie; Re += _t) {
          for (var En = Re, ca = Re + $e * (Ne - Ee); En <= ca; En += It) {
            var yn = En + Ut, zn = En + je, xn = zn + Ut;
            Gt ? (Vt($[En + pe], $[zn + pe]), on = ct.a, Qt = ct.b, Vt($[yn + pe], $[xn + pe]), sn = ct.a, bn = ct.b, Vt(on, sn), $[En + pe] = ct.a, $[yn + pe] = ct.b, Vt(Qt, bn), $[zn + pe] = ct.a, $[xn + pe] = ct.b) : (Zt($[En + pe], $[zn + pe]), on = ct.a, Qt = ct.b, Zt($[yn + pe], $[xn + pe]), sn = ct.a, bn = ct.b, Zt(on, sn), $[En + pe] = ct.a, $[yn + pe] = ct.b, Zt(Qt, bn), $[zn + pe] = ct.a, $[xn + pe] = ct.b);
          }
          if (Ne & ye) {
            var zn = En + je;
            Gt ? Vt($[En + pe], $[zn + pe]) : Zt($[En + pe], $[zn + pe]), on = ct.a, $[zn + pe] = ct.b, $[En + pe] = on;
          }
        }
        if (nt & ye)
          for (var En = Re, ca = Re + $e * (Ne - Ee); En <= ca; En += It) {
            var yn = En + Ut;
            Gt ? Vt($[En + pe], $[yn + pe]) : Zt($[En + pe], $[yn + pe]), on = ct.a, $[yn + pe] = ct.b, $[En + pe] = on;
          }
        Ee = ye, ye >>= 1;
      }
      return Re;
    }
    function rn($, pe, Ne, $e, nt, pt, Ft, Gt, ee, ye) {
      for (var Ee = 0, Re = 0, Ie = Gt, je = Math.trunc(nt.value + (pt + 7) / 8); nt.value < je; )
        for (we(Ee, Re, Ne, nt), Ee = ue.c, Re = ue.lc; Re >= 14; ) {
          var _t = Ee >> Re - 14 & 16383, Ut = pe[_t];
          if (Ut.len)
            Re -= Ut.len, We(Ut.lit, Ft, Ee, Re, Ne, $e, nt, ee, ye, Ie), Ee = De.c, Re = De.lc;
          else {
            if (!Ut.p)
              throw "hufDecode issues";
            var It;
            for (It = 0; It < Ut.lit; It++) {
              for (var on = te($[Ut.p[It]]); Re < on && nt.value < je; )
                we(Ee, Re, Ne, nt), Ee = ue.c, Re = ue.lc;
              if (Re >= on && ae($[Ut.p[It]]) == (Ee >> Re - on & (1 << on) - 1)) {
                Re -= on, We(
                  Ut.p[It],
                  Ft,
                  Ee,
                  Re,
                  Ne,
                  $e,
                  nt,
                  ee,
                  ye,
                  Ie
                ), Ee = De.c, Re = De.lc;
                break;
              }
            }
            if (It == Ut.lit)
              throw "hufDecode issues";
          }
        }
      var sn = 8 - pt & 7;
      for (Ee >>= sn, Re -= sn; Re > 0; ) {
        var Ut = pe[Ee << 14 - Re & 16383];
        if (Ut.len)
          Re -= Ut.len, We(Ut.lit, Ft, Ee, Re, Ne, $e, nt, ee, ye, Ie), Ee = De.c, Re = De.lc;
        else
          throw "hufDecode issues";
      }
      return !0;
    }
    function dn($, pe, Ne, $e, nt, pt) {
      var Ft = { value: 0 }, Gt = Ne.value, ee = nn(pe, Ne), ye = nn(pe, Ne);
      Ne.value += 4;
      var Ee = nn(pe, Ne);
      if (Ne.value += 4, ee < 0 || ee >= 65537 || ye < 0 || ye >= 65537)
        throw "Something wrong with HUF_ENCSIZE";
      var Re = new Array(65537), Ie = new Array(16384);
      re(Ie);
      var je = $e - (Ne.value - Gt);
      if (P($, pe, Ne, je, ee, ye, Re), Ee > 8 * ($e - (Ne.value - Gt)))
        throw "Something wrong with hufUncompress";
      Se(Re, ee, ye, Ie), rn(Re, Ie, $, pe, Ne, Ee, ye, pt, nt, Ft);
    }
    function Zn($, pe, Ne) {
      for (var $e = 0; $e < Ne; ++$e)
        pe[$e] = $[pe[$e]];
    }
    function Rn($) {
      for (var pe = 1; pe < $.length; pe++) {
        var Ne = $[pe - 1] + $[pe] - 128;
        $[pe] = Ne;
      }
    }
    function Te($, pe) {
      for (var Ne = 0, $e = Math.floor(($.length + 1) / 2), nt = 0, pt = $.length - 1; !(nt > pt || (pe[nt++] = $[Ne++], nt > pt)); )
        pe[nt++] = $[$e++];
    }
    function Ha($) {
      for (var pe = $.byteLength, Ne = new Array(), $e = 0, nt = new DataView($); pe > 0; ) {
        var pt = nt.getInt8($e++);
        if (pt < 0) {
          var Ft = -pt;
          pe -= Ft + 1;
          for (var Gt = 0; Gt < Ft; Gt++)
            Ne.push(nt.getUint8($e++));
        } else {
          var Ft = pt;
          pe -= 2;
          for (var ee = nt.getUint8($e++), Gt = 0; Gt < Ft + 1; Gt++)
            Ne.push(ee);
        }
      }
      return Ne;
    }
    function Tt($, pe, Ne, $e, nt, pt) {
      var yn = new DataView(pt.buffer), Ft = Ne[$.idx[0]].width, Gt = Ne[$.idx[0]].height, ee = 3, ye = Math.floor(Ft / 8), Ee = Math.ceil(Ft / 8), Re = Math.ceil(Gt / 8), Ie = Ft - (Ee - 1) * 8, je = Gt - (Re - 1) * 8, _t = { value: 0 }, Ut = new Array(ee), It = new Array(ee), on = new Array(ee), sn = new Array(ee), Qt = new Array(ee);
      for (let ta = 0; ta < ee; ++ta)
        Qt[ta] = pe[$.idx[ta]], Ut[ta] = ta < 1 ? 0 : Ut[ta - 1] + Ee * Re, It[ta] = new Float32Array(64), on[ta] = new Uint16Array(64), sn[ta] = new Uint16Array(Ee * 64);
      for (let ta = 0; ta < Re; ++ta) {
        var bn = 8;
        ta == Re - 1 && (bn = je);
        var En = 8;
        for (let Qn = 0; Qn < Ee; ++Qn) {
          Qn == Ee - 1 && (En = Ie);
          for (let Ta = 0; Ta < ee; ++Ta)
            on[Ta].fill(0), on[Ta][0] = nt[Ut[Ta]++], St(_t, $e, on[Ta]), Mt(on[Ta], It[Ta]), kt(It[Ta]);
          At(It);
          for (let Ta = 0; Ta < ee; ++Ta)
            ce(It[Ta], sn[Ta], Qn * 64);
        }
        let Li = 0;
        for (let Qn = 0; Qn < ee; ++Qn) {
          const Ta = Ne[$.idx[Qn]].type;
          for (let da = 8 * ta; da < 8 * ta + bn; ++da) {
            Li = Qt[Qn][da];
            for (let qi = 0; qi < ye; ++qi) {
              const Ya = qi * 64 + (da & 7) * 8;
              yn.setUint16(Li + 0 * 2 * Ta, sn[Qn][Ya + 0], !0), yn.setUint16(Li + 1 * 2 * Ta, sn[Qn][Ya + 1], !0), yn.setUint16(Li + 2 * 2 * Ta, sn[Qn][Ya + 2], !0), yn.setUint16(Li + 3 * 2 * Ta, sn[Qn][Ya + 3], !0), yn.setUint16(Li + 4 * 2 * Ta, sn[Qn][Ya + 4], !0), yn.setUint16(Li + 5 * 2 * Ta, sn[Qn][Ya + 5], !0), yn.setUint16(Li + 6 * 2 * Ta, sn[Qn][Ya + 6], !0), yn.setUint16(Li + 7 * 2 * Ta, sn[Qn][Ya + 7], !0), Li += 8 * 2 * Ta;
            }
          }
          if (ye != Ee)
            for (let da = 8 * ta; da < 8 * ta + bn; ++da) {
              const qi = Qt[Qn][da] + 8 * ye * 2 * Ta, Ya = ye * 64 + (da & 7) * 8;
              for (let Ei = 0; Ei < En; ++Ei)
                yn.setUint16(qi + Ei * 2 * Ta, sn[Qn][Ya + Ei], !0);
            }
        }
      }
      for (var ca = new Uint16Array(Ft), yn = new DataView(pt.buffer), zn = 0; zn < ee; ++zn) {
        Ne[$.idx[zn]].decoded = !0;
        var xn = Ne[$.idx[zn]].type;
        if (Ne[zn].type == 2)
          for (var si = 0; si < Gt; ++si) {
            const ta = Qt[zn][si];
            for (var jn = 0; jn < Ft; ++jn)
              ca[jn] = yn.getUint16(ta + jn * 2 * xn, !0);
            for (var jn = 0; jn < Ft; ++jn)
              yn.setFloat32(ta + jn * 2 * xn, Je(ca[jn]), !0);
          }
      }
    }
    function St($, pe, Ne) {
      for (var $e, nt = 1; nt < 64; )
        $e = pe[$.value], $e == 65280 ? nt = 64 : $e >> 8 == 255 ? nt += $e & 255 : (Ne[nt] = $e, nt++), $.value++;
    }
    function Mt($, pe) {
      pe[0] = Je($[0]), pe[1] = Je($[1]), pe[2] = Je($[5]), pe[3] = Je($[6]), pe[4] = Je($[14]), pe[5] = Je($[15]), pe[6] = Je($[27]), pe[7] = Je($[28]), pe[8] = Je($[2]), pe[9] = Je($[4]), pe[10] = Je($[7]), pe[11] = Je($[13]), pe[12] = Je($[16]), pe[13] = Je($[26]), pe[14] = Je($[29]), pe[15] = Je($[42]), pe[16] = Je($[3]), pe[17] = Je($[8]), pe[18] = Je($[12]), pe[19] = Je($[17]), pe[20] = Je($[25]), pe[21] = Je($[30]), pe[22] = Je($[41]), pe[23] = Je($[43]), pe[24] = Je($[9]), pe[25] = Je($[11]), pe[26] = Je($[18]), pe[27] = Je($[24]), pe[28] = Je($[31]), pe[29] = Je($[40]), pe[30] = Je($[44]), pe[31] = Je($[53]), pe[32] = Je($[10]), pe[33] = Je($[19]), pe[34] = Je($[23]), pe[35] = Je($[32]), pe[36] = Je($[39]), pe[37] = Je($[45]), pe[38] = Je($[52]), pe[39] = Je($[54]), pe[40] = Je($[20]), pe[41] = Je($[22]), pe[42] = Je($[33]), pe[43] = Je($[38]), pe[44] = Je($[46]), pe[45] = Je($[51]), pe[46] = Je($[55]), pe[47] = Je($[60]), pe[48] = Je($[21]), pe[49] = Je($[34]), pe[50] = Je($[37]), pe[51] = Je($[47]), pe[52] = Je($[50]), pe[53] = Je($[56]), pe[54] = Je($[59]), pe[55] = Je($[61]), pe[56] = Je($[35]), pe[57] = Je($[36]), pe[58] = Je($[48]), pe[59] = Je($[49]), pe[60] = Je($[57]), pe[61] = Je($[58]), pe[62] = Je($[62]), pe[63] = Je($[63]);
    }
    function kt($) {
      const pe = 0.5 * Math.cos(0.7853975), Ne = 0.5 * Math.cos(3.14159 / 16), $e = 0.5 * Math.cos(3.14159 / 8), nt = 0.5 * Math.cos(3 * 3.14159 / 16), pt = 0.5 * Math.cos(5 * 3.14159 / 16), Ft = 0.5 * Math.cos(3 * 3.14159 / 8), Gt = 0.5 * Math.cos(7 * 3.14159 / 16);
      for (var ee = new Array(4), ye = new Array(4), Ee = new Array(4), Re = new Array(4), Ie = 0; Ie < 8; ++Ie) {
        var je = Ie * 8;
        ee[0] = $e * $[je + 2], ee[1] = Ft * $[je + 2], ee[2] = $e * $[je + 6], ee[3] = Ft * $[je + 6], ye[0] = Ne * $[je + 1] + nt * $[je + 3] + pt * $[je + 5] + Gt * $[je + 7], ye[1] = nt * $[je + 1] - Gt * $[je + 3] - Ne * $[je + 5] - pt * $[je + 7], ye[2] = pt * $[je + 1] - Ne * $[je + 3] + Gt * $[je + 5] + nt * $[je + 7], ye[3] = Gt * $[je + 1] - pt * $[je + 3] + nt * $[je + 5] - Ne * $[je + 7], Ee[0] = pe * ($[je + 0] + $[je + 4]), Ee[3] = pe * ($[je + 0] - $[je + 4]), Ee[1] = ee[0] + ee[3], Ee[2] = ee[1] - ee[2], Re[0] = Ee[0] + Ee[1], Re[1] = Ee[3] + Ee[2], Re[2] = Ee[3] - Ee[2], Re[3] = Ee[0] - Ee[1], $[je + 0] = Re[0] + ye[0], $[je + 1] = Re[1] + ye[1], $[je + 2] = Re[2] + ye[2], $[je + 3] = Re[3] + ye[3], $[je + 4] = Re[3] - ye[3], $[je + 5] = Re[2] - ye[2], $[je + 6] = Re[1] - ye[1], $[je + 7] = Re[0] - ye[0];
      }
      for (var _t = 0; _t < 8; ++_t)
        ee[0] = $e * $[16 + _t], ee[1] = Ft * $[16 + _t], ee[2] = $e * $[48 + _t], ee[3] = Ft * $[48 + _t], ye[0] = Ne * $[8 + _t] + nt * $[24 + _t] + pt * $[40 + _t] + Gt * $[56 + _t], ye[1] = nt * $[8 + _t] - Gt * $[24 + _t] - Ne * $[40 + _t] - pt * $[56 + _t], ye[2] = pt * $[8 + _t] - Ne * $[24 + _t] + Gt * $[40 + _t] + nt * $[56 + _t], ye[3] = Gt * $[8 + _t] - pt * $[24 + _t] + nt * $[40 + _t] - Ne * $[56 + _t], Ee[0] = pe * ($[_t] + $[32 + _t]), Ee[3] = pe * ($[_t] - $[32 + _t]), Ee[1] = ee[0] + ee[3], Ee[2] = ee[1] - ee[2], Re[0] = Ee[0] + Ee[1], Re[1] = Ee[3] + Ee[2], Re[2] = Ee[3] - Ee[2], Re[3] = Ee[0] - Ee[1], $[0 + _t] = Re[0] + ye[0], $[8 + _t] = Re[1] + ye[1], $[16 + _t] = Re[2] + ye[2], $[24 + _t] = Re[3] + ye[3], $[32 + _t] = Re[3] - ye[3], $[40 + _t] = Re[2] - ye[2], $[48 + _t] = Re[1] - ye[1], $[56 + _t] = Re[0] - ye[0];
    }
    function At($) {
      for (var pe = 0; pe < 64; ++pe) {
        var Ne = $[0][pe], $e = $[1][pe], nt = $[2][pe];
        $[0][pe] = Ne + 1.5747 * nt, $[1][pe] = Ne - 0.1873 * $e - 0.4682 * nt, $[2][pe] = Ne + 1.8556 * $e;
      }
    }
    function ce($, pe, Ne) {
      for (var $e = 0; $e < 64; ++$e)
        pe[Ne + $e] = XS.toHalfFloat(se($[$e]));
    }
    function se($) {
      return $ <= 1 ? Math.sign($) * Math.pow(Math.abs($), 2.2) : Math.sign($) * Math.pow(Q, Math.abs($) - 1);
    }
    function Xe($) {
      return new DataView($.array.buffer, $.offset.value, $.size);
    }
    function dt($) {
      var pe = $.viewer.buffer.slice($.offset.value, $.offset.value + $.size), Ne = new Uint8Array(Ha(pe)), $e = new Uint8Array(Ne.length);
      return Rn(Ne), Te(Ne, $e), new DataView($e.buffer);
    }
    function Et($) {
      var pe = $.array.slice($.offset.value, $.offset.value + $.size), Ne = $b(pe), $e = new Uint8Array(Ne.length);
      return Rn(Ne), Te(Ne, $e), new DataView($e.buffer);
    }
    function yt($) {
      for (var pe = $.viewer, Ne = { value: $.offset.value }, $e = new Uint16Array($.width * $.scanlineBlockSize * ($.channels * $.type)), nt = new Uint8Array(8192), pt = 0, Ft = new Array($.channels), Gt = 0; Gt < $.channels; Gt++)
        Ft[Gt] = {}, Ft[Gt].start = pt, Ft[Gt].end = Ft[Gt].start, Ft[Gt].nx = $.width, Ft[Gt].ny = $.lines, Ft[Gt].size = $.type, pt += Ft[Gt].nx * Ft[Gt].ny * Ft[Gt].size;
      var ee = tt(pe, Ne), ye = tt(pe, Ne);
      if (ye >= 8192)
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
      if (ee <= ye)
        for (var Gt = 0; Gt < ye - ee + 1; Gt++)
          nt[Gt + ee] = Ue(pe, Ne);
      var Ee = new Uint16Array(65536), Re = j(nt, Ee), Ie = nn(pe, Ne);
      dn($.array, pe, Ne, Ie, $e, pt);
      for (var Gt = 0; Gt < $.channels; ++Gt)
        for (var je = Ft[Gt], _t = 0; _t < Ft[Gt].size; ++_t)
          Bn($e, je.start + _t, je.nx, je.size, je.ny, je.nx * je.size, Re);
      Zn(Ee, $e, pt);
      for (var Ut = 0, It = new Uint8Array($e.buffer.byteLength), on = 0; on < $.lines; on++)
        for (var sn = 0; sn < $.channels; sn++) {
          var je = Ft[sn], Qt = je.nx * je.size, bn = new Uint8Array($e.buffer, je.end * 2, Qt * 2);
          It.set(bn, Ut), Ut += Qt * 2, je.end += Qt;
        }
      return new DataView(It.buffer);
    }
    function Jt($) {
      var pe = $.array.slice($.offset.value, $.offset.value + $.size), Ne = $b(pe);
      const $e = $.lines * $.channels * $.width, nt = $.type == 1 ? new Uint16Array($e) : new Uint32Array($e);
      let pt = 0, Ft = 0;
      const Gt = new Array(4);
      for (let ee = 0; ee < $.lines; ee++)
        for (let ye = 0; ye < $.channels; ye++) {
          let Ee = 0;
          switch ($.type) {
            case 1:
              Gt[0] = pt, Gt[1] = Gt[0] + $.width, pt = Gt[1] + $.width;
              for (let Re = 0; Re < $.width; ++Re) {
                const Ie = Ne[Gt[0]++] << 8 | Ne[Gt[1]++];
                Ee += Ie, nt[Ft] = Ee, Ft++;
              }
              break;
            case 2:
              Gt[0] = pt, Gt[1] = Gt[0] + $.width, Gt[2] = Gt[1] + $.width, pt = Gt[2] + $.width;
              for (let Re = 0; Re < $.width; ++Re) {
                const Ie = Ne[Gt[0]++] << 24 | Ne[Gt[1]++] << 16 | Ne[Gt[2]++] << 8;
                Ee += Ie, nt[Ft] = Ee, Ft++;
              }
              break;
          }
        }
      return new DataView(nt.buffer);
    }
    function Xt($) {
      var pe = $.viewer, Ne = { value: $.offset.value }, $e = new Uint8Array($.width * $.lines * ($.channels * $.type * 2)), nt = {
        version: ot(pe, Ne),
        unknownUncompressedSize: ot(pe, Ne),
        unknownCompressedSize: ot(pe, Ne),
        acCompressedSize: ot(pe, Ne),
        dcCompressedSize: ot(pe, Ne),
        rleCompressedSize: ot(pe, Ne),
        rleUncompressedSize: ot(pe, Ne),
        rleRawSize: ot(pe, Ne),
        totalAcUncompressedCount: ot(pe, Ne),
        totalDcUncompressedCount: ot(pe, Ne),
        acCompression: ot(pe, Ne)
      };
      if (nt.version < 2)
        throw "EXRLoader.parse: " + zl.compression + " version " + nt.version + " is unsupported";
      for (var pt = new Array(), Ft = tt(pe, Ne) - 2; Ft > 0; ) {
        var Gt = Wt(pe.buffer, Ne), ee = Ue(pe, Ne), ye = ee >> 2 & 3, Ee = (ee >> 4) - 1, Re = new Int8Array([Ee])[0], Ie = Ue(pe, Ne);
        pt.push({
          name: Gt,
          index: Re,
          type: Ie,
          compression: ye
        }), Ft -= Gt.length + 3;
      }
      for (var je = zl.channels, _t = new Array($.channels), Ut = 0; Ut < $.channels; ++Ut) {
        var It = _t[Ut] = {}, on = je[Ut];
        It.name = on.name, It.compression = 0, It.decoded = !1, It.type = on.pixelType, It.pLinear = on.pLinear, It.width = $.width, It.height = $.lines;
      }
      for (var sn = {
        idx: new Array(3)
      }, Qt = 0; Qt < $.channels; ++Qt)
        for (var It = _t[Qt], Ut = 0; Ut < pt.length; ++Ut) {
          var bn = pt[Ut];
          It.name == bn.name && (It.compression = bn.compression, bn.index >= 0 && (sn.idx[bn.index] = Qt), It.offset = Qt);
        }
      if (nt.acCompressedSize > 0)
        switch (nt.acCompression) {
          case 0:
            var yn = new Uint16Array(nt.totalAcUncompressedCount);
            dn(
              $.array,
              pe,
              Ne,
              nt.acCompressedSize,
              yn,
              nt.totalAcUncompressedCount
            );
            break;
          case 1:
            var En = $.array.slice(Ne.value, Ne.value + nt.totalAcUncompressedCount), ca = $b(En), yn = new Uint16Array(ca.buffer);
            Ne.value += nt.totalAcUncompressedCount;
            break;
        }
      if (nt.dcCompressedSize > 0) {
        var zn = {
          array: $.array,
          offset: Ne,
          size: nt.dcCompressedSize
        }, xn = new Uint16Array(Et(zn).buffer);
        Ne.value += nt.dcCompressedSize;
      }
      if (nt.rleRawSize > 0) {
        var En = $.array.slice(Ne.value, Ne.value + nt.rleCompressedSize), ca = $b(En), si = Ha(ca.buffer);
        Ne.value += nt.rleCompressedSize;
      }
      for (var jn = 0, ta = new Array(_t.length), Ut = 0; Ut < ta.length; ++Ut)
        ta[Ut] = new Array();
      for (var Li = 0; Li < $.lines; ++Li)
        for (var Qn = 0; Qn < _t.length; ++Qn)
          ta[Qn].push(jn), jn += _t[Qn].width * $.type * 2;
      Tt(sn, ta, _t, yn, xn, $e);
      for (var Ut = 0; Ut < _t.length; ++Ut) {
        var It = _t[Ut];
        if (!It.decoded)
          switch (It.compression) {
            case 2:
              for (var Ta = 0, da = 0, Li = 0; Li < $.lines; ++Li) {
                for (var qi = ta[Ut][Ta], Ya = 0; Ya < It.width; ++Ya) {
                  for (var Ei = 0; Ei < 2 * It.type; ++Ei)
                    $e[qi++] = si[da + Ei * It.width * It.height];
                  da++;
                }
                Ta++;
              }
              break;
            case 1:
            default:
              throw "EXRLoader.parse: unsupported channel compression";
          }
      }
      return new DataView($e.buffer);
    }
    function Wt($, pe) {
      for (var Ne = new Uint8Array($), $e = 0; Ne[pe.value + $e] != 0; )
        $e += 1;
      var nt = new TextDecoder().decode(Ne.slice(pe.value, pe.value + $e));
      return pe.value = pe.value + $e + 1, nt;
    }
    function Vn($, pe, Ne) {
      var $e = new TextDecoder().decode(new Uint8Array($).slice(pe.value, pe.value + Ne));
      return pe.value = pe.value + Ne, $e;
    }
    function Pt($, pe) {
      var Ne = gn($, pe), $e = nn($, pe);
      return [Ne, $e];
    }
    function pn($, pe) {
      var Ne = nn($, pe), $e = nn($, pe);
      return [Ne, $e];
    }
    function gn($, pe) {
      var Ne = $.getInt32(pe.value, !0);
      return pe.value = pe.value + 4, Ne;
    }
    function nn($, pe) {
      var Ne = $.getUint32(pe.value, !0);
      return pe.value = pe.value + 4, Ne;
    }
    function jt($, pe) {
      var Ne = $[pe.value];
      return pe.value = pe.value + 1, Ne;
    }
    function Ue($, pe) {
      var Ne = $.getUint8(pe.value);
      return pe.value = pe.value + 1, Ne;
    }
    const ot = function($, pe) {
      let Ne;
      return "getBigInt64" in DataView.prototype ? Ne = Number($.getBigInt64(pe.value, !0)) : Ne = $.getUint32(pe.value + 4, !0) + Number($.getUint32(pe.value, !0) << 32), pe.value += 8, Ne;
    };
    function Ht($, pe) {
      var Ne = $.getFloat32(pe.value, !0);
      return pe.value += 4, Ne;
    }
    function xe($, pe) {
      return XS.toHalfFloat(Ht($, pe));
    }
    function Je($) {
      var pe = ($ & 31744) >> 10, Ne = $ & 1023;
      return ($ >> 15 ? -1 : 1) * (pe ? pe === 31 ? Ne ? NaN : 1 / 0 : Math.pow(2, pe - 15) * (1 + Ne / 1024) : 6103515625e-14 * (Ne / 1024));
    }
    function tt($, pe) {
      var Ne = $.getUint16(pe.value, !0);
      return pe.value += 2, Ne;
    }
    function Ct($, pe) {
      return Je(tt($, pe));
    }
    function $t($, pe, Ne, $e) {
      for (var nt = Ne.value, pt = []; Ne.value < nt + $e - 1; ) {
        var Ft = Wt(pe, Ne), Gt = gn($, Ne), ee = Ue($, Ne);
        Ne.value += 3;
        var ye = gn($, Ne), Ee = gn($, Ne);
        pt.push({
          name: Ft,
          pixelType: Gt,
          pLinear: ee,
          xSampling: ye,
          ySampling: Ee
        });
      }
      return Ne.value += 1, pt;
    }
    function tn($, pe) {
      var Ne = Ht($, pe), $e = Ht($, pe), nt = Ht($, pe), pt = Ht($, pe), Ft = Ht($, pe), Gt = Ht($, pe), ee = Ht($, pe), ye = Ht($, pe);
      return {
        redX: Ne,
        redY: $e,
        greenX: nt,
        greenY: pt,
        blueX: Ft,
        blueY: Gt,
        whiteX: ee,
        whiteY: ye
      };
    }
    function Mn($, pe) {
      var Ne = [
        "NO_COMPRESSION",
        "RLE_COMPRESSION",
        "ZIPS_COMPRESSION",
        "ZIP_COMPRESSION",
        "PIZ_COMPRESSION",
        "PXR24_COMPRESSION",
        "B44_COMPRESSION",
        "B44A_COMPRESSION",
        "DWAA_COMPRESSION",
        "DWAB_COMPRESSION"
      ], $e = Ue($, pe);
      return Ne[$e];
    }
    function Wn($, pe) {
      var Ne = nn($, pe), $e = nn($, pe), nt = nn($, pe), pt = nn($, pe);
      return { xMin: Ne, yMin: $e, xMax: nt, yMax: pt };
    }
    function Xa($, pe) {
      var Ne = ["INCREASING_Y"], $e = Ue($, pe);
      return Ne[$e];
    }
    function sa($, pe) {
      var Ne = Ht($, pe), $e = Ht($, pe);
      return [Ne, $e];
    }
    function ul($, pe) {
      var Ne = Ht($, pe), $e = Ht($, pe), nt = Ht($, pe);
      return [Ne, $e, nt];
    }
    function xa($, pe, Ne, $e, nt) {
      if ($e === "string" || $e === "stringvector" || $e === "iccProfile")
        return Vn(pe, Ne, nt);
      if ($e === "chlist")
        return $t($, pe, Ne, nt);
      if ($e === "chromaticities")
        return tn($, Ne);
      if ($e === "compression")
        return Mn($, Ne);
      if ($e === "box2i")
        return Wn($, Ne);
      if ($e === "lineOrder")
        return Xa($, Ne);
      if ($e === "float")
        return Ht($, Ne);
      if ($e === "v2f")
        return sa($, Ne);
      if ($e === "v3f")
        return ul($, Ne);
      if ($e === "int")
        return gn($, Ne);
      if ($e === "rational")
        return Pt($, Ne);
      if ($e === "timecode")
        return pn($, Ne);
      if ($e === "preview")
        return Ne.value += nt, "skipped";
      Ne.value += nt;
    }
    function Ui($, pe, Ne) {
      const $e = {};
      if ($.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
      $e.version = $.getUint8(4);
      const nt = $.getUint8(5);
      $e.spec = {
        singleTile: !!(nt & 2),
        longName: !!(nt & 4),
        deepFormat: !!(nt & 8),
        multiPart: !!(nt & 16)
      }, Ne.value = 8;
      for (var pt = !0; pt; ) {
        var Ft = Wt(pe, Ne);
        if (Ft == 0)
          pt = !1;
        else {
          var Gt = Wt(pe, Ne), ee = nn($, Ne), ye = xa($, pe, Ne, Gt, ee);
          ye === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${Gt}'.`) : $e[Ft] = ye;
        }
      }
      if ((nt & -5) != 0)
        throw console.error("EXRHeader:", $e), "THREE.EXRLoader: provided file is currently unsupported.";
      return $e;
    }
    function cl($, pe, Ne, $e, nt) {
      const pt = {
        size: 0,
        viewer: pe,
        array: Ne,
        offset: $e,
        width: $.dataWindow.xMax - $.dataWindow.xMin + 1,
        height: $.dataWindow.yMax - $.dataWindow.yMin + 1,
        channels: $.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: $.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [TA ? "colorSpace" : "encoding"]: null
      };
      switch ($.compression) {
        case "NO_COMPRESSION":
          pt.lines = 1, pt.uncompress = Xe;
          break;
        case "RLE_COMPRESSION":
          pt.lines = 1, pt.uncompress = dt;
          break;
        case "ZIPS_COMPRESSION":
          pt.lines = 1, pt.uncompress = Et;
          break;
        case "ZIP_COMPRESSION":
          pt.lines = 16, pt.uncompress = Et;
          break;
        case "PIZ_COMPRESSION":
          pt.lines = 32, pt.uncompress = yt;
          break;
        case "PXR24_COMPRESSION":
          pt.lines = 16, pt.uncompress = Jt;
          break;
        case "DWAA_COMPRESSION":
          pt.lines = 32, pt.uncompress = Xt;
          break;
        case "DWAB_COMPRESSION":
          pt.lines = 256, pt.uncompress = Xt;
          break;
        default:
          throw "EXRLoader.parse: " + $.compression + " is unsupported";
      }
      if (pt.scanlineBlockSize = pt.lines, pt.type == 1)
        switch (nt) {
          case pr:
            pt.getter = Ct, pt.inputSize = 2;
            break;
          case au:
            pt.getter = tt, pt.inputSize = 2;
            break;
        }
      else if (pt.type == 2)
        switch (nt) {
          case pr:
            pt.getter = Ht, pt.inputSize = 4;
            break;
          case au:
            pt.getter = xe, pt.inputSize = 4;
        }
      else
        throw "EXRLoader.parse: unsupported pixelType " + pt.type + " for " + $.compression + ".";
      pt.blockCount = ($.dataWindow.yMax + 1) / pt.scanlineBlockSize;
      for (var Ft = 0; Ft < pt.blockCount; Ft++)
        ot(pe, $e);
      pt.outputChannels = pt.channels == 3 ? 4 : pt.channels;
      const Gt = pt.width * pt.height * pt.outputChannels;
      switch (nt) {
        case pr:
          pt.byteArray = new Float32Array(Gt), pt.channels < pt.outputChannels && pt.byteArray.fill(1, 0, Gt);
          break;
        case au:
          pt.byteArray = new Uint16Array(Gt), pt.channels < pt.outputChannels && pt.byteArray.fill(15360, 0, Gt);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", nt);
          break;
      }
      return pt.bytesPerLine = pt.width * pt.inputSize * pt.channels, pt.outputChannels == 4 ? pt.format = xo : pt.format = lE, TA ? pt.colorSpace = "srgb-linear" : pt.encoding = 3e3, pt;
    }
    const Xl = new DataView(e), Ws = new Uint8Array(e), lu = { value: 0 }, zl = Ui(Xl, e, lu), Jn = cl(zl, Xl, Ws, lu, this.type), un = { value: 0 }, li = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let $ = 0; $ < Jn.height / Jn.scanlineBlockSize; $++) {
      const pe = nn(Xl, lu);
      Jn.size = nn(Xl, lu), Jn.lines = pe + Jn.scanlineBlockSize > Jn.height ? Jn.height - pe : Jn.scanlineBlockSize;
      const $e = Jn.size < Jn.lines * Jn.bytesPerLine ? Jn.uncompress(Jn) : Xe(Jn);
      lu.value += Jn.size;
      for (let nt = 0; nt < Jn.scanlineBlockSize; nt++) {
        const pt = nt + $ * Jn.scanlineBlockSize;
        if (pt >= Jn.height)
          break;
        for (let Ft = 0; Ft < Jn.channels; Ft++) {
          const Gt = li[zl.channels[Ft].name];
          for (let ee = 0; ee < Jn.width; ee++) {
            un.value = (nt * (Jn.channels * Jn.width) + Ft * Jn.width + ee) * Jn.inputSize;
            const ye = (Jn.height - 1 - pt) * (Jn.width * Jn.outputChannels) + ee * Jn.outputChannels + Gt;
            Jn.byteArray[ye] = Jn.getter($e, un);
          }
        }
      }
    }
    return {
      header: zl,
      width: Jn.width,
      height: Jn.height,
      data: Jn.byteArray,
      format: Jn.format,
      [TA ? "colorSpace" : "encoding"]: Jn[TA ? "colorSpace" : "encoding"],
      type: this.type
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, a, r) {
    function d(p, y) {
      TA ? p.colorSpace = y.colorSpace : p.encoding = y.encoding, p.minFilter = Ni, p.magFilter = Ni, p.generateMipmaps = !1, p.flipY = !1, t && t(p, y);
    }
    return super.load(e, d, a, r);
  }
}
const IC = /* @__PURE__ */ new WeakMap();
class HV extends cf {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, a, r) {
    const d = new of(this.manager);
    d.setPath(this.path), d.setResponseType("arraybuffer"), d.setRequestHeader(this.requestHeader), d.setWithCredentials(this.withCredentials), d.load(
      e,
      (p) => {
        const y = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: !1
        };
        this.decodeGeometry(p, y).then(t).catch(r);
      },
      a,
      r
    );
  }
  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
  decodeDracoFile(e, t, a, r) {
    const d = {
      attributeIDs: a || this.defaultAttributeIDs,
      attributeTypes: r || this.defaultAttributeTypes,
      useUniqueIDs: !!a
    };
    this.decodeGeometry(e, d).then(t);
  }
  decodeGeometry(e, t) {
    for (const _ in t.attributeTypes) {
      const E = t.attributeTypes[_];
      E.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[_] = E.name);
    }
    const a = JSON.stringify(t);
    if (IC.has(e)) {
      const _ = IC.get(e);
      if (_.key === a)
        return _.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let r;
    const d = this.workerNextTaskID++, p = e.byteLength, y = this._getWorker(d, p).then((_) => (r = _, new Promise((E, T) => {
      r._callbacks[d] = { resolve: E, reject: T }, r.postMessage({ type: "decode", id: d, taskConfig: t, buffer: e }, [e]);
    }))).then((_) => this._createGeometry(_.geometry));
    return y.catch(() => !0).then(() => {
      r && d && this._releaseTask(r, d);
    }), IC.set(e, {
      key: a,
      promise: y
    }), y;
  }
  _createGeometry(e) {
    const t = new Pa();
    e.index && t.setIndex(new Hi(e.index.array, 1));
    for (let a = 0; a < e.attributes.length; a++) {
      const r = e.attributes[a], d = r.name, p = r.array, y = r.itemSize;
      t.setAttribute(d, new Hi(p, y));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const a = new of(this.manager);
    return a.setPath(this.decoderPath), a.setResponseType(t), a.setWithCredentials(this.withCredentials), new Promise((r, d) => {
      a.load(e, r, void 0, d);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((a) => {
      const r = a[0];
      e || (this.decoderConfig.wasmBinary = a[1]);
      const d = LV.toString(), p = [
        "/* draco decoder */",
        r,
        "",
        "/* worker */",
        d.substring(d.indexOf("{") + 1, d.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([p]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const r = new Worker(this.workerSourceURL);
        r._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({ type: "init", decoderConfig: this.decoderConfig }), r.onmessage = function(d) {
          const p = d.data;
          switch (p.type) {
            case "decode":
              r._callbacks[p.id].resolve(p);
              break;
            case "error":
              r._callbacks[p.id].reject(p);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + p.type + '"');
          }
        }, this.workerPool.push(r);
      } else
        this.workerPool.sort(function(r, d) {
          return r._taskLoad > d._taskLoad ? -1 : 1;
        });
      const a = this.workerPool[this.workerPool.length - 1];
      return a._taskCosts[e] = t, a._taskLoad += t, a;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this;
  }
}
function LV() {
  let o, e;
  onmessage = function(p) {
    const y = p.data;
    switch (y.type) {
      case "init":
        o = y.decoderConfig, e = new Promise(function(T) {
          o.onModuleLoaded = function(C) {
            T({ draco: C });
          }, DracoDecoderModule(o);
        });
        break;
      case "decode":
        const _ = y.buffer, E = y.taskConfig;
        e.then((T) => {
          const C = T.draco, D = new C.Decoder(), B = new C.DecoderBuffer();
          B.Init(new Int8Array(_), _.byteLength);
          try {
            const z = t(C, D, B, E), V = z.attributes.map((G) => G.array.buffer);
            z.index && V.push(z.index.array.buffer), self.postMessage({ type: "decode", id: y.id, geometry: z }, V);
          } catch (z) {
            console.error(z), self.postMessage({ type: "error", id: y.id, error: z.message });
          } finally {
            C.destroy(B), C.destroy(D);
          }
        });
        break;
    }
  };
  function t(p, y, _, E) {
    const T = E.attributeIDs, C = E.attributeTypes;
    let D, B;
    const z = y.GetEncodedGeometryType(_);
    if (z === p.TRIANGULAR_MESH)
      D = new p.Mesh(), B = y.DecodeBufferToMesh(_, D);
    else if (z === p.POINT_CLOUD)
      D = new p.PointCloud(), B = y.DecodeBufferToPointCloud(_, D);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!B.ok() || D.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + B.error_msg());
    const V = { index: null, attributes: [] };
    for (const G in T) {
      const N = self[C[G]];
      let F, q;
      if (E.useUniqueIDs)
        q = T[G], F = y.GetAttributeByUniqueId(D, q);
      else {
        if (q = y.GetAttributeId(D, p[T[G]]), q === -1)
          continue;
        F = y.GetAttribute(D, q);
      }
      V.attributes.push(r(p, y, D, G, N, F));
    }
    return z === p.TRIANGULAR_MESH && (V.index = a(p, y, D)), p.destroy(D), V;
  }
  function a(p, y, _) {
    const T = _.num_faces() * 3, C = T * 4, D = p._malloc(C);
    y.GetTrianglesUInt32Array(_, C, D);
    const B = new Uint32Array(p.HEAPF32.buffer, D, T).slice();
    return p._free(D), { array: B, itemSize: 1 };
  }
  function r(p, y, _, E, T, C) {
    const D = C.num_components(), z = _.num_points() * D, V = z * T.BYTES_PER_ELEMENT, G = d(p, T), N = p._malloc(V);
    y.GetAttributeDataArrayForAllPoints(_, C, G, V, N);
    const F = new T(p.HEAPF32.buffer, N, z).slice();
    return p._free(N), {
      name: E,
      array: F,
      itemSize: D
    };
  }
  function d(p, y) {
    switch (y) {
      case Float32Array:
        return p.DT_FLOAT32;
      case Int8Array:
        return p.DT_INT8;
      case Int16Array:
        return p.DT_INT16;
      case Int32Array:
        return p.DT_INT32;
      case Uint8Array:
        return p.DT_UINT8;
      case Uint16Array:
        return p.DT_UINT16;
      case Uint32Array:
        return p.DT_UINT32;
    }
  }
}
let tM;
const VC = () => {
  if (tM)
    return tM;
  const o = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", t = new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    4,
    1,
    96,
    0,
    0,
    3,
    3,
    2,
    0,
    0,
    5,
    3,
    1,
    0,
    1,
    12,
    1,
    0,
    10,
    22,
    2,
    12,
    0,
    65,
    0,
    65,
    0,
    65,
    0,
    252,
    10,
    0,
    0,
    11,
    7,
    0,
    65,
    0,
    253,
    15,
    26,
    11
  ]), a = new Uint8Array([
    32,
    0,
    65,
    253,
    3,
    1,
    2,
    34,
    4,
    106,
    6,
    5,
    11,
    8,
    7,
    20,
    13,
    33,
    12,
    16,
    128,
    9,
    116,
    64,
    19,
    113,
    127,
    15,
    10,
    21,
    22,
    14,
    255,
    66,
    24,
    54,
    136,
    107,
    18,
    23,
    192,
    26,
    114,
    118,
    132,
    17,
    77,
    101,
    130,
    144,
    27,
    87,
    131,
    44,
    45,
    74,
    156,
    154,
    70,
    167
  ]);
  if (typeof WebAssembly != "object")
    return {
      supported: !1
    };
  let r = o;
  WebAssembly.validate(t) && (r = e);
  let d;
  const p = WebAssembly.instantiate(y(r), {}).then((C) => {
    d = C.instance, d.exports.__wasm_call_ctors();
  });
  function y(C) {
    const D = new Uint8Array(C.length);
    for (let z = 0; z < C.length; ++z) {
      const V = C.charCodeAt(z);
      D[z] = V > 96 ? V - 71 : V > 64 ? V - 65 : V > 47 ? V + 4 : V > 46 ? 63 : 62;
    }
    let B = 0;
    for (let z = 0; z < C.length; ++z)
      D[B++] = D[z] < 60 ? a[D[z]] : (D[z] - 60) * 64 + D[++z];
    return D.buffer.slice(0, B);
  }
  function _(C, D, B, z, V, G) {
    const N = d.exports.sbrk, F = B + 3 & -4, q = N(F * z), Y = N(V.length), ie = new Uint8Array(d.exports.memory.buffer);
    ie.set(V, Y);
    const k = C(q, B, z, Y, V.length);
    if (k === 0 && G && G(q, F, z), D.set(ie.subarray(q, q + B * z)), N(q - N(0)), k !== 0)
      throw new Error(`Malformed buffer data: ${k}`);
  }
  const E = {
    // legacy index-based enums for glTF
    0: "",
    1: "meshopt_decodeFilterOct",
    2: "meshopt_decodeFilterQuat",
    3: "meshopt_decodeFilterExp",
    // string-based enums for glTF
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  }, T = {
    // legacy index-based enums for glTF
    0: "meshopt_decodeVertexBuffer",
    1: "meshopt_decodeIndexBuffer",
    2: "meshopt_decodeIndexSequence",
    // string-based enums for glTF
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  return tM = {
    ready: p,
    supported: !0,
    decodeVertexBuffer(C, D, B, z, V) {
      _(
        d.exports.meshopt_decodeVertexBuffer,
        C,
        D,
        B,
        z,
        d.exports[E[V]]
      );
    },
    decodeIndexBuffer(C, D, B, z) {
      _(d.exports.meshopt_decodeIndexBuffer, C, D, B, z);
    },
    decodeIndexSequence(C, D, B, z) {
      _(d.exports.meshopt_decodeIndexSequence, C, D, B, z);
    },
    decodeGltfBuffer(C, D, B, z, V, G) {
      _(
        d.exports[T[V]],
        C,
        D,
        B,
        z,
        d.exports[E[G]]
      );
    }
  }, tM;
}, GV = () => parseInt(T1.replace(/\D+/g, "")), cR = /* @__PURE__ */ GV();
let nM = null, Jw = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";
function Kw(o = !0, e = !0, t) {
  return (a) => {
    t && t(a), o && (nM || (nM = new HV()), nM.setDecoderPath(typeof o == "string" ? o : Jw), a.setDRACOLoader(nM)), e && a.setMeshoptDecoder(typeof VC == "function" ? VC() : VC);
  };
}
const fR = (o, e, t, a) => jy(uR, o, Kw(e, t, a));
fR.preload = (o, e, t, a) => jy.preload(uR, o, Kw(e, t, a));
fR.clear = (o) => jy.clear(uR, o);
fR.setDecoderPath = (o) => {
  Jw = o;
};
const vF = /* @__PURE__ */ st.forwardRef(({
  makeDefault: o,
  camera: e,
  regress: t,
  domElement: a,
  enableDamping: r = !0,
  keyEvents: d = !1,
  onChange: p,
  onStart: y,
  onEnd: _,
  ...E
}, T) => {
  const C = nu((k) => k.invalidate), D = nu((k) => k.camera), B = nu((k) => k.gl), z = nu((k) => k.events), V = nu((k) => k.setEvents), G = nu((k) => k.set), N = nu((k) => k.get), F = nu((k) => k.performance), q = e || D, Y = a || z.connected || B.domElement, ie = st.useMemo(() => new KI(q), [q]);
  return k0(() => {
    ie.enabled && ie.update();
  }, -1), st.useEffect(() => (d && ie.connect(d === !0 ? Y : d), ie.connect(Y), () => void ie.dispose()), [d, Y, t, ie, C]), st.useEffect(() => {
    const k = (Q) => {
      C(), t && F.regress(), p && p(Q);
    }, le = (Q) => {
      y && y(Q);
    }, ne = (Q) => {
      _ && _(Q);
    };
    return ie.addEventListener("change", k), ie.addEventListener("start", le), ie.addEventListener("end", ne), () => {
      ie.removeEventListener("start", le), ie.removeEventListener("end", ne), ie.removeEventListener("change", k);
    };
  }, [p, y, _, ie, C, V]), st.useEffect(() => {
    if (o) {
      const k = N().controls;
      return G({
        controls: ie
      }), () => G({
        controls: k
      });
    }
  }, [o, ie]), /* @__PURE__ */ st.createElement("primitive", Jy({
    ref: T,
    object: ie,
    enableDamping: r
  }, E));
});
class IV extends iu {
  constructor(e = new Ot()) {
    super({
      uniforms: {
        inputBuffer: new $f(null),
        depthBuffer: new $f(null),
        resolution: new $f(new Ot()),
        texelSize: new $f(new Ot()),
        halfTexelSize: new $f(new Ot()),
        kernel: new $f(0),
        scale: new $f(1),
        cameraNear: new $f(0),
        cameraFar: new $f(1),
        minDepthThreshold: new $f(0),
        maxDepthThreshold: new $f(1),
        depthScale: new $f(0),
        depthToBlurRatioBias: new $f(0.25)
      },
      fragmentShader: `#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
            depthFactor *= depthScale;
            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));
          #endif
          
          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));
          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));
          gl_FragColor = sum * 0.25 ;

          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <${cR >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }`,
      vertexShader: `uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,
      blending: jv,
      depthWrite: !1,
      depthTest: !1
    }), this.toneMapped = !1, this.setTexelSize(e.x, e.y), this.kernel = new Float32Array([0, 1, 2, 2, 3]);
  }
  setTexelSize(e, t) {
    this.uniforms.texelSize.value.set(e, t), this.uniforms.halfTexelSize.value.set(e, t).multiplyScalar(0.5);
  }
  setResolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
}
class VV {
  constructor({
    gl: e,
    resolution: t,
    width: a = 500,
    height: r = 500,
    minDepthThreshold: d = 0,
    maxDepthThreshold: p = 1,
    depthScale: y = 0,
    depthToBlurRatioBias: _ = 0.25
  }) {
    this.renderToScreen = !1, this.renderTargetA = new uf(t, t, {
      minFilter: Ni,
      magFilter: Ni,
      stencilBuffer: !1,
      depthBuffer: !1,
      type: au
    }), this.renderTargetB = this.renderTargetA.clone(), this.convolutionMaterial = new IV(), this.convolutionMaterial.setTexelSize(1 / a, 1 / r), this.convolutionMaterial.setResolution(new Ot(a, r)), this.scene = new R1(), this.camera = new oE(), this.convolutionMaterial.uniforms.minDepthThreshold.value = d, this.convolutionMaterial.uniforms.maxDepthThreshold.value = p, this.convolutionMaterial.uniforms.depthScale.value = y, this.convolutionMaterial.uniforms.depthToBlurRatioBias.value = _, this.convolutionMaterial.defines.USE_DEPTH = y > 0;
    const E = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), T = new Float32Array([0, 0, 2, 0, 0, 2]), C = new Pa();
    C.setAttribute("position", new Hi(E, 3)), C.setAttribute("uv", new Hi(T, 2)), this.screen = new es(C, this.convolutionMaterial), this.screen.frustumCulled = !1, this.scene.add(this.screen);
  }
  render(e, t, a) {
    const r = this.scene, d = this.camera, p = this.renderTargetA, y = this.renderTargetB;
    let _ = this.convolutionMaterial, E = _.uniforms;
    E.depthBuffer.value = t.depthTexture;
    const T = _.kernel;
    let C = t, D, B, z;
    for (B = 0, z = T.length - 1; B < z; ++B)
      D = (B & 1) === 0 ? p : y, E.kernel.value = T[B], E.inputBuffer.value = C.texture, e.setRenderTarget(D), e.render(r, d), C = D;
    E.kernel.value = T[B], E.inputBuffer.value = C.texture, e.setRenderTarget(this.renderToScreen ? null : a), e.render(r, d);
  }
}
let FV = class extends B1 {
  constructor(e = {}) {
    super(e), this._tDepth = {
      value: null
    }, this._distortionMap = {
      value: null
    }, this._tDiffuse = {
      value: null
    }, this._tDiffuseBlur = {
      value: null
    }, this._textureMatrix = {
      value: null
    }, this._hasBlur = {
      value: !1
    }, this._mirror = {
      value: 0
    }, this._mixBlur = {
      value: 0
    }, this._blurStrength = {
      value: 0.5
    }, this._minDepthThreshold = {
      value: 0.9
    }, this._maxDepthThreshold = {
      value: 1
    }, this._depthScale = {
      value: 0
    }, this._depthToBlurRatioBias = {
      value: 0.25
    }, this._distortion = {
      value: 1
    }, this._mixContrast = {
      value: 1
    }, this.setValues(e);
  }
  onBeforeCompile(e) {
    var t;
    (t = e.defines) != null && t.USE_UV || (e.defines.USE_UV = ""), e.uniforms.hasBlur = this._hasBlur, e.uniforms.tDiffuse = this._tDiffuse, e.uniforms.tDepth = this._tDepth, e.uniforms.distortionMap = this._distortionMap, e.uniforms.tDiffuseBlur = this._tDiffuseBlur, e.uniforms.textureMatrix = this._textureMatrix, e.uniforms.mirror = this._mirror, e.uniforms.mixBlur = this._mixBlur, e.uniforms.mixStrength = this._blurStrength, e.uniforms.minDepthThreshold = this._minDepthThreshold, e.uniforms.maxDepthThreshold = this._maxDepthThreshold, e.uniforms.depthScale = this._depthScale, e.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias, e.uniforms.distortion = this._distortion, e.uniforms.mixContrast = this._mixContrast, e.vertexShader = `
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${e.vertexShader}`, e.vertexShader = e.vertexShader.replace("#include <project_vertex>", `#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`), e.fragmentShader = `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDiffuseBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
			  uniform float cameraFar;
        uniform bool hasBlur;
        uniform float mixBlur;
        uniform float mirror;
        uniform float mixStrength;
        uniform float minDepthThreshold;
        uniform float maxDepthThreshold;
        uniform float mixContrast;
        uniform float depthScale;
        uniform float depthToBlurRatioBias;
        varying vec4 my_vUv;
        ${e.fragmentShader}`, e.fragmentShader = e.fragmentShader.replace("#include <emissivemap_fragment>", `#include <emissivemap_fragment>

      float distortionFactor = 0.0;
      #ifdef USE_DISTORTION
        distortionFactor = texture2D(distortionMap, vUv).r * distortion;
      #endif

      vec4 new_vUv = my_vUv;
      new_vUv.x += distortionFactor;
      new_vUv.y += distortionFactor;

      vec4 base = texture2DProj(tDiffuse, new_vUv);
      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);

      vec4 merge = base;

      #ifdef USE_NORMALMAP
        vec2 normal_uv = vec2(0.0);
        vec4 normalColor = texture2D(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;
        vec4 base_normal = texture2D(tDiffuse, normal_uv);
        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);
        merge = base_normal;
        blur = blur_normal;
      #endif

      float depthFactor = 0.0001;
      float blurFactor = 0.0;

      #ifdef USE_DEPTH
        vec4 depth = texture2DProj(tDepth, new_vUv);
        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));
        depthFactor *= depthScale;
        depthFactor = max(0.0001, min(1.0, depthFactor));

        #ifdef USE_BLUR
          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);
          merge = merge * min(1.0, depthFactor + 0.5);
        #else
          merge = merge * depthFactor;
        #endif

      #endif

      float reflectorRoughnessFactor = roughness;
      #ifdef USE_ROUGHNESSMAP
        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );
        reflectorRoughnessFactor *= reflectorTexelRoughness.g;
      #endif

      #ifdef USE_BLUR
        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);
        merge = mix(merge, blur, blurFactor);
      #endif

      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);
      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;
      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;
      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;

      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);
      `);
  }
  get tDiffuse() {
    return this._tDiffuse.value;
  }
  set tDiffuse(e) {
    this._tDiffuse.value = e;
  }
  get tDepth() {
    return this._tDepth.value;
  }
  set tDepth(e) {
    this._tDepth.value = e;
  }
  get distortionMap() {
    return this._distortionMap.value;
  }
  set distortionMap(e) {
    this._distortionMap.value = e;
  }
  get tDiffuseBlur() {
    return this._tDiffuseBlur.value;
  }
  set tDiffuseBlur(e) {
    this._tDiffuseBlur.value = e;
  }
  get textureMatrix() {
    return this._textureMatrix.value;
  }
  set textureMatrix(e) {
    this._textureMatrix.value = e;
  }
  get hasBlur() {
    return this._hasBlur.value;
  }
  set hasBlur(e) {
    this._hasBlur.value = e;
  }
  get mirror() {
    return this._mirror.value;
  }
  set mirror(e) {
    this._mirror.value = e;
  }
  get mixBlur() {
    return this._mixBlur.value;
  }
  set mixBlur(e) {
    this._mixBlur.value = e;
  }
  get mixStrength() {
    return this._blurStrength.value;
  }
  set mixStrength(e) {
    this._blurStrength.value = e;
  }
  get minDepthThreshold() {
    return this._minDepthThreshold.value;
  }
  set minDepthThreshold(e) {
    this._minDepthThreshold.value = e;
  }
  get maxDepthThreshold() {
    return this._maxDepthThreshold.value;
  }
  set maxDepthThreshold(e) {
    this._maxDepthThreshold.value = e;
  }
  get depthScale() {
    return this._depthScale.value;
  }
  set depthScale(e) {
    this._depthScale.value = e;
  }
  get depthToBlurRatioBias() {
    return this._depthToBlurRatioBias.value;
  }
  set depthToBlurRatioBias(e) {
    this._depthToBlurRatioBias.value = e;
  }
  get distortion() {
    return this._distortion.value;
  }
  set distortion(e) {
    this._distortion.value = e;
  }
  get mixContrast() {
    return this._mixContrast.value;
  }
  set mixContrast(e) {
    this._mixContrast.value = e;
  }
};
const yF = /* @__PURE__ */ st.forwardRef(({
  mixBlur: o = 0,
  mixStrength: e = 1,
  resolution: t = 256,
  blur: a = [0, 0],
  minDepthThreshold: r = 0.9,
  maxDepthThreshold: d = 1,
  depthScale: p = 0,
  depthToBlurRatioBias: y = 0.25,
  mirror: _ = 0,
  distortion: E = 1,
  mixContrast: T = 1,
  distortionMap: C,
  reflectorOffset: D = 0,
  ...B
}, z) => {
  Gx({
    MeshReflectorMaterialImpl: FV
  });
  const V = nu(({
    gl: We
  }) => We), G = nu(({
    camera: We
  }) => We), N = nu(({
    scene: We
  }) => We);
  a = Array.isArray(a) ? a : [a, a];
  const F = a[0] + a[1] > 0, q = a[0], Y = a[1], ie = st.useRef(null);
  st.useImperativeHandle(z, () => ie.current, []);
  const [k] = st.useState(() => new Pg()), [le] = st.useState(() => new ve()), [ne] = st.useState(() => new ve()), [Q] = st.useState(() => new ve()), [j] = st.useState(() => new ia()), [re] = st.useState(() => new ve(0, 0, -1)), [_e] = st.useState(() => new Bi()), [me] = st.useState(() => new ve()), [Ae] = st.useState(() => new ve()), [He] = st.useState(() => new Bi()), [P] = st.useState(() => new ia()), [te] = st.useState(() => new Ls()), ae = st.useCallback(() => {
    var We;
    const Me = ie.current.parent || ((We = ie.current) == null || (We = We.__r3f.parent) == null ? void 0 : We.object);
    if (!Me || (ne.setFromMatrixPosition(Me.matrixWorld), Q.setFromMatrixPosition(G.matrixWorld), j.extractRotation(Me.matrixWorld), le.set(0, 0, 1), le.applyMatrix4(j), ne.addScaledVector(le, D), me.subVectors(ne, Q), me.dot(le) > 0)) return;
    me.reflect(le).negate(), me.add(ne), j.extractRotation(G.matrixWorld), re.set(0, 0, -1), re.applyMatrix4(j), re.add(Q), Ae.subVectors(ne, re), Ae.reflect(le).negate(), Ae.add(ne), te.position.copy(me), te.up.set(0, 1, 0), te.up.applyMatrix4(j), te.up.reflect(le), te.lookAt(Ae), te.far = G.far, te.updateMatrixWorld(), te.projectionMatrix.copy(G.projectionMatrix), P.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), P.multiply(te.projectionMatrix), P.multiply(te.matrixWorldInverse), P.multiply(Me.matrixWorld), k.setFromNormalAndCoplanarPoint(le, ne), k.applyMatrix4(te.matrixWorldInverse), _e.set(k.normal.x, k.normal.y, k.normal.z, k.constant);
    const Ze = te.projectionMatrix;
    He.x = (Math.sign(_e.x) + Ze.elements[8]) / Ze.elements[0], He.y = (Math.sign(_e.y) + Ze.elements[9]) / Ze.elements[5], He.z = -1, He.w = (1 + Ze.elements[10]) / Ze.elements[14], _e.multiplyScalar(2 / _e.dot(He)), Ze.elements[2] = _e.x, Ze.elements[6] = _e.y, Ze.elements[10] = _e.z + 1, Ze.elements[14] = _e.w;
  }, [G, D]), [Se, ue, we, De] = st.useMemo(() => {
    const We = {
      minFilter: Ni,
      magFilter: Ni,
      type: au
    }, Me = new uf(t, t, We);
    Me.depthBuffer = !0, Me.depthTexture = new _x(t, t), Me.depthTexture.format = WS, Me.depthTexture.type = kS;
    const Ze = new uf(t, t, We), ct = new VV({
      gl: V,
      resolution: t,
      width: q,
      height: Y,
      minDepthThreshold: r,
      maxDepthThreshold: d,
      depthScale: p,
      depthToBlurRatioBias: y
    }), Vt = {
      mirror: _,
      textureMatrix: P,
      mixBlur: o,
      tDiffuse: Me.texture,
      tDepth: Me.depthTexture,
      tDiffuseBlur: Ze.texture,
      hasBlur: F,
      mixStrength: e,
      minDepthThreshold: r,
      maxDepthThreshold: d,
      depthScale: p,
      depthToBlurRatioBias: y,
      distortion: E,
      distortionMap: C,
      mixContrast: T,
      "defines-USE_BLUR": F ? "" : void 0,
      "defines-USE_DEPTH": p > 0 ? "" : void 0,
      "defines-USE_DISTORTION": C ? "" : void 0
    };
    return [Me, Ze, ct, Vt];
  }, [V, q, Y, P, t, _, F, o, e, r, d, p, y, E, C, T]);
  return k0(() => {
    var We;
    const Me = ie.current.parent || ((We = ie.current) == null || (We = We.__r3f.parent) == null ? void 0 : We.object);
    if (!Me) return;
    Me.visible = !1;
    const Ze = V.xr.enabled, ct = V.shadowMap.autoUpdate;
    ae(), V.xr.enabled = !1, V.shadowMap.autoUpdate = !1, V.setRenderTarget(Se), V.state.buffers.depth.setMask(!0), V.autoClear || V.clear(), V.render(N, te), F && we.render(V, Se, ue), V.xr.enabled = Ze, V.shadowMap.autoUpdate = ct, Me.visible = !0, V.setRenderTarget(null);
  }), /* @__PURE__ */ st.createElement("meshReflectorMaterialImpl", Jy({
    attach: "material",
    key: "key" + De["defines-USE_BLUR"] + De["defines-USE_DEPTH"] + De["defines-USE_DISTORTION"],
    ref: ie
  }, De, B));
}), SF = /* @__PURE__ */ st.forwardRef(({
  children: o,
  enabled: e = !0,
  speed: t = 1,
  rotationIntensity: a = 1,
  floatIntensity: r = 1,
  floatingRange: d = [-0.1, 0.1],
  autoInvalidate: p = !1,
  ...y
}, _) => {
  const E = st.useRef(null);
  st.useImperativeHandle(_, () => E.current, []);
  const T = st.useRef(Math.random() * 1e4);
  return k0((C) => {
    var D, B;
    if (!e || t === 0) return;
    p && C.invalidate();
    const z = T.current + C.clock.elapsedTime;
    E.current.rotation.x = Math.cos(z / 4 * t) / 8 * a, E.current.rotation.y = Math.sin(z / 4 * t) / 8 * a, E.current.rotation.z = Math.sin(z / 4 * t) / 20 * a;
    let V = Math.sin(z / 4 * t) / 10;
    V = dx.mapLinear(V, -0.1, 0.1, (D = d == null ? void 0 : d[0]) !== null && D !== void 0 ? D : -0.1, (B = d == null ? void 0 : d[1]) !== null && B !== void 0 ? B : 0.1), E.current.position.y = V * r, E.current.updateMatrix();
  }), /* @__PURE__ */ st.createElement("group", y, /* @__PURE__ */ st.createElement("group", {
    ref: E,
    matrixAutoUpdate: !1
  }, o));
}), kw = (o, e, t) => {
  let a;
  switch (o) {
    case qh:
      a = new Uint8ClampedArray(e * t * 4);
      break;
    case au:
      a = new Uint16Array(e * t * 4);
      break;
    case jg:
      a = new Uint32Array(e * t * 4);
      break;
    case lx:
      a = new Int8Array(e * t * 4);
      break;
    case sx:
      a = new Int16Array(e * t * 4);
      break;
    case iE:
      a = new Int32Array(e * t * 4);
      break;
    case pr:
      a = new Float32Array(e * t * 4);
      break;
    default:
      throw new Error("Unsupported data type");
  }
  return a;
};
let aM;
const PV = (o, e, t, a) => {
  if (aM !== void 0)
    return aM;
  const r = new uf(1, 1, a);
  e.setRenderTarget(r);
  const d = new es(new Ky(), new Yh({ color: 16777215 }));
  e.render(d, t), e.setRenderTarget(null);
  const p = kw(o, r.width, r.height);
  return e.readRenderTargetPixels(r, 0, 0, r.width, r.height, p), r.dispose(), d.geometry.dispose(), d.material.dispose(), aM = p[0] !== 0, aM;
};
class dR {
  /**
   * Constructs a new QuadRenderer
   *
   * @param options Parameters for this QuadRenderer
   */
  constructor(e) {
    var t, a, r, d, p, y, _, E, T, C, D, B, z, V, G, N;
    this._rendererIsDisposable = !1, this._supportsReadPixels = !0, this.render = () => {
      this._renderer.setRenderTarget(this._renderTarget);
      try {
        this._renderer.render(this._scene, this._camera);
      } catch (q) {
        throw this._renderer.setRenderTarget(null), q;
      }
      this._renderer.setRenderTarget(null);
    }, this._width = e.width, this._height = e.height, this._type = e.type, this._colorSpace = e.colorSpace;
    const F = {
      // fixed options
      format: xo,
      depthBuffer: !1,
      stencilBuffer: !1,
      // user options
      type: this._type,
      // set in class property
      colorSpace: this._colorSpace,
      // set in class property
      anisotropy: ((t = e.renderTargetOptions) === null || t === void 0 ? void 0 : t.anisotropy) !== void 0 ? (a = e.renderTargetOptions) === null || a === void 0 ? void 0 : a.anisotropy : 1,
      generateMipmaps: ((r = e.renderTargetOptions) === null || r === void 0 ? void 0 : r.generateMipmaps) !== void 0 ? (d = e.renderTargetOptions) === null || d === void 0 ? void 0 : d.generateMipmaps : !1,
      magFilter: ((p = e.renderTargetOptions) === null || p === void 0 ? void 0 : p.magFilter) !== void 0 ? (y = e.renderTargetOptions) === null || y === void 0 ? void 0 : y.magFilter : Ni,
      minFilter: ((_ = e.renderTargetOptions) === null || _ === void 0 ? void 0 : _.minFilter) !== void 0 ? (E = e.renderTargetOptions) === null || E === void 0 ? void 0 : E.minFilter : Ni,
      samples: ((T = e.renderTargetOptions) === null || T === void 0 ? void 0 : T.samples) !== void 0 ? (C = e.renderTargetOptions) === null || C === void 0 ? void 0 : C.samples : void 0,
      wrapS: ((D = e.renderTargetOptions) === null || D === void 0 ? void 0 : D.wrapS) !== void 0 ? (B = e.renderTargetOptions) === null || B === void 0 ? void 0 : B.wrapS : Mo,
      wrapT: ((z = e.renderTargetOptions) === null || z === void 0 ? void 0 : z.wrapT) !== void 0 ? (V = e.renderTargetOptions) === null || V === void 0 ? void 0 : V.wrapT : Mo
    };
    if (this._material = e.material, e.renderer ? this._renderer = e.renderer : (this._renderer = dR.instantiateRenderer(), this._rendererIsDisposable = !0), this._scene = new R1(), this._camera = new Zm(), this._camera.position.set(0, 0, 10), this._camera.left = -0.5, this._camera.right = 0.5, this._camera.top = 0.5, this._camera.bottom = -0.5, this._camera.updateProjectionMatrix(), !PV(this._type, this._renderer, this._camera, F)) {
      let q;
      switch (this._type) {
        case au:
          q = this._renderer.extensions.has("EXT_color_buffer_float") ? pr : void 0;
          break;
      }
      q !== void 0 ? (console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${pr}`), this._type = q) : (this._supportsReadPixels = !1, console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"));
    }
    this._quad = new es(new Ky(), this._material), this._quad.geometry.computeBoundingBox(), this._scene.add(this._quad), this._renderTarget = new uf(this.width, this.height, F), this._renderTarget.texture.mapping = ((G = e.renderTargetOptions) === null || G === void 0 ? void 0 : G.mapping) !== void 0 ? (N = e.renderTargetOptions) === null || N === void 0 ? void 0 : N.mapping : X0;
  }
  /**
   * Instantiates a temporary renderer
   *
   * @returns
   */
  static instantiateRenderer() {
    const e = new tR();
    return e.setSize(128, 128), e;
  }
  /**
   * Obtains a Buffer containing the rendered texture.
   *
   * @throws Error if the browser cannot read pixels from this RenderTarget type.
   * @returns a TypedArray containing RGBA values from this renderer
   */
  toArray() {
    if (!this._supportsReadPixels)
      throw new Error("Can't read pixels in this browser");
    const e = kw(this._type, this._width, this._height);
    return this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, e), e;
  }
  /**
   * Performs a readPixel operation in the renderTarget
   * and returns a DataTexture containing the read data
   *
   * @param options options
   * @returns
   */
  toDataTexture(e) {
    const t = new Jv(
      // fixed values
      this.toArray(),
      this.width,
      this.height,
      xo,
      this._type,
      // user values
      (e == null ? void 0 : e.mapping) || X0,
      (e == null ? void 0 : e.wrapS) || Mo,
      (e == null ? void 0 : e.wrapT) || Mo,
      (e == null ? void 0 : e.magFilter) || Ni,
      (e == null ? void 0 : e.minFilter) || Ni,
      (e == null ? void 0 : e.anisotropy) || 1,
      // fixed value
      Kv
    );
    return t.generateMipmaps = (e == null ? void 0 : e.generateMipmaps) !== void 0 ? e == null ? void 0 : e.generateMipmaps : !1, t;
  }
  /**
   * If using a disposable renderer, it will dispose it.
   */
  disposeOnDemandRenderer() {
    this._renderer.setRenderTarget(null), this._rendererIsDisposable && (this._renderer.dispose(), this._renderer.forceContextLoss());
  }
  /**
   * Will dispose of **all** assets used by this renderer.
   *
   *
   * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later
   * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`
   * or are otherwise done with it.
   *
   * @example
   * ```js
   * const loader = new HDRJPGLoader(renderer)
   * const result = await loader.loadAsync('gainmap.jpeg')
   * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )
   * // DO NOT dispose the renderTarget here,
   * // it is used directly in the material
   * result.dispose()
   * ```
   *
   * @example
   * ```js
   * const loader = new HDRJPGLoader(renderer)
   * const pmremGenerator = new PMREMGenerator( renderer );
   * const result = await loader.loadAsync('gainmap.jpeg')
   * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)
   * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )
   * // renderTarget can be disposed here
   * // because it was used to generate a PMREM texture
   * result.dispose(true)
   * ```
   */
  dispose(e) {
    this.disposeOnDemandRenderer(), e && this.renderTarget.dispose(), this.material instanceof iu && Object.values(this.material.uniforms).forEach((t) => {
      t.value instanceof Ml && t.value.dispose();
    }), Object.values(this.material).forEach((t) => {
      t instanceof Ml && t.dispose();
    }), this.material.dispose(), this._quad.geometry.dispose();
  }
  /**
   * Width of the texture
   */
  get width() {
    return this._width;
  }
  set width(e) {
    this._width = e, this._renderTarget.setSize(this._width, this._height);
  }
  /**
   * Height of the texture
   */
  get height() {
    return this._height;
  }
  set height(e) {
    this._height = e, this._renderTarget.setSize(this._width, this._height);
  }
  /**
   * The renderer used
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * The `WebGLRenderTarget` used.
   */
  get renderTarget() {
    return this._renderTarget;
  }
  set renderTarget(e) {
    this._renderTarget = e, this._width = e.width, this._height = e.height;
  }
  /**
   * The `Material` used.
   */
  get material() {
    return this._material;
  }
  /**
   *
   */
  get type() {
    return this._type;
  }
  get colorSpace() {
    return this._colorSpace;
  }
}
const XV = (
  /* glsl */
  `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`
), YV = (
  /* glsl */
  `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`
);
class qV extends iu {
  /**
   *
   * @param params
   */
  constructor({ gamma: e, offsetHdr: t, offsetSdr: a, gainMapMin: r, gainMapMax: d, maxDisplayBoost: p, hdrCapacityMin: y, hdrCapacityMax: _, sdr: E, gainMap: T }) {
    super({
      name: "GainMapDecoderMaterial",
      vertexShader: XV,
      fragmentShader: YV,
      uniforms: {
        sdr: { value: E },
        gainMap: { value: T },
        gamma: { value: new ve(1 / e[0], 1 / e[1], 1 / e[2]) },
        offsetHdr: { value: new ve().fromArray(t) },
        offsetSdr: { value: new ve().fromArray(a) },
        gainMapMin: { value: new ve().fromArray(r) },
        gainMapMax: { value: new ve().fromArray(d) },
        weightFactor: {
          value: (Math.log2(p) - y) / (_ - y)
        }
      },
      blending: jv,
      depthTest: !1,
      depthWrite: !1
    }), this._maxDisplayBoost = p, this._hdrCapacityMin = y, this._hdrCapacityMax = _, this.needsUpdate = !0, this.uniformsNeedUpdate = !0;
  }
  get sdr() {
    return this.uniforms.sdr.value;
  }
  set sdr(e) {
    this.uniforms.sdr.value = e;
  }
  get gainMap() {
    return this.uniforms.gainMap.value;
  }
  set gainMap(e) {
    this.uniforms.gainMap.value = e;
  }
  /**
   * @see {@link GainMapMetadata.offsetHdr}
   */
  get offsetHdr() {
    return this.uniforms.offsetHdr.value.toArray();
  }
  set offsetHdr(e) {
    this.uniforms.offsetHdr.value.fromArray(e);
  }
  /**
   * @see {@link GainMapMetadata.offsetSdr}
   */
  get offsetSdr() {
    return this.uniforms.offsetSdr.value.toArray();
  }
  set offsetSdr(e) {
    this.uniforms.offsetSdr.value.fromArray(e);
  }
  /**
   * @see {@link GainMapMetadata.gainMapMin}
   */
  get gainMapMin() {
    return this.uniforms.gainMapMin.value.toArray();
  }
  set gainMapMin(e) {
    this.uniforms.gainMapMin.value.fromArray(e);
  }
  /**
   * @see {@link GainMapMetadata.gainMapMax}
   */
  get gainMapMax() {
    return this.uniforms.gainMapMax.value.toArray();
  }
  set gainMapMax(e) {
    this.uniforms.gainMapMax.value.fromArray(e);
  }
  /**
   * @see {@link GainMapMetadata.gamma}
   */
  get gamma() {
    const e = this.uniforms.gamma.value;
    return [1 / e.x, 1 / e.y, 1 / e.z];
  }
  set gamma(e) {
    const t = this.uniforms.gamma.value;
    t.x = 1 / e[0], t.y = 1 / e[1], t.z = 1 / e[2];
  }
  /**
   * @see {@link GainMapMetadata.hdrCapacityMin}
   * @remarks Logarithmic space
   */
  get hdrCapacityMin() {
    return this._hdrCapacityMin;
  }
  set hdrCapacityMin(e) {
    this._hdrCapacityMin = e, this.calculateWeight();
  }
  /**
   * @see {@link GainMapMetadata.hdrCapacityMin}
   * @remarks Logarithmic space
   */
  get hdrCapacityMax() {
    return this._hdrCapacityMax;
  }
  set hdrCapacityMax(e) {
    this._hdrCapacityMax = e, this.calculateWeight();
  }
  /**
   * @see {@link GainmapDecodingParameters.maxDisplayBoost}
   * @remarks Non Logarithmic space
   */
  get maxDisplayBoost() {
    return this._maxDisplayBoost;
  }
  set maxDisplayBoost(e) {
    this._maxDisplayBoost = Math.max(1, Math.min(65504, e)), this.calculateWeight();
  }
  calculateWeight() {
    const e = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);
    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, e));
  }
}
class Ww extends Error {
}
class $w extends Error {
}
const CA = (o, e, t) => {
  const a = new RegExp(`${e}="([^"]*)"`, "i").exec(o);
  if (a)
    return a[1];
  const r = new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`, "i").exec(o);
  if (r) {
    const d = r[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);
    return d && d.length === 3 ? d.map((p) => p.replace(/<\/?rdf:li>/g, "")) : r[1].trim();
  }
  if (t !== void 0)
    return t;
  throw new Error(`Can't find ${e} in gainmap metadata`);
}, ZV = (o) => {
  let e;
  typeof TextDecoder < "u" ? e = new TextDecoder().decode(o) : e = o.toString();
  let t = e.indexOf("<x:xmpmeta");
  for (; t !== -1; ) {
    const a = e.indexOf("x:xmpmeta>", t), r = e.slice(t, a + 10);
    try {
      const d = CA(r, "hdrgm:GainMapMin", "0"), p = CA(r, "hdrgm:GainMapMax"), y = CA(r, "hdrgm:Gamma", "1"), _ = CA(r, "hdrgm:OffsetSDR", "0.015625"), E = CA(r, "hdrgm:OffsetHDR", "0.015625"), T = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(r), C = T ? T[1] : "0", D = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(r);
      if (!D)
        throw new Error("Incomplete gainmap metadata");
      const B = D[1];
      return {
        gainMapMin: Array.isArray(d) ? d.map((z) => parseFloat(z)) : [parseFloat(d), parseFloat(d), parseFloat(d)],
        gainMapMax: Array.isArray(p) ? p.map((z) => parseFloat(z)) : [parseFloat(p), parseFloat(p), parseFloat(p)],
        gamma: Array.isArray(y) ? y.map((z) => parseFloat(z)) : [parseFloat(y), parseFloat(y), parseFloat(y)],
        offsetSdr: Array.isArray(_) ? _.map((z) => parseFloat(z)) : [parseFloat(_), parseFloat(_), parseFloat(_)],
        offsetHdr: Array.isArray(E) ? E.map((z) => parseFloat(z)) : [parseFloat(E), parseFloat(E), parseFloat(E)],
        hdrCapacityMin: parseFloat(C),
        hdrCapacityMax: parseFloat(B)
      };
    } catch {
    }
    t = e.indexOf("<x:xmpmeta", a);
  }
};
class QV {
  constructor(e) {
    this.options = {
      debug: e && e.debug !== void 0 ? e.debug : !1,
      extractFII: e && e.extractFII !== void 0 ? e.extractFII : !0,
      extractNonFII: e && e.extractNonFII !== void 0 ? e.extractNonFII : !0
    };
  }
  extract(e) {
    return new Promise((t, a) => {
      const r = this.options.debug, d = new DataView(e.buffer);
      if (d.getUint16(0) !== 65496) {
        a(new Error("Not a valid jpeg"));
        return;
      }
      const p = d.byteLength;
      let y = 2, _ = 0, E;
      for (; y < p; ) {
        if (++_ > 250) {
          a(new Error(`Found no marker after ${_} loops `));
          return;
        }
        if (d.getUint8(y) !== 255) {
          a(new Error(`Not a valid marker at offset 0x${y.toString(16)}, found: 0x${d.getUint8(y).toString(16)}`));
          return;
        }
        if (E = d.getUint8(y + 1), r && console.log(`Marker: ${E.toString(16)}`), E === 226) {
          r && console.log("Found APP2 marker (0xffe2)");
          const T = y + 4;
          if (d.getUint32(T) === 1297106432) {
            const C = T + 4;
            let D;
            if (d.getUint16(C) === 18761)
              D = !1;
            else if (d.getUint16(C) === 19789)
              D = !0;
            else {
              a(new Error("No valid endianness marker found in TIFF header"));
              return;
            }
            if (d.getUint16(C + 2, !D) !== 42) {
              a(new Error("Not valid TIFF data! (no 0x002A marker)"));
              return;
            }
            const B = d.getUint32(C + 4, !D);
            if (B < 8) {
              a(new Error("Not valid TIFF data! (First offset less than 8)"));
              return;
            }
            const z = C + B, V = d.getUint16(z, !D), G = z + 2;
            let N = 0;
            for (let ie = G; ie < G + 12 * V; ie += 12)
              d.getUint16(ie, !D) === 45057 && (N = d.getUint32(ie + 8, !D));
            const q = z + 2 + V * 12 + 4, Y = [];
            for (let ie = q; ie < q + N * 16; ie += 16) {
              const k = {
                MPType: d.getUint32(ie, !D),
                size: d.getUint32(ie + 4, !D),
                // This offset is specified relative to the address of the MP Endian
                // field in the MP Header, unless the image is a First Individual Image,
                // in which case the value of the offset shall be NULL (0x00000000).
                dataOffset: d.getUint32(ie + 8, !D),
                dependantImages: d.getUint32(ie + 12, !D),
                start: -1,
                end: -1,
                isFII: !1
              };
              k.dataOffset ? (k.start = C + k.dataOffset, k.isFII = !1) : (k.start = 0, k.isFII = !0), k.end = k.start + k.size, Y.push(k);
            }
            if (this.options.extractNonFII && Y.length) {
              const ie = new Blob([d]), k = [];
              for (const le of Y) {
                if (le.isFII && !this.options.extractFII)
                  continue;
                const ne = ie.slice(le.start, le.end + 1, "image/jpeg");
                k.push(ne);
              }
              t(k);
            }
          }
        }
        y += 2 + d.getUint16(y + 2);
      }
    });
  }
}
const jV = async (o) => {
  const e = ZV(o);
  if (!e)
    throw new $w("Gain map XMP metadata not found");
  const a = await new QV({ extractFII: !0, extractNonFII: !0 }).extract(o);
  if (a.length !== 2)
    throw new Ww("Gain map recovery image not found");
  return {
    sdr: new Uint8Array(await a[0].arrayBuffer()),
    gainMap: new Uint8Array(await a[1].arrayBuffer()),
    metadata: e
  };
}, AU = (o) => new Promise((e, t) => {
  const a = document.createElement("img");
  a.onload = () => {
    e(a);
  }, a.onerror = (r) => {
    t(r);
  }, a.src = URL.createObjectURL(o);
});
class eN extends cf {
  /**
   *
   * @param renderer
   * @param manager
   */
  constructor(e, t) {
    super(t), e && (this._renderer = e), this._internalLoadingManager = new Nx();
  }
  /**
   * Specify the renderer to use when rendering the gain map
   *
   * @param renderer
   * @returns
   */
  setRenderer(e) {
    return this._renderer = e, this;
  }
  /**
   * Specify the renderTarget options to use when rendering the gain map
   *
   * @param options
   * @returns
   */
  setRenderTargetOptions(e) {
    return this._renderTargetOptions = e, this;
  }
  /**
   * @private
   * @returns
   */
  prepareQuadRenderer() {
    this._renderer || console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");
    const e = new qV({
      gainMapMax: [1, 1, 1],
      gainMapMin: [0, 0, 0],
      gamma: [1, 1, 1],
      offsetHdr: [1, 1, 1],
      offsetSdr: [1, 1, 1],
      hdrCapacityMax: 1,
      hdrCapacityMin: 0,
      maxDisplayBoost: 1,
      gainMap: new Ml(),
      sdr: new Ml()
    });
    return new dR({
      width: 16,
      height: 16,
      type: au,
      colorSpace: Kv,
      material: e,
      renderer: this._renderer,
      renderTargetOptions: this._renderTargetOptions
    });
  }
  /**
  * @private
  * @param quadRenderer
  * @param metadata
  * @param sdrBuffer
  * @param gainMapBuffer
  */
  async render(e, t, a, r) {
    const d = r ? new Blob([r], { type: "image/jpeg" }) : void 0, p = new Blob([a], { type: "image/jpeg" });
    let y, _, E = !1;
    if (typeof createImageBitmap > "u") {
      const D = await Promise.all([
        d ? AU(d) : Promise.resolve(void 0),
        AU(p)
      ]);
      _ = D[0], y = D[1], E = !0;
    } else {
      const D = await Promise.all([
        d ? createImageBitmap(d, { imageOrientation: "flipY" }) : Promise.resolve(void 0),
        createImageBitmap(p, { imageOrientation: "flipY" })
      ]);
      _ = D[0], y = D[1];
    }
    const T = new Ml(_ || new ImageData(2, 2), X0, Mo, Mo, Ni, qC, xo, qh, 1, Kv);
    T.flipY = E, T.needsUpdate = !0;
    const C = new Ml(y, X0, Mo, Mo, Ni, qC, xo, qh, 1, lf);
    C.flipY = E, C.needsUpdate = !0, e.width = y.width, e.height = y.height, e.material.gainMap = T, e.material.sdr = C, e.material.gainMapMin = t.gainMapMin, e.material.gainMapMax = t.gainMapMax, e.material.offsetHdr = t.offsetHdr, e.material.offsetSdr = t.offsetSdr, e.material.gamma = t.gamma, e.material.hdrCapacityMin = t.hdrCapacityMin, e.material.hdrCapacityMax = t.hdrCapacityMax, e.material.maxDisplayBoost = Math.pow(2, t.hdrCapacityMax), e.material.needsUpdate = !0, e.render();
  }
}
class JV extends eN {
  /**
   * Loads a gainmap using separate data
   * * sdr image
   * * gain map image
   * * metadata json
   *
   * useful for webp gain maps
   *
   * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]
   * @param onLoad Load complete callback, will receive the result
   * @param onProgress Progress callback, will receive a {@link ProgressEvent}
   * @param onError Error callback
   * @returns
   */
  load([e, t, a], r, d, p) {
    const y = this.prepareQuadRenderer();
    let _, E, T;
    const C = async () => {
      if (_ && E && T) {
        try {
          await this.render(y, T, _, E);
        } catch (Q) {
          this.manager.itemError(e), this.manager.itemError(t), this.manager.itemError(a), typeof p == "function" && p(Q), y.disposeOnDemandRenderer();
          return;
        }
        typeof r == "function" && r(y), this.manager.itemEnd(e), this.manager.itemEnd(t), this.manager.itemEnd(a), y.disposeOnDemandRenderer();
      }
    };
    let D = !0, B = 0, z = 0, V = !0, G = 0, N = 0, F = !0, q = 0, Y = 0;
    const ie = () => {
      if (typeof d == "function") {
        const Q = B + G + q, j = z + N + Y, re = D && V && F;
        d(new ProgressEvent("progress", { lengthComputable: re, loaded: j, total: Q }));
      }
    };
    this.manager.itemStart(e), this.manager.itemStart(t), this.manager.itemStart(a);
    const k = new of(this._internalLoadingManager);
    k.setResponseType("arraybuffer"), k.setRequestHeader(this.requestHeader), k.setPath(this.path), k.setWithCredentials(this.withCredentials), k.load(e, async (Q) => {
      if (typeof Q == "string")
        throw new Error("Invalid sdr buffer");
      _ = Q, await C();
    }, (Q) => {
      D = Q.lengthComputable, z = Q.loaded, B = Q.total, ie();
    }, (Q) => {
      this.manager.itemError(e), typeof p == "function" && p(Q);
    });
    const le = new of(this._internalLoadingManager);
    le.setResponseType("arraybuffer"), le.setRequestHeader(this.requestHeader), le.setPath(this.path), le.setWithCredentials(this.withCredentials), le.load(t, async (Q) => {
      if (typeof Q == "string")
        throw new Error("Invalid gainmap buffer");
      E = Q, await C();
    }, (Q) => {
      V = Q.lengthComputable, N = Q.loaded, G = Q.total, ie();
    }, (Q) => {
      this.manager.itemError(t), typeof p == "function" && p(Q);
    });
    const ne = new of(this._internalLoadingManager);
    return ne.setRequestHeader(this.requestHeader), ne.setPath(this.path), ne.setWithCredentials(this.withCredentials), ne.load(a, async (Q) => {
      if (typeof Q != "string")
        throw new Error("Invalid metadata string");
      T = JSON.parse(Q), await C();
    }, (Q) => {
      F = Q.lengthComputable, Y = Q.loaded, q = Q.total, ie();
    }, (Q) => {
      this.manager.itemError(a), typeof p == "function" && p(Q);
    }), y;
  }
}
class KV extends eN {
  /**
   * Loads a JPEG containing gain map metadata
   * Renders a normal SDR image if gainmap data is not found
   *
   * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]
   * @param onLoad Load complete callback, will receive the result
   * @param onProgress Progress callback, will receive a {@link ProgressEvent}
   * @param onError Error callback
   * @returns
   */
  load(e, t, a, r) {
    const d = this.prepareQuadRenderer(), p = new of(this._internalLoadingManager);
    return p.setResponseType("arraybuffer"), p.setRequestHeader(this.requestHeader), p.setPath(this.path), p.setWithCredentials(this.withCredentials), this.manager.itemStart(e), p.load(e, async (y) => {
      if (typeof y == "string")
        throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");
      const _ = new Uint8Array(y);
      let E, T, C;
      try {
        const D = await jV(_);
        E = D.sdr, T = D.gainMap, C = D.metadata;
      } catch (D) {
        if (D instanceof $w || D instanceof Ww)
          console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`), C = {
            gainMapMin: [0, 0, 0],
            gainMapMax: [1, 1, 1],
            gamma: [1, 1, 1],
            hdrCapacityMin: 0,
            hdrCapacityMax: 1,
            offsetHdr: [0, 0, 0],
            offsetSdr: [0, 0, 0]
          }, E = _;
        else
          throw D;
      }
      try {
        await this.render(d, C, E, T);
      } catch (D) {
        this.manager.itemError(e), typeof r == "function" && r(D), d.disposeOnDemandRenderer();
        return;
      }
      typeof t == "function" && t(d), this.manager.itemEnd(e), d.disposeOnDemandRenderer();
    }, a, (y) => {
      this.manager.itemError(e), typeof r == "function" && r(y);
    }), d;
  }
}
const nE = {
  apartment: "lebombo_1k.hdr",
  city: "potsdamer_platz_1k.hdr",
  dawn: "kiara_1_dawn_1k.hdr",
  forest: "forest_slope_1k.hdr",
  lobby: "st_fagans_interior_1k.hdr",
  night: "dikhololo_night_1k.hdr",
  park: "rooitou_park_1k.hdr",
  studio: "studio_small_03_1k.hdr",
  sunset: "venice_sunset_1k.hdr",
  warehouse: "empty_warehouse_01_1k.hdr"
}, tN = "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/", h1 = (o) => Array.isArray(o), hR = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"];
function Vx({
  files: o = hR,
  path: e = "",
  preset: t = void 0,
  colorSpace: a = void 0,
  extensions: r
} = {}) {
  t && (pR(t), o = nE[t], e = tN);
  const d = h1(o), {
    extension: p,
    isCubemap: y
  } = mR(o), _ = vR(p);
  if (!_) throw new Error("useEnvironment: Unrecognized file extension: " + o);
  const E = nu((B) => B.gl);
  HN(() => {
    if (p !== "webp" && p !== "jpg" && p !== "jpeg") return;
    function B() {
      jy.clear(_, d ? [o] : o);
    }
    E.domElement.addEventListener("webglcontextlost", B, {
      once: !0
    });
  }, [o, E.domElement]);
  const T = jy(_, d ? [o] : o, (B) => {
    (p === "webp" || p === "jpg" || p === "jpeg") && B.setRenderer(E), B.setPath == null || B.setPath(e), r && r(B);
  });
  let C = d ? (
    // @ts-ignore
    T[0]
  ) : T;
  if (p === "jpg" || p === "jpeg" || p === "webp") {
    var D;
    C = (D = C.renderTarget) == null ? void 0 : D.texture;
  }
  return C.mapping = y ? Qg : p1, C.colorSpace = a ?? (y ? "srgb" : "srgb-linear"), C;
}
const kV = {
  files: hR,
  path: "",
  preset: void 0,
  extensions: void 0
};
Vx.preload = (o) => {
  const e = {
    ...kV,
    ...o
  };
  let {
    files: t,
    path: a = ""
  } = e;
  const {
    preset: r,
    extensions: d
  } = e;
  r && (pR(r), t = nE[r], a = tN);
  const {
    extension: p
  } = mR(t);
  if (p === "webp" || p === "jpg" || p === "jpeg")
    throw new Error("useEnvironment: Preloading gainmaps is not supported");
  const y = vR(p);
  if (!y) throw new Error("useEnvironment: Unrecognized file extension: " + t);
  jy.preload(y, h1(t) ? [t] : t, (_) => {
    _.setPath == null || _.setPath(a), d && d(_);
  });
};
const WV = {
  files: hR,
  preset: void 0
};
Vx.clear = (o) => {
  const e = {
    ...WV,
    ...o
  };
  let {
    files: t
  } = e;
  const {
    preset: a
  } = e;
  a && (pR(a), t = nE[a]);
  const {
    extension: r
  } = mR(t), d = vR(r);
  if (!d) throw new Error("useEnvironment: Unrecognized file extension: " + t);
  jy.clear(d, h1(t) ? [t] : t);
};
function pR(o) {
  if (!(o in nE)) throw new Error("Preset must be one of: " + Object.keys(nE).join(", "));
}
function mR(o) {
  var e;
  const t = h1(o) && o.length === 6, a = h1(o) && o.length === 3 && o.some((p) => p.endsWith("json")), r = h1(o) ? o[0] : o;
  return {
    extension: t ? "cube" : a ? "webp" : r.startsWith("data:application/exr") ? "exr" : r.startsWith("data:application/hdr") ? "hdr" : r.startsWith("data:image/jpeg") ? "jpg" : (e = r.split(".").pop()) == null || (e = e.split("?")) == null || (e = e.shift()) == null ? void 0 : e.toLowerCase(),
    isCubemap: t,
    isGainmap: a
  };
}
function vR(o) {
  return o === "cube" ? jO : o === "hdr" ? NV : o === "exr" ? zV : o === "jpg" || o === "jpeg" ? KV : o === "webp" ? JV : null;
}
const $V = (o) => o.current && o.current.isScene, eF = (o) => $V(o) ? o.current : o;
function gR(o, e, t, a, r = {}) {
  var d, p, y, _;
  r = {
    backgroundBlurriness: 0,
    backgroundIntensity: 1,
    backgroundRotation: [0, 0, 0],
    environmentIntensity: 1,
    environmentRotation: [0, 0, 0],
    ...r
  };
  const E = eF(e || t), T = E.background, C = E.environment, D = {
    // @ts-ignore
    backgroundBlurriness: E.backgroundBlurriness,
    // @ts-ignore
    backgroundIntensity: E.backgroundIntensity,
    // @ts-ignore
    backgroundRotation: (d = (p = E.backgroundRotation) == null || p.clone == null ? void 0 : p.clone()) !== null && d !== void 0 ? d : [0, 0, 0],
    // @ts-ignore
    environmentIntensity: E.environmentIntensity,
    // @ts-ignore
    environmentRotation: (y = (_ = E.environmentRotation) == null || _.clone == null ? void 0 : _.clone()) !== null && y !== void 0 ? y : [0, 0, 0]
  };
  return o !== "only" && (E.environment = a), o && (E.background = a), Xg(E, r), () => {
    o !== "only" && (E.environment = C), o && (E.background = T), Xg(E, D);
  };
}
function yR({
  scene: o,
  background: e = !1,
  map: t,
  ...a
}) {
  const r = nu((d) => d.scene);
  return st.useLayoutEffect(() => {
    if (t) return gR(e, o, r, t, a);
  }), null;
}
function nN({
  background: o = !1,
  scene: e,
  blur: t,
  backgroundBlurriness: a,
  backgroundIntensity: r,
  backgroundRotation: d,
  environmentIntensity: p,
  environmentRotation: y,
  ..._
}) {
  const E = Vx(_), T = nu((C) => C.scene);
  return st.useLayoutEffect(() => gR(o, e, T, E, {
    backgroundBlurriness: t ?? a,
    backgroundIntensity: r,
    backgroundRotation: d,
    environmentIntensity: p,
    environmentRotation: y
  })), st.useEffect(() => () => {
    E.dispose();
  }, [E]), null;
}
function tF({
  children: o,
  near: e = 0.1,
  far: t = 1e3,
  resolution: a = 256,
  frames: r = 1,
  map: d,
  background: p = !1,
  blur: y,
  backgroundBlurriness: _,
  backgroundIntensity: E,
  backgroundRotation: T,
  environmentIntensity: C,
  environmentRotation: D,
  scene: B,
  files: z,
  path: V,
  preset: G = void 0,
  extensions: N
}) {
  const F = nu((ne) => ne.gl), q = nu((ne) => ne.scene), Y = st.useRef(null), [ie] = st.useState(() => new R1()), k = st.useMemo(() => {
    const ne = new C2(a);
    return ne.texture.type = au, ne;
  }, [a]);
  st.useEffect(() => () => {
    k.dispose();
  }, [k]), st.useLayoutEffect(() => {
    if (r === 1) {
      const ne = F.autoClear;
      F.autoClear = !0, Y.current.update(F, ie), F.autoClear = ne;
    }
    return gR(p, B, q, k.texture, {
      backgroundBlurriness: y ?? _,
      backgroundIntensity: E,
      backgroundRotation: T,
      environmentIntensity: C,
      environmentRotation: D
    });
  }, [o, ie, k.texture, B, q, p, r, F]);
  let le = 1;
  return k0(() => {
    if (r === 1 / 0 || le < r) {
      const ne = F.autoClear;
      F.autoClear = !0, Y.current.update(F, ie), F.autoClear = ne, le++;
    }
  }), /* @__PURE__ */ st.createElement(st.Fragment, null, J9(/* @__PURE__ */ st.createElement(st.Fragment, null, o, /* @__PURE__ */ st.createElement("cubeCamera", {
    ref: Y,
    args: [e, t, k]
  }), z || G ? /* @__PURE__ */ st.createElement(nN, {
    background: !0,
    files: z,
    preset: G,
    path: V,
    extensions: N
  }) : d ? /* @__PURE__ */ st.createElement(yR, {
    background: !0,
    map: d,
    extensions: N
  }) : null), ie));
}
function nF(o) {
  var e, t, a, r;
  const d = Vx(o), p = o.map || d;
  st.useMemo(() => Gx({
    GroundProjectedEnvImpl: PI
  }), []), st.useEffect(() => () => {
    d.dispose();
  }, [d]);
  const y = st.useMemo(() => [p], [p]), _ = (e = o.ground) == null ? void 0 : e.height, E = (t = o.ground) == null ? void 0 : t.radius, T = (a = (r = o.ground) == null ? void 0 : r.scale) !== null && a !== void 0 ? a : 1e3;
  return /* @__PURE__ */ st.createElement(st.Fragment, null, /* @__PURE__ */ st.createElement(yR, Jy({}, o, {
    map: p
  })), /* @__PURE__ */ st.createElement("groundProjectedEnvImpl", {
    args: y,
    scale: T,
    height: _,
    radius: E
  }));
}
function _F(o) {
  return o.ground ? /* @__PURE__ */ st.createElement(nF, o) : o.map ? /* @__PURE__ */ st.createElement(yR, o) : o.children ? /* @__PURE__ */ st.createElement(tF, o) : /* @__PURE__ */ st.createElement(nN, o);
}
const AF = /* @__PURE__ */ st.forwardRef(({
  scale: o = 10,
  frames: e = 1 / 0,
  opacity: t = 1,
  width: a = 1,
  height: r = 1,
  blur: d = 1,
  near: p = 0,
  far: y = 10,
  resolution: _ = 512,
  smooth: E = !0,
  color: T = "#000000",
  depthWrite: C = !1,
  renderOrder: D,
  ...B
}, z) => {
  const V = st.useRef(null), G = nu((Ae) => Ae.scene), N = nu((Ae) => Ae.gl), F = st.useRef(null);
  a = a * (Array.isArray(o) ? o[0] : o || 1), r = r * (Array.isArray(o) ? o[1] : o || 1);
  const [q, Y, ie, k, le, ne, Q] = st.useMemo(() => {
    const Ae = new uf(_, _), He = new uf(_, _);
    He.texture.generateMipmaps = Ae.texture.generateMipmaps = !1;
    const P = new Ky(a, r).rotateX(Math.PI / 2), te = new es(P), ae = new wx();
    ae.depthTest = ae.depthWrite = !1, ae.onBeforeCompile = (we) => {
      we.uniforms = {
        ...we.uniforms,
        ucolor: {
          value: new hn(T)
        }
      }, we.fragmentShader = we.fragmentShader.replace(
        "void main() {",
        //
        `uniform vec3 ucolor;
           void main() {
          `
      ), we.fragmentShader = we.fragmentShader.replace(
        "vec4( vec3( 1.0 - fragCoordZ ), opacity );",
        // Colorize the shadow, multiply by the falloff so that the center can remain darker
        "vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );"
      );
    };
    const Se = new iu(OV), ue = new iu(wV);
    return ue.depthTest = Se.depthTest = !1, [Ae, P, ae, te, Se, ue, He];
  }, [_, a, r, o, T]), j = (Ae) => {
    k.visible = !0, k.material = le, le.uniforms.tDiffuse.value = q.texture, le.uniforms.h.value = Ae * 1 / 256, N.setRenderTarget(Q), N.render(k, F.current), k.material = ne, ne.uniforms.tDiffuse.value = Q.texture, ne.uniforms.v.value = Ae * 1 / 256, N.setRenderTarget(q), N.render(k, F.current), k.visible = !1;
  };
  let re = 0, _e, me;
  return k0(() => {
    F.current && (e === 1 / 0 || re < e) && (re++, _e = G.background, me = G.overrideMaterial, V.current.visible = !1, G.background = null, G.overrideMaterial = ie, N.setRenderTarget(q), N.render(G, F.current), j(d), E && j(d * 0.4), N.setRenderTarget(null), V.current.visible = !0, G.overrideMaterial = me, G.background = _e);
  }), st.useImperativeHandle(z, () => V.current, []), /* @__PURE__ */ st.createElement("group", Jy({
    "rotation-x": Math.PI / 2
  }, B, {
    ref: V
  }), /* @__PURE__ */ st.createElement("mesh", {
    renderOrder: D,
    geometry: Y,
    scale: [1, -1, 1],
    rotation: [-Math.PI / 2, 0, 0]
  }, /* @__PURE__ */ st.createElement("meshBasicMaterial", {
    transparent: !0,
    map: q.texture,
    opacity: t,
    depthWrite: C
  })), /* @__PURE__ */ st.createElement("orthographicCamera", {
    ref: F,
    args: [-a / 2, a / 2, r / 2, -r / 2, p, y]
  }));
});
function aF(o, e, t = new ve()) {
  const a = Math.PI * (o - 0.5), r = 2 * Math.PI * (e - 0.5);
  return t.x = Math.cos(r), t.y = Math.sin(a), t.z = Math.sin(r), t;
}
const EF = /* @__PURE__ */ st.forwardRef(({
  inclination: o = 0.6,
  azimuth: e = 0.1,
  distance: t = 1e3,
  mieCoefficient: a = 5e-3,
  mieDirectionalG: r = 0.8,
  rayleigh: d = 0.5,
  turbidity: p = 10,
  sunPosition: y = aF(o, e),
  ..._
}, E) => {
  const T = st.useMemo(() => new ve().setScalar(t), [t]), [C] = st.useState(() => new VI());
  return /* @__PURE__ */ st.createElement("primitive", Jy({
    object: C,
    ref: E,
    "material-uniforms-mieCoefficient-value": a,
    "material-uniforms-mieDirectionalG-value": r,
    "material-uniforms-rayleigh-value": d,
    "material-uniforms-sunPosition-value": y,
    "material-uniforms-turbidity-value": p,
    scale: T
  }, _));
});
class iF extends iu {
  constructor() {
    super({
      uniforms: {
        time: {
          value: 0
        },
        fade: {
          value: 1
        }
      },
      vertexShader: (
        /* glsl */
        `
      uniform float time;
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
        gl_Position = projectionMatrix * mvPosition;
      }`
      ),
      fragmentShader: (
        /* glsl */
        `
      uniform sampler2D pointTexture;
      uniform float fade;
      varying vec3 vColor;
      void main() {
        float opacity = 1.0;
        if (fade == 1.0) {
          float d = distance(gl_PointCoord, vec2(0.5, 0.5));
          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
        }
        gl_FragColor = vec4(vColor, opacity);

        #include <tonemapping_fragment>
	      #include <${cR >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
      }`
      )
    });
  }
}
const lF = (o) => new ve().setFromSpherical(new KM(o, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)), bF = /* @__PURE__ */ st.forwardRef(({
  radius: o = 100,
  depth: e = 50,
  count: t = 5e3,
  saturation: a = 0,
  factor: r = 4,
  fade: d = !1,
  speed: p = 1
}, y) => {
  const _ = st.useRef(null), [E, T, C] = st.useMemo(() => {
    const B = [], z = [], V = Array.from({
      length: t
    }, () => (0.5 + 0.5 * Math.random()) * r), G = new hn();
    let N = o + e;
    const F = e / t;
    for (let q = 0; q < t; q++)
      N -= F * Math.random(), B.push(...lF(N).toArray()), G.setHSL(q / t, a, 0.9), z.push(G.r, G.g, G.b);
    return [new Float32Array(B), new Float32Array(z), new Float32Array(V)];
  }, [t, e, r, o, a]);
  k0((B) => _.current && (_.current.uniforms.time.value = B.clock.elapsedTime * p));
  const [D] = st.useState(() => new iF());
  return /* @__PURE__ */ st.createElement("points", {
    ref: y
  }, /* @__PURE__ */ st.createElement("bufferGeometry", null, /* @__PURE__ */ st.createElement("bufferAttribute", {
    attach: "attributes-position",
    args: [E, 3]
  }), /* @__PURE__ */ st.createElement("bufferAttribute", {
    attach: "attributes-color",
    args: [T, 3]
  }), /* @__PURE__ */ st.createElement("bufferAttribute", {
    attach: "attributes-size",
    args: [C, 1]
  })), /* @__PURE__ */ st.createElement("primitive", {
    ref: _,
    object: D,
    attach: "material",
    blending: cM,
    "uniforms-fade-value": d,
    depthWrite: !1,
    transparent: !0,
    vertexColors: !0
  }));
});
class sF extends iu {
  constructor() {
    super({
      uniforms: {
        time: {
          value: 0
        },
        pixelRatio: {
          value: 1
        }
      },
      vertexShader: (
        /* glsl */
        `
        uniform float pixelRatio;
        uniform float time;
        attribute float size;  
        attribute float speed;  
        attribute float opacity;
        attribute vec3 noise;
        attribute vec3 color;
        varying vec3 vColor;
        varying float vOpacity;

        void main() {
          vec4 modelPosition = modelMatrix * vec4(position, 1.0);
          modelPosition.y += sin(time * speed + modelPosition.x * noise.x * 100.0) * 0.2;
          modelPosition.z += cos(time * speed + modelPosition.x * noise.y * 100.0) * 0.2;
          modelPosition.x += cos(time * speed + modelPosition.x * noise.z * 100.0) * 0.2;
          vec4 viewPosition = viewMatrix * modelPosition;
          vec4 projectionPostion = projectionMatrix * viewPosition;
          gl_Position = projectionPostion;
          gl_PointSize = size * 25. * pixelRatio;
          gl_PointSize *= (1.0 / - viewPosition.z);
          vColor = color;
          vOpacity = opacity;
        }
      `
      ),
      fragmentShader: (
        /* glsl */
        `
        varying vec3 vColor;
        varying float vOpacity;
        void main() {
          float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
          float strength = 0.05 / distanceToCenter - 0.1;
          gl_FragColor = vec4(vColor, strength * vOpacity);
          #include <tonemapping_fragment>
          #include <${cR >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }
      `
      )
    });
  }
  get time() {
    return this.uniforms.time.value;
  }
  set time(e) {
    this.uniforms.time.value = e;
  }
  get pixelRatio() {
    return this.uniforms.pixelRatio.value;
  }
  set pixelRatio(e) {
    this.uniforms.pixelRatio.value = e;
  }
}
const aN = (o) => o && o.constructor === Float32Array, rF = (o) => [o.r, o.g, o.b], iN = (o) => o instanceof Ot || o instanceof ve || o instanceof Bi, lN = (o) => Array.isArray(o) ? o : iN(o) ? o.toArray() : [o, o, o];
function RA(o, e, t) {
  return st.useMemo(() => {
    if (e !== void 0) {
      if (aN(e))
        return e;
      if (e instanceof hn) {
        const a = Array.from({
          length: o * 3
        }, () => rF(e)).flat();
        return Float32Array.from(a);
      } else if (iN(e) || Array.isArray(e)) {
        const a = Array.from({
          length: o * 3
        }, () => lN(e)).flat();
        return Float32Array.from(a);
      }
      return Float32Array.from({
        length: o
      }, () => e);
    }
    return Float32Array.from({
      length: o
    }, t);
  }, [e]);
}
const MF = /* @__PURE__ */ st.forwardRef(({
  noise: o = 1,
  count: e = 100,
  speed: t = 1,
  opacity: a = 1,
  scale: r = 1,
  size: d,
  color: p,
  children: y,
  ..._
}, E) => {
  st.useMemo(() => Gx({
    SparklesImplMaterial: sF
  }), []);
  const T = st.useRef(null), C = nu((q) => q.viewport.dpr), D = lN(r), B = st.useMemo(() => Float32Array.from(Array.from({
    length: e
  }, () => D.map(dx.randFloatSpread)).flat()), [e, ...D]), z = RA(e, d, Math.random), V = RA(e, a), G = RA(e, t), N = RA(e * 3, o), F = RA(p === void 0 ? e * 3 : e, aN(p) ? p : new hn(p), () => 1);
  return k0((q) => {
    T.current && T.current.material && (T.current.material.time = q.clock.elapsedTime);
  }), st.useImperativeHandle(E, () => T.current, []), /* @__PURE__ */ st.createElement("points", Jy({
    key: `particle-${e}-${JSON.stringify(r)}`
  }, _, {
    ref: T
  }), /* @__PURE__ */ st.createElement("bufferGeometry", null, /* @__PURE__ */ st.createElement("bufferAttribute", {
    attach: "attributes-position",
    args: [B, 3]
  }), /* @__PURE__ */ st.createElement("bufferAttribute", {
    attach: "attributes-size",
    args: [z, 1]
  }), /* @__PURE__ */ st.createElement("bufferAttribute", {
    attach: "attributes-opacity",
    args: [V, 1]
  }), /* @__PURE__ */ st.createElement("bufferAttribute", {
    attach: "attributes-speed",
    args: [G, 1]
  }), /* @__PURE__ */ st.createElement("bufferAttribute", {
    attach: "attributes-color",
    args: [F, 3]
  }), /* @__PURE__ */ st.createElement("bufferAttribute", {
    attach: "attributes-noise",
    args: [N, 3]
  })), y || /* @__PURE__ */ st.createElement("sparklesImplMaterial", {
    transparent: !0,
    pixelRatio: C,
    depthWrite: !1
  }));
});
export {
  ed as BackSide,
  dF as Canvas,
  Mo as ClampToEdgeWrapping,
  hn as Color,
  AF as ContactShadows,
  Lp as DoubleSide,
  _F as Environment,
  p1 as EquirectangularReflectionMapping,
  SF as Float,
  Zg as FrontSide,
  hF as Html,
  Ni as LinearFilter,
  qC as LinearMipMapLinearFilter,
  yF as MeshReflectorMaterial,
  B1 as MeshStandardMaterial,
  m1 as MirroredRepeatWrapping,
  _c as NearestFilter,
  vF as OrbitControls,
  q0 as RepeatWrapping,
  lf as SRGBColorSpace,
  EF as Sky,
  MF as Sparkles,
  bF as Stars,
  JO as TextureLoader,
  ve as Vector3,
  Gx as extend,
  k0 as useFrame,
  fR as useGLTF,
  pF as useProgress
};
